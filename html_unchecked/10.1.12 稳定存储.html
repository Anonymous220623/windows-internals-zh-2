<h3 class="bt3" id="sigil_toc_id_118">10.1.12　稳定存储</h3>
<p class="zw">为确保非易失性注册表配置单元（有磁盘文件的配置单元）始终处于可恢复的状态，配置管理器使用了日志配置单元。每个非易失配置单元都有相关的日志配置单元，这是一种隐藏文件，名称与配置单元相同，但扩展名为logN。为了实现更进一步的保障，配置管理器使用了一种双重日志方案。日志文件可能有两个：.log1和.log2，如果出于任何原因，导致.log1虽然被写入但在向主日志文件写入脏数据时出现了故障，下一次进行刷新时，就会用积累的脏数据切换至.log2。如果这次依然失败了，积累的脏数据（.log1中的数据以及两次操作之间变脏的其他数据）会被保存到.log2中。因此再下一次将继续使用.log1，直到对主日志文件成功执行了写入操作。如果未出现任何失败，那么将只使用.log1。</p>
<p class="zw">举例来说，查看%SystemRoot%\System32\Config目录（需要在文件夹选项中选中“显示隐藏的文件和文件夹”选项，并取消选择“隐藏受保护的操作系统文件”选项，否则将看不到任何文件），将会在这里看到System.log1、Sam.log1以及其他.log1和.log2文件。当配置单元初始化时，配置管理器会分配一个位数组，其中的每位代表配置单元中一个512字节的部分（也可称为“扇区”）。这个数组也可以叫脏扇区数组，因为该数组中设置的位意味着系统已修改了内存中配置单元对应的扇区，必须将扇区回写到配置单元文件中（未设置该位则意味着相应扇区为最新状态，与内存中的配置单元内容一致）。</p>
<p class="zw">当新建键或值或修改现有键或值时，配置管理器会记录主配置单元中发生改动的扇区，并将其写入配置单元在内存中的脏扇区数组。随后，配置管理器会安排一次延迟刷新操作，或者叫日志同步操作。配置单元惰性写入器这个系统线程会在发出请求一分钟后被唤醒，以便同步配置单元的日志。它会从脏扇区数组的有效位引用的内存中为配置单元扇区生成一个新的日志项，并将其写入磁盘上的配置单元日志文件。与此同时，系统会刷新从配置单元同步请求发出到配置单元同步实际进行期间产生的所有注册表改动。惰性写入器会使用低优先级I/O将脏扇区写入磁盘上的日志文件（而非写入主配置单元）。在进行配置单元同步后，1分钟内将不会再进行下一次配置单元同步。</p>
<p class="zw">如果惰性写入器只是简单地将配置单元的所有脏扇区写入配置单元文件，而系统在操作过程中崩溃了，配置单元文件可能会处于不一致（损坏）并且不可恢复的状态。为防止出现此类情况，惰性写入器首先会将配置单元的脏扇区数组以及所有脏扇区转储到配置单元的日志文件中，并在必要时增大日志文件的大小。配置单元的基块包含两个序列号。当进行首次刷新操作（而非后续刷新操作）时，配置管理器会更新其中的一个序列号，使其大于另一个序列号。因此，如果系统在对配置单元执行写入操作时崩溃，下次重启动时，配置管理器会注意到配置单元基块中的这两个序列号不匹配，此时就可以使用配置单元日志文件中的脏扇区更新配置单元，使配置单元的状态实现正确的“前进”。这样一来，配置单元就可以处于最新且一致的状态了。</p>
<p class="zw">在将日志项写入配置单元的日志后，惰性刷新器会清除脏扇区数组中对应的有效位，但实际上会将这些位插入另一个重要的向量——未协调数组（unreconciled array）中。配置管理器可以使用这个数组了解要将哪些日志项写入主配置单元。借助对新增的增量日志（见下文）的支持，主配置单元文件很少需要在操作系统正常运行的过程中写入。配置单元的同步协议（与日志同步并非一回事）作为一种算法，可将所有内存和日志中的注册表改动写入主配置单元文件，并为配置单元设置两个序列号。实际上根据下文可知，这是一种开销很高的多阶段操作。</p>
<p class="zw">协调器（reconciler）是另一种类型的惰性写入器系统线程，它每小时唤醒一次，会冻结日志，将所有脏日志项写入主配置单元文件。在脏扇区和未协调数组的帮助下，协调算法可以知道内存中配置单元的哪些部分需要写入主文件。不过协调操作很少发生。如果系统崩溃，借助已经写入日志文件的日志项，配置管理器本就具备了重建配置单元所需的全部信息。注册表协调操作每小时只进行一次（或会在日志的大小落后于某个阈值时进行，这取决于配置文件所在存储卷的大小），因此可大幅改善性能。只有在日志刷新操作期间，配置单元才可能丢失某些数据。</p>
<p class="zw">请注意，协调操作并不会更新主配置单元文件中的第二个序列号。这两个序列号只有在“验证”阶段（另一种形式的配置单元刷新操作）才会被更新为相等的值，而只有在配置单元被卸载（应用程序调用RegUnloadKey API）、系统关机时，或配置文件被首次加载时才会进行这种验证。这意味着在操作系统的大部分生命周期中，主注册表配置单元都处于脏状态，需要借助日志文件才能正确读取。</p>
<p class="zw">Windows启动加载器也包含一些与注册表可靠性有关的代码。例如，它可以在内核加载前解析System.log文件，并通过修复解决一致性问题。此外，在某些配置单元损坏的情况下（例如基块、Bin或单元格包含的数据无法通过一致性检查），配置管理器可以重新初始化损坏的数据结构，甚至在该过程中删除某些子键，随后继续正常运作。如果必须通过自愈操作进行还原，则会弹出系统错误对话框以提醒用户注意。</p>
<h4 class="bt4 sigil_not_in_toc">增量日志</h4>
<p class="zw">如上文所述，Windows 8.1对配置单元同步算法的性能进行了大幅改进，而这要归功于增量日志（Incremental logging）功能。通常来说，配置单元文件中的单元格可处于下列四种状态之一。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">干净</strong>。单元格数据位于配置单元的主文件中且未被修改。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">脏</strong>。单元格数据已修改但只位于内存中。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">未协调</strong>。单元格数据已修改并正确地写入日志文件中，但尚未写入主文件。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">脏且未协调</strong>。单元格被写入日志文件后被再次修改，仅第一次修改位于日志文件中，第二次修改在内存中。</p>
<p class="zw">Windows 8.1之前的系统中，最初的同步算法会在一个或多个单元格被修改5秒后执行。这个算法可总结为下列四步。</p>
<p class="zw">1）配置管理器通过日志文件中一个项，写入“脏”矢量发送过信号的所有已修改单元格。</p>
<p class="zw">2）让配置单元的基块失效（将一个序列号设置为大于另一个序列号的值）。</p>
<p class="zw">3）将所有修改后的数据写入主配置单元的文件。</p>
<p class="zw">4）验证主配置单元（验证操作会将主配置单元文件的两个序列号设置为完全相同的值）。</p>
<p class="zw">为了保持配置单元的完整性和可恢复性，该算法会在完成每阶段操作后向文件系统驱动程序发出一个刷新操作，以免损坏数据。但是对随机访问数据执行刷新操作会产生极高的开销（对传统机械硬盘来说这一点尤为严重）。</p>
<p class="zw">增量日志解决了这个性能问题。旧版算法通过一个日志项写入多次配置单元验证操作期间产生的所有脏数据，但增量模型打破了这个假设。新的同步算法会在每次执行延迟刷新器时写入一个日志项，并且根据上文可知，它只会在首次执行时让配置单元的基块失效。后续刷新操作会继续写入新日志项，而不会触及配置单元的主文件。每小时，或如果日志空间耗尽，协调器都会将日志项中存储的所有数据写入主配置单元的文件，但不进行验证操作。这样既可以回收日志文件中的空间，同时维持了配置单元的可恢复性。如果系统在这个过程中崩溃，下一次加载配置单元时会重新应用日志中未写入的原始项；否则新项会重新应用到日志开头处，这样如果系统稍后崩溃了，那么在加载配置单元时只有日志中的新项会被应用。</p>
<p class="zw">图10-6展示了可能出现的崩溃情形以及如何通过增量日志方案加以应对。在情况A中，系统已将新数据写入内存中的配置单元，惰性刷新器也已将相应的项写入日志（但未进行协调）。在系统重启动时，恢复过程会将所有日志项应用给主配置单元并再次验证配置单元文件。在情况B中，协调器已在崩溃前将存储在日志项中的数据写入主配置单元（未验证配置单元）。当系统重启动时，恢复过程会重新应用现有日志项，但不会对主配置单元文件进行任何修改。情况C与情况B类似，不过新项已在重协调后被写入日志。在这种情况下，恢复过程会只写入最后修改但不在主文件中的数据。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx974.png" style="width: 100%" />
<p class="图题">图10-6　系统在不同时间崩溃后可能造成的结果</p>
<p class="zw">配置单元验证操作只在某些罕见情况下进行。配置单元被卸载后，系统会进行协调，随后验证配置单元的主文件。验证结束后，会将配置单元主文件的两个序列号设置为一个完全相同的新值，并在将配置单元从内存卸载之前发出最后一次文件系统刷新请求。当系统重启动时，配置单元加载的代码检测到配置单元主文件处于干净状态（因为那两个序列号的值完全相同），此时不会执行任何形式的配置单元恢复过程。通过新增的增量同步协议，操作系统不再会因为旧版日志协议而损失性能。</p>
<table> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　在运行旧版本Windows的计算机上加载Windows 8.1或后续版本系统创建的配置单元时，如果配置单元主文件处于非干净状态，加载可能会造成一些问题。旧版操作系统（如Windows 7）完全不知道该如何处理新版日志文件。因此微软创建了RegHiveRecovery微型过滤器驱动程序，该驱动程序被包含在Windows评估和部署工具包（ADK）中。RegHiveRecovery驱动程序可以使用Registry回调拦截来自系统的“配置单元加载”请求，并判断配置单元的主文件是否需要恢复以及是否需要使用增量日志。如果需要，它会执行恢复操作并修复配置单元的主文件，随后系统才有机会读取其中的内容。</p> </td> 
  </tr> 
 </tbody> 
</table>

<p class="epubit-contents-id" style="display: none">{"index":11,"parentId":"5a53b69b-1f5b-45b1-989a-6fe8c9cf2a82","id":"8e3fd91b-0706-4223-9b80-dbbdc34ce22d"}</p>