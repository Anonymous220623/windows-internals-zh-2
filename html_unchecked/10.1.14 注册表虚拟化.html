<h3 class="bt3" id="sigil_toc_id_120">10.1.14　注册表虚拟化</h3>
<p class="zw">Windows 10周年更新（RS1）为Argon和Helium容器引入了注册表虚拟化的概念，甚至可以加载1.6版配置单元所支持的差分配置单元。注册表虚拟化由配置管理器和VReg驱动程序（集成于Windows内核中）提供。这两个组件提供了如下服务。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">命名空间重定向</strong>。应用程序可将虚拟键的内容重定向至主机中的另一个真实键。应用程序也可以将一个虚拟键重定向至差分配置单元中的键，随后合并到主机上的根键中。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">注册表合并</strong>。差分配置单元可理解为相对基准配置单元的差异化内容。基准配置单元代表一种基准层，其中包含不可变的注册表视图。差分配置单元中的键是相对于基准配置单元中的键增加或减少的内容，而后者也被叫作Thumbstone键。</p>
<p class="zw">配置管理器会在操作系统初始化的阶段1期间创建VRegDriver设备对象（并设置相应的安全描述符，只允许SYSTEM和Administrator访问）和VRegConfigurationContext对象类型，代表用于跟踪命名空间重定向以及注册表合并所需的容器Silo上下文。服务器Silo详见卷1第3章。</p>
<h4 class="bt4 sigil_not_in_toc">命名空间重定向</h4>
<p class="zw">注册表命名空间重定向只能为Silo容器（服务器Silo和应用程序Silo）启用。应用程序创建Silo（但并未启动）后，会向VReg设备对象发送初始化IOCTL，并将句柄传递给Silo。VReg驱动程序会创建一个空的配置上下文，并将其附加给Silo对象。随后它会创建一个命名空间节点，借此将容器的\Registry\WC根键重新映射到主机键，因为所有容器需要共享主机键的同一个视图。创建\Registry\WC根键是为了挂载为Silo容器虚拟化的所有配置单元。</p>
<p class="zw">VReg驱动程序是一种注册表过滤器驱动程序，可使用注册表回调机制正确地实现命名空间重定向。当应用程序首次初始化命名空间重定向时，VReg驱动程序会注册自己的主RegistryCallback通知例程（通过一个类似CmRegisterCallbackEx的内部API）。为了向根键正确添加命名空间重定向，应用程序会向VReg的设备发送一个Create Namespace Node IOCTL并指定虚拟键路径（容器可看到该路径）、真实的主机键路径，以及容器的作业句柄。作为回应，VReg设备会新建一个命名空间节点（一种包含键的数据和某些标记的小型数据结构），并将其加入Silo的配置上下文。</p>
<p class="zw">当应用程序完成容器的所有注册表重定向配置工作后，会将自己的进程（或新生成的进程）附加到Silo对象（使用AssignProcessToJobObject，详见本书卷1第3章）。此后，容器进程发出的每个注册表I/O都将被VReg注册表微型过滤器拦截。我们一起通过一个例子看看命名空间重定向是如何生效的。</p>
<p class="zw">假设现代应用程序框架为一个Centennial应用程序设置了多个注册表命名空间重定向，尤其是有一个重定向节点会将键从HKCU重定向到主机的\Registry\WC\a20834ea- 8f46-c05f-46e2-a1b71f9f2f9cuser_sid键。在某个时间点，该Centennial应用程序希望在HKCU\Software\Microsoft父键下新建一个名为AppA的键。当进程调用RegCreateKeyEx API时，VReg注册表回调会拦截该请求并获得作业的配置上下文。随后它会在上下文中搜索与调用方指定的键路径最接近的命名空间节点。如果什么都没找到，会返回一个对象未找到错误：不允许在非虚拟化路径上进行容器操作。假设上下文中有一个描述了HKCU根键的命名空间节点，并且该节点是HKCU\Software\Microsoft子键的父节点，VReg驱动程序会使用主机键的名称替换原始注册表键的相对路径，并将请求转发给配置管理器。因此在这种情况下，配置管理器实际看到的请求是需要创建\Registry\ WC\a20834ea-8f46-c05f-46e2a1b71f9f2f9cuser_sid\Software\Microsoft\AppA，该请求会成功完成。容器化应用程序不会发现其中的差异。在应用程序看来，该注册表键就位于主机HKCU下。</p>
<h4 class="bt4 sigil_not_in_toc">差分配置单元</h4>
<p class="zw">虽然命名空间重定向是在VReg驱动程序中实现的，并且仅限容器化的环境下使用，但注册表合并也可以在全局范围内工作，主要在配置管理器自身内部实现（不过VReg驱动程序依然会被用作入口点，借此将差分配置单元挂载到基准键）。如上文所述，差分配置单元使用了1.6版本的配置单元，虽然与1.5版类似，但支持为差分键使用元数据。配置单元版本的升高也杜绝了将配置单元挂载到不支持注册表虚拟化的系统的可能。</p>
<p class="zw">应用程序可以创建一个差分配置单元并向VReg设备发送IOCTL，借此将其全局挂载到系统或某个Silo容器。不过这需要具备备份和还原特权，因此只有以管理员身份运行的应用程序可以管理差分配置单元。要挂载差分配置单元，应用程序需要用基准键（也叫基层，基层是一种根键，其中包含了差分配置单元的所有子键和值）的名称、差分配置单元的路径以及一个挂载点来填充一个数据结构。随后通过VR_LOAD_DIFFERENCING_ HIVE控制代码将该数据结构发送给VReg驱动程序。挂载点包含了差分配置单元和基层中所含数据合并后的数据。</p>
<p class="zw">VReg驱动程序通过一个哈希表维护所有已加载差分配置单元的列表。这样VReg驱动程序就可以用不同挂载点挂载差分配置单元。如上文所述，现代应用程序架构使用\Registry\WC根键中的随机GUID来挂载独立Centennial应用程序的差分配置单元。在该哈希表中创建一个项后，VReg驱动程序会直接将请求转发给配置管理器的内部函数CmLoadDifferencingKey。大部分工作都是由该函数完成的。它会调用注册表回调并加载差分配置单元。差分配置单元的创建过程与常规配置单元类似。配置管理器的底层创建好配置单元后，还将创建一个键控制块数据结构。这个新的键控制块会被链接至基层键控制块。</p>
<p class="zw">当通过请求指示打开或读取作为挂载点的键或其子键中包含的值时，配置管理器会知道表示差分配置单元的相关键控制块是哪个。因此解析过程会从差分配置单元开始。如果配置管理器在差分配置单元中遇到子键，就会停止解析过程并读取差分配置单元中存储的键和数据。否则，如果未在差分配置单元中找到所需数据，配置管理器会从基准配置单元重新启动解析过程。另一种情况则是验证是否在差分配置单元中找到了Thumbstone键：配置管理器会隐藏搜索的键并且不返回数据（或错误信息）。实际上，Thumbstone可用于在基准配置单元中将键标记为已删除。</p>
<p class="zw">系统支持三种类型的差分配置单元。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">可变配置单元（mutable hive）：</strong>可被写入或更新。所有指向挂载点（或子键）的写入请求会被存储在差分配置单元中。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">不可变配置单元（immutable hive）：</strong>无法被修改。这意味着对差分配置单元中键的所有修改请求都将失败。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">直写配置单元（write-through hive）：</strong>代表不可变的差分配置单元，但指向挂载点（或子键）的写入请求会被重定向至基层（此时基层不再是不可变的）。</p>
<p class="zw">NT内核和应用程序也可以挂载差分配置单元，随后在其挂载点上应用命名空间重定向，这样即可实现复杂的虚拟化配置，例如Centennial应用程序所用机制（如图10-7所示）。现代应用程序模型以及Centennial应用程序架构的详细信息请参阅第8章。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx1087.png" style="width: 100%" />
<p class="图题">图10-7　Centennial应用程序的现代化应用程序模型中软件配置单元的注册表虚拟化</p>

<p class="epubit-contents-id" style="display: none">{"index":13,"parentId":"5a53b69b-1f5b-45b1-989a-6fe8c9cf2a82","id":"3ad1a864-c1ac-4768-b6a4-fa526ade6021"}</p>