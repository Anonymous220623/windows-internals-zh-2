<h3 class="bt3" id="sigil_toc_id_121">10.1.15　注册表优化</h3>
<p class="zw">配置管理器对注册表进行了一些值得一提的优化。首先，几乎每个注册表键都由安全描述符提供访问保护。但为配置单元中每个键存储一个唯一的安全描述符是一种低效的做法，因为注册表的整个子树往往会应用相同安全设置。在为键设置安全性时，配置管理器会在要设置新安全性的键所在的配置单元中检查一个由唯一安全描述符组成的池，并为键共享现有的安全描述符，这样即可确保在每个配置单元中，每个唯一安全描述符最多只存在一个副本。</p>
<p class="zw">配置管理器还会优化自己在配置单元中存储键和值的方式。虽然注册表是完全支持Unicode的，并使用Unicode约定来指定所有名称，但如果名称只包含ASCII字符，配置管理器会将名称以ASCII形式存储在配置单元中。</p>
<p class="zw">当配置管理器读取名称（例如执行名称查找）时，会在内存中将名称转换为Unicode形式。以ASCII形式存储名称可大幅减小配置单元的大小。</p>
<p class="zw">为最大限度减小内存用量，键控制块并不存储键的完整注册表路径名，相反只会引用键的名称。例如，一个指向\Registry\System\Control的键控制块会引用Control这个名称而非完整路径。此外还有进一步的优化措施：配置管理器会使用键名称控制块存储键名称，而所有同名键的键控制块共享了同一个键名称控制块。为优化性能，配置管理器会将键控制块的名称存储在一个哈希表中以便能快速查找。</p>
<p class="zw">为了能快速访问键控制块，配置管理器会将频繁访问的键控制块存储在缓存表（一种哈希表）中。当配置管理器需要查找一个键控制块时，首先会检查该缓存表。最后，配置管理器还有另一个缓存，即延迟关闭表，其中存储了应用程序已经关闭的键控制块，这样，应用程序即可快速重新打开自己最近关闭的键。为了优化查找，每个配置单元都会存储这些缓存表。随着添加最新关闭的块，配置管理器会从延迟关闭表中移除最旧的键控制块。</p>

<p class="epubit-contents-id" style="display: none">{"index":14,"parentId":"5a53b69b-1f5b-45b1-989a-6fe8c9cf2a82","id":"fcc7cfc7-1c09-4f76-bbea-be3bf6929e9a"}</p>