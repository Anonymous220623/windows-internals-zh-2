<h3 class="bt3" id="sigil_toc_id_111">10.1.5　应用程序配置单元</h3>
<p class="zw">应用程序通常能从全局注册表读/写数据。当应用程序打开一个注册表键时，Windows内核会针对特定键所包含的ACL，对进程（或线程，如果在进行线程模拟的话，详见本书卷1第7章）的访问令牌执行访问检查验证。应用程序也可以使用RegSaveKeyEx和RegLoadKeyEx API加载并保存注册表配置单元。在这些情况下，应用程序所操作的数据，可能会被运行在相同或更高特权级别下的其他进程所干扰。此外，为了加载和保存配置单元，应用程序需要启用备份和还原特权，这两个特权只会提供给以管理员身份运行的进程。</p>
<p class="zw">显然，对于大部分需要访问私有存储库来存储自己设置的应用程序来说，这受到了一定的限制。Windows 7引入了应用程序配置单元的概念。应用程序配置单元是一种标准的配置单元文件（会链接至相应的日志文件），在挂载后，这样的配置单元只对请求该配置单元的应用程序可见。开发者可以使用RegSaveKeyEx API（可导出配置单元文件中的常规注册表键内容）来创建基础配置单元文件。随后，该应用程序即可使用RegLoadAppKey函数以私密的方式挂载配置单元（指定REG_PROCESS_APPKEY标记可防止其他应用程序访问同一个配置单元）。在内部，该函数将执行以下操作。</p>
<p class="zw">1）以“\Registry\A\&lt;随机Guid&gt;”的形式创建一个随机GUID并将其分配给私有命名空间（\Registry组成NT内核注册表命名空间，详见下文“注册表的命名空间和操作”一节）。</p>
<p class="zw">2）将指定的配置单元文件名称的DOS路径转换为NT格式，并通过适当的参数集调用NtLoadKeyEx原生API。</p>
<p class="zw">NtLoadKeyEx函数会调用常规注册表回调。然而，当检测到这是一个应用程序配置单元时，它会使用CmLoadAppKey将配置单元和相关日志文件加载到私有命名空间中，这种命名空间无法被其他任何应用程序枚举，并会与调用方进程的生命周期直接绑定（不过配置单元和日志文件依然会被映射至“注册表进程”，注册表进程的详细信息请参阅下文）。应用程序可以使用标准注册表API读/写自己存储在应用程序配置单元中的私有设置。当应用程序退出或键的最后一个句柄关闭后，配置单元会自动卸载。</p>
<p class="zw">很多Windows组件都使用了应用程序配置单元，例如，应用程序兼容性遥测代理（CompatTelRunner.exe）以及现代应用程序模型。通用Windows平台（UWP）应用程序使用应用程序配置单元存储WinRT类的相关信息，这些信息可被实例化并被应用程序以私有的方式使用。这种配置单元存储在一个名为ActivationStore.dat的文件中，主要在应用程序启动（更准确地说应该是“激活”）时被激活管理器（activation manager）所使用。现代应用程序模型的后台基础架构组件也会通过配置单元中存储的数据保存后台任务信息。这样，当一个后台任务的计时器到时间后，就可以精确得知该任务的代码位于哪个应用程序库（以及激活类型和线程模型）中。</p>
<p class="zw">此外，现代应用程序栈还为UWP开发者提供了应用程序数据容器的概念，这种容器也可用于存储本地设备上运行应用程序的对应的设置信息（此时这种容器叫作本地容器），或者还可在用户安装了同一个应用程序的所有设备上共享设置信息。这两类容器都是通过Windows.Storage.ApplicationData.dll这个WinRT库实现的，该库使用了对应用程序而言属于“本地”的应用程序配置单元（支持文件名为settings.dat）来存储UWP应用程序创建的设置。</p>
<p class="zw">Settings.dat和ActivationStore.dat配置单元文件都由现代应用程序模型的部署过程（在安装应用时）创建，相关内容已在第8章中进行了详细介绍（并概括讨论了打包的应用程序）。应用程序数据容器的详细信息可参阅：https://docs.microsoft.com/windows/uwp/ get-started/settings-learning-track。</p>

<p class="epubit-contents-id" style="display: none">{"index":4,"parentId":"5a53b69b-1f5b-45b1-989a-6fe8c9cf2a82","id":"ddd26216-2794-44fa-97ff-a4f6fcbfd1a5"}</p>