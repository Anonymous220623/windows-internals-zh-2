<h3 class="bt3" id="sigil_toc_id_135">10.2.13　服务标签</h3>
<p class="zw">使用服务托管进程的另一个不足之处在于：更加难以按照不同服务核算CPU时间和用量以及其他资源的用量，因为很多服务都与同一个服务组中的其他服务共享了内存地址空间、句柄表，以及每进程CPU数目。虽然在服务托管进程中始终有一个线程是属于某个特定服务的，但这种关联可能并不总是那么容易建立。例如，服务可能会使用工作线程执行操作，或者线程的起始地址和栈无法揭示服务的DLL名称，这就很难确定一个线程正在做什么工作，以及这个线程到底属于哪个服务。</p>
<p class="zw">Windows实现了一种名为服务标签（service tag）的服务特性（请勿将其与驱动程序标记混淆），在创建新服务或系统启动过程中生成服务数据库时，SCM会调用ScGenerateServiceTag生成服务标签。该属性实际上是一种识别服务的索引。服务标签存储在每个线程的线程环境块（TEB）中的SubProcessTag字段内（有关TEB的详细信息请参阅卷1第3章），会被传播给主服务线程创建的所有线程（由线程池API间接创建的线程除外）。</p>
<p class="zw">虽然服务标签保存在SCM内部，但很多Windows工具（如Netstat.exe，可显示每个程序打开了哪些网络端口）可使用未公开的API查询服务标签，并将其映射到服务名称。此外还可以通过其他工具查看服务标签，例如Winsider Seminars &amp; Solutions Inc.提供的ScTagQuery（www.winsiderss.com/tools/sctagquery/sctagquery.htm）。该工具可以向SCM查询每个服务标签的映射关系，随后显示整个系统或每进程范围的查询结果。该工具还可以告诉我们一个服务托管进程中的所有线程都分属哪个服务（前提是这些线程关联了相应的服务标记）。借此，如果有一个失控的服务耗费了大量CPU时间，在通过线程的起始地址或堆栈无法直观了解该线程所关联的DLL情况下，我们依然可以揪出“罪魁祸首”。</p>

<p class="epubit-contents-id" style="display: none">{"index":12,"parentId":"1cbfd336-a8a2-4665-b935-06b6507ec061","id":"b685257b-8d0b-4e03-958f-bcf8e8dc96c6"}</p>