<h3 class="bt3" id="sigil_toc_id_262">11.12.11　非稀疏数据的压缩</h3>
<p class="zw">上述稀疏文件压缩的例子其实有些“刻意”，这个例子描述了一种当文件的整个节都被零填充时的“压缩”，但文件中的其余数据并未受到压缩的影响。大部分文件中的数据并非稀疏的，但依然可以使用压缩算法来压缩。</p>
<p class="zw">在NTFS中，用户可以压缩特定的文件或一个目录中的所有文件（被压缩的目录中以后新建的文件也会被自动压缩，如果以编程的方式使用FSCTL_SET_COMPRESSION来启用对目录的压缩，则目录中现有的文件需要单独进行压缩）。压缩文件时，NTFS会将文件中尚未处理的数据分成长度为16个簇的压缩单元（例如簇的大小为8&nbsp;KB时，压缩单元大小就为128&nbsp;KB）。文件中的某些数据序列可能无法大幅压缩，甚至可能完全无法压缩。因此，对于文件中的每个压缩单元，NTFS会判断压缩该单元是否可以节约至少1个簇的容量。如果压缩后无法释放出至少1个簇的容量，那么NTFS会分配一个16个簇的运行，将该单元中的数据直接写入磁盘，不进行压缩。如果16个簇单元中的数据可以压缩至15个簇或更少的簇，NTFS将只分配包含压缩后数据所需数量的簇，随后将其写入磁盘。图11-47展示了一个包含4个运行的文件的压缩。图中未填充阴影的区域代表压缩之后该文件实际占用的存储位置。第1、2和4个运行都已被压缩，第3个运行未压缩。虽然包含1个未压缩的运行，压缩该文件也节约了26个簇的磁盘空间（41%）。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx2304.png" style="width: 100%" />
<p class="图题">图11-47　压缩文件包含的数据运行</p>
<table> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　尽管本章的图表都展示了连续的LCN，但压缩单元并不需要存储在物理上连续的簇中。占用非连续簇的运行，其MFT记录会比图11-47所示的记录略为复杂一些。</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">在将数据写入压缩文件后，NTFS会确保每个运行都从虚拟的16簇边界开始。因此，每个运行的起始VCN都是16的倍数，并且运行不会超过16个簇。当访问压缩文件时，NTFS每次至少读/写一个压缩单元。不过在写入压缩后的数据时，NTFS会试图将压缩单元存储在物理连续的位置，这样就可以通过一个I/O操作完全读取。NTFS压缩单元大小为16个簇，选择这个大小主要是为了避免产生内部碎片：压缩单元越大，存储数据所需的总体磁盘空间就越小。这16个簇的压缩单元大小实际上是在“产生尽量小的压缩文件”和“降低随机访问文件的程序读取操作速度”之间进行权衡后的结果。每次缓存缺失都必须对相当于16个簇的数据解压缩（缓存缺失更可能出现在随机访问时）。图11-48显示了图11-47中压缩文件的MFT记录。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx2352.png" style="width: 100%" />
<p class="图题">图11-48　压缩文件的MFT记录</p>
<p class="zw">这个压缩文件和上文包含稀疏数据的压缩文件两个例子最主要的差别在于：该文件中的三个压缩运行的长度都小于16个簇。从文件的MFT文件记录中读取这些信息后，NTFS可以知道文件中的数据是否被压缩。如果任何不超过16个簇的运行中包含压缩数据，NTFS在首次将数据读入缓存时必须解压缩。恰巧16个簇长度的运行不包含压缩数据，因此不需要解压缩。</p>
<p class="zw">如果运行中的数据已被压缩，则NTFS会将数据解压缩到从头开始的缓冲区，随后将其复制到调用方的缓冲区。NTFS还会将解压缩后的数据载入缓存，因此，同一个运行的后续读取就会和其他缓存读取操作一样快。NTFS会将文件的更新写入缓存，利用惰性写入器以异步的方式将修改后的数据压缩并写入磁盘。该策略确保了向压缩文件执行写入操作不会比非压缩文件的写入操作产生更明显的延迟。</p>
<p class="zw">NTFS会尽可能保持压缩文件磁盘分配的连续性。正如LCN所示，在图11-47中，压缩文件的前两个运行在物理上是连续的，后两个也是连续的。如果两个或更多运行是连续的，NTFS就会像处理其他文件数据那样执行磁盘预读取。由于连续文件数据的读取和解压缩可在程序请求数据之前以异步方式进行，所以后续读取操作将直接从缓存中获得数据，这大幅改善了读取操作的性能。</p>

<p class="epubit-contents-id" style="display: none">{"index":10,"parentId":"65b5fd03-8e4f-4d2b-beba-4e7c140dd099","id":"5d4f3b33-876c-4422-a529-ab9065e0afbc"}</p>