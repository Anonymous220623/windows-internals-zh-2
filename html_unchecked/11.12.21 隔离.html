<h3 class="bt3" id="sigil_toc_id_272">11.12.21　隔离</h3>
<p class="zw">虽然事务型文件操作是可选的，但正如第10章介绍的事务型注册表（TxR）操作那样，TxF也会对无法感知事务的常规应用程序产生一定影响，因为它可以保证实现隔离的事务型操作。举例来说，如果杀毒软件正在扫描的文件被其他应用程序通过事务型操作修改了，则&nbsp;TxF&nbsp;必须确保扫描器能读取到执行事务型操作前的数据，而在事务型操作中访问文件的应用程序必须能读取到修改后的数据。这种模型也叫读取-提交隔离（read- committed isolation）。</p>
<p class="zw">读取-提交隔离涉及事务写入者和事务读取者的概念。写入者始终能看到文件最新版本的视图，包括当前与该文件相关事务做出的所有改动。任何时候，一个文件只能有一个事务写入者，这意味着这种写入是独占式的写入。另外，事务读取者在打开文件时只能访问该文件提交后的版本，因此读取者与写入者所做的改动是相互隔离的。这样读取者就可以对文件获得一致的视图，哪怕此时还有写入者正在提交改动。要查看更新后的数据，事务读取者必须打开一个指向修改后的文件新句柄。</p>
<p class="zw">事务写入者和事务读取者还会禁止非事务型写入者打开文件，因此，除非执行事务型操作，否则将无法更改文件。非事务型读取者的行为与事务型读取者的行为类似，只能看到文件句柄打开时最后一次提交后的文件内容。不过与事务型读取者不同的是，非事务型读取者无法实现读取-提交隔离，因此无须打开新句柄，也可以始终获得事务型操作的文件最近一次提交后的最新版本视图。这样无法感知事务的应用程序才能表现出符合预期的行为。</p>
<p class="zw">总而言之，TxF的读取-提交隔离模型具备下列特征：</p>
<p class="zwd"><span style="color: #0092dd">●</span> 变更会与事务型读取者相互隔离。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 如果相关事务因为计算机崩溃或卷被强行卸载而回滚，变更也会回滚（撤销）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 如果相关事务成功提交，变更也会刷新到磁盘。</p>

<p class="epubit-contents-id" style="display: none">{"index":20,"parentId":"65b5fd03-8e4f-4d2b-beba-4e7c140dd099","id":"a192fec7-76c1-45e4-b8e9-ee96c9b86c73"}</p>