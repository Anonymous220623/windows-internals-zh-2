<h3 class="bt3" id="sigil_toc_id_280">11.13.4　日志记录类型</h3>
<p class="zw">NTFS的恢复机制使用了与TxF恢复机制类似的日志记录类型：更新（Update）记录，对应于TxF所用的重做和撤销记录；检查点（Checkpoint）记录，类似于TxF的重启动记录。图11-58展示了日志文件中的三个更新记录。每个记录代表事务的一个子操作，会创建一个新文件。每个更新记录中的“重做”项会告诉NTFS如何将子操作重新应用给卷，而“撤销”项则会告诉NTFS如何回滚（撤销）子操作。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx2623.png" style="width: 100%" />
<p class="图题">图11-58　日志文件中的更新记录</p>
<p class="zw">在记录了一个事务（例如本例中调用LFS向日志文件写入三条更新记录）后，NTFS会在缓存中针对卷本身执行子操作。缓存更新完毕后，NTFS会向日志文件写入另一条记录，借此将整个事务标记为已完成，这个子操作也称为事务提交。事务提交完毕后，NTFS即可保证哪怕操作系统随后故障，整个事务也会出现在卷上。</p>
<p class="zw">在从系统故障中恢复时，NTFS会读取日志文件并重做每个已提交的事务。虽然NTFS已在系统故障前完成了已提交事务，但它并不知道缓存管理器是否已将对卷的改动及时刷新到磁盘。当系统出现故障时，这些更新可能已从缓存中丢失。因此NTFS会再次执行已提交事务，以确保磁盘上的内容是最新的。</p>
<p class="zw">在文件系统恢复过程中重做了已提交事务后，NTFS会在日志文件中查找故障时尚未提交的所有事务，并对每个已记录的子操作进行回滚。在图11-58中，NTFS将首先撤销T1c子操作，随后跟随向后的指针到达T1b并撤销该子操作。NTFS还将继续跟随向后的指针撤销所有子操作，直到抵达事务中的第一个子操作。通过跟随指针进行处理，NTFS可以知道必须撤销多少个更新记录，以及撤销哪些更新记录才能将一个事务彻底回滚。</p>
<p class="zw">重做和撤销信息可以用物理或逻辑的方式来表达。作为维护文件系统结构的最底层软件，NTFS所写入的更新记录包含了物理描述，其中指定了磁盘上需要对卷进行更改、移动等操作的特定字节范围。这一点与TxF有所不同，TxF使用逻辑描述表达了要执行的更新操作，例如“删除文件A.dat”。NTFS会为下列每种事务写入更新记录（通常会包含多条记录）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 创建文件。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 删除文件。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 扩展文件。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 截断文件。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 设置文件信息。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 重命名文件。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 更改应用给文件的安全性设置。</p>
<p class="zw">更新记录中的重做和撤销信息必须经过精心设计，因为尽管NTFS可以撤销事务，从系统故障中恢复，甚至能够正常运行，但它可能依然会尝试重做一个已经完成的事务，或者撤销一个从未发生或已被撤销的事务。类似地，NTFS可能尝试重做或撤销包含多个更新记录的事务，但其中部分记录已经在磁盘上完成了。因此，更新记录的格式必须保证重复执行相同的重做或撤销操作可以实现幂等的结果（即中性效果）。例如，设置一个已经设置过的位，将不会产生任何影响；但开关一个已经切换过的位，将会产生影响。文件系统还必须能正确处理中间卷状态。</p>
<p class="zw">除了更新记录，NTFS还会定期向日志文件中写入检查点记录，如图11-59所示。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx26311.png" style="width: 100%" />
<p class="图题">图11-59　日志文件中的检查点记录</p>
<p class="zw">检查点记录可以帮助NTFS确定在突然发生崩溃的情况下，需要执行怎样的处理方式才能恢复卷。NTFS可以借助检查点记录中存储的信息获知很多情况，例如，必须抵达日志文件中多远的位置才能开始恢复。在写入检查点记录后，NTFS会将该记录的LSN存储到重启动区域，这样，当系统崩溃需要恢复文件系统时，就可以快速找到最新写入的检查点记录，这与TxF使用重启动LSN的原因是相同的。</p>
<p class="zw">尽管LFS向NTFS呈现的日志文件似乎是无限大的，但其实并非如此。日志文件本身就足够大，并且检查点记录的写入频率足够高（该操作通常可释放日志文件空间），这些因素使得日志文件几乎不会被填满。尽管如此，LFS也会像CLFS那样跟踪下列多个运行参数来确定日志文件被填满的可能性。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 可用日志空间。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 写入一条传入的日志记录和撤销该写入操作（如果必要）所需的空间量。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 回滚所有活动（未提交）事务（如果必要）所需的空间量。</p>
<p class="zw">如果日志文件不具备可容纳上述最后两项所需的总空间，LFS会返回“日志文件已满”错误，NTFS会发出异常。NTFS异常处理程序将回滚当前事务，并将其放入队列中以便稍后重新启动。</p>
<p class="zw">为了释放日志文件的空间，NTFS必须暂时阻止针对文件进一步执行的事务。为此，NTFS会阻止文件创建和删除的操作，随后请求以独占的方式访问所有系统文件，并以共享方式访问所有的用户文件。借此，活跃事务将会逐渐成功完成，或收到“日志文件已满”的异常。NTFS会回滚收到异常的事务并将其放入队列。</p>
<p class="zw">一旦按照上文介绍的方式阻止了针对文件执行的事务活动，NTFS会调用缓存管理器将未写入的数据（包括未写入的日志文件数据）刷新到磁盘。在将一切都安全地刷新到磁盘后，NTFS就不再需要日志文件中的数据了。随后它会将日志文件的开头重设为当前位置，让日志文件“变空”。接着，NTFS会重启动队列中的事务。除了I/O处理会短暂地暂停外，日志文件已满错误不会对程序的执行产生任何影响。</p>
<p class="zw">上述场景只是NTFS使用日志文件的一个例子，日志文件不仅可用于文件系统的恢复，而且可用于正常运行过程中的错误恢复。下文将进一步介绍错误恢复过程。</p>

<p class="epubit-contents-id" style="display: none">{"index":3,"parentId":"244f39ce-6f59-4168-9f84-d031b04d0916","id":"ab4bcf1a-58f6-419f-b0fd-e17eeb0f6347"}</p>