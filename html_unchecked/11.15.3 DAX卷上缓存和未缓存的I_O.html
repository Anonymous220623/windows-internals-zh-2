<h3 class="bt3" id="sigil_toc_id_298">11.15.3　DAX卷上缓存和未缓存的I/O</h3>
<p class="zw">尽管DAX卷的内存映射I/O为底层存储提供了零复制访问方式，DAX卷依然支持通过标准方式（使用传统的ReadFile和WriteFile API）执行的I/O。正如开头所述，Windows支持两种类型的常规I/O：缓存的和未缓存的。针对DAX卷执行这两种类型的I/O所产生的效果有很大区别。</p>
<p class="zw">缓存I/O依然需要缓存管理器介入，当为文件创建共享的缓存映射时，缓存管理器会要求内存管理器创建直接映射至PM硬件的节对象。NTFS可以通过新增的CcInitializeCacheMapEx例程告知缓存管理器目标文件处于DAX模式。随后缓存管理器即可将数据从用户缓冲区复制到持久性内存，也就是说，缓存I/O会对持久性存储执行“一次复制”访问操作。请注意，缓存I/O依然会与其他内存映射I/O保持一致（缓存管理器使用了同一个节）；与内存映射I/O的情况类似，此时依然不需要读取或写入分页文件，因此无须启用延迟写入器线程和智能预读取。</p>
<p class="zw">这种直接映射的含义在于：一旦NtWriteFile函数完成，缓存管理器就直接写入DAX磁盘。这意味着缓存I/O本质上是未缓存的。因此未缓存I/O请求会被文件系统直接转换为缓存I/O，这样缓存管理器就依然可以在用户缓冲区和持久性内存之间直接执行复制操作。此类I/O与缓存I/O以及内存映射I/O依然保持了一致。</p>
<p class="zw">NTFS在处理与元数据文件有关的更新时依然会使用标准I/O。每个文件的DAX模式I/O是在创建流的时候决定的，为此需要在流控制块中设置一个标记。系统元数据文件永远不会设置该属性，因此当映射此类文件时，缓存管理器会创建标准的非DAX文件支撑的节，并使用标准存储堆栈来执行分页文件读写I/O（最终，每个I/O都会像块卷那样由Pmem驱动程序处理，并会使用扇区原子性算法。详见“块卷”一节）。这种行为是兼容预写入日志记录功能所必需的。在刷新相应日志之前，元数据不能被持久保存到磁盘上。因此，如果元数据文件被DAX映射，预写入日志记录的相关要求就会被打破。</p>
<h4 class="bt4 sigil_not_in_toc">对文件系统功能的影响</h4>
<p class="zw">由于不执行常规分页I/O，并且应用程序能够直接访问持久性内存，这些特征使得文件系统和相关过滤器用来实现多种功能所需的传统挂钩点（hook point）不复存在。DAX卷无法支持多个功能，例如文件加密、压缩文件、稀疏文件、快照及USN日志支持。</p>
<p class="zw">在DAX模式下，文件系统已经无法得知可写入的内存映射文件何时被修改。当首次创建内存节时，NTFS文件系统驱动程序会更新文件的修改和访问时间，并在USN变更日志中将该文件标记为已修改。同时，NTFS驱动程序会发出一个代表目录更改的通知信号。DAX卷已经无法兼容任何类型的传统过滤器驱动程序，并且对微型过滤器（过滤器管理器客户端）产生了巨大的影响。诸如BitLocker和卷影副本驱动程序（Volsnap. sys）等组件无法作用于DAX卷，因此会从设备堆栈中移除。由于微型过滤器已经无法得知文件是否已被修改，因此，诸如上文描述的那种反恶意软件文件访问扫描程序也将无法得知自己是否需要对某个文件执行病毒扫描。此时它只能假设任何句柄关闭时都意味着文件内容发生了更改。因而也会对性能产生较大的不利影响，为了支持DAX卷，微型过滤器必须以手动的方式选择性启用。</p>

<p class="epubit-contents-id" style="display: none">{"index":2,"parentId":"79bbbed1-3a35-4d22-b579-86536ea07e54","id":"a9111499-3131-435d-921b-ad57f3e3b19b"}</p>