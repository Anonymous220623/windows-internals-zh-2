<h3 class="bt3" id="sigil_toc_id_300">11.15.5　块卷</h3>
<p class="zw">在某些情况下，DAX卷的一些局限是不可接受的。Windows通过块模式卷（block-mode volume）为PM硬件提供向后兼容性，传统I/O堆栈会像对待机械硬盘和SSD硬盘上的普通卷那样管理这种块卷。块卷还沿用了原有的存储语义：所有I/O操作都需要经由存储堆栈抵达PM磁盘类驱动程序（不过不存在微型过滤器驱动程序，因为不需要）。块卷完全兼容所有现有应用程序、传统过滤器以及微型过滤器驱动程序。</p>
<p class="zw">持久性内存存储能够以字节级别的粒度执行I/O。更确切地说，I/O是以缓存行的粒度执行的，具体大小取决于架构，但通常为64字节。不过块模式卷会被公开为标准卷，以扇区为粒度（通常为512字节或4&nbsp;KB）执行I/O。如果正在写入DAX卷但设备突然遭遇断电，那么数据块（扇区）中将同时包含新老数据。应用程序并未针对这种情况做好准备。在块模式下，扇区的原子性是由PM磁盘类驱动程序实现的块转换表（Block Translation Table，BTT）算法保证的。</p>
<p class="zw">BTT算法由英特尔开发，将可用磁盘分割成最高可达512&nbsp;GB的块（称为“竞技场”）。该算法对每个竞技场维护一个BTT，并通过一种简单的“指示/查找”将LBA映射到属于该竞技场的内部块。对于映射中的每个32位项，算法会使用两个最重要的位（MSB）存储块的状态（共有有效、归零、错误三种状态）。尽管该表维持了每个LBA的状态，但BTT算法会提供一种包含nfree块数组的Flog区域来保证扇区的原子性。</p>
<p class="zw">nfree块包含算法提供扇区原子性所需的全部数据。数组中共有256个nfree项，每个nfree项的大小为32字节，因此Flog区域将占用8&nbsp;KB空间。每个nfree项被一个CPU使用，因此nfree的总数用于描述一个竞技场可以并发处理的原子性I/O的数量。图11-75展示了格式化为块模式的DAX磁盘的布局。BTT算法所使用的数据结构对文件系统驱动程序是不可见的。BTT算法消除了可能出现的子扇区撕裂式写入，如上文所述，为了支持文件系统写入元数据，即使格式化为DAX的卷，也需要这种算法。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3127.png" style="width: 100%" />
<p class="图题">图11-75 支持原子性扇区（BTT算法）的DAX磁盘布局</p>
<p class="zw">块模式卷的分区项中不存在GPT_BASIC_DATA_ ATTRIBUTE_DAX标记。NTFS会像处理普通卷那样依靠缓存管理器来执行缓存I/O，并通过PM磁盘类驱动程序处理未缓存I/O。Pmem驱动程序公开的读取和写入函数可以为用户缓冲区和设备物理块地址构建内存描述符列表（MDL，详见卷1第5章），借此执行直接内存访问（DMA）传输。BTT算法提供了扇区原子性。图11-76展示了传统卷、DAX卷以及块卷的I/O堆栈。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3211.png" style="width: 100%" />
<p class="图题">图11-76　传统卷、块模式卷和DAX卷的设备I/O堆栈对比</p>

<p class="epubit-contents-id" style="display: none">{"index":4,"parentId":"79bbbed1-3a35-4d22-b579-86536ea07e54","id":"83e50540-d61b-4c6b-b0c2-a73614c5e42f"}</p>