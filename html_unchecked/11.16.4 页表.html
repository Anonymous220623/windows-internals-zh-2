<h3 class="bt3" id="sigil_toc_id_309">11.16.4　页表</h3>
<p class="zw">当Minstore更新B+树中的桶时（也许是因为需要移动子节点，或向表中添加一行），通常还需要更新父（或引导者）节点（更确切地说，Minstore会使用不同的链接指向每个节点新的和原来的子桶）。这是因为，如上文所述，每个引导者节点都包含其下所有叶节点的校验值，此外，叶节点可能已被移动甚至被删除。这会导致同步问题，例如，假设一个线程正在读取B+树，而同时有一行被删除了。如果锁定该树并等待针对物理介质的每个修改操作，则会造成极大的性能开销。Minstore需要通过一种更方便、快捷的方法来跟踪有关树的信息。Minstore页表（与CPU的页表没有任何关系）是一种内存中的哈希表，由每个Minstore的根表（通常为目录和文件表）专用，借此可以跟踪哪些桶是脏的、可用的，或者已被删除的。这个表绝对不会存储到磁盘上。在Minstore中，“桶”和“页”这两个术语往往是可以互换使用的，页通常驻留在内存中，而桶存储在磁盘上，但它们都代表了同一个上层概念。“树”和“表”一般也可以互换使用，这也解释了“页表”这个名字的由来。页表中的行由目标桶的LCN（作为键）和一个数据结构（作为值）组成，该数据结构可跟踪页的状态并协助B+树实现同步。</p>
<p class="zw">当首次读取或创建一个页时，代表页表的哈希表中会插入一个新项。只有在满足下列所有条件的情况下，才能删除页表中的项。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 没有正在访问该页的活动事务。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 页是干净的，没有任何修改。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 页并不是原有页执行“写入时复制”操作产生的新页。</p>
<p class="zw">在这些规则的限制下，干净的页才能反复进入页表，然后被删除，而脏页则会始终停留在页表中，直到B+树被更新并最终写入磁盘。将树写入持久介质的过程在很大程度上取决于页表在任何特定时间的状态。如图11-82所示，页表被Minstore用作内存中的缓存，进而产生一种隐含的状态机来描述每个页的状态。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3276.png" style="width: 100%" />
<p class="图题">图11-82　该图展示了页表中的脏页（桶）的状态。在对原有页执行写入复制操作时，或因B+树增长而需要更多的空间来存储桶时，就会产生新页</p>

<p class="epubit-contents-id" style="display: none">{"index":3,"parentId":"4bbec909-3cd8-4eac-81f1-9dd5481ba72c","id":"4ae97f3a-c100-4788-8366-dc08350e2b34"}</p>