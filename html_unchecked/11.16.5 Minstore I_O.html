<h3 class="bt3" id="sigil_toc_id_310">11.16.5　Minstore I/O</h3>
<p class="zw">Minstore会以不同的方式读/写最终物理介质中的B+树：读取操作通常会针对树的不同部分分段进行，这意味着读取操作可能只包含一些叶桶，例如，作为事务型访问的一部分或抢占式预读取操作来进行。将桶读入缓存（详见上文“缓存管理器”一节）后，Minstore依然无法解读自己的数据，因为还需要先验证桶校验值。预期校验值存储在父节点中：在ReFS驱动程序（位于Minstore之上）拦截了读取到的数据后，就会知道节点依然需要验证。此时父节点已经位于缓存中（已经在树中进入子节点位置），并且包含了子节点的校验值。Minstore已经具备了验证桶中所含有效数据需要的全部信息。请注意，页表中可能包含一些从未被访问过的页面，这是因为其校验值依然需要验证。</p>
<p class="zw">Minstore在执行树的更新操作时，会将整个B+树作为单一事务进行写入。树更新过程会将B+树的脏页写入物理磁盘。导致树需要更新的原因有很多：应用程序明确刷新了自己的变更、系统在内存不足或其他类似条件下运行、缓存管理器将缓存的数据刷新到磁盘等。值得注意的是，Minstore通常会使用惰性写入器线程来惰性写入更新后的树。如上文所述，有多个触发器可以触发惰性写入器（例如脏页数量达到某一阈值）。</p>
<p class="zw">Minstore并不了解树更新请求背后的原因。Minstore要做的第一件事是确保没有其他事务在同时修改树（为此将使用一些复杂的同步基元）。初始同步完成后，Minstore会开始写入脏页并删除旧页面。在这种“写新”的实现中，新页面代表已被修改，因而需要替换内容的桶；释放的页面则是需要与父节点断开链接的旧页面。如果事务需要修改叶节点，则会（在内存中）复制根桶和叶页面，随后Minstore会在不修改任何链接的前提下，在页表中创建相应的页表项。</p>
<p class="zw">树更新算法枚举了页表中的每个页。然而页表对页面在B+树的哪个层级上完全没有概念，因此该算法会从更外部的节点（通常为叶节点）开始检查B+树，直到抵达根节点。对于每个页面，算法将执行下列步骤。</p>
<p class="zw">1）检查页面状态。如果是已释放的页面，则会跳过该页。如果是脏页，则会更新其父指针和校验值，并将该页面放入一个由等待写入页面组成的内部列表。</p>
<p class="zw">2）丢弃旧页面。</p>
<p class="zw">当算法抵达根节点时，会直接在对象表中更新根节点的父指针和校验值，并最终将根桶放置在等待写入页面的列表中。至此，Minstore就可以在底层卷上的可用空间中写入新树，并将旧树保留在原来的位置。旧树只会被标记为已释放，但依然存在于物理介质中。这是一个重要特性，算得上是“写新”策略的精髓，可以让Minstore基础之上的ReFS文件系统支持高级联机恢复功能。图11-83展示了一个包含两个新叶页（A'和B'）的B+表的更新过程。如图所示，位于页表中的页为浅灰色，旧页面则为深灰色。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3285.png" style="width: 100%" />
<p class="图题">图11-83　Minstore树的更新过程</p>
<p class="zw">在树更新的过程中，对树维持独占式访问可能造成一些性能问题，并且其他方无法对独占锁定的树执行任何读取或写入操作。在最新版的Windows 10中，Minstore中的B+树已经具备了世代（Generational）的概念，每个B+树都被附加了一个世代编号。这意味着树中的某个页面可能在某个世代看来是脏页。如果某个页面最开始只对某个特定世代的树是脏的，那么即可直接更新，无须进行写入时复制，因为最终的树还没有写入磁盘上。</p>
<p class="zw">在新模型中，树更新的过程通常可分为两个阶段。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">可失败阶段</strong>：Minstore获得树独占锁，增大树的世代编号，计算并分配树更新需要的内存，将锁转为共享锁。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">不可失败阶段</strong>：该阶段使用共享锁执行（意味着其他I/O可以读取该树），Minstore会更新引导者节点的链接和所有树的校验值，并将最终的树写入底层磁盘。如果在写入磁盘的过程中有其他事务需要更改树，则Minstore会检测到树的世代编号增大，随后会对树再次进行写入时复制操作。</p>
<p class="zw">在这种新模式下，Minstore只在可失败阶段持有独占锁。这意味着树更新可以与其他Minstore事务并行执行，这可以大幅改善系统整体性能。</p>

<p class="epubit-contents-id" style="display: none">{"index":4,"parentId":"4bbec909-3cd8-4eac-81f1-9dd5481ba72c","id":"fdd9a648-7418-458d-9220-be9ae6de0bcf"}</p>