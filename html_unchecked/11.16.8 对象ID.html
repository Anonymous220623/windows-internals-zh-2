<h3 class="bt3" id="sigil_toc_id_313">11.16.8　对象ID</h3>
<p class="zw">ReFS还需要解决与文件ID有关的另一个问题。出于各种原因（主要是为了有效跟踪并存储文件元数据，而不要将这些信息与命名空间绑定到一起），ReFS需要为通过文件ID打开文件（例如使用OpenFileById API）的应用程序提供支持。NTFS是通过$Extend\$ObjId文件（使用$0索引根属性，详见上文有关NTFS的章节）实现这一目标的。在ReFS中，为每个目录分配一个ID是一种微不足道的操作，实际上，Minstore会将目录的对象ID存储在对象表中。但问题在于，当系统需要为文件分配ID时，ReFS不像NTFS那样有一个中心的文件ID存储库。为了正确找到目录树中的文件ID，ReFS将文件ID空间分为两部分：目录部分和文件部分。目录ID使用目录部分，并使用对象表中行的键进行索引。文件部分则从目录的内部文件ID空间进行分配。代表目录的ID通常在其文件部分有一个“零”，但该目录中的所有文件会共享同一个目录部分。通过在目录的B+树中添加一个单独的行（由&lt;文件ID, 文件名&gt;对组成），ReFS为文件ID的概念提供了支持，借此可将文件ID映射至目录中的文件名。</p>
<p class="zw">当系统需要使用文件ID打开ReFS卷中的文件时，ReFS会通过下列方式满足请求。</p>
<p class="zw">1）打开由目录部分指定的目录。</p>
<p class="zw">2）查询文件部分的键在目录B+树中对应的FileId行。</p>
<p class="zw">3）在目录B+树中查询最后一次所找到的文件名。</p>
<p class="zw">细心的读者可能已经注意到，该算法并未解释当文件被更名或移动后会发生什么。更名后的文件的ID应当与之前的ID的位置相同，即使新目录的ID与文件ID的目录部分并不相同。ReFS的解决方法是：使用新的“墓碑”（tombstone）项取代旧目录B+树中的原始文件ID项，这个“墓碑”项的值并未指定目标文件名，而是包含为更名后的文件新分配的ID（其中的目录部分和文件部分均已改变）。新目录的B+树中也会分配另一个新的文件ID项，这样即可将新的本地文件ID分配给更名后的文件。如果该文件随后被移动到另一个目录，则第二个目录的ID项会被删除，因为已经不再需要了，对于任何特定文件，一个文件最多只需要一个“墓碑”项。</p>

<p class="epubit-contents-id" style="display: none">{"index":7,"parentId":"4bbec909-3cd8-4eac-81f1-9dd5481ba72c","id":"9c6c09ac-7dac-4d1b-b715-0e39499ff0a1"}</p>