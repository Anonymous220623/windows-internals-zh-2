<h3 class="bt3" id="sigil_toc_id_317">11.17.2　ReFS直写</h3>
<p class="zw">ReFS的设计目标之一是将因为文件系统损坏导致的不可用性降到接近于零的水平。下一节我们将介绍ReFS从磁盘故障中恢复所采用的各种联机修复方法。但在介绍这些方法前，首先有必要了解在将事务写入底层介质时，ReFS是如何实现直写的。</p>
<p class="zw">直写是指系统能够合理地保证操作结果在崩溃恢复之后依然可见之前，任何基元修改操作（如创建文件、扩展文件、写入块）都不能被视为完成。直写的性能对各种I/O场景都非常重要，这些场景可以分为两类文件系统操作：数据操作和元数据操作。</p>
<p class="zw">当ReFS对一个文件进行原地更新而不需要变更任何元数据（例如系统修改一个已分配文件的内容，但并未扩展文件的长度）时，直写性能的开销最小。由于ReFS对元数据使用了“写入时分配”的策略，因此，在元数据产生变化后，为其他场景进行直写的开销是非常大的。例如文件被重命名，意味着从文件系统的根一直到描述该文件名称的块，所有元数据块都必须写入一个新位置。ReFS写入时分配的本质还有一个特性：并不会原地修改数据。这意味着，与NTFS相比，系统的恢复不应撤销任何操作。</p>
<p class="zw">为了实现直写，Minstore使用了提前写入日志（Write-Ahead-Logging，WAL）。这种方法如图11-89所示，系统会将记录附加到一个在逻辑上无限长的日志中。当恢复时，将读取并重新应用该日志。Minstore对除分配器表之外的其他所有表维护了一个逻辑重做事务记录日志。每个日志记录都描述了一个完整的事务，这样即可在恢复时重新应用。每个事务记录包含一个或多个操作重做记录，其中描述了实际要执行的高层操作（如在表X中插入[键K/值V]对）。事务记录可实现对特定事务的恢复，这是一种原子性的单位（任何事务都不能部分重做）。从逻辑上来看，日志被每个ReFS事务所拥有，日志记录会被记录到一个小型日志缓冲区中。如果事务已提交，则日志缓冲区会被附加到内存中的卷日志中，并在稍后写入磁盘；但如果事务被中止，那么内部日志缓冲区也将被丢弃。直写事务会等待来自日志引擎的确认，由此得知截至通知那一刻的日志均已提交，而非直写事务可以无须确认，随时继续。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3553.png" style="width: 100%" />
<p class="图题">图11-89 Minstore的提前写入日志方案</p>
<p class="zw">此外，ReFS还会利用检查点将系统的某些视图提交至底层磁盘，这会导致一些之前写入的日志记录变得不再有必要。一旦检查点将受影响的树的视图提交至磁盘，就不再需要事务的重做日志记录了。这意味着检查点将负责确定可以被日志引擎丢弃的日志记录范围。</p>

<p class="epubit-contents-id" style="display: none">{"index":1,"parentId":"bfef1a76-a058-4e31-96a2-fa59897a014e","id":"8e1093ff-88ca-4227-9945-daa9c57708d9"}</p>