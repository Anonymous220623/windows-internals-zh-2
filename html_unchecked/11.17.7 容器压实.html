<h3 class="bt3" id="sigil_toc_id_322">11.17.7　容器压实</h3>
<p class="zw">容器旋转会造成性能问题，尤其是在存储小文件，而这些小文件无法装满整个带时。此外，如上文所述，SMR磁盘永远不会进行容器旋转。之前曾经提到，每个SMR带都有相关的写入指针（由硬件实现），借此可识别顺序写入的位置。如果系统以非顺序方式在写入指针之前或之后写入，就会破坏其他簇中的数据（因此SMR固件必须拒绝此类写入）。</p>
<p class="zw">ReFS支持两种类型的容器：基础容器（base container）和压实容器（compacted container）<br> <sup>[5]</sup>，基础容器会将虚拟簇的范围直接映射至物理空间，而压实容器会将虚拟容器映射至多个不同的基础容器。为了正确映射压实容器所映射的空间与构成压实容器的基础容器之间的对应关系，ReFS实现了一种分配位图，该位图存储在全局容器索引表（这是另一种表，其中的每一行描述一个压实容器）的行中。如果相关的簇已经分配，则该位图中有一位会被设置为1，反之则会设置为0。</p>
<p class="footnote">[5]本节介绍的压实（compacted）容器和下一节将要介绍的压缩（compressed）功能是两个不同的概念。目前网上的一些文档将compacted容器称为“压缩容器”，但为了避免与下一节介绍的compressed功能混淆，这里将其称为“压实容器”。还请读者注意区分。——译者注</p>
<p class="zw">图11-93展示了一个基础容器（C32）范例，该容器将虚拟LCN范围（0x8000至0x8400）映射到真实卷的LCN（0xB800至0xBC00，通过R46区分）。如上文所述，特定虚拟LCN范围的容器ID是从起始处的虚拟簇编号派生而来的，所有容器实际上是连续的。这样，ReFS&nbsp;就永远不需要针对特定容器范围查找容器ID。图&nbsp;11-93&nbsp;中的容器&nbsp;C32&nbsp;只有&nbsp;560（0x230）个持续分配的簇（总共有1024个簇）。只有基础容器末端的可用空间能被ReFS使用。或者对于非SMR磁盘，如果基础容器中间位置的一大块空间被释放，这些空间也可以被重用。即便非SMR磁盘，这方面同样要求空间必须是连续的。</p>
<p class="zw">如果容器变得碎片化（因为一些小的文件范围最终被释放），ReFS可以将基础容器转换为压实容器。该操作使得ReFS能够重用容器的闲置空间，而无须在描述容器本身所用簇的文件范围表中重新分配任何行。</p>
<p class="zw">ReFS提供了一种对碎片化容器进行碎片整理的方法。在常规系统I/O活动中，需要更新或创建很多小文件或数据块。因此，位于慢速存储层中的容器可以容纳被释放的小块簇，并很快变得碎片化。压实容器这项功能可以在慢速存储层中生成一个新的空带，借此即可对容器进行适当的碎片整理。压实容器操作只在分层卷的容量层中进行，其主要设计目标有以下两个。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">压实操作是SMR磁盘的垃圾回收机制</strong>：对于SMR磁盘，ReFS只能以顺序的方式将数据写入容量区域。小数据无法在慢速存储层中的容器里单独更新。这些数据并不会驻留在SMR写入指针所指向的位置，因此，任何此类I/O都可能破坏同一个带中的其他数据。在这种情况下，数据会被复制到一个新带中。非SMR磁盘不存在这种问题，ReFS可以直接更新驻留在小型层中的数据。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">在非SMR分层卷中，压实操作催生了容器旋转</strong>：当数据从快速层移动至慢速层时，所产生的空闲容器可以作为向前旋转的目标。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3629.png" style="width: 100%" />
<p class="图题">图11-93　由210&nbsp;MB文件寻址的基础容器范例，容器C32只使用了64&nbsp;MB空间中的35&nbsp;MB</p>
<p class="zw">当格式化卷时，ReFS会从容量层分配一些专门用于执行压实操作的基础容器，这些容器称为压实保留容器。压实操作首先会在慢速层中搜索碎片化的容器。ReFS会将碎片化容器读入系统内存并整理碎片。随后，碎片整理后的数据会存储到位于容量层的压实保留容器中。借此，由文件范围表寻址的原始容器就被压实了。描述它的范围变为虚拟范围（压实操作会增加另一个间接层），并指向由另一个基础容器（保留容器）所描述的虚拟LCN。压实结束后，原始物理容器会被标记为已释放，随后即可用作其他用途。原始容器还可以充当新的压实保留容器。由于位于慢速层中的容器通常会在相对较短的时间内变得高度碎片化，所以压实操作可以在慢速层中产生大量空带。</p>
<p class="zw">由压实容器分配的簇可以存储在不同的基础容器中。为了正确管理压实容器中这种存储在不同基础容器中的簇，ReFS还额外使用了另一个间接层，该层由全局容器索引表和压实容器的不同布局共同提供。图11-94展示了与图11-93相同的容器，但这次该容器因为碎片化已进行了压实（总共560个簇释放了272个）。在容器表中，描述压实容器的行存储了压实容器所描述的簇范围、与基础容器所描述的虚拟簇之间的映射关系。压实容器最多支持4个不同范围（也叫“腿”）。这4条腿创建了第二个间接层，使得ReFS能够高效地整理容器碎片。压实容器的分配位图也提供了第二个间接层。通过检查所分配的簇（对应于位图中的“1”）位置，ReFS可以正确映射压实容器中每个碎片化的簇。</p>
<p class="zw">在图11-94所示的例子中，第一个被设置为“1”的位处于位置17处，也就是十六进制的0x11。在本例中，1位对应16个簇，但在实际的实现中，1位只对应1个簇。这意味着在压实容器C32偏移量0x110处分配的第一个簇，其实存储在基础容器C124的虚拟簇0x1F2E0中。压实容器C32中偏移量0x230处的簇之后的可用空间会映射至基础容器C56。物理容器R46已被ReFS重新映射，并成为一个空的压实保留容器，被基础容器C180所映射。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3636.png" style="width: 100%" />
<p class="图题">图11-94　容器C32已被压实到基础容器C124和C56中</p>
<p class="zw">在SMR磁盘中，启动压实操作的过程也叫垃圾回收。对于SMR磁盘，应用程序可以通过文件系统控制代码FSCTL_SET_REFS_SMR_VOLUME_GC_PARAMETERS决定在什么时候手动启动、停止或暂停垃圾回收过程。</p>
<p class="zw">与NTFS相反，对于非SMR磁盘，ReFS卷分析引擎可以自动启动容器压实过程。ReFS会追踪慢速层和快速层的闲置空间以及慢速层可用的可写入闲置空间。如果闲置空间与可用空间之间的差异超过阈值，则卷分析引擎会自动发起压实过程。此外，如果底层存储是由存储空间提供的，则会定期由一个专门的线程执行容器压实。</p>

<p class="epubit-contents-id" style="display: none">{"index":6,"parentId":"bfef1a76-a058-4e31-96a2-fa59897a014e","id":"37cb18c7-5dfa-48af-8869-10d3dc366849"}</p>