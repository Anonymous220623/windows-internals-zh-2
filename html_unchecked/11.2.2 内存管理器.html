<h3 class="bt3" id="sigil_toc_id_176">11.2.2　内存管理器</h3>
<p class="zw">缓存管理器不同寻常的地方在于，它永远不会知道物理内存中实际包含多少缓存的数据。这种说法也许会让人感觉奇怪，毕竟缓存的目的就是将一部分频繁访问的数据保留在物理内存中，以此提高I/O性能。而缓存管理器不知道物理内存中保留了多少缓存数据的原因在于，它是通过将文件视图映射到系统虚拟地址空间中来访问数据的，这一过程中使用了标准的节对象（或者使用符合Windows API术语的称呼，叫作文件映射对象）（节对象是内存管理器的一种基本基元，详见卷1第5章）。当访问映射视图中所包含的地址时，内存管理器会对不在物理内存中的块进行页面换入（pages-in）。而当内存需求发生变化时，内存管理器会将这些页面解除映射，从缓存中移出，如果数据发生了变化，则会将数据重新分页回到文件中。</p>
<p class="zw">通过在虚拟地址空间的基础上使用映射的文件进行缓存，缓存管理器可避免为访问所缓存的文件数据而生成读取或写入的I/O请求包（IRP）。相反，缓存管理器只是简单地针对被缓存文件中已映射部分对应的虚拟地址进行数据复制操作，并根据需要依赖的内存管理器将数据换入或换出内存。该过程使得内存管理器可以在全局范围内权衡要为系统缓存和用户进程分别分配多少RAM（缓存管理器也会发起I/O操作，如延迟写入，详见下文。不过它会调用内存管理器来写入页面）。此外，正如下一节将要讨论的，这种设计使得打开了被缓存文件的进程，可以像将同一个文件映射到自己用户地址空间的进程那样看到相同的数据。</p>

<p class="epubit-contents-id" style="display: none">{"index":1,"parentId":"3ad34383-9660-4e89-b628-a8cbdfed9828","id":"03db2f28-aca9-4a78-af95-d30fb790c06c"}</p>