<h3 class="bt3" id="sigil_toc_id_182">11.2.8　内存分区支持</h3>
<p class="zw">为了对Hyper-V容器和游戏模式提供支持，Windows 10引入了内存分区的概念。内存分区的概念已经在卷1第5章进行了介绍。通过那些介绍可知，内存分区由一种大型数据结构（MI_PARTITION）所代表，它维护了与分区有关的内存管理结构，如页面列表（备用、已修改、清零、闲置等）、内存使用（commit charge）、工作集、页面裁边器（page trimmer）、已修改页面写入器以及零页面线程。为了支持分区，缓存管理器必须与内存管理器相互配合。在NT内核初始化的阶段1期间，系统会创建并初始化缓存管理器分区（有关Windows内核初始化的详细信息请参阅第12章），该分区将成为系统执行体分区（MemoryPartition0）的一部分。为支持分区，缓存管理器的代码已进行了大规模重构，所有全局缓存管理器数据结构和变量已被移入缓存管理器分区数据结构（CC_ PARTITION）。</p>
<p class="zw">缓存管理器的分区包含与缓存有关的数据，如全局共享缓存映射列表、工作线程列表（预读取、后写入、额外后写入、惰性写入、惰性写入扫描、异步读取）、惰性写入器扫描事件、保存后写入历史吞吐量的数组、脏页阈值上限和下限、脏页数量等。当缓存管理器系统分区被初始化时，会在属于该分区的System进程上下文中启动所有需要的系统线程。每个分区总是有一个相关的最小System进程，它是在创建分区时由NtCreatePartition API创建的。</p>
<p class="zw">当系统通过NtCreatePartition API创建新的分区时，始终会创建并初始化一个空的MI_PARTITION对象（内存会从父分区移入子分区，或稍后由NtManagePartition函数热添加）。缓存管理器分区对象只在需要时创建。如果新分区的上下文中没有创建文件，此时就无须创建缓存管理器的分区对象。当文件系统创建或打开用于缓存访问的文件时，CcinitializeCacheMap(Ex)函数会检查该文件属于哪个分区，以及该分区是否具备指向缓存管理器分区的有效链接。如果不存在缓存管理器分区，系统就会通过CcCreatePartition例程创建并初始化一个新分区。这个新分区会启动一个与缓存管理器有关的独立线程（预读取、延迟写入等），并根据属于特定分区的页面数量来计算脏页阈值的新值。</p>
<p class="zw">文件对象通过其控制区包含一个指向自己所属分区的链接，该控制区最初由文件系统驱动程序在创建和映射流控制块（Stream Control Block，SCB）时分配。目标文件的分区会被存储到一个文件对象扩展（其类型为MemoryPartitionInformation）中，内存管理器在为SCB创建节对象时会检查该分区。一般来说，文件是一种共享的实体，因此文件系统驱动程序无法自动将文件关联到系统分区之外的其他分区。不过应用程序可以通过NtSetInformationFileKernel API和新增的FileMemoryPartitionInformation类为文件设置不同的分区。</p>

<p class="epubit-contents-id" style="display: none">{"index":7,"parentId":"3ad34383-9660-4e89-b628-a8cbdfed9828","id":"db6e6ac7-cc0f-4757-a311-c170eb69fde8"}</p>