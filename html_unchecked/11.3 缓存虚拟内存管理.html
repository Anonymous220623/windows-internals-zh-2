<h2 class="bt2" id="sigil_toc_id_183"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/bt2.png" style=""> 11.3　缓存虚拟内存管理</h2>
<p class="zw">由于Windows系统缓存管理器会以虚拟的方式缓存数据，因此需要占用系统虚拟地址空间（而非物理内存）中的区域，并在一个名为虚拟地址控制块（Virtual Address Control Block，VACB）的结构中进行管理。VACB将这些地址空间区域定义为256&nbsp;KB大小、名为视图（view）的槽。当缓存管理器在系统启动过程中初始化时，会分配一个初始VACB数组来描述缓存的内存。随着缓存需求的增加而需要使用更多内存，缓存管理器会按需分配更多的VACB数组。当其他需求为系统造成压力时，它也可以收缩虚拟地址空间。</p>
<p class="zw">在文件的首次I/O（读或写）操作中，缓存管理器会将文件中按照256&nbsp;KB对齐区域所包含请求数据的256&nbsp;KB视图映射至系统缓存地址空间中闲置的槽内。举例来说，如果要将从偏移量300000字节处开始的10字节读入文件，那么被映射的视图将从偏移量262144处开始（文件的第二个256&nbsp;KB对齐区域），并延伸到256&nbsp;KB。</p>
<p class="zw">缓存管理器会以循环的方式将文件视图映射到缓存地址空间的槽中，第一个被请求的视图会被映射至第一个256&nbsp;KB槽，第二个视图会被映射至第二个256KB槽，以此类推，如图11-3所示。在本例中，文件B首先被映射，文件A其次被映射，文件C第三个被映射，因此文件B被映射的块占据了缓存中的第一个槽。请注意，只有文件B的第一个256&nbsp;KB部分被映射了，因为该文件中只有这部分被实际访问。由于文件C仅100&nbsp;KB（小于系统缓存中的一个视图），因此只会在缓存中占据一个256&nbsp;KB槽。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx544.png" style="width: 100%" />
<p class="图题">图11-3 不同大小的文件被映射至系统缓存</p>
<p class="zw">缓存管理器保证只要视图处于活动状态，就会被映射（不过视图变为不活动状态后也可能维持映射）。然而，只有在对文件进行读取或写入操作时，视图才会被标记为活动。除非进程在调用CreateFile时指定了用FILE_FLAG_RANDOM_ ACCESS标记打开文件，否则缓存管理器在映射新视图时，如果检测到文件正在被连续访问，则会解除对不活动视图的映射。未映射视图的页面会被发送至备用或已修改列表（取决于内容是否有更改）中，因为内存管理器为缓存管理器导出一个特殊接口，缓存管理器可以指示将这些页面放置到这些列表的头部或尾部。对于使用FILE_FLAG_ SEQUENTIAL_SCAN标记打开的文件，其对应的视图页面会移动至列表头部，所有其他页面会移至尾部。这种设计方案是为了鼓励重复使用属于顺序读取文件的页面，尤其可防止大文件复制操作影响到太多物理内存。该标记还会对解除映射的操作产生影响，提供此标记时，缓存管理器会主动解除视图映射。</p>
<p class="zw">如果缓存管理器需要映射文件的视图，但缓存中已经没有空闲的槽位，此时会取消最近最少使用的非活动视图并使用其释放出的槽位。如果没有可取消映射的视图，则将会返回I/O错误，这表明没有足够的系统资源来执行该操作。不过考虑到视图只会在执行读取或写入操作时标记为活动，因此这种情况极为罕见，只有在同时访问成千上万个文件时才可能出现这种情况。</p>

<p class="epubit-contents-id" style="display: none">{"index":2,"parentId":"12042f06-13bb-4487-b2cc-12b9114bd68f","id":"d4e5a01c-c1d6-4c99-8cd1-3909dad371f4"}</p>