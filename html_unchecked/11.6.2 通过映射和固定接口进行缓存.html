<h3 class="bt3" id="sigil_toc_id_193">11.6.2　通过映射和固定接口进行缓存</h3>
<p class="zw">正如用户应用程序需要读/写磁盘上的文件数据一样，文件系统驱动程序也需要读/写描述文件本身的数据（元数据或卷结构数据）。然而，由于文件系统驱动程序运行在内核模式中，如果缓存管理器收到正确的通知，它们将可以直接修改系统缓存中的数据。为了允许这种优化，缓存管理器提供了一些函数，帮助文件系统驱动程序在虚拟内存中找到文件系统元数据的位置，因而可以在无需中间缓冲区的情况下直接修改这些数据。</p>
<p class="zw">如果文件系统驱动程序需要读取缓存中的文件系统元数据，它会调用缓存管理器的映射接口，以此获得所需数据的虚拟地址。缓存管理器会解除所请求的全部页面，将其带入内存，随后将控制返回给文件系统驱动程序。这样文件系统驱动程序就可以直接访问数据了。</p>
<p class="zw">如果文件系统驱动程序需要修改缓存页面，则会调用缓存管理器的固定（pinning）服务，借此让页面在虚拟内存中保持活动状态，使其无法被回收。但实际上这些页面并未锁定到内存中（例如设备驱动程序可能会锁定这些页面以便进行直接内存访问传输）。大多时候，文件系统驱动程序会将自己的元数据流标记为不可写入，借此告诉内存管理器的已映射页面写入器（详见卷1第5章）不要将这些页面写入磁盘，除非被明确告知需要这样做。当文件系统驱动程序取消固定（释放）页面后，缓存管理器也将释放自己的资源，以便通过延迟刷新的方式将改动写入磁盘，并释放元数据之前占用的缓存视图。</p>
<p class="zw">映射和固定接口解决了文件系统实现过程中的一个棘手问题：缓冲区管理。在无法直接操作已缓存元数据的情况下，更新卷结构时，文件系统必须预测自己需要的缓冲区的最大数量。通过允许文件系统直接在缓存中访问并更新自己的元数据，缓存管理器将不再需要缓冲区，只需直接在内存管理器提供的虚拟内存中更新卷结构即可。此时，可用内存量将是文件系统唯一可能受到的限制。</p>

<p class="epubit-contents-id" style="display: none">{"index":1,"parentId":"b7204c60-a482-40f3-b450-11354c2fbbd3","id":"d98a5c76-da77-4b13-837d-26a31dadedb6"}</p>