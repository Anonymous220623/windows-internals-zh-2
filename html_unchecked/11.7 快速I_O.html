<h2 class="bt2" id="sigil_toc_id_195"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/bt2.png" style=""> 11.7　快速I/O</h2>
<p class="zw">在可能的情况下，缓存文件的读/写是由一种名为快速I/O（Fast I/O）的高速机制处理的。快速I/O是一种无须生成IRP，直接对缓存文件进行读/写的方式。借助快速I/O，I/O管理器可以调用文件系统驱动程序的快速I/O例程，以查看是否无须生成IRP，直接通过缓存管理器满足I/O需求。</p>
<p class="zw">由于缓存管理器在架构上位于虚拟内存子系统之上，文件系统驱动程序可以使用缓存管理器访问文件数据，为此只需要对映射至被引用实际文件的页面进行复制即可，无须因为生成IRP而产生不必要的开销。</p>
<p class="zw">快速I/O并不能总是实现。例如，对文件的首次读/写需要设置文件以便进行缓存（将文件映射至缓存，并设置缓存数据结构，详见“缓存数据结构”一节）。此外，如果调用方指定了异步读取或写入，此时也将不使用快速I/O，因为调用方可能会在满足从/向系统缓存复制数据所需的分页I/O操作中停滞，因而无法真正提供所需的异步I/O操作。但是，即便在同步I/O操作中，文件系统驱动程序可能也会确定自己无法使用快速I/O机制处理I/O操作，例如，目标文件可能有锁定的字节范围（可能因为调用了Windows的LockFile和UnlockFile函数）。因为缓存管理器并不知道哪个文件的哪些部分被锁定，文件系统驱动程序必须检查读/写操作的有效性，这就会产生IRP。快速I/O的决策树如图11-12所示。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx695.png" style="width: 100%" />
<p class="图题">图11-12　快速I/O的决策树</p>
<p class="zw">通过快速I/O提供服务的读/写操作涉及下列步骤。</p>
<p class="zw">1）线程执行了读取或写入操作。</p>
<p class="zw">2）如果文件被缓存并且I/O是同步的，操作请求会被传递给文件系统驱动程序堆栈的快速I/O入口点。如果文件未被缓存，文件系统驱动程序会设置文件以便将其缓存，这样下一次就可以使用快速I/O满足读/写请求。</p>
<p class="zw">3）如果文件系统驱动程序的快速I/O例程判断快速I/O可行，那么它会调用缓存管理器的读取或写入例程，借此直接访问缓存中的文件数据（如果快速I/O不可行，文件系统驱动程序会返回到I/O系统，随后为该I/O生成一个IRP，并最终调用文件系统的常规读取例程）。</p>
<p class="zw">4）缓存管理器将收到的文件偏移量转换为缓存中的虚拟地址。</p>
<p class="zw">5）对于读取操作，缓存管理器会将数据从缓存复制到请求进程的缓冲区；对于写入操作，则会将数据从缓冲区复制到缓存。</p>
<p class="zw">6）随后将进行下列一种操作。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 对于读取操作，如果打开文件时未指定FILE_FLAG_RANDOM_ACCESS，则调用方的专用缓存图中的预读取信息会被更新。如果文件未指定FO_RANDOM_ ACCESS标记，则预读取操作可能会被放入队列。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 对于写入操作，缓存中任何已修改页面均会被设置“脏”位，这样延迟写入器就会知道要将其刷新到磁盘。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 对于直接写入（write-through）的文件，任何改动都会被刷新到磁盘。</p>

<p class="epubit-contents-id" style="display: none">{"index":6,"parentId":"12042f06-13bb-4487-b2cc-12b9114bd68f","id":"0bf80db4-89e5-4f11-a267-f429f05f8001"}</p>