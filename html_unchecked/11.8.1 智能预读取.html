<h3 class="bt3" id="sigil_toc_id_197">11.8.1　智能预读取</h3>
<p class="zw">缓存管理器可以利用空间定位的原理执行智能预读取，借此根据目前读取的数据来预测调用方的进程接下来最有可能读取哪些数据。由于系统缓存基于虚拟地址，而对特定文件来说虚拟地址是连续的，因此，实际上在物理内存中是否连续并不重要。逻辑块缓存的文件预读取更为复杂，需要文件系统驱动程序与块缓存之间的紧密配合，因为该缓存系统基于磁盘上被访问数据的相对位置，当然，文件并不一定会以连续的方式存储在磁盘上。我们可以使用Cache: Read Aheads/sec性能计数器或CcReadAheadIos系统变量查看预读取活动。</p>
<p class="zw">读取一个正在按顺序访问文件的下一个块，这种做法可以明显提高性能，但不足之处在于需要寻找头部（head seek）。为了将这种预读取带来的好处拓展至连续数据访问的情况（包括向前和向后的文件访问），缓存管理器会使用映射缓存映射，为被访问的文件句柄维持一个包含最近两次读取请求的历史记录，这种方法也称“带历史记录的异步预读取”。如果能从调用方的明显随机读取操作中确定某种模式，缓存管理器就会做出相应推断。举例来说，如果调用方读取页面4000后又读取了页面3000，缓存管理器就会假设调用方接下来会读取页面2000并进行预读取。</p>
<table> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　虽然调用方必须至少发出三个读取操作才能建立可预测的序列，但私有缓存映射中只存储最近的两个操作。</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">为了使预读取变得更加高效，Win32的CreateFile函数还提供了一个指示前向顺序文件访问的标记：FILE_FLAG_SEQUENTIAL_SCAN。如果设置了该标记，缓存管理器将不会为调用方保留预测所需的读取历史，而是会执行顺序性的预读取。不过随着文件被读入缓存的工作集，缓存管理器会取消对文件中不再活跃的视图的映射，如果这些视图未被修改，则会指示内存管理器将属于未映射视图的页面放在备用列表的前端，以便能快速重用。此外还会预读取两倍的数据（例如读取2&nbsp;MB，而非1&nbsp;MB）。当调用方继续读取时，缓存管理器还会预读取额外的数据块，始终比调用方领先一个读取（按照当前读取的数据大小进行预读取）。</p>
<p class="zw">缓存管理器的预读取是一种异步操作，因为这是通过独立于调用方线程的另一个线程来执行的，并且会与调用方同时进行。调用检索缓存的数据时，缓存管理器首先会访问被请求的虚拟页，以满足请求，随后将一个额外的I/O请求放入队列，借此为系统工作线程检索更多的数据。随后会在后台执行该工作线程，读取额外数据并等待调用方的下一个读取请求。当程序继续执行时，预读取的页面进入内存，这样，当调用方请求时，相关数据就已经位于内存中了。</p>
<p class="zw">对于读取模式不可预测的应用程序，可在调用CreateFile函数时指定FILE_FLAG_ RANDOM_ACCESS标记。该标记会指示缓存管理器不要试图预测应用程序接下来读取什么，进而可以禁用预读取。该标记还可以阻止缓存管理器在文件被访问时积极地解除文件视图映射，进而在应用程序重新访问文件中的部分内容时，最大限度地减少文件的映射/取消映射活动。</p>

<p class="epubit-contents-id" style="display: none">{"index":0,"parentId":"12f97583-be18-467a-a595-eb74d0d9db22","id":"a79ad012-cda1-40d3-a478-d52a3c9e1dac"}</p>