<h3 class="bt3" id="sigil_toc_id_206">11.8.10　动态内存</h3>
<p class="zw">如上文所述，脏页阈值是根据物理内存的可用数量动态计算而来的。缓存管理器会使用该阈值决定何时对传入的写入操作进行限流，以及是否执行更激进的后写入操作。</p>
<p class="zw">在系统引入分区这个概念前，该计算由CcInitializeCacheManager例程（通过检查MmNumberOfPhysicalPages全局值）进行，这个例程会在内核初始化的阶段1期间执行。现在，则由缓存管理器分区的初始化函数根据属于相关联内存分区的可用物理内存页执行该计算（有关缓存管理器分区的详细信息，请参阅上文“内存分区支持”一节）。但这还不够，因为Windows还支持物理内存的热添加，Hyper-V大量借助该功能为子虚拟机的动态内存提供支持。</p>
<p class="zw">在内存管理器初始化的阶段0期间，MiCreatePfnDatabase将计算PFN数据库的最大可能大小。在64位系统中，内存管理器会假定已安装物理内存可能的最大值等于所有可寻址的虚拟内存范围（例如，非LA57系统为256&nbsp;TB）。系统会要求内存管理器为整个地址空间中每个虚拟页面保留存储PFN所需的虚拟地址空间数量（这个假设中的PFN数据库大小约为64&nbsp;GB）。随后MiCreateSparsePfnDatabase会在Winload检测到的每个有效物理内存范围之间循环，将有效PFN映射至数据库。PFN数据库会使用稀疏内存。当MiAddPhysicalMemory例程检测到新的物理内存后，会在PFN数据库中分配新区域，借此创建新的PFN。有关动态内存的详细信息请参阅第9章，下文将进一步介绍其中的一些细节。</p>
<p class="zw">缓存管理器需要检测新的热添加或热移除内存，并要适应新的系统配置，否则可能出现多种问题，如下。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 热添加了新内存的情况下，缓存管理器可能认为系统内存较少，导致脏页的阈值低于本应使用的值。这会导致缓存管理器缓存的脏页的数量少于本应缓存的数量，因此会更快速地对写入进行限流。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 如果大量可用内存被锁定或不再可用，在系统中执行缓存的I/O可能影响其他应用程序的响应性（即进行了热移除后，这些应用程序基本上已经没有更多内存可用）。</p>
<p class="zw">为了正确处理这些情况，缓存管理器并不会向内存管理器注册回调，而是在惰性写入器扫描（LWS）线程中实现了一种自适应修正机制。除了扫描共享缓存映射列表并确定要写入哪些脏页外，LWS线程还可以根据前台速率、自己的写入速率以及可用内存数更改脏页的阈值。LWS维护了分区的物理页面和脏页的平均可用数历史记录。每隔一秒，LWS线程会更新这些列表并计算汇总值。借助这个汇总值，LWS就可以响应内存大小的变化，削弱峰值并逐渐修改阈值的上限和下限。</p>

<p class="epubit-contents-id" style="display: none">{"index":9,"parentId":"12f97583-be18-467a-a595-eb74d0d9db22","id":"ae4b1c13-49a7-4c77-ab32-1366d224f2c1"}</p>