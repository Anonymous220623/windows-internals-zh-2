<h3 class="bt3" id="sigil_toc_id_202">11.8.6　刷新映射的文件</h3>
<p class="zw">如果惰性写入器必须从一个同时也被映射到另一个进程地址空间的视图中将数据写入磁盘，那么情况将变得有些复杂，因为缓存管理器只知道自己修改过的页面（被另一个进程修改的页面只有该进程才会知道，因为已修改页面在页表项中的“已修改”位保存在进程的私有页表中）。为了解决这个问题，当用户映射文件时，内存管理器会向缓存管理器发出通知。当这样的文件在缓存中刷新时（例如可能调用了Windows的FlushFileBuffers函数），缓存管理器会将脏页写入缓存，随后检查该文件是否也被其他进程映射。如果发现该文件也被其他进程映射，缓存管理器将刷新该节的完整视图，以便写出第二个进程可能修改过的页面。如果用户映射的文件视图也在其他缓存中打开，在视图被撤销映射后，则已修改页面会被标记为脏页，延迟写入器线程随后会刷新该视图，这些脏页将被写入磁盘。该过程会按照下列顺序依次进行。</p>
<p class="zw">1）用户撤销对视图的映射。</p>
<p class="zw">2）进程刷新文件缓冲区。</p>
<p class="zw">如果不使用这样的顺序，就无法预测要将哪些页面写入磁盘。</p>
<p class="zwtsh">实验：观察缓存的刷新</p>
<p class="zwts1">我们可以在性能监视器中使用Data Maps/sec和Lazy Write Flushes/sec计数器查看缓存管理器将视图映射至系统缓存，并将页面刷新到磁盘的过程（这些计数器位于“Cache”组中）。随后将大文件从一个位置复制到另一个位置。下图中较高的那条线对应了Data Maps/sec，另一条线对应了Lazy Write Flushes/sec。在文件复制过程中，Lazy Write Flushes/sec的数值明显增加。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx928.png" style="width: 100%" />

<p class="epubit-contents-id" style="display: none">{"index":5,"parentId":"12f97583-be18-467a-a595-eb74d0d9db22","id":"35375a18-bb3e-453e-aeea-37526868d625"}</p>