<h3 class="bt3" id="sigil_toc_id_218">11.9.10　远程FSD</h3>
<p class="zw">每个远程FSD都包含两个组件：一个客户端和一个服务器。客户端远程FSD可供应用程序访问远程文件和目录。客户端FSD组件可接收来自应用程序的I/O请求，将其转换为网络文件系统协议命令（如SMB），随后这些命令被FSD通过网络发送给服务器端组件（也是一种远程FSD）。服务器端FSD监听来自网络连接的命令，并向命令所要访问的文件或目录所在卷对应的本地FSD发出I/O请求，进而完成这些命令。</p>
<p class="zw">Windows包含一个客户端远程FSD，名为LANMan Redirector（通常可简称为重定向器）；以及一个服务器端远程FSD，名为LANMan Server（%SystemRoot%\System32\ Drivers\Srv2.sys）。图11-18展示了客户端通过重定向器和服务器FSD从服务器上远程访问文件时这几方之间的关系。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx1277.png" style="width: 100%" />
<p class="图题">图11-18　CIFS文件共享</p>
<p class="zw">Windows依赖通用Internet文件系统（Common Internet File System，CIFS）协议来调整重定向器和服务器间所交换消息的格式。CIFS是微软服务器消息块（Server Message Block，SMB）协议的一个版本（有关SMB的详情请访问https://docs.microsoft.com/windows/ win32/fileio/microsoft-smb-protocol-and-cifs-protocol-overview）。</p>
<p class="zw">与本地FSD类似，客户端远程FSD通常使用缓存管理器服务对属于远程文件和目录的数据创建本地缓存文件，这种情况下，双方必须在客户端和服务器端之间实现一种分布式锁定机制。SMB客户端远程FSD实现了一种名为Oplock（Opportunistic Locking，机会锁）的分布式缓存一致性协议，这样，当一个应用程序访问远程文件时，它就能和另一端计算机上运行的应用程序访问同一个文件时看到的数据相同。第三方文件系统可以选择使用Oplock协议，或者也可能实现自己的协议。尽管服务器端远程FSD参与了跨客户端的缓存一致性的维护工作，但并不缓存来自本地FSD的数据，因为本地FSD会自行缓存自己的数据。</p>
<p class="zw">最基本的问题在于，只要一个资源可以被多个访问者同时共享访问，就必须提供一种序列化机制来对资源的写入操作进行仲裁，进而保证对任意一个特定时间，只有一个访问者可以执行写入访问。如果缺乏这种机制，那么资源就可能会损坏。所有实现SMB协议的文件服务器均会以Oplock（机会锁）和Lease（租约）作为锁定机制。具体使用哪种机制取决于服务器端和客户端的能力，其中Lease是首选机制。</p>
<p class="zw">Oplock　该功能实现于文件系统运行时库（FsRtlXxx函数）中，可被任何文件系统驱动程序使用。远程文件服务器的客户端可以使用Oplock动态地确定为最大限度地减少网络流量，该使用哪种客户端缓存策略。当应用程序试图打开文件时，文件系统驱动程序或重定向器会代表该应用程序对共享中包含的这个文件请求一个Oplock。授予Oplock后，客户端即可缓存文件，而不需要将每次读/写操作通过网络发送给文件服务器。例如，客户端能够以独占访问的方式打开一个文件，这样该客户端即可缓存对这个文件的所有读/写，并在文件关闭后将更新发送给文件服务器。相反，如果服务器未向客户端授予Oplock，就必须将所有读/写发送到服务器。</p>
<p class="zw">一旦授予Oplock，客户端就可开始缓存文件，并通过Oplock的类型确定可进行哪些类型的缓存。Oplock并不一定要一直保持到客户端完成对文件的所有操作，如果服务器收到一个与现有已授予Oplock不兼容的操作，那么已授予的Oplock也可以随时打破。这意味着客户端必须能够快速对Oplock的打破做出响应并动态更改自己的缓存策略。</p>
<p class="zw">在SMB 2.1之前，Oplock共分为以下四种类型。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 1<strong style="color:#0092dd">级，独占式访问</strong>。这种锁可供客户端以独占访问方式打开文件。客户端可执行预读取缓冲和读取或写入缓存。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 2<strong style="color:#0092dd">级，共享式访问</strong>。这种锁可以支持一个文件的多个并发读取者，但不支持写入者。客户端可执行预读取缓冲并对文件数据和属性进行读取缓存。对文件执行写入操作将导致锁的持有者收到“锁已打破”的通知。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">批处理，独占式访问</strong>。顾名思义，这种锁是一种用于处理批处理（.bat）文件的锁，文件中每行内容的处理都需要打开并关闭一次。客户端也许保持服务器上的文件处于打开状态，但应用程序可以（也许临时性地）关闭该文件。这种锁支持读取、写入和句柄缓存。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">过滤器，独占式访问</strong>。这种锁为应用程序和文件系统过滤器提供了一种机制，以便在其他客户端试图访问同一个文件时放弃自己的锁，但与2级锁的不同之处在于，打开的文件无法进行删除访问，其他客户端也不会收到共享违规的通知。这种锁支持读取和写入缓存。</p>
<p class="zw">以最简单的方式来说，如果多个客户端系统全都在缓存某一个服务器上的同一个共享文件，那么只要（来自任何客户端或服务器的）每个应用程序访问该文件时都只进行读取操作，那么这些读取操作都将能被每个系统的本地缓存所满足。这大幅减少了网络流量，因为并不需要服务器将文件内容发送给每个系统。此时依然需要在客户端系统和服务器之间交换锁信息，但这只需要很少的网络带宽。然而，如果哪怕只有一个客户端以读/写访问（或独占写入）的方式打开文件，那么任何一个客户端都无法使用自己的本地缓存，对文件执行的所有I/O操作必须立即发送到服务器，哪怕该文件从未被写入（锁定模式取决于文件的打开方式，而非具体的I/O请求）。</p>
<p class="zw">图11-19所示的这个例子可以帮助大家了解Oplock操作。服务器自动为打开并访问文件的第一个客户端授予了1级Oplock。客户端上的重定向器将文件数据的读/写操作都缓存在客户端计算机上的文件缓存中。如果第二个客户端打开了同一个文件，该客户端也请求了一个1级Oplock。然而，由于目前有两个客户端在访问同一个文件，所以服务器必须采取相应措施，以便为这两个客户端展示文件数据的一致视图。如果像图11-19中演示的那样，第一个客户端写入了文件，那么服务器会撤销它的Oplock，并且不再向任何客户端授予Oplock。当第一个客户端的Oplock被撤销或打破后，该客户端会把自己为该文件缓存的所有数据刷新到服务器端。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx1284.png" style="width: 100%" />
<p class="图题">图11-19　Oplock范例</p>
<p class="zw">如果第一个客户端未写入文件，那么第一个客户端的Oplock就会被“降级”为2级Oplock，服务器为第二个客户端授予的也是这种锁。这样两个客户端就可以对读取操作进行缓存，但如果任一方写入了文件，那么服务器将撤销双方的Oplock，随后将只能在非缓存的情况下执行操作。一旦Oplock被打破，那么将无法再次授予打开该文件的同一个实例。然而，如果客户端关闭并重新打开同一个文件，服务器将重新评估需要向客户端授予哪种级别的锁，该评估工作将考虑其他哪些客户端打开了该文件，以及其中是否有至少一个客户端写入过该文件。</p>
<p class="zwtsh">实验：查看已注册文件系统列表</p>
<p class="zwts1">当I/O管理器将设备驱动程序载入内存时，通常会为自己创建的代表驱动程序的驱动程序对象命名，并将其放入对象管理器的\Driver目录下。I/O管理器加载的任何驱动程序所对应的驱动程序对象，如果其Type特性值为SERVICE_FILE_SYSTEM_ DRIVER (2)，则都会被I/O管理器放入\FileSystem目录下。因此使用诸如WinObj（来自Sysinternals）等工具即可看到系统中已注册的文件系统，如下图所示。请注意，文件系统过滤器驱动程序也会出现在该列表中。过滤器驱动程序详见下文介绍。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx1293.png" style="width: 100%" />
<p class="zwts1">另一种查看已注册文件系统的方法是使用系统信息查看器。从“<strong style="color:#0092dd">开始</strong>”菜单的“<strong style="color:#0092dd">运行</strong>”对话框中运行Msinfo32，选择“<strong style="color:#0092dd">软件环境</strong>”下的“<strong style="color:#0092dd">系统驱动程序</strong>”。随后点击“<strong style="color:#0092dd">类型</strong>”列，列表将按照驱动程序进行排序，这样所有类型为SERVICE_FILE_SYSTEM_ DRIVER的驱动程序就会显示在一起。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx1303.png" style="width: 100%" />
<p class="zwts1">请注意，驱动程序即使注册为文件系统驱动程序，也并不一定意味着它是本地或远程FSD。例如，NPFS（命名管道文件系统）是一种通过类似文件系统的私有命名空间实现命名管道的驱动程序。如上文所述，该列表中也包含文件系统过滤器驱动程序。</p>
<p class="zw">Lease　在SMB 2.1之前，SMB协议会假设客户端和服务器间的网络连接是不会出错的，因此无法容忍瞬时网络故障、服务器重启动或集群故障转移导致的网络断开。当客户端收到网络断开事件时，会孤立所有受影响服务器上打开的句柄，并且对这些孤立句柄进行的所有后续I/O操作都将失败。类似地，服务器也会释放所有打开的句柄以及与已断开用户会话相关的资源。这种行为会导致应用程序丢失状态，并产生不必要的网络流量。</p>
<p class="zw">SMB 2.1中引入了Lease（租约）的概念，这是一种与Oplock类似的全新客户端缓存机制类型。租约的目的与Oplock相同，但提供了更高灵活性和更好的性能。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">读取（R），共享式访问</strong>。允许一个文件拥有多个并发读取者，但没有写入者。这种租约允许客户端执行预读取缓冲和读取缓存。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">读取句柄（RH），共享式访问</strong>。与2级Oplock类似，但额外的好处是可以让客户端在服务器上保持一个文件处于打开状态，即便客户端访问者已关闭了该文件（缓存管理器会对未写入数据进行延迟刷新，并根据可用内存状况清空未修改的缓存页）。这是一种比2级Oplock更好的做法，因为打开和关闭文件句柄期间无须破坏租约（这方面其实提供了与批处理Oplock类似的语义）。此类租约适合需要反复打开和关闭的文件，因为文件关闭后缓存不会失效，文件再次打开后也无须重新填充缓存，这可有效改善复杂的I/O密集型应用程序性能。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">读取-写入（RW），独占式访问</strong>。该租约可供客户端以独占访问方式打开文件。该租约允许客户端执行预读取缓冲和读取或写入缓存。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">读取-写入-句柄（RWH），独占式访问</strong>。此租约可供客户端以独占访问方式打开文件。该租约支持读取、写入和句柄缓存（类似于读取-句柄租约）。</p>
<p class="zw">相比Oplock，租约的另一个优势在于，即便客户端上有多个打开的文件句柄，文件依然可以被缓存（对很多应用程序来说，这是一种很常见的行为）。这是通过使用一种租约密钥（通过GUID实现）做到的，租约密钥可由客户端创建，并与缓存文件的文件控制块（File Control Block，FCB）相关联，这样，同一个文件的所有句柄即可共享相同的租约状态，进而实现按文件进行缓存，而非按句柄进行缓存的功能。在引入租约前，当文件打开了新句柄时，哪怕是从同一个客户端打开，Oplock都会被打破。图11-20展示了Oplock行为，图11-21展示了新的租约行为。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx1314.png" style="width: 100%" />
<p class="图题">图11-20　同一个客户端打开多个句柄时的Oplock</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx1326.png" style="width: 100%" />
<p class="图题">图11-21　同一个客户端打开多个句柄时的租约</p>
<p class="zw">在SMB 2.1之前，Oplock只能授予或打破，但租约还可以转换。例如，读取租约可转换为读取-写入租约，这样可以大幅减少网络流量，因为特定文件的缓存无须失效并重新填充，就像是（2级Oplock）在锁打破后请求并授予1级Oplock那样。</p>

<p class="epubit-contents-id" style="display: none">{"index":9,"parentId":"0c1656e4-96a3-4397-a023-91a7bb19a11b","id":"b472e46c-edd0-46ac-a296-67fe2e9f78eb"}</p>