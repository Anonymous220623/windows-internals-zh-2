<h3 class="bt3" id="sigil_toc_id_223">11.9.15　缓存管理器的预读取线程</h3>
<p class="zw">缓存的工作依赖程序引用代码和数据时的两个特征：时间局部性（temporal locality）和空间局部性（spatial locality）。时间局部性背后的思想是，如果一个内存位置被引用，那么可能很快就会再次被引用。空间局部性背后的思想是，如果一个内存位置被引用，那么可能很快就会引用该位置周围的其他位置。因此，缓存通常在为曾被访问过的内存位置进行访问加速时可取得不错的效果，但对未曾访问过的内存位置，其加速效果就很糟糕（缓存几乎没有“前瞻性”）。为了将很快可能被用到的数据填充到缓存中，缓存管理器实现了两种机制，即预读取（read-ahead）线程和Superfetch。</p>
<p class="zw">如上文所述，缓存管理器包含一个线程，该线程负责在应用程序、驱动程序或系统线程明确请求某些数据之前，尝试从文件中读取这些数据。这个预读取线程会借助针对文件执行读取操作的历史记录（这些记录存储在文件对象的私有缓存映射中）来确定要读取多少数据。当该线程执行预读取操作时，会直接将自己希望读取的文件部分映射至缓存（并在必要时分配VACB），随后直接处理映射的数据。由内存访问引起的页面错误会调用页面错误处理程序，并借此将页面读入系统工作集。</p>
<p class="zw">预读取线程的一个局限在于只适用于打开的文件。而Windows中随后增加的Superfetch可以在文件打开之前主动将其加入缓存中。具体来说，内存管理器会将页面使用信息发送给Superfetch服务（%SystemRoot%\System32\Sysmain.dll），并由文件系统小型过滤器提供文件名称解析数据。Superfetch服务会试图找出文件的使用模式，例如每周五12:00运行薪酬应用，每天早晨8:00运行Outlook。在得出这些模式后，相关信息会存储在一个数据库中并会请求计时器。当文件最有可能被使用的时间即将到达时，计时器会启动并告诉内存管理器将相关文件（使用低优先级磁盘I/O）读入低优先级内存。如果随后打开了这些文件，此时数据已经位于内存中，就无须等待数据从磁盘读取了。如果文件未被打开，低优先级内存将被系统回收。有关Superfetch服务内部原理的完整介绍请参阅卷1第5章。</p>

<p class="epubit-contents-id" style="display: none">{"index":14,"parentId":"0c1656e4-96a3-4397-a023-91a7bb19a11b","id":"f5e100f0-2a16-4bd2-8032-601b57613246"}</p>