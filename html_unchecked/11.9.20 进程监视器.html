<h3 class="bt3" id="sigil_toc_id_228">11.9.20　进程监视器</h3>
<p class="zw">本书中大量使用的Sysinternals系统活动监视工具进程监视器（Procmon）就用到了被动的微过滤器驱动程序。“被动”是指它不会修改应用程序和文件系统驱动程序之间的IRP流。</p>
<p class="zw">进程监视器的工作原理：在系统启动后首次运行时，从自己的可执行映像（以资源形式存储在Procmon.exe中）中提取一个文件系统微过滤器驱动程序，并将该驱动程序安装到内存中，随后从磁盘上删除驱动程序的映像（除非配置了持久的启动时监视）。我们可以通过进程监视器的GUI指示该驱动程序监视分配了盘符的本地卷、网络共享、命名管道，以及邮件槽上的文件系统活动。当驱动程序收到开始监视卷的命令时，它会向过滤器管理器注册过滤回调，而过滤器管理器会被附加至代表卷上所挂载文件系统的设备对象。附加操作之后，I/O管理器会以底层设备对象为目标，将IRP重定向至拥有该附加设备的驱动程序，本例中是指过滤器管理器，它会将事件发送至已注册的微过滤器驱动程序，也就是本例中的进程监视器。</p>
<p class="zw">当进程监视器驱动程序拦截了IRP时，会记录有关IRP命令的信息，包括目标文件名和与命令有关的其他参数（如读/写长度和偏移量），这些信息会被记录到非分页内核缓冲区中。每500毫秒，进程监视器的GUI程序会向进程监视器的接口设备对象发送一个IRP，借此请求缓冲区中所包含最新活动信息的副本，随后将这些活动显示在自己的输出窗口中。进程监视器会在发生那一刻显示出所有的文件活动，因此它很适合用于排查与文件系统相关的系统和应用程序故障。在系统上首次运行进程监视器时，账户必须具备Load Driver和Debug特权。加载后，驱动程序将常驻，因此后续运行时只需要具备Debug特权。</p>
<p class="zw">在运行进程监视器时，它会以基本模式启动，只显示对排错工作最有价值的文件系统活动。处于基本模式的进程监视器会忽略（不显示）某些文件系统操作，包括：</p>
<p class="zwd"><span style="color: #0092dd">●</span> 针对NTFS元数据文件的I/O。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 针对分页文件的I/O。</p>
<p class="zwd"><span style="color: #0092dd">●</span> System进程生成的I/O。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 进程监视器进程生成的I/O。</p>
<p class="zw">基本模式下的进程监视器还会使用更友好的名称（而不是表示名称的IRP类型）来报告文件的I/O操作。例如，IRP_MJ_WRITE和FASTIO_WRITE的操作都会显示为WriteFile，而IRP_MJ_CREATE的操作则会显示为Open（如果代表打开操作）或Create（如果代表新建文件）。</p>
<p class="zwtsh">实验：查看进程监视器的微过滤器驱动程序</p>
<p class="zwts1">要查看已加载的文件系统微过滤器驱动程序，请以管理员身份启动命令提示符窗口，运行过滤器管理器控制程序（%SystemRoot%\System32\Fltmc.exe）。然后启动进程监视器（ProcMon.exe）并再次运行Fltmc。这样将能看到进程监视器的过滤器驱动程序（PROCMON20）已加载，且Instances列中显示有一个非0值。最后退出进程监视器并再次运行Fltmc。这次可以看到进程监视器的过滤器驱动程序依然加载，但实例数为0。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx1437.png" style="width: 100%" />

<p class="epubit-contents-id" style="display: none">{"index":19,"parentId":"0c1656e4-96a3-4397-a023-91a7bb19a11b","id":"8bca8a8d-b476-4aed-9772-3aecb24b784a"}</p>