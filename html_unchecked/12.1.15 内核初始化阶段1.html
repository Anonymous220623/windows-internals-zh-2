<h3 class="bt3" id="sigil_toc_id_343">12.1.15　内核初始化阶段1</h3>
<p class="zw">只要Idle线程得到执行机会，将开始内核初始化的第一阶段。该阶段包含下列步骤。</p>
<p class="zw">1）顾名思义，Phase1InitializationDiscard将丢弃内核映像中INIT节所包含的代码，借此保留内存。</p>
<p class="zw">2）初始化线程将自己的优先级设置为31，这是最高优先级，主要是为了防止自己被抢占。</p>
<p class="zw">3）评估BCD选项，借此指定虚拟处理器（hypervisorrootproc）数量的最大值。</p>
<p class="zw">4）创建NUMA/组拓扑关系，系统会尝试通过这种关系在逻辑处理器和处理器组之间实现最优化的映射关系，除非被相关BCD设置覆盖，否则还会考虑NUMA的位置和距离。</p>
<p class="zw">5）HalInitSystem执行自己的第一阶段初始化，让系统准备好接收来自外设的中断。</p>
<p class="zw">6）系统时钟中断初始化完成，启用系统时钟的时钟周期（tick）生成工作。</p>
<p class="zw">7）初始化传统的启动视频驱动程序（Bootvid），该驱动程序只用于输出调试信息，以及由SMSS启动的原生应用程序（如NT Chkdsk）所生成的信息。</p>
<p class="zw">8）内核构建各种字符串和版本信息，如果启用了SOS启动选项，这些信息会通过Bootvid显示在屏幕上。其中包括完整的版本信息、支持的处理器数量以及支持的内存数量。</p>
<p class="zw">9）调用电源管理器的初始化过程。</p>
<p class="zw">10）通过HalQueryRealTimeClock初始化系统时间，随后将其作为系统的启动时间存储起来。</p>
<p class="zw">11）在多处理器系统中，其他处理器将由KeStartAllProcessors和HalAllProcessorsStarted初始化。可被初始化并可支持的处理器数量取决于多种因素的组合，包括实际安装的物理处理器数量、已安装Windows版本的许可信息、启动选项（如numproc和bootproc），以及是否启用了动态分区（仅限服务器系统）。在所有可用处理器均初始化完毕后，系统处理器的相关性会被更新，以涵盖所有处理器。</p>
<p class="zw">12）对象管理器初始化全局系统Silo、每个处理器的非分页查找列表和描述符，以及基本审计（如果被系统控制向量启用）。它会创建命名空间根目录（\）、\KernelObjects目录、\ObjectTypes目录以及DOS设备名映射目录（\Global??），并在其中创建Global和GLOBALROOT链接。对象管理器还会创建Silo设备映射，借此控制DOS设备名映射并将其附加给系统进程。它还将创建传统的\DosDevices符号链接（为了维持兼容性），该符号链接会指向Windows子系统设备名映射目录。最后，对象管理器会将每个已注册的对象类型插入\ObjectTypes目录对象中。</p>
<p class="zw">13）调用执行体以创建执行体的对象类型，包括信号量、互斥、事件、计时器、键控事件、推锁以及线程池工作器。</p>
<p class="zw">14）调用I/O管理器以创建I/O管理器对象类型，包括设备、驱动程序、控制器、适配器、I/O完成、等待完成以及文件对象。</p>
<p class="zw">15）内核初始化系统监视器（Watchdog）。监视器主要分两种类型：DPC监视器，负责检查DPC例程的执行时间是否超过指定时间；CPU Keep Alive监视器，负责确认每个CPU是否总能提供响应。如果系统由虚拟机监控程序执行，那么监视器将不被初始化。</p>
<p class="zw">16）内核初始化每个CPU的处理器控制块（KPRCB）数据结构，计算NUMA成本阵列，最后计算系统时钟周期和量程时长。</p>
<p class="zw">17）无论此前调试器是否被触发，此时内核调试器库都会完成调试设置和参数的初始化工作。</p>
<p class="zw">18）事务管理器创建自己的对象类型，例如登记（Enlistment）、资源管理器以及事务管理器类型。</p>
<p class="zw">19）为全局系统Silo初始化用户模式调试库（Dbgk）数据结构。</p>
<p class="zw">20）如果已启用驱动程序认证器并取决于验证选项，则启用池认证，并开始跟踪系统进程的对象句柄。</p>
<p class="zw">21）安全引用监视器在对象管理器命名空间中创建\Security目录，通过安全描述符对该目录提供保护，只允许SYSTEM账户进行完整访问。如果启用了审计，还将初始化审计数据结构。此外，安全引用监视器会初始化内核模式SDDL库并创建在LSA初始化完成后发送信号的事件（\Security\LSA_AUTHENTICATION_INITIALIZED）。最后，安全引用监视器会调用内部的CiInitialize例程以首次进行内核代码完整性组件（Ci.dll）的初始化，期间会初始化所有代码的完整性回调并保存启动驱动程序列表，以供后续审计与认证工作使用。</p>
<p class="zw">22）进程管理器为执行体系统分区创建系统句柄。首先，该句柄永远不会被取消引用，因此系统分区无法被销毁。随后，进程管理器将初始化对内核可选扩展的支持（详见步骤26）。它会为各种操作系统服务注册主机调用，例如，后台活动审查器（Background Activity Moderator，BAM）、桌面活动审查器（Desktop Activity Moderator，DAM）、多媒体类计划程序服务（Multimedia Class Scheduler Service，MMCSS）、内核硬件跟踪，以及Windows Defender System Guard。最后，如果启用VSM，还会创建第一个最小化进程IUM系统进程，并将其命名为Secure System。</p>
<p class="zw">23）创建\SystemRoot符号链接。</p>
<p class="zw">24）调用内存管理器以执行第一阶段的初始化工作。首先，该阶段将创建Section对象类型，初始化所有相关结构（如控制区），并创建\Device\PhysicalMemory节对象。随后，它将初始化对内核控制流防护（control flow guard）功能的支持，并创建页面文件支撑的节，这些节将用于描述用户模式CFG位图（有关控制流防护的更多信息请参阅本书卷1第7章）。内存管理器将初始化对内存隔区的支持（仅限兼容SGX的系统），以及对热补丁的支持，还将初始化页面组合数据结构和系统内存事件。最后，它将启动三个内存管理器系统工作线程（Balance Set Manager、Process Swapper和Zero Page Thread详见本书卷1第5章），并创建一个用于将API集Schema内存缓冲区映射至系统空间所使用的节对象（这个系统空间之前已由Windows加载器分配）。这些新创建的系统线程将有机会在阶段1结束后的后续环节中执行。</p>
<p class="zw">25）NLS表被映射至系统空间，这样就可以被用户模式进程轻松映射。</p>
<p class="zw">26）缓存管理器初始化文件系统缓存数据结构并创建自己的工作线程。</p>
<p class="zw">27）配置管理器在对象管理器命名空间中创建\Registry键对象，并将内存中的SYSTEM配置单元作为适当的配置单元文件打开。随后它会将Winload传递来的初始硬件树数据复制到易失的HARDWARE配置单元。</p>
<p class="zw">28）系统初始化内核可选扩展。该功能由Windows 8.1引入，目的在于在不使用标准PE（可移植可执行）导出的前提下，将私有系统组件和Windows加载器数据（如内存缓存要求、UEFI运行时服务指针、UEFI内存映射、SMBIOS数据、安全启动策略及代码完整性数据）导出给不同的内核组件（如安全内核）。</p>
<p class="zw">29）勘误表管理器（errata manager）初始化并扫描注册表中的勘误信息，以及包含各类驱动程序对应的勘误信息的INF数据库（INF是一种驱动程序安装文件，详见本书卷1第6章）。</p>
<p class="zw">30）处理与生产有关的设置。生产模式（manufacturing mode）是一种特殊的操作系统模式，可用于处理与生产商有关的各类任务，例如组件和支持测试。该功能仅适用于移动系统，由UEFI子系统提供。如果固件（通过一个特殊的UEFI协议）告知操作系统这个特殊模式已启用，Windows将从HKLM\System\CurrentControlSet\ Control\ManufacturingMode注册表键读/写所有的必要信息。</p>
<p class="zw">31）初始化Superfetch及其预取程序。</p>
<p class="zw">32）初始化内核虚拟存储管理器，该组件是内存压缩功能的一部分。</p>
<p class="zw">33）初始化VM组件，该组件是一种用于与虚拟机监控程序通信的内核可选扩展。</p>
<p class="zw">34）初始化并设置当前时区信息。</p>
<p class="zw">35）初始化全局文件系统驱动程序数据结构。</p>
<p class="zw">36）初始化NT Rtl压缩引擎。</p>
<p class="zw">37）如果需要，设置对虚拟机监控程序调试器的支持，这样系统的其他部分就不需要使用自己的设备了。</p>
<p class="zw">38）通过在已注册的传输（如Kdcom.dll）中调用KdDebuggerInitialize1例程，执行与调试器传输相关的阶段1工作。</p>
<p class="zw">39）高级本地过程调用（ALPC）子系统初始化ALPC端口类型和ALPC可等待端口类型对象，并将旧的LPC对象设置为别名。</p>
<p class="zw">40）如果系统（使用BCD的Bootlog选项）启用了启动日志记录，将初始化启动日志文件。如果系统启动到安全模式，则会判断是否需要运行备用shell（例如启动到带命令提示符的安全模式）。</p>
<p class="zw">41）调用执行体以执行它的第二阶段初始化工作，这期间会在内核中配置有关Windows许可的部分功能，例如，认证包含了许可数据的注册表设置。此外，如果存在来自启动应用程序的持久数据（如内存诊断结果或从休眠状态恢复的信息），那么相关日志文件和信息还会被写入硬盘或注册表。</p>
<p class="zw">42）上述方式的启动还将创建MiniNT/WinPE注册表键，随后在命名空间中创建NLS对象目录，该目录稍后将用于保存各种内存映射NLS文件的节对象。</p>
<p class="zw">43）初始化Windows内核代码完整性策略（例如受信任签名方列表和证书哈希）和调试选项，所有相关设置会从加载器程序块复制到内核CI模块（Ci.dll）。</p>
<p class="zw">44）再次调用电源管理器并进行初始化。这次将设置对电源请求、电源监视器、用于亮度调整通知的ALPC通道，以及配置文件回调的支持。</p>
<p class="zw">45）开始初始化I/O管理器。这是系统启动过程中的一个复杂阶段，大部分启动时间都在处理这一阶段的工作。</p>
<p class="zw">I/O管理器首先初始化各种内部结构并创建驱动程序和设备对象类型及它们的根目录：\Driver、\FileSystem、\FileSystem\Filters、\UMDFCommunicationPorts（适用于UMDF驱动程序框架）。然后初始化内核填充码引擎并调用即插即用管理器、电源管理器和HAL，以开始执行动态设备枚举和初始化所涉及的不同阶段（这个复杂而特殊的过程请参阅本书卷1第6章）。最后处理Windows管理规范（WMI）子系统，进而为设备驱动程序提供WMI支持（详见第10章）。期间还将初始化Windows事件跟踪（ETW）并将所有存在的启动持久数据写入ETW事件。</p>
<p class="zw">I/O管理器启动与平台相关的错误驱动程序并初始化硬件错误资源的全局表。这二者是Windows硬件错误基础架构的重要组成部分。然后I/O管理器将执行首个安全内核调用，要求安全内核在VTL 1下执行自己初始化过程最后阶段的工作。此外，期间还将初始化加密的安全转储驱动程序，并从Windows注册表（HKLM\System\CurrentControlSet\Control\ CrashControl）读取部分配置信息。</p>
<p class="zw">再根据依赖性和加载顺序枚举并排序启动时运行的所有驱动程序（有关注册表中所包含的驱动程序加载控制信息处理方式的详细介绍请参阅本书卷1第6章）。所有链接的内核模式DLL都将使用内置的RAW文件系统驱动程序进行初始化。</p>
<p class="zw">在这一阶段，I/O管理器还会将Ntdll.dll、Vertdll.dll以及WOW64版本的Ntdll映射至系统地址空间。首先调用所有启动时运行的驱动程序来执行相关的驱动程序初始化工作，接下来会启动系统运行的设备驱动程序。Windows子系统设备名会以符号链接的形式创建到对象管理器的命名空间中。</p>
<p class="zw">46）配置管理器注册并启动自己Windows注册表的ETW跟踪日志记录提供程序，以跟踪整个配置管理器的活动。</p>
<p class="zw">47）事务管理器设置Windows软件跟踪预处理器（WPP）并注册自己的ETW提供程序。</p>
<p class="zw">48）至此，引导时运行的以及系统启动时运行的驱动程序均已加载，勘误表管理器将加载并解析INF数据库中的驱动程序勘误表，并应用注册表PCI配置中的应变措施。</p>
<p class="zw">49）如果计算机启动到安全模式，那么这一情况也将被记录到注册表中。</p>
<p class="zw">50）除非在注册表中明确禁用，否则将启用Ntoskrnl和驱动程序中内核模式代码的分页。</p>
<p class="zw">51）调用电源管理器以完成初始化工作。</p>
<p class="zw">52）初始化对内核时钟计时器的支持。</p>
<p class="zw">53）在Ntoskrnl的INIT节被丢弃前，系统的其余许可信息（包括注册表中存储的当前策略设置）将被复制到一个私有系统节中，随后设置系统过期时间。</p>
<p class="zw">54）调用进程管理器以设置作业速率限制和系统进程创建时间。它将为受保护进程初始化静态环境，并在先前由I/O管理器映射的用户模式系统库（通常是Ntdll.dll、Ntdll32.dll和Vertdll.dll）中查找各种系统定义的入口点。</p>
<p class="zw">55）调用安全引用监视器来创建与LSASS通信的Command Server线程。这一阶段将创建引用监视器命令端口，LSA会使用该端口向SRM发送命令（有关Windows实施安全性的详情请参阅卷1第7章）。</p>
<p class="zw">56）如果VSM已启用，那么加密的VSM密钥将被保存到硬盘。系统中用户模式的库会被映射至Secure System进程。这样，安全内核就可以收到有关VTL 0下系统DLL的所有必要信息。</p>
<p class="zw">57）会话管理器（SMSS）进程（详见本书卷1第2章）将启动。Smss负责为Windows提供可见接口的用户模式环境，下一节将介绍该组件的初始化过程。</p>
<p class="zw">58）启用Bootvid驱动程序，以允许NT磁盘检查工具显示输出的字符串。</p>
<p class="zw">59）查询TPM启动熵值。这些值在每次启动系统时只能查询一次，通常来说，到这一步，TPM系统驱动程序应该已经查询过了，但如果因为某些原因该驱动程序尚未运行（也许被用户禁用），那么未查询的值依然是可用的。因此，为了避免出现这种情况，内核也可以手动查询该值。正常情况下，内核自己的查询操作应该会失败。</p>
<p class="zw">60）加载器参数块使用和引用的所有内存（例如位于INIT节中的Ntoskrnl的初始化代码和所有启动时运行的驱动程序）都将被释放。</p>
<p class="zw">作为执行体和内核初始化完成之前的最后一步，第一阶段的初始化线程会将终止时的关键中断标记设置给新的Smss进程，这样，如果Smss进程退出或因为其他原因被终止，那么内核将进行拦截并进入附加的调试器（如果有的话），然后让系统崩溃并显示CRITICAL_PROCESS_DIED停止代码。</p>
<p class="zw">如果5秒的等待时间结束（也就是说，崩溃并等待5秒后），会话管理器会被认定为已成功启动，第一阶段的初始化线程将会退出。因此，启动处理器将开始执行步骤22中创建的某一个内存管理器系统线程，或返回到Idle循环。</p>

<p class="epubit-contents-id" style="display: none">{"index":14,"parentId":"7de50c71-6922-40ef-8532-4dcba3bf6021","id":"63b72606-fd52-4d5e-bc8b-f84b9822f817"}</p>