<h3 class="bt3" id="sigil_toc_id_331">12.1.3　安全启动</h3>
<p class="zw">如本书卷1第7章所述，Windows在设计上即可防范恶意软件。所有老旧的BIOS系统都容易受到高级持续性威胁（Advanced Persistent Threat，APT），这类威胁会借助Bootkit隐蔽自身并执行代码。Bootkit是一种特殊类型的恶意软件，可以先于Windows启动管理器运行，进而在不被反病毒解决方案检测到的情况下运行注入模块。BIOS Bootkit的初始部分通常位于系统盘的主引导记录（MBR）或卷引导记录（VBR）扇区中。这样，老旧的BIOS系统在开机后就会直接执行Bootkit代码，而非操作系统主代码。随后，恶意代码开始运行操作系统加密保存在硬盘其他区域中的原始引导代码。这类Bootkit甚至能在任何版本Windows的引导阶段直接修改内存中的操作系统代码。</p>
<p class="zw">正如大量安全研究人员所证明的那样，UEFI规范的第一个版本依然容易受到这个问题的影响，因为固件、引导加载器以及其他组件并不进行验证，因此能够从物理上接触到计算机的攻击者可篡改这些组件，用恶意引导加载器替换原本的引导加载器。实际上，任何EFI应用程序（符合可移植/可执行格式或简洁可执行文件格式的可执行文件）只要在相对引导变量中正确注册，都可用于引导系统。此外，即便DXE驱动程序也并未进行正确验证，使得在SPI闪存中注入恶意EFI驱动程序具备了可行性。Windows无法正确识别被篡改的引导过程。</p>
<p class="zw">这个问题推动着&nbsp;UEFI&nbsp;联盟设计开发了安全启动技术。安全启动（Secure Boot）是UEFI的一项功能，可以确保引导过程中所加载的每个组件都包含数字签名并通过验证。安全启动使得PC只能使用被PC制造商或用户信任的软件引导。在安全启动中，固件负责验证所有组件（DXE驱动程序、UEFI引导管理器、加载器等），验证通过才会加载。如果某个组件未能通过验证，则会向用户显示错误信息，引导过程会被中止。</p>
<p class="zw">验证过程会使用公钥算法（如RSA）进行数字签名，并与UEFI固件中可接受或要拒绝的证书（或哈希）数据库进行对比。这些算法采用了两种类型的密钥。</p>
<p class="zw">1）公钥，用于解密加密后的摘要信息（是指可执行文件二进制数据的哈希值）。该密钥存储在文件的数字签名中。</p>
<p class="zw">2）私钥，用于加密二进制可执行文件的哈希值，会存储在一个安全保密的位置。可执行文件的数字签名包含三个阶段。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 使用强哈希算法（如SHA256）计算文件内容的摘要。强“哈希”可以产生一个唯一（并且相对较小）的消息摘要，可用于完整代表原始数据（有点像一种复杂的校验值）。哈希算法是一种单向加密，也就是说，无法从摘要逆推出源文件。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 使用密钥中的私钥加密计算出来的摘要。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 将加密后的摘要、密钥中的公钥以及哈希算法的名称存储在文件的数字签名中。</p>
<p class="zw">这样，当系统需要验证并确认文件的完整性时，只需要重新计算文件哈希并将其与（从数字签名中解密出的）摘要进行对比即可。除了私钥的拥有者，其他人都无法修改或改变数字签名中存储的加密摘要。</p>
<p class="zw">这种简化的模型还可以进一步扩展，创建一种证书链，其中的每一环都可被固件所信任。实际上，如果某个特定证书中的公钥对固件来说是未知的，但该证书由受信任的实体（中间证书或根证书）在另一时间签署，那么固件认为这种内部公钥依然是可以被信任的。这种机制名为信任链，如图12-3所示。该机制依赖这样一种事实：用于代码签名的数字证书可以使用另一个受信任的高级证书（中间证书或根证书）的公钥进行签名。此处对该模型的介绍进行了简化，因为完整详细的介绍已经超出了本书范围。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx488.png" style="width: 100%" />
<p class="图题">图12-3　简化后的信任链</p>
<p class="zw">允许/撤销UEFI证书以及哈希值必须通过图12-4所示的实体建立一种信任层级。这些实体存储在UEFI变量中。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx5351.png" style="width: 100%" />
<p class="图题">图12-4 UEFI安全启动所用的信任链证书</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">平台密钥（Platform Key，PK）：</strong>平台密钥代表信任的根基，用于保护密钥交换密钥数据库。平台供应商会在生产过程中将PK的公共部分放入UEFI固件，而私密部分依然由供应商保管。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">密钥交换密钥（Key Exchange Key，KEK）：</strong>密钥交换密钥数据库包含的受信任证书可用于修改允许的签名数据库（DB）、不允许的签名数据库（DBX）以及时间戳签名数据库（DBT）。KEK数据库通常包含操作系统供应商证书（OSV），由PK保护其安全性。</p>
<p class="zw">用于验证引导加载器和其他预引导组件的哈希值和签名保存在三个数据库中。允许的签名数据库（DB）包含特定的二进制文件或证书（或其哈希值）的哈希值，它们可用于生成代码签名证书，而这种证书可用于对引导加载器和其他预引导组件进行签名（需要遵守信任链模型）。不允许的签名数据库（DBX）包含已被破坏或被撤销的特定二进制文件或证书（或其哈希值）的哈希值。时间戳签名数据库（DBT）包含在对引导加载器映像进行签名时所需的时间戳证书。所有这些数据库都会被KEK锁定而无法编辑。</p>
<p class="zw">为妥善保护安全启动密钥，不应允许固件更新密钥，除非试图更新密钥的实体能够（使用带有数字签名的特定载荷，也叫“验证描述符”）证明自己拥有创建变量所用密钥的私密部分。UEFI通过已验证变量（Authenticated Variable）实现了这种机制。截至撰写这部分内容，UEFI规范只允许两类签名密钥：X509和RSA2048。一个认证变量可通过写入一个空的更新来清除，但其中依然需要包含一个有效的验证描述符。在首次创建已验证变量时，其中同时存储了创建变量的密钥中对应的公共部分，以及时间初始值（或一个单调计数器），并且随后只接受使用该密钥签名，且具备相同类型的更新。例如，使用某个PK创建的KEK变量，只能使用通过该PK签名的验证描述符更新。</p>
<table> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　UEFI固件在安全启动环境中使用已验证变量的方式可能导致一些混乱。实际上，PK、KEK和签名数据库会使用已验证变量来存储。存储启动配置数据的其他UEFI引导变量依然是常规的运行时变量。这意味着在安全启动环境中，用户依然可以毫无障碍地更新或更改引导配置（甚至更改引导顺序）。不过这并不算是问题，因为每一种引导应用程序（无论来源或顺序如何）都需要进行安全验证。安全启动在设计上并不是为了禁止修改系统引导配置而产生的。</p> </td> 
  </tr> 
 </tbody> 
</table>

<p class="epubit-contents-id" style="display: none">{"index":2,"parentId":"7de50c71-6922-40ef-8532-4dcba3bf6021","id":"415cdbf4-8256-4abf-b3ef-86bcb88b0a9e"}</p>