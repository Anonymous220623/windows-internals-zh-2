<h3 class="bt3" id="sigil_toc_id_66">8.11.8　程序包激活</h3>
<p class="zw">用户无法仅通过执行.exe文件的方式启动UWP应用程序（专为此用途创建的AppExecution别名除外，本章下文将详细介绍AppExecution别名）。为了正确地激活现代应用程序，用户需要点击现代菜单中的磁贴，使用资源管理器能够正确解析的特殊链接文件，或使用其他某些激活选项（双击应用程序的文档、调用特殊URL等）。随后将由ShellExperienceHost进程根据应用程序类型决定执行哪种类型的激活操作。</p>
<h4 class="bt4 sigil_not_in_toc">UWP应用程序</h4>
<p class="zw">激活管理器（activation manager）是管理此类激活的主要组件，它在ActivationManager. dll中实现，由于需要与用户桌面交互，因此运行在一个sihost.exe服务中。激活管理器会与视图管理器（View Manager）进行严格的合作。现代菜单会通过RPC调用到激活管理器中，随后激活管理器会启动激活过程，大致流程如图8-45所示。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 获取需要激活的用户的SID、程序包家族ID以及程序包的PRAID。这样即可验证程序包是否真的在系统中注册（会用到依赖项小型存储库及其注册表缓存）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 如果上述检查发现需要注册程序包，则会调用到AppX Deployment客户端并开始注册程序包。在“按需注册”的情况下，可能需要注册某些程序包，例如应用程序已下载但尚未安装（这样可以节约时间，尤其是在企业环境中），或者应用程序可能需要更新。激活管理器可以通过状态存储库得知具体是上述哪种情况。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 使用HAM注册应用程序，并为新程序包及其初始活动创建HAM主机。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 激活管理器与视图管理器（通过RPC）通信，进而对新会话的GUI激活进行初始化（就算后台激活也需要这样做，视图管理器始终需要获得相关通知）。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx5603.png" style="width: 100%" />
<p class="图题">图8-45　现代UWP应用程序激活流程</p>
<p class="zwd"><span style="color: #0092dd">●</span> 激活过程在DcomLaunch服务中继续，因为激活管理器在这一阶段会使用WinRT类启动底层进程创建过程。</p>
<p class="zwd"><span style="color: #0092dd">●</span> DcomLaunch服务负责启动COM、DCOM和WinRT服务器以响应对象激活请求，它是在rpcss.dll库中实现的。DcomLaunch会记录激活请求并准备调用CreateProcessAsUser这个Win32 API。但在此之前，它还需要设置正确的进程属性（如程序包完整名称），以确保用户具备启动该应用程序的正确许可，随后还需要复制用户令牌，设置新的低完整性级别，并用必需的安全属性添加戳记（请注意，DcomLaunch服务使用System账户运行，具备TCB特权。这种类型的令牌操作必须具备TCB特权。详见卷1第7章）。随后，DcomLaunch会调用CreateProcessAsUser，通过进程的某个属性解析传递来的程序包完整名称，并创建出一个已暂停进程。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 后续激活过程继续在Kernelbase.dll中进行。DcomLaunch产生的令牌依然不是AppContainer，但其中包含了UWP安全属性。CreateProcessInternal函数中的一段特殊代码会使用依赖项小型存储库的注册表缓存收集与打包应用程序有关的下列信息：根文件夹、程序包状态、AppContainer程序包SID，以及应用程序能力列表。随后它会验证许可未被篡改（很多游戏会用到该功能）。接下来，依赖项小型存储库文件会被映射至父进程，并开始解析UWP应用程序DLL的替代加载路径。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 使用BasepCreateLowBox函数创建AppContainer令牌、它的对象名称空间以及符号链接，这些工作大部分都在用户模式下进行，但实际的AppContainer令牌创建工作是使用NtCreateLowBoxToken内核函数进行的。有关AppContainer令牌的详细信息请参阅卷1第7章。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 使用NtCreateUserProcess内核API照常创建内核进程对象。</p>
<p class="zwd"><span style="color: #0092dd">●</span> CSRSS子系统接到通知后，BasepPostSuccessAppXExtension函数会将依赖项小型存储库映射至子进程的PEB中，并将子进程与父进程解除映射。随后即可恢复主线程，借此启动新进程了。</p>
<h4 class="bt4 sigil_not_in_toc">Centennial应用程序</h4>
<p class="zw">Centennial应用程序的激活过程与UWP激活类似，但实现方式完全不同。对于这类激活，始终会由现代菜单ShellExperienceHost调用Explorer.exe。Centennial激活类型涉及多个库（如Daxexec.dll、Twinui.dll以及Windows.Storage.dll），并会在Explorer中进行映射。当Explorer收到激活请求后，它会获取程序包完整名称和应用程序ID，并通过RPC从状态存储库获取主应用程序可执行文件路径和程序包属性。随后它会执行与UWP激活相似的步骤（步骤2～4）。但主要差异在于，Centennial激活在这一阶段的操作并未使用DcomLaunch服务，而是会使用Shell32库的ShellExecute API启动进程。更新后的ShellExecute代码已经可以识别Centennial应用程序，进而可以（通过COM）使用Windows.Storage.dll中的特殊激活过程。Windows.Storage.dll库可通过RPC调用AppInfo服务中的RAiLaunchProcessWithIdentity函数。AppInfo可使用状态存储库验证应用程序许可和应用程序所有文件的完整性，随后调用进程令牌。接着它会使用必要的安全属性为令牌添加戳记，并最终创建处于已暂停状态的进程。AppInfo可使用PROC_ THREAD_ATTRIBUTE_PACKAGE_FULL_NAME这个进程属性将程序包完整名称传递给CreateProcessAsUser API。</p>
<p class="zw">与UWP不同的是，Centennial激活完全不会创建AppContainer，AppInfo会调用DaxExec.dll的PostCreateProcessDesktopAppXActivation函数来实现Centennial应用程序（注册表和文件系统）虚拟化层的初始化。更多信息请参阅上文“Centennial应用程序”一节。</p>
<p class="zwtsh">实验：通过命令行激活现代应用程序</p>
<p class="zwts1">借助这个实验，我们可以更好地理解UWP与Centennial的差异，并发现选择使用ShellExecute API激活Centennial应用程序这种决定背后的动机。在这个实验中，我们需要安装至少一个Centennial应用程序。在撰写这部分内容时，我们可以在Windows应用商店中通过一个简单的办法找出这种类型的应用程序。在商店中打开目标应用程序的详情页后，向下滚动页面打开“<strong style="color:#0092dd">其他信息</strong>”选项。如果在“支持的语言”之前看到“此应用可以：使用全部系统资源”字样，就意味着这是一个Centennial类型的应用程序。</p>
<p class="zwts1">在这个实验中我们将使用Notepad++。请在Windows应用商店中搜索并安装“(unofficial) Notepad++”应用程序。随后打开相机应用和Notepad++。以管理员身份打开一个命令提示符窗口（可在搜索框中输入cmd，右键点击“<strong style="color:#0092dd">命令提示符</strong>”并选择</p>
<p class="zwts1">“<strong style="color:#0092dd">以管理员身份运行</strong>”）。随后使用下列命令查找这两个正在运行的打包应用程序的完整路径：</p>
<pre class="代码无行号"><code>wmic process where "name='WindowsCamera.exe'" get ExecutablePath 
wmic process where "name='notepad++.exe’" get ExecutablePath </code></pre>
<p class="zwts1">接着使用下列命令创建两个指向应用程序可执行文件的链接：</p>
<pre class="代码无行号"><code>mklink "%USERPROFILE%\Desktop\notepad.exe" "&lt;Notepad++ executable Full Path&gt;" 
mklink "%USERPROFILE%\Desktop\camera.exe" "&lt;WindowsCamera executable full path&gt; </code></pre>
<p class="zwts1">将“&lt;”和“&gt;”符号之间的内容替换为通过前两个命令找出的，真正的可执行文件路径。</p>
<p class="zwts1">随后即可关闭命令提示符和这两个应用程序。此时桌面上应该已经出现了两个新建的链接。与Notepad.exe链接不同，如果试图从桌面启动相机应用，则激活操作将会失败，Windows会显示类似下图这样的错误对话框。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx5611.png" style="width: 100%" />
<p class="zwts1">这是因为Windows资源管理器会使用Shell32库激活可执行文件的链接。对于UWP应用程序，Shell32库完全不知道自己要启动的可执行文件是一个UWP应用程序，因此它会在不指定任何程序包标识符的情况下调用CreateProcessAsUser API。然而，Shell32可以识别Centennial应用，因此整个激活过程可顺利完成，应用程序也可以正常启动。如果试图在命令提示符窗口中启动这两个链接，则它们都将无法正确启动应用程序。这是因为命令提示符完全没有使用Shell32，而是会通过自己的代码直接调用CreateProcess API。该实验展示了每种类型打包应用程序的不同激活方式。</p>
<table> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　从Windows 10 Creators Update（RS2）开始，现代应用程序模型已经可以支持可选程序包（optional package，内部将其称为RelatedSet）的概念。可选程序包在游戏中有着广泛应用，借此即可让主游戏支持DLC（扩展包）。一些软件套件也能受益于此，Microsoft Office就是一个很好的例子。用户可以下载并安装Word，其中包含的框架程序包里面包括了Office的所有通用代码。随后当用户需要安装Excel时，部署操作即可跳过主框架程序包的下载过程，因为Word可选程序包已经包含于Office的主框架。</p> <p class="zwzy">可选程序包通过清单文件与主程序包建立关联。清单文件（使用AMUID）包含了对主程序包的依赖声明。可选程序包架构的深入介绍已超出了本书范围。</p> </td> 
  </tr> 
 </tbody> 
</table>
<h4 class="bt4 sigil_not_in_toc">AppExecution别名</h4>
<p class="zw">如上文所述，打包应用程序不能直接通过可执行文件来激活。这会受到很大的局限，对新的现代控制台应用程序来说尤为严重。为了能通过命令行启动现代应用（Centennial和UWP应用），从Windows 10 Fall Creators Update（版本1709）开始，现代应用程序模型引入了AppExecution别名的概念。借助这项新功能，用户可以通过控制台命令行启动Edge或任何其他现代应用程序。本质上，AppExecution别名是一种0字节长度的可执行文件，位于C:\Users\&lt;UserName&gt;\AppData\Local\Microsoft\WindowsApps（如图8-46所示）。该位置会被加入系统可执行文件搜索路径列表（通过PATH环境变量实现），因此，若要运行现代应用程序，用户只需指定位于该文件夹中的可执行文件的文件名，无须像在“运行”对话框或控制台命令行中那样指定完整路径。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx5694.png" style="width: 100%" />
<p class="图题">图8-46　AppExecution别名的主文件夹</p>
<p class="zw">0字节的文件该如何执行？这要归功于文件系统中一个鲜为人知的功能：重分析点。重分析点通常可用于创建符号链接，但其中不仅可以存储符号链接信息，也可以存储任何其他数据。现代应用程序模型使用该功能将打包应用程序的激活数据（程序包家族名称、应用程序用户模型ID、应用程序路径）直接存储在重分析点中。</p>
<p class="zw">当用户启动AppExecution别名可执行文件时，会照常使用CreateProcess API。但用于编排内核模式进程创建的NtCreateUserProcess系统调用（详见卷&nbsp;1&nbsp;第&nbsp;3&nbsp;章“CreateProcess流程”一节）会失败，因为该文件的内容为空。作为常规进程创建工作的一部分，文件系统会（通过IoCreateFileEx API）打开目标文件并（在分析路径的最后一个节点时）遇到重分析点数据，随后向调用方返回STATUS_REPARSE代码。NtCreateUserProcess会将该代码转换为STATUS_IO_REPARSE_TAG_NOT_HANDLED错误并退出。借此，CreateProcess API可以知道进程创建因为无效的重分析点而失败，因此会调用到ApiSetHost. AppExecutionAlias.dll库，该库包含了解析现代应用程序重分析点所需的代码。</p>
<p class="zw">该库的代码解析重分析点，得到了打包应用程序的激活数据。随后，为了用必要的安全属性为令牌添加戳记，还会调用AppInfo服务。AppInfo验证用户具备运行该打包应用程序所需的许可，再通过状态存储库检查文件的完整性。实际的进程创建是由调用方进程完成的。CreateProcess API检测到重分析错误并使用正确的软件包可执行文件路径（通常位于C:\Program Files\WindowsApps\）重启动自己的执行过程。这一次，它可以正确地创建进程以及AppContainer令牌，或为Centennial应用正确完成虚拟化层的初始化工作（实际上，对于Centennial应用，需要再次为AppInfo使用另一个RPC）。此外，它还会创建应用程序所需的HAM主机及活动。至此，激活完成。</p>
<p class="zwtsh">实验：读取AppExecution别名数据</p>
<p class="zwts1">这个实验将从0字节的可执行文件中提取AppExecution别名数据。我们可以使用本书随附资源提供的FsReparser实用工具解析重分析点或NTFS文件系统的扩展特性。直接在命令提示符窗口中运行该工具并指定命令行参数READ即可：</p>
<pre class="代码无行号"><code>C:\Users\Andrea\AppData\Local\Microsoft\WindowsApps&gt;fsreparser read MicrosoftEdge.exe
　
File System Reparse Point / Extended Attributes Parser 0.1 
Copyright 2018 by Andrea Allievi (AaLl86) 
　
Reading UWP attributes... 
Source file: MicrosoftEdge.exe. 
　
The source file does not contain any Extended Attributes. 
　
The file contains a valid UWP Reparse point (version 3). 
Package family name: Microsoft.MicrosoftEdge_8wekyb3d8bbwe 
Application User Model Id: Microsoft.MicrosoftEdge_8wekyb3d8bbwe!MicrosoftEdge
UWP App Target full path: C:\Windows\System32\SystemUWPLauncher.exe 
Alias Type: UWP Single Instance </code></pre>
<p class="zwts1">从上述输出结果中可以看到，CreateProcess API可以提取正确执行现代应用程序激活操作所需的全部信息。这也解释了为何可以在命令行下启动Edge浏览器。</p>

<p class="epubit-contents-id" style="display: none">{"index":7,"parentId":"9334f317-a4b1-4935-821c-b084138eb566","id":"11924b9d-19b5-4751-a6fd-2267586c6aec"}</p>