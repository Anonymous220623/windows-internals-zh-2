<h3 class="bt3" id="sigil_toc_id_67">8.11.9　程序包注册</h3>
<p class="zw">当用户安装现代应用程序时，通常会在Windows应用商店查找应用程序并点击“获取”按钮。随后开始下载一个包含一系列文件的打包文件，其中包含程序包清单文件、应用程序的数字签名，以及代表数字签名中不同证书之间信任链的块图（block map）。这个打包文件最初会存储在C:\Windows\SoftwareDistribution\Download文件夹中。AppStore进程（WinStore.App.exe）还会与管理下载请求的Windows Update服务（wuaueng.dll）通信。</p>
<p class="zw">下载的文件属于一种清单（manifest），其中包含现代应用程序所有文件的列表、应用程序依赖项、许可数据，以及正确注册程序包所需执行的步骤。Windows Update服务可以识别出这是一个现代应用程序的下载请求，随后会验证调用方进程的令牌（应该是一个AppContainer），并使用AppXDeploymentClient.dll库提供的服务验证该程序包是否已安装到系统中。随后它会创建一个AppX部署请求，并通过RPC将其发送给AppX部署服务器。AppX部署服务器以PPL服务的形式运行在共享的服务宿主进程中（宿主进程甚至承载了以相同受保护级别运行的客户端许可服务）。部署请求会被放入一个异步管理的队列。在AppX部署服务器看到这样的请求后，会将请求取消排队并创建一个线程，真正开始现代应用程序部署过程。</p>
<table> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　从Windows 8.1开始，UWP部署栈开始支持捆绑包（bundle）的概念。捆绑包是一种包含多种资源（例如只针对特定区域提供的不同语言或功能）的程序包。部署栈实现了一种适用性逻辑，可在检查用户配置和系统设置后，只从压缩的捆绑包中下载真正需要的那部分文件。</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">现代应用程序部署过程需要进行一系列复杂的活动，我们可以将部署过程分为下列三个主要阶段。</p>
<h4 class="bt4 sigil_not_in_toc">阶段1：程序包暂存</h4>
<p class="zw">当Windows Update下载完应用程序清单后，AppX部署服务器会验证程序包的所有依赖性是否均得到满足，随后检查应用程序的先决条件，例如可支持的目标设备（手机、台式计算机、Xbox等），并检查目标卷的文件系统是否被支持。应用程序的所有先决条件会与每个依赖项一起罗列在清单文件中。如果所有检查都成功通过，暂存过程会创建程序包根目录（通常位于C:\Program Files\WindowsApps\&lt;PackageFullName&gt;）及其子文件夹。此外，暂存过程还会对这些目录应用适当的ACL以便加以必要保护。对于Centennial类型的现代应用程序，则会加载daxexec.dll库并创建Windows容器隔离微过滤驱动程序所需的VFS重分析点（详见上文“Centennial应用程序”一节），这是为了对应用程序数据文件夹进行正确的虚拟化。最后，它会将程序包跟路径保存到HKLM\SOFTWARE\ Classes\LocalSettings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Packages\&lt;PackageFullName&gt;注册表键下的Path注册表值中。</p>
<p class="zw">随后，暂存过程会在磁盘上预分配应用程序的文件，计算最终需要下载的数据量，提取包含所有程序包文件（压缩为AppX文件）的服务器URL，最后，再次使用Windows Update服务从远程服务器下载AppX。</p>
<h4 class="bt4 sigil_not_in_toc">阶段2：用户数据暂存</h4>
<p class="zw">该阶段仅在用户更新应用程序时才会执行。这个阶段只是简单地还原上一个程序包中的用户数据，并将其存储到新应用程序路径中。</p>
<h4 class="bt4 sigil_not_in_toc">阶段3：程序包注册</h4>
<p class="zw">程序包注册是部署过程中最重要的阶段。这个复杂的阶段用到了AppXDeploymentExtensions.onecore.dll库提供的服务（以及AppXDeploymentExtensions. desktop.dll&nbsp;为台式计算机上的部署提供的有关服务）。我们将其称为&nbsp;Package Core Installation（程序包核心安装）。在该阶段，AppX部署服务器主要负责更新状态存储库。它会在这个存储库中为程序包、程序包中包含的一个或多个应用程序、新磁贴、程序包能力、程序包许可等内容创建新的项。为此，AppX部署服务器会用到数据库事务，但只有在没有出现任何错误的情况下，才会最终提交这些事务（如果出错，那么事务会被丢弃）。当组成状态存储库部署操作的所有数据库事务都正确提交后，状态存储库即可调用已注册的侦听方，借此向每个请求通知的客户端发出通知（有关状态存储库变更和事件跟踪的详情，请参阅“状态存储库”一节）。</p>
<p class="zw">程序包注册的最后一个步骤是创建依赖项小型存储库文件，并更新计算机的注册表以体现状态存储库中存储的新数据。部署过程至此结束。新应用程序已经可以激活并运行了。</p>
<table> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　为了提高可读性，上述部署过程已进行了大幅简化。在上文所述的暂存阶段，我们省略了初始过程中的一些子阶段，例如用于解析AppX清单文件的索引阶段、用于创建工作方案并分析程序包依赖性的依赖项管理器阶段，以及与PLM通信并验证程序包尚未安装或未在使用中的程序包使用中（package in use）阶段。</p> <p class="zwzy">此外，如果某个操作失败，部署栈必须能够撤销所有改动。上文也没有详细介绍其他撤销阶段。</p> </td> 
  </tr> 
 </tbody> 
</table>

<p class="epubit-contents-id" style="display: none">{"index":8,"parentId":"9334f317-a4b1-4935-821c-b084138eb566","id":"b26de9be-2f39-4578-8ea8-fc57b067e71e"}</p>