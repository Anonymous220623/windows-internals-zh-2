<h3 class="bt3" id="sigil_toc_id_5">8.2.1　乱序执行</h3>
<p class="zw">现代微处理器通过自己的流水线执行计算机指令。流水线包含很多阶段，如指令获取、解码、寄存器分配和更名、指令重排序、执行，以及退出。CPU应对内存访问速度不够快的一种常用策略是：让执行引擎忽略指令顺序，优先执行所需资源已可用的指令。这意味着CPU并不会按照某种严格一致的顺序执行指令，借此能够通过让所有内核尽可能满载的方式将所有执行单元的利用率提升至最大限度。在确定某些指令很快将会被用到并被提交（退出）之前，现代处理器能够以预测性的方式执行数百条此类指令。</p>
<p class="zw">上述乱序执行方法最大的问题之一在于分支指令。一条带有附带条件的分支指令会在机器代码中定义两个可能的路径，而最终要执行的“正确”路径取决于之前执行过的指令。在计算具体情况时，因为所依赖的“之前执行过的指令”需要访问速度缓慢的RAM，因此整体速度也会被拖慢。此时，执行引擎需要等待定义条件的指令退出（意味着需要等待内存总线完成内存访问操作），随后才能以乱序执行的方式执行正确路径下所包含的后续指令。间接分支也会遇到类似情况。在间接分支中，CPU的执行引擎并不知道分支（通常为Jump或Call）的具体目标，因为必须从主存中获取相关地址。在这个语境中，“推测执行”（speculative execution）这个术语意味着CPU的流水线需要以并行或乱序的方式解码并执行多条指令，但其结果并不会退出至永久性寄存器中，在分支指令最终执行完毕之前，内存写入操作依然会处于挂起状态。</p>

<p class="epubit-contents-id" style="display: none">{"index":0,"parentId":"ac03d224-518d-4e2e-aef7-2110569f03ee","id":"c2efc03c-ba6b-4619-beb2-9e03346246a4"}</p>