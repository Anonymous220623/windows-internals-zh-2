<h3 class="bt3" id="sigil_toc_id_7">8.2.3　CPU缓存</h3>
<p class="zw">正如上一节所述，CPU缓存（Cache）是一种高速内存，可大幅缩短获取和存储数据与指令所需的时间。数据会以固定大小的块（通常为64或128字节）在内存和缓存之间传输，这种数据块也叫缓存行或缓存块。当一个缓存行从内存复制到缓存时，会创建一个缓存项。该缓存项中包含数据副本以及用于分辨所请求内存位置的标签。与分支目标预测器不同，缓存始终会通过物理地址创建索引（否则多个地址空间之间的映射和变更过程将变得极为复杂）。从缓存的角度来看，一个物理地址可以拆分为不同的成分，其中较高的位通常代表标签，较低的位代表缓存行以及行本身的偏移量。标签具备唯一性，可用于区分每个缓存块所属的内存地址，如图8-4所示。</p>
<p class="zw">当CPU读/写内存位置时，首先会检查缓存中是否存在对应的项（会在可能包含来自该地址数据的任何缓存行中检查。但某些缓存可能存在不同的“向”，下文很快将会提到）。如果处理器发现来自该位置的内存数据已经位于缓存中，此时就出现了“缓存命中”的情况，处理器会立即通过该缓存行读/写数据；如果数据不在缓存中，此谓之“缓存未命中”，此时CPU会在缓存中分配一个新项，并将数据从主存中复制进去，随后进行访问。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx522.png" style="width: 100%" />
<p class="图题">图8-4　48位单向CPU缓存范例</p>
<p class="zw">图8-4展示了一个单向CPU缓存，该缓存最大可寻址48位虚拟地址空间。在本例中，CPU正在从虚拟地址0x19F566030中读取48字节数据。内存内容最开始已从主存读取到缓存块0x60，该块已经被完全装满，但所请求的数据位于偏移量0x30处。范例缓存只有256块，每块256字节，因此多个物理地址可以装入编号为0x60的块中。标签（0x19F56）能够唯一地区分数据在主存中所在的物理地址。</p>
<p class="zw">通过类似的方式，当CPU接到指令向一个内存地址写入新内容时，它首先会更新该内存地址所属的一个或多个缓存行。某些时候，CPU还会将数据写回至物理RAM，这主要取决于内存页面所应用的缓存类型（write-back、write-through、uncached等）。请注意，在多处理器系统中这具有重要的意义：必须设计某种缓存一致协议，以避免出现主CPU更新某个缓存块后，其他CPU针对陈旧数据执行操作的情况（多CPU缓存一致算法是存在的，但超出了本书的讨论范畴）。</p>
<p class="zw">当出现缓存未命中情况时，为了给新的缓存项腾出空间，CPU有时会清除某个现有的缓存块。选择要清除的缓存项（意味着选择用哪个缓存块来存储新数据）时所用的算法叫作放置策略（placement policy）。如果放置策略只能替换特定虚拟地址的一个块，这种情况可以叫作直接映射（如图8-4所示缓存只有一个方向，且属于直接映射）。相反，如果缓存可以自由选择（具备相同块编号的）任意项来保存新数据，这样的缓存也叫全相联（fully associative）缓存。很多缓存机制在实现方面进行了妥协，使得主存中的每个项可保存到缓存中<em>N</em>个位置中的任何一个位置内，这种机制也叫N向组相联（N-ways set associative）。因此一个“向”可以看作缓存的一个组成部分，缓存中每个向的容量相等，并按照相同的方式进行索引。图8-5展示了一个四向组相联缓存。图中所示的缓存可以存储分属于四个不同物理地址的数据，并通过不同的四个缓存组（使用不同标记）对相同的缓存块创建索引。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx719.png" style="width: 100%" />
<p class="图题">图8-5　一个四向组相联缓存</p>

<p class="epubit-contents-id" style="display: none">{"index":2,"parentId":"ac03d224-518d-4e2e-aef7-2110569f03ee","id":"a1cfb3cc-6649-4062-8562-ce95e0f66803"}</p>