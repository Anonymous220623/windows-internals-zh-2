<h3 class="bt3" id="sigil_toc_id_16">8.4.2　基于线的中断和基于消息信号的中断</h3>
<p class="zw">共享的中断经常会导致较高的中断延迟，甚至可能导致稳定性问题。对于物理中断线路（interrupt line）有限的计算机，这是一种需要尽力避免的副作用。例如，对于能同时支持USB、Compact Flash存储卡、Sony Memory Stick记忆棒、Secure Digital存储卡以及其他介质的多合一读卡器，同一个物理设备中包含的所有控制器通常都会连接到同一个中断线，随后被不同设备驱动程序配置为共享的中断向量。这会导致延迟增加，因为需要按顺序轮流调用每个驱动程序才能确定为该媒体设备发出中断的实际控制器。</p>
<p class="zw">更好的解决方案是让每个设备控制器使用自己的中断，并通过同一个驱动程序管理不同的中断，以此得知这些中断来自哪个设备。然而，为一个设备使用四个传统的IRQ线会很快导致IRQ线耗尽。此外无论如何，每个PCI设备都只能连接到一个IRQ线，因此，对于上述那样的多媒体读卡器，即使需要，也无法使用超过一个的IRQ。</p>
<p class="zw">通过IRQ线生成中断的另一个问题在于，如果无法正确管理IRQ信号，可能会导致计算机遇到中断风暴或其他类型的死锁，因为在ISR确认信号之前，信号需要处于“高”或“低”的状态（此外，中断控制器通常必须收到EOI信号）。如果由于存在Bug而无法实现上述操作，系统将永久陷入中断状态，后续中断将无法被屏蔽，甚至同时出现这两种情况。最后，基于线的中断在多处理器环境中的可扩展性有限。很多情况下，当即插即用管理器为一个中断选择了一组处理器后，最终将由硬件决定要中断哪个处理器，设备驱动程序在其中起到的作用极为有限。</p>
<p class="zw">为解决上述所有问题，PCI 2.2标准中首次引入了一种名为消息信号中断（Message- Signaled Interrupt，MSI）的机制。虽然这是该标准的一种可选组件，并且很少出现在客户端计算机（主要被服务器用于改善网卡和存储控制器性能）中，但随着PCI Express 3.0和后续标准的普及，大部分现代操作系统已经可以全面支持这种模型。在MSI的世界里，设备可以通过PCI总线对一个特定内存地址执行写入操作，以此向自己的驱动程序传递消息。从硬件的角度来看，实际上这可以视为一种直接内存访问（Direct Memory Access，DMA）操作。该操作会产生一个中断，随后Windows即可使用消息内容（值）和消息传递到的地址来调用ISR。设备还可以向内存地址传递多个消息（最多32个），以此根据不同事件传递不同的消息载荷。</p>
<p class="zw">对于某些要求更高性能和更低延迟的系统，PCI 3.0标准引入了MSI-X技术，这是对原有MSI模型的扩展，该技术可支持32位（而不再是16位）的消息，最多可支持2048个（不再是仅仅32个）不同的消息，更重要的是，该技术可以为每个MSI载荷使用不同的地址（地址可动态确定）。不同地址的使用使得MSI载荷可以被写入属于不同处理器的不同物理地址范围，或写入不同的目标处理器集，这种方式高效地实现了通过非一致内存访问（Nonuniform Memory Access，NUMA）来感知中断交付，进而可将中断发送给最初发起相关硬件请求的处理器。通过在中断完成过程中监视负载和距离最近的NUMA节点，该技术可以大幅改善延迟与可扩展性。</p>
<p class="zw">在上述这些模型中，因为要基于内存值进行通信，并且因为内容是与中断一起交付的，因此可以不再需要IRQ线（进而使得系统对于MSI整体限于中断向量的数量，而非IRQ线的数量），而是需要通过驱动程序ISR向设备查询与中断有关的数据，进而降低了延迟。由于该模型可提供大量设备中断，也使得共享中断的必要性显著降低，进而通过将中断数据直接交付给相关ISR而进一步降低了延迟。</p>
<p class="zw">也正因如此，我们可以看到大部分调试器命令会使用GSIV这个术语来替代IRQ，因为GSIV可以概括地描述MSI向量（由不同的“负数”进行区分）、传统的基于IRQ的线，甚至嵌入式设备中的通用输入/输出（General Purpose Input Output，GPIO）引脚。此外，ARM和ARM64系统并未使用上述任何一种模型，而是使用了通用中断控制器（Generic Interrupt Controller，GIC）架构。从图8-16中可以看到两个计算机系统中的设备管理器，其中分别显示了传统的基于IRQ的GSIV，以及以负数形式显示的MSI值的分配情况。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx1371.png" style="width: 100%" />
<p class="图题">图8-16　基于IRQ和MSI的GSIV分配情况</p>
<h4 class="bt4 sigil_not_in_toc">中断路由控制</h4>
<p class="zw">在非虚拟化环境中运行且一个处理器组包含2～16个处理器的客户端（即非服务器SKU）系统中，Windows会通过一种名为中断路由控制（Interrupt Steering）的功能满足消费级现代操作系统对能耗和延迟的需求。在该功能的帮助下，可以按需将中断的负载分摊到多个处理器，以避免单一CPU可能造成的瓶颈，而内核休止引擎（Core Parking Engine，详见本书卷1第6章）亦可将中断路由至未休止的内核，以避免大量中断的分配导致太多处理器在同一时间处于被唤醒的状态。</p>
<p class="zw">中断路由控制的具体功能取决于中断控制器。例如，在支持GIC的ARM系统中，所有等级敏感的以及边缘（锁存）触发的中断均可进行路由控制；而在APIC系统（除非在Hyper-V中运行）中，仅等级敏感的中断可进行路由控制。然而，由于MSI始终是等级边缘触发（level edge-triggered）的，所以会导致该技术提供的收益大幅降低，为应对这种情况，Windows还实现了另一种中断重定向模型。</p>
<p class="zw">在启用路由控制后，中断控制器通过重编程将GSIV交付给不同处理器的LAPIC（在ARM GIC环境中也会实现类似的交付机制）。在必须进行重定向的情况下，所有处理器都会成为GSIV的交付目标，随后实际收到该中断的处理器需要手动向该中断原本应该路由到的目标处理器发送一个IPI。</p>
<p class="zw">除了内核休止引擎所使用的中断路由控制，Windows还会通过系统信息类暴露这些功能，该信息类会由KeIntSteerAssignCpuSetForGsiv通过Windows 10的实时音频功能和CPU集（CPU Set）功能进行处理，详见本书卷1第4章。由此特定GSIV即可路由至能够被用户模式应用程序选择的特定处理器组，但前提是应用程序需具备Increase Base Priority权限，通常只有管理员或本地服务账户具备该权限。</p>
<h4 class="bt4 sigil_not_in_toc">中断的相关性和优先级</h4>
<p class="zw">Windows允许驱动程序开发者和管理员在一定程度上控制处理器相关性（选择接收中断的处理器或处理器组）和相关性策略（决定处理器的选择方式以及要选择处理器组中的哪个处理器）。此外，Windows还能根据IRQL的选择情况实现一种用于为中断划分优先级的基元机制。相关性策略的定义如表8-5所示，这些策略可通过设备实例的注册表键中Interrupt Management\Affinity Policy子键下一个名为InterruptPolicyValue的注册表值加以控制。因此管理员无须配置任何代码，即可将该值添加到特定驱动程序的注册表键中，进而改变其行为。有关中断相关性的详细介绍可参阅微软文档：https://docs.microsoft.com/ windows-hardware/drivers/kernel/interrupt-affinity-and-priority。</p>
<p class="表题">表8-5　IRQ相关性策略</p>
<table> 
 <tbody> 
  <tr> 
   <th> <p class="bt">名称</p> </th> 
   <th> <p class="bt">值</p> </th> 
  </tr> 
  <tr> 
   <td> <p class="bg">IrqPolicyMachineDefault</p> </td> 
   <td> <p class="bg">该设备无需特定相关性策略。Windows将使用默认的计算机策略，即选择计算机（逻辑处理器不超过8个的计算机）上任何可用处理器</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">IrqPolicyAllCloseProcessors</p> </td> 
   <td> <p class="bg">在NUMA计算机中，即插即用管理器会将中断分配给靠近设备（位于同一个节点中）的所有处理器；在非NUMA计算机中，将使用与IrqPolicyAllProcessorsInMachine相同的行为</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">IrqPolicyOneCloseProcessor</p> </td> 
   <td> <p class="bg">在NUMA计算机中，即插即用管理器会将中断分配给靠近设备（位于同一个节点中）的一个处理器；在非NUMA计算机中，将选择系统中任何一个可用处理器</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">IrqPolicyAllProcessorsInMachine</p> </td> 
   <td> <p class="bg">中断将由计算机中任何可用处理器处理</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">IrqPolicySpecifiedProcessors</p> </td> 
   <td> <p class="bg">中断仅由AssignmentSetOverride注册表值下的相关性掩码指定的处理器处理</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">IrqPolicySpreadMessagesAcrossAllProcessors</p> </td> 
   <td> <p class="bg">不同的消息信号中断将分散到有资格的处理器所组成的最佳处理器集中，并在可能的情况下尽量跟踪NUMA拓扑问题。该策略需要设备和平台支持MSI-X</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">IrqPolicyAllProcessorsInGroupWhenSteered</p> </td> 
   <td> <p class="bg">中断完全由中断路由控制机制进行控制，因此中断会分配给所有处理器IDT，并根据路由控制规则动态选择目标处理器</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">除了设置上述相关性策略，我们还可以根据表8-6列出的注册表值设置中断的优先级。</p>
<p class="表题">表8-6　IRQ优先级</p>
<table> 
 <tbody> 
  <tr> 
   <th> <p class="bt">名称</p> </th> 
   <th> <p class="bt">值</p> </th> 
  </tr> 
  <tr> 
   <td> <p class="bg">IrqPriorityUndefined</p> </td> 
   <td> <p class="bg">该设备无需特定优先级。此时将获得默认优先级（IrqPriorityNormal）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">IrqPriorityLow</p> </td> 
   <td> <p class="bg">该设备可容忍高延迟，因此可获得低于常规的IRQL（3或4）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">IrqPriorityNormal</p> </td> 
   <td> <p class="bg">该设备可获得平均延迟，因此可获得与其中断向量相关的默认IRQL（5或11）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">IrqPriorityHigh</p> </td> 
   <td> <p class="bg">该设备需要尽可能降低延迟，因此可获得超出正常情况的高IRQL（12）</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">我们需要意识到Windows并非实时操作系统，因此这些IRQ优先级仅仅是提供给系统的一种“暗示”，只能用于控制与中断有关的IRQL，无法提供Windows IRQL优先级方案机制之外的其他优先级。由于IRQ优先级也存储在注册表中，因此管理员可以自由地为未利用此功能的驱动程序更改相关注册表值，以便有更低的延迟。</p>
<h4 class="bt4 sigil_not_in_toc">软件中断</h4>
<p class="zw">虽然大部分中断是硬件生成的，但Windows内核也能为很多任务生成软件中断，这些任务包括：</p>
<p class="zwd"><span style="color: #0092dd">●</span> 初始化线程调度。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 处理非时间关键型中断。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 处理计时器过期。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 在特定线程的上下文中以异步方式执行过程。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 为异步I/O操作提供支持。</p>
<p class="zw">下面将详细介绍这些任务。</p>
<h4 class="bt4 sigil_not_in_toc">调度或延迟过程调用（DPC）中断</h4>
<p class="zw">DPC通常是一种与中断有关的功能，会在所有设备中断处理完毕后执行某种处理任务。该功能名称中的“延迟”是指相关任务也许不会立即执行。内核会使用DPC处理计时器过期（并释放等待该计时器的线程）并在线程的量程过期后重新调度处理器（这一过程发生在DPC IRQL下，但其实并非通过常规内核DPC进行的）。设备驱动程序可使用DPC处理中断并执行更高IRQL下不可用的操作。为了向硬件中断提供及时的服务，Windows会在设备驱动程序的配合下尝试保持该IRQL低于设备的IRQL级别。实现这一目标的方法之一是让设备驱动程序ISR仅执行确认设备所需的最少量必要工作，保存可变的中断状态，并将数据传输工作或对时间要求不敏感的中断处理工作延迟到在DPC/Dispatch IRQL下通过DPC来执行（有关I/O系统的详细信息请参阅本书卷1第6章）。</p>
<p class="zw">如果IRQL为被动模式或处于APC级别，DPC将立即执行并阻止所有其他非硬件相关的处理任务，因此该机制通常也用于强制立即执行高优先级的系统代码。借此，DPC为操作系统提供了生成中断并在内核模式下执行系统函数的能力。例如，当一个线程无法继续执行时（也许因为该线程已终止或自愿进入等待状态），内核会直接调用调度程序来立即执行上下文切换。然而，有时候内核会检测到自己深陷于多层代码中，进而需要重新调度。此时内核会请求进行调度，但会延迟调度操作的发生，直到自己完成当前操作。DPC软件中断是实现这种延迟处理目标的一种便利方法。</p>
<p class="zw">当内核需要同步访问与调度有关的内核结构时，会始终将处理器的IRQL提升至DPC/ Dispatch级别或更高级别。这会同时禁用其他的软件中断和线程调度。当内核检测到需要进行调度时，会请求一个DPC/Dispatch级别的中断，但由于IRQL已处于或高于该级别，处理器会将该中断置于检查状态。内核完成当前活动后，发现自己需要将IRQL降低至DPC/Dispatch级别以下，并需要检查是否有挂起的调度中断。如果有，则IRQL会降低至DPC/Dispatch级别并开始处理调度中断。使用软件中断激活线程调度程序，是一种在所需条件满足之前进行延迟调度的方法。DPC由DPC对象表示，这是一种对用户模式程序不可见，但对设备驱动程序和其他系统代码可见的内核控制对象。内核在处理DPC中断时所调用系统函数的地址是DPC对象中包含的最重要信息。等待执行的DPC例程会保存在内核管理的队列中，该队列名为DPC队列，每个处理器都有一个这样的队列。若要请求DPC，系统代码会调用内核初始化一个DPC对象，并将其保存在DPC队列中。</p>
<p class="zw">默认情况下，内核会将DPC对象放置在请求了该DPC的处理器（通常也是负责执行ISR的处理器）所属的两个DPC队列之一的末尾处。不过设备驱动程序可以重写此行为，为此只需要指定一个DPC优先级（低、中、中高、高，其中“中”为默认优先级）并为该DPC选择一个特定处理器作为目标。针对特定CPU的DPC也称定向DPC（Targeted DPC）。如果DPC优先级为“高”，则内核会将该DPC对象插入队列前方；如果为其他任何优先级，则会置于队列末尾。</p>
<p class="zw">当处理器的IRQL即将从DPC/Dispatch级别或更高级别降至更低级别（APC或被动级别）时，内核将开始处理DPC。Windows会保证IRQL依然处于DPC/Dispatch级别，并从当前处理器的队列中持续“取出”DPC对象，直到队列为空（也就是说，内核开始“排空”队列），并会按顺序调用每个DPC函数。只有在队列为空后，内核才会让IRQL降至低于DPC/Dispatch的级别，并让常规线程继续执行。图8-17展示了DPC的处理过程。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx1537.png" style="width: 100%" />
<p class="图题">图8-17　DPC的处理过程</p>
<p class="zw">DPC优先级还会以其他方式对系统行为产生影响。内核通常会使用DPC/Dispatch级别的中断发起DPC队列排空操作。但只有在DPC被当前处理器（执行ISR的处理器）控制且DPC的优先级高于“低”优先级时，内核才会生成此类中断。如果DPC的优先级为“低”，那么只有在该处理器尚未解决的DPC请求数量（存储在KPRCB的DpcQueueDepth字段中）超过某一阈值（在KPRCB中该阈值被称为MaximumDpcQueueDepth）之后，或特定时间窗口内处理器所请求的DPC数量极低的情况下，内核才会请求这样的中断。</p>
<p class="zw">如果某个DPC的目标CPU不同于运行ISR的CPU，且该DPC的优先级为“高”或“中高”时，内核就会立即向目标CPU发送信号（发送“调度IPI”）以排空其DPC队列，但前提是目标处理器必须为空闲状态。如果优先级为“中”或“低”，那么目标处理器DPC队列中的请求数量（依然是DpcQueueDepth）必须超过内核触发DPC/Dispatch中断的阈值（MaximumDpcQueueDepth）。系统闲置线程也可以排空它所运行的处理器的DPC队列。虽然DPC目标和优先级机制非常灵活，但设备驱动程序很少需要更改自己DPC对象的默认行为。表8-7总结了可以发起DPC队列排空的各种情况。从生成规则的角度来看，“中高”和“高”优先级其实是等同的，它们之间的差异在于插入队列的位置，“高”优先级中断会被插入头部，“中高”优先级中断会被插入尾部。</p>
<p class="表题">表8-7　DPC中断生成规则</p>
<table> 
 <tbody> 
  <tr> 
   <th> <p class="bt">DPC优先级</p> </th> 
   <th> <p class="bt">以ISR的处理器为目标的DPC</p> </th> 
   <th> <p class="bt">以其他处理器为目标的DPC</p> </th> 
  </tr> 
  <tr> 
   <td> <p class="bg">低</p> </td> 
   <td> <p class="bg">DPC队列长度超过DPC队列最大长度，或DPC请求速率低于DPC请求最小速率</p> </td> 
   <td> <p class="bg">DPC队列长度超过DPC队列最大长度，或系统为空闲状态</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">中</p> </td> 
   <td> <p class="bg">始终</p> </td> 
   <td> <p class="bg">DPC队列长度超过DPC队列最大长度，或系统为空闲状态</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">中高</p> </td> 
   <td> <p class="bg">始终</p> </td> 
   <td> <p class="bg">目标处理器为空闲状态</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">高</p> </td> 
   <td> <p class="bg">始终</p> </td> 
   <td> <p class="bg">目标处理器为空闲状态</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">另外，表8-8描述了各种DPC中断生成变量及其默认值，以及该如何通过注册表修改这些值。除了注册表，我们也可以通过SystemDpcBehaviorInformation这个系统信息类来设置这些值。</p>
<p class="表题">表8-8　DPC中断生成变量及其默认值</p>
<table> 
 <tbody> 
  <tr> 
   <th> <p class="bt">变量</p> </th> 
   <th> <p class="bt">定义</p> </th> 
   <th> <p class="bt">默认值</p> </th> 
   <th> <p class="bt">覆盖值</p> </th> 
  </tr> 
  <tr> 
   <td> <p class="bg">KiMaximumDpcQueueDepth</p> </td> 
   <td> <p class="bg">发出中断前可加入队列的DPC数量（即便是“中”和更低优先级的DPC）</p> </td> 
   <td> <p class="bg">4</p> </td> 
   <td> <p class="bg">DpcQueueDepth</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">KiMinimumDpcRate</p> </td> 
   <td> <p class="bg">“低”优先级DPC不导致生成本地中断的前提下，处理器每个时钟周期可处理的DPC数量</p> </td> 
   <td> <p class="bg">3</p> </td> 
   <td> <p class="bg">MinimumDpcRate</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">KiIdealDpcRate</p> </td> 
   <td> <p class="bg">如果DPC已挂起但未生成中断，在DPC队列深度最大值被减小前，处理器每个时钟周期可处理的DPC数量</p> </td> 
   <td> <p class="bg">20</p> </td> 
   <td> <p class="bg">IdealDpcRate</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">KiAdjustDpcThreshold</p> </td> 
   <td> <p class="bg">如果DPC未挂起，在DPC队列深度最大值被增大前，可处理的处理器时钟周期数量</p> </td> 
   <td> <p class="bg">20</p> </td> 
   <td> <p class="bg">AdjustDpcThreshold</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">由于用户模式线程以低IRQL执行，DPC在很多时候会中断常规用户线程的执行。DPC例程的执行并不考虑哪些线程正在运行，这意味着当DPC例程运行时，并不能假定当前已经映射了哪些进程地址空间。DPC例程可以调用内核函数，但无法调用系统服务，无法生成页面错误，也无法创建或等待调度程序对象（下文将详细介绍）。不过DPC例程可以访问未分页系统内存地址，因为无论当前进程是哪个，系统地址空间始终会被映射。</p>
<p class="zw">由于所有用户模式内存都可分页且DPC会在任意进程上下文中执行，DPC代码永远不能以任何方式访问用户模式内存。在支持管理模式访问保护（Supervisor Mode Access Protection，SMAP）或永无特权访问（Privileged Access Never，PAN）的系统中，Windows会在处理DPC队列（及执行例程）的过程中激活这些功能，保证访问用户模式内存的任何操作均会立即导致Bugcheck错误。</p>
<p class="zw">DPC中断线程执行带来的另一个副作用是最终会导致线程的运行时间被“窃取”。因为当调度器认为当前线程正在执行时，实际上执行的可能是DPC。卷1第4章中讨论过调度器会通过一些机制跟踪线程运行所消耗的CPU时钟周期准确数量，并在必要时扣除DPC和ISR时间，以此为线程失去的运行时间做出补偿。</p>
<p class="zw">虽然这保证了线程不会牺牲自己的量程作为代价，但仍意味着，从用户的角度来看，钟表时间（也就是现实世界中流逝的时间）依然用于处理其他事情了。假设用户正在通过在线音乐服务听自己喜欢的歌曲，如果DPC运行耗时2秒，在这2秒时间里，音乐可能会卡顿或重复播放一小段相同内容。在线视频流媒体甚至键盘鼠标的输入也可能会受到类似影响。因此，对于客户端系统或工作站工作负载来说，DPC已成为导致很多可察觉系统卡顿问题的主要原因，即使是最高优先级的线程，也可能被DPC的运行所打断。为了让某些包含需长时间运行DPC的驱动程序能够正确实现，Windows开始支持线程式DPC（Threaded DPC）。顾名思义，线程式DPC可以在实时优先级（优先级31）的线程上以被动模式执行DPC例程，这样DPC就可以抢占大部分用户模式线程（因为大部分应用程序线程并不在实时优先级的范围内运行），但同时又允许其他中断、非线程式DPC、APC以及其他优先级为31的线程能够抢占这种DPC例程的执行。</p>
<p class="zw">线程式DPC默认已经启用，我们可在注册表的HKEY_LOCAL_MACHINE\System\ CurrentControlSet\Control\Session Manager\Kernel键下添加一个名为ThreadDpcEnable的DWORD值，并将其数值设置为“0”，这样即可禁用线程式DPC。线程式DPC必须由开发者通过KeInitializeThreadedDpc API进行初始化，由此可将DPC的内部类型设置为ThreadedDpcObject。由于线程式DPC可以被禁用，所以使用该机制的驱动程序开发者必须按照与非线程式DPC例程相同的规则编写自己的例程，不能访问已分页内存、执行调度程序等待，或者假设执行所用的IRQL级别。此外，此类驱动程序的开发者也不应使用KeAcquire/ReleaseSpinLockAtDpcLevel API，因为相关函数会假设CPU处于调度级别。实际上，线程式DPC必须使用KeAcquire/ReleaseSpinLockForDpc，借此在检查当前IRQL后执行相应操作。</p>
<p class="zw">虽然线程式DPC是一项出色的功能，可帮助驱动程序开发者尽可能地保护系统资源，但无论是从开发者还是系统管理员的角度，这都是一项选择性使用的功能。因此大部分DPC依然以非线程式的模式执行，并可能导致上述系统卡顿问题。Windows会使用大量性能跟踪机制诊断并协助解决与DPC有关的问题。第一个问题当然是通过性能计数器和更精确的ETW跟踪机制来跟踪DPC和ISR所消耗的时间。</p>
<p class="zwtsh">实验：监视DPC活动</p>
<p class="zwts1">可以使用Process Explorer监视DPC活动，为此请打开“System Information”对话框并切换至CPU选项卡，这里列出了每一次Process Explorer刷新显示结果（默认为1秒）过程中所执行的中断和DPC数量。</p>
<p class="图"></p>
<p></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx1616.png" style="width: 100%" />
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx1630.png" style="width: 100%" />
<p></p>
<p class="zwts1">也可以使用内核调试器查看KPRCB中名称以“Dpc”开头的各种字段，例如，DpcRequestRate、DpcLastCount、DpcTime以及DpcData（其中包含DpcQueueDepth和DpcCount，分别对应非线程式和线程式DPC）。此外，较新版本的Windows还包含IsrDpcStats字段，该字段是一个指向_ISRDPCSTATS结构的指针，这个结构已包含在公开发布的符号文件中。例如，下列命令可显示当前KPRCB中已加入队列的（线程式和非线程式）DPC总数，以及已执行过的DPC数量：</p>
<pre class="代码无行号"><code>lkd&gt; dx new { QueuedDpcCount = @$prcb-&gt;DpcData[0].DpcCount + @$prcb-&gt;DpcData[1].DpcCount, ExecutedDpcCount = ((nt!_ISRDPCSTATS*)@$prcb-&gt;IsrDpcStats)-&gt;DpcCount },d
    QueuedDpcCount   : 3370380 
    ExecutedDpcCount : 1766914 [Type: unsigned __int64] </code></pre>
<p class="zwts1">上述范例输出结果中的差异是正常的，驱动程序可能会将已位于队列中的DPC再次加入队列，而Windows可以安全地处理这种情况。此外，最开始DPC可能会被加入特定处理器的队列（但并不以任何具体处理器作为目标），在某些情况下，它可能在另一个处理器上执行，例如，当驱动程序使用KeSetTargetProcessorDpc（该API可以让驱动程序将特定处理器作为DPC目标）时。</p>
<p class="zw">Windows不仅可以帮助用户手动调查由DPC导致的延迟问题，还能通过一套内置的机制解决少数导致严重问题的常见场景。首先是DPC Watchdog和DPC Timeout机制，这些机制可通过注册表HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Kernel键下的DPCTimeout、DpcWatchdogPeriod以及DpcWatchdogProfileOffset等值进行配置。</p>
<p class="zw">如果IRQL降低事件在很长时间里都未注册，DPC Watchdog将负责监视在DISPATCH_ LEVEL或更高级别执行的所有代码。另外，DPC Timeout负责监视特定DPC的执行时间。默认情况下，特定DPC会在大约20秒后超时，而所有DISPATCH_LEVEL（以及更高级别）的执行会在2分钟后超时。这两项限制都可以通过上文提到的注册表值进行配置（DPCTimeout控制了特定DPC的时间限制，而DpcWatchdogPeriod控制了在高IRQL下运行的所有代码的整体执行情况）。当达到这些阈值后，系统可能会发出DPC_WATCHDOG_ VIOLATION的Bugcheck错误（由此可判断到底是哪种情况），如果附加了内核调试器，则会发出一个可以继续运行的断言。</p>
<p class="zw">驱动程序开发者如果希望通过自己的工作避免出现这些情况，可以使用KeQueryDpcWatchdogInformation API查看这些注册表当前配置的值以及剩余时间。此外，KeShouldYieldProcessor API也可以将这些值（以及其他与系统状态有关的值）纳入考虑范围，进而为驱动程序返回相关提示信息，供驱动程序决定接下来是否继续处理自己的DPC工作，或是否在可行的情况下将IRQL重新降低至PASSIVE_LEVEL（主要适用于DPC并未执行但驱动程序持有了锁或是通过某种方式与DPC进行同步的情况）。</p>
<p class="zw">在最新版本的Windows 10中，每个PRCB还包含一个DPC运行时历史记录表（DpcRuntimeHistoryHashTable），其中保存了一个哈希（或散列）表桶，它由最近执行的特定DPC回调函数及其运行所消耗的CPU周期数量等痕迹信息所组成。在分析内存转储或远程系统时，可在无须借助UI工具的情况下通过这些信息研究延迟问题，但更重要的是，内核也可以使用这些信息。</p>
<p class="zw">驱动程序开发者通过KeInsertQueueDpc将DPC插入队列时，该API将枚举处理器的表并检查该DPC之前是否曾执行并耗费了相当长时间（默认为100毫秒，可通过注册表HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Kernel下的LongDpcRuntimeThreshold值进行配置）。如果是这种情况，上文提到的DpcData结构中将被设置LongDpcPresent字段。</p>
<p class="zw">对于每个闲置线程（有关线程调度和闲置线程的详细信息请参阅本卷1第4章），现在的内核也可以创建DPC委派线程（DPC Delegate Thread）。这是一种具备高度唯一性的线程，隶属于System Idle Process（这一点与闲置线程，即Idle Thread一样）。这种线程永远不会被包含在调度器的默认线程选择算法中，而是在内核中专供内核自己使用。图8-18展示了一个具备16个逻辑处理器、16个闲置线程和16个DPC委派线程的系统。请注意，在这种情况下，这些线程有着真实的线程ID（TID），图中Processor列显示的信息即可视为其TID。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx1709.png" style="width: 100%" />
<p class="图题">图8-18　具备16个CPU的系统中的DPC委派线程</p>
<p class="zw">内核调度DPC时，会检查DPC队列深度是否已超过这种长时间运行DPC的阈值（默认深度为2，可通过上文多次提到的注册表键进行配置）。如果已超出，则需要决定是否通过查看当前执行中线程的属性来缓解这种情况，而具体要研究的属性包括：该线程是否闲置、是否为实时线程，其相关性掩码是否决定了该线程通常需要在不同的处理器上运行。基于结果，内核可能决定调度DPC委派线程作为代替，从本质来看，这等于是将该DPC从运行时间所剩无几的线程切换至一个优先级尽可能高的专用线程中（但依然在DISPATCH_LEVEL级别下执行）。这样原本被抢占的线程（或位于待命列表中的任何其他线程）就有机会重新调度至其他CPU。</p>
<p class="zw">该机制与上文提到的线程式DPC类似，但也有些差异。委派线程依然运行在DISPATCH_LEVEL级别下。实际上，当委派线程在NT内核初始化（详见第12章）的阶段1创建并启动时，就会将自己的IRQL提升至DISPATCH级别，保存到自己内核线程数据结构的WaitIrql字段中，并自发地请求调度器对另一个待机或就绪线程进行上下文切换（通过KiSwapThread例程实现）。因此，委派DPC为系统提供了一种自动化均衡操作，并不需要由驱动程序开发者选择性地采用并慎重地应用在自己的代码中。</p>
<p class="zw">如果是具备该功能的新版本Windows 10系统，可在内核调试器中运行下列命令来查看对委派线程的需求到底有多频繁，这可以从系统引导后执行的上下文切换次数推断出来：</p>
<pre class="代码无行号"><code>lkd&gt; dx @$cursession.Processes[0].Threads.Where(t =&gt; t.KernelObject.ThreadName-&gt;
ToDisplayString().Contains("DPC Delegate Thread")).Select(t =&gt; t.KernelObject.Tcb.
ContextSwitches),d 
    [44]             : 2138 [Type: unsigned long] 
    [52]             : 4 [Type: unsigned long] 
    [60]             : 11 [Type: unsigned long] 
    [68]             : 6 [Type: unsigned long] 
    [76]             : 13 [Type: unsigned long] 
    [84]             : 3 [Type: unsigned long] 
    [92]             : 16 [Type: unsigned long] 
    [100]            : 19 [Type: unsigned long] 
    [108]            : 2 [Type: unsigned long] 
    [116]            : 1 [Type: unsigned long] 
    [124]            : 2 [Type: unsigned long] 
    [132]            : 2 [Type: unsigned long] 
    [140]            : 3 [Type: unsigned long] 
    [148]            : 2 [Type: unsigned long] 
    [156]            : 1 [Type: unsigned long] 
    [164]            : 1 [Type: unsigned long] </code></pre>
<h4 class="bt4 sigil_not_in_toc">异步过程调用中断</h4>
<p class="zw">异步过程调用（Asynchronous Procedure Call，APC）为用户程序和系统代码提供了一种在特定用户线程的上下文（进而在特定进程地址空间）中执行的方法。由于APC需要在特定用户线程的上下文中排队执行，因此也会受制于线程调度规则，无法在与DPC相同的环境中运行。也就是说，APC无法在DISPATCH_LEVEL下运行，可能会被更高优先级的线程抢占，可以执行阻塞等待，可以访问可分页的内存。</p>
<p class="zw">话虽如此，但由于APC依然是一种软件中断，因此必须以某种方式从线程的主执行路径“夺取”控制权，本节将会介绍这是通过在名为APC_LEVEL的IRQL上操作实现的。这意味着尽管APC的运行不像DPC那样会遇到相同限制，但开发者依然需要遵守某些规则，下文还将详细介绍这一点。</p>
<p class="zw">APC是由一个名为APC对象的内核控制对象描述的。待执行的APC在内核管理的两个APC队列中等待。这与DPC队列不同，DPC队列是每个处理器专用的（并会分为线程的和非线程的），而APC队列是每个线程的，每个线程有两个APC队列：一个适用于内核APC，另一个适用于用户APC。</p>
<p class="zw">在需要将APC加入队列时，内核会查看APC的模式（用户或线程），随后将APC加入执行该APC例程的线程所属的相应队列。在介绍该APC如何以及何时执行之前，我们先来看看两种模式之间的差异。当APC被加入线程队列时，该线程可能处于下列三种情况之一：</p>
<p class="zwd"><span style="color: #0092dd">●</span> 线程当前正在运行（甚至可能就是当前线程）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 线程当前正在等待。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 线程正在执行其他操作（就绪、准备等）。</p>
<p class="zw">首先请回忆卷1第4章的内容，执行等待的线程具备一个可告警的状态。除非针对某个线程彻底禁用了APC，否则对于内核APC，该状态会被忽略，也就是说，APC总是会终止等待，而这一行为的结果会在下文进一步讨论。不过对于用户APC，只有在等待操作是可告警的并且代表某个用户模式组件进行了实例化，或者其他正在挂起的用户APC已经开始终止该等待（如果有大量处理器试图将APC加入同一个线程的队列，就会发生这种情况）的情况下，该线程才是可以中断的。</p>
<p class="zw">用户APC也永远不会中断正在用户模式下运行的线程，此时该线程需要执行可告警的等待，或者通过Ring级别转换或上下文切换重新访问用户APC队列。然而对于内核APC，在目标线程所在处理器上请求中断会将IRQL提升至APC_LEVEL级别，通知处理器必须查看当前运行中线程的内核APC队列。并且在这两种场景下，如果线程正在“做其他事情”，则需要通过某种转换让该线程进入运行中或等待中的状态。而这种操作实际上会导致线程被挂起，例如不再执行被加入自己队列中的APC。</p>
<p class="zw">除了上文介绍的有关可告警场景，我们曾提到线程的APC是可被禁用的。内核与驱动程序开发者可通过两种机制做到这一点，一种是在执行某些代码时直接将其IRQL提升至APC_LEVEL或更高级别。由于线程已经处于运行中的状态，因此通常会产生一个中断，但根据之前介绍过的IRQL规则，如果处理器已经处于APC_LEVEL（或更高）级别，中断将会被遮掩。因此，只有当IRQL被降低至PASSIVE_LEVEL，挂起的中断才会被交付，APC才能正常执行。</p>
<p class="zw">如果希望将APC重新交付给线程，强烈建议使用第二种机制，即使用内核API KeEnterGuardedRegion并配合使用KeLeaveGuardedRegion，这种方式可避免更改中断控制器状态。这些API是递归的，可通过嵌套的方式多次调用。只要依然在这样的区域中，就可以安全地通过上下文切换至其他线程，因为状态更新操作会应用于线程对象（KTHREAD）结构中的SpecialApcDisable字段，而不是每个处理器的状态。</p>
<p class="zw">类似地，上下文切换也可以发生在APC_LEVEL级别上，即使这是每个处理器的状态。调度程序会将IRQL保存在KTHREAD的WaitIrql字段中，随后将处理器IRQL设置为新传入线程的WaitIrql（该IRQL可能是PASSIVE_LEVEL）。这会导致一种非常有趣的情况：从技术上来说，PASSIVE_LEVEL级别的线程可抢占APC_LEVEL级别的线程。这种可能性很常见并且完全正常，并且这也证明了在线程执行方面，调度器本身的重要性远远超过任何IRQL。只有提升至DISPATCH_LEVEL级别，禁用线程抢占，才能让IRQL取代调度器。由于最终只有APC_LEVEL的IRQL存在这样的行为，因此这通常也被称为线程本地IRQL（Thread-local IRQL），虽然并不完全准确，但该机制已经足以描述此处提到的这种行为。</p>
<p class="zw">无论内核开发者如何禁用APC，有一条规则是始终适用的：代码不能以PASSIVE_ LEVEL之上的任何APC级别返回至用户模式，SpecialApcDisable也不能设置为“0”之外的其他任何值。实际出现这种情况会立即触发Bugcheck，通常这意味着某些驱动程序忘了释放锁，或者离开了自己的保护区域。</p>
<p class="zw">对于两种APC模式，每种模式也有两个类型的APC：常规APC与特殊APC，这取决于不同的模式，这两种APC的行为也存在差异。下面将分别讨论每种组合。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">特殊内核APC</strong>。这种组合产生的APC会始终被插入APC队列中其他所有现有特殊内核APC的尾部，但在任何常规内核APC之前的位置。内核例程会收到指向APC参数和常规例程的指针，并在APC_LEVEL级别上运行，这样就可以选择将新的常规APC加入队列。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">常规内核APC</strong>。此类APC始终会被插入APC队列的末尾，由此，特殊内核APC就可以将新的常规内核APC加入队列并稍后执行，上文的例子中描述了这样的情况。此类APC不仅可以通过上文提到的两种机制禁用，也可以通过一种名为KeEnterCriticalRegion的API（配合KeLeaveCriticalRegion）禁用，这会更新KTHREAD中的KernelApcDisable计数器，但不会更新SpecialApcDisable计数器。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 这些APC首先会在APC_LEVEL级别下执行自己的内核例程，并向其发送参数和常规例程指针。如果常规例程尚未清除，则会将IRQL降低至PASSIVE_LEVEL并照常执行常规例程，只不过此时会通过值的形式来传递输入参数。一旦常规例程返回，IRQL将再次重新提升至APC_LEVEL。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">常规用户APC</strong>。这种组合会导致APC被插入APC队列的末尾，进而供内核例程按照上一段所描述的方法在APC_LEVEL级别下首次执行。随后如果常规例程依然存在，该APC将准备进行用户模式的交付（很明显，是在PASSIVE_LEVEL级别进行的），为此会创建一个陷阱帧和执行帧，并最终导致在返回用户模式后，将由Ntdll.dll中的用户模式APC调度程序接管控制权，还将调用所提供的用户指针。一旦用户模式APC返回，调度程序将使用NtContinue或NtContinueEx系统调用返回到原来的陷阱帧。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 这里需要注意，如果内核例程最后清理了常规例程，那么已收到告警的线程将失去该状态；相反，如果没有收到告警，则会变为已告警状态并且用户APC挂起标记会被设置，这可能导致其他用户模式APC被尽快交付。这是由KeTestAlertThread API负责执行的，本质上，其行为依然类似于常规APC在用户模式下执行，尽管内核例程已经取消了该调度。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">特殊用户APC</strong>。这种组合产生的APC是较新版本的Windows 10中新增的，概括体现了一种为线程终止APC而做的特殊调度情况，其他开发者也可以使用这种组合。下文很快将会提到，终止远程（非当前）线程的操作需要使用APC，但该操作只有在所有内核模式代码均已执行完毕后才能进行。以用户APC的形式交付终止代码很适合这种情况，但这也意味着用户模式的开发者应避免通过执行不可告警的等待或使用其他用户APC填充队列的方式进行终止。</p>
<p class="zw">为了解决这种问题，长久以来，内核都会通过一种硬编码的检查来验证用户APC的内核例程是否使用了KiSchedulerApcTerminate。如果是，则用户APC会被视为“特殊”的，放置在队列的开头处。此外，线程的状态也会被忽略，并且始终设置为“用户APC正在挂起”的状态，这会迫使系统在下一次用户模式Ring级别转换或上下文切换到该线程时执行该APC。</p>
<p class="zw">该功能是专为终止代码路径保留的，这意味着开发者如果希望为用户APC的执行提供类似保证，无论可告警状态如何，都必须进一步使用更复杂的机制，如使用SetThreadContext手动更改线程上下文，但这种做法易出错。为了解决此问题，QueueUserAPC2 API应运而生，该API可通过QUEUE_USER_APC_FLAGS_SPECIAL_ USER_APC标记传递，也能以官方可支持的方式为开发者提供类似功能。此类APC在加入队列后始终位于其他任何用户模式APC之前（极为特殊的终止APC除外），并且对于等待中的线程，还会忽略可告警标记。此外，该&nbsp;APC&nbsp;首先会以一种非常特殊的内核APC形式插入，其内核例程几乎可以立即执行，并将APC重新注册为一个特殊用户APC。</p>
<p class="zw">表8-9总结了每一类APC的插入与交付行为。</p>
<p class="表题">表8-9　APC的插入与交付行为</p>
<table> 
 <tbody> 
  <tr> 
   <th> <p class="bt">APC类型</p> </th> 
   <th> <p class="bt">插入行为</p> </th> 
   <th> <p class="bt">交付行为</p> </th> 
  </tr> 
  <tr> 
   <td> <p class="bg">特殊（内核）</p> </td> 
   <td> <p class="bg">插入最后一个特殊APC之后（位于所有其他常规APC之前）</p> </td> 
   <td> <p class="bg">IRQL降低时，内核例程将在APC级别交付，此时线程不在保护区域内。当插入APC时，它将收到特定参数的指针</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">常规（内核）</p> </td> 
   <td> <p class="bg">插入内核模式APC列表末尾</p> </td> 
   <td> <p class="bg">IRQL降低时，内核例程将在APC_LEVEL级别交付，此时线程不在关键（或保护）区域内。当插入APC时，它将收到特定参数的指针。如果存在常规例程，在相关内核例程执行完毕后，这些常规例程将在PASSIVE_LEVEL级别上执行，并会收到相关内核例程返回的参数（可能是执行插入或新建操作时使用的原始参数）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">常规（用户）</p> </td> 
   <td> <p class="bg">插入用户模式APC列表末尾</p> </td> 
   <td> <p class="bg">IRQL降低时，内核例程将在APC_LEVEL级别交付，此时线程将被设置为“用户APC挂起中”标记（意味着APC已被加入队列，线程处于可告警的等待状态），当插入APC时，它将收到特定参数的指针<br></p> <p class="bg">如果存在常规例程，当相关内核例程执行完毕后，这些常规例程将在PASSIVE_LEVEL级别上以用户模式执行，并会收到相关内核例程返回的参数（可能是执行插入或新建操作时使用的原始参数）。如果常规例程被内核例程清理，则它会针对该线程执行Test-alert操作</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">用户线程终止APC<br></p> <p class="bg">（KiSchedulerApcTerminate）</p> </td> 
   <td> <p class="bg">插入用户模式APC列表开头</p> </td> 
   <td> <p class="bg">立即设置为“用户APC挂起中”标记并按照与上文所述类似的规则进行处理，但在返回用户模式时会在PASSIVE_ LEVEL级别上进行交付，并收到线程终止特殊APC所返回的参数</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">特殊（用户）</p> </td> 
   <td> <p class="bg">插入用户模式APC列表开头，但在线程终止APC（如果存在的话）之后</p> </td> 
   <td> <p class="bg">与上一种情况相同，但参数是通过QueueUserAPC2（NtQueueApcThreadEx2）的调用方控制的。内核例程是一种内部的KeSpecialUserApcKernelRoutine函数，该函数可重新插入APC，将其由最初的特殊内核APC转换为特殊用户APC</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">执行体会使用内核模式APC来执行必须在特定线程地址空间（以及上下文）中执行的操作系统工作。例如，它可以使用特殊内核模式APC指示线程停止执行可中断的系统服务，或借此记录某个线程地址空间内的一次异步I/O操作结果。环境子系统会使用特殊内核模式APC让线程变得可挂起或终止自身运行，或借此让线程获取或设置自己的用户模式执行上下文。Windows Subsystem for Linux（WSL）会使用内核模式APC来模拟向UNIX应用程序进程子系统传递的UNIX信号。</p>
<p class="zw">内核模式APC的另一个重要用途与线程的挂起和终止有关。由于这些操作可从任意线程发起并以其他任意线程为目标，内核会使用APC来查询线程上下文以及终止线程。设备驱动程序通常会阻止APC，或通过进入关键/保护区域防止在自己持有了锁的情况下执行此类操作，否则锁可能将永远无法释放，进而导致系统宕机。</p>
<p class="zw">设备驱动程序也可以使用内核模式APC。举例来说，如果发起一个I/O操作并且有线程进入等待状态，此时可调度执行另一个进程中的其他线程。当设备数据传输操作完成后，I/O系统必须通过某种方式重新进入发起该I/O操作的线程的上下文，以便将I/O操作结果复制到包含该线程的进程的地址空间缓冲区中。I/O系统使用一种特殊的内核模式APC来执行该操作，除非应用程序使用了SetFileIoOverlappedRange API或I/O完成端口，在这种情况下，缓冲区可能是内存中的全局缓冲区，否则，只有在线程从端口拉取到完成结果之后才能进行复制（I/O系统对APC的使用已在卷1第6章进行过详细介绍）。</p>
<p class="zw">很多Windows API（如ReadFileEx、WriteFileEx以及QueueUserAPC）也会使用用户模式APC。例如ReadFileEx和WriteFileEx函数可允许调用方指定I/O操作结束后要调用的完成例程。I/O完成是通过查询发起I/O操作的线程所对应的APC实现的，然而对完成例程的回调并不一定发生在将APC加入队列的时候，因为用户模式APC只能交付给处于可告警等待状态的线程。为了进入等待状态，线程可以等待对象句柄并指定自己的等待是可告警的（使用Windows的WaitForMultipleObjectsEx函数），或者可以直接测试自己是否有正在挂起的APC（使用SleepEx）。在这两种情况下，如果有用户模式APC正处于挂起状态，内核会中断（告警）这个线程，将控制转交给APC例程，并在APC例程完成后恢复线程的执行。与在APC_LEVEL级别下执行的内核模式APC不同，用户模式APC会在PASSIVE_LEVEL级别下执行。</p>
<p class="zw">APC的交付会导致等待队列重新排序，此处的“等待队列”可以理解为一个列表，其中列出了哪个线程正在等待什么，以及它们等待的具体顺序（有关如何解决这些等待的详细信息，请参阅“低IRQL同步”一节）。如果在交付APC时线程处于等待状态，在APC例程完成后，将重新发起或重新执行该等待。如果等待依然未能解决，线程将返回至等待状态，但这一次它会处于对象等待列表的末尾。例如，由于APC可用于挂起线程的执行过程，如果线程正在等待任何对象，那么其等待状态将被移除，直到线程恢复执行，随后该线程将被放置在线程列表的末尾，继续等待访问自己所等待的对象。正在执行可告警的内核模式等待的线程还可在线程终止时被唤醒，借此该线程就可以检查自己的唤醒到底是因为终止还是其他什么原因造成的。</p>

<p class="epubit-contents-id" style="display: none">{"index":1,"parentId":"a89070c3-60d0-4159-89c3-afa07663a88a","id":"def21ff0-ec8b-4163-b8f1-1a57c834904a"}</p>