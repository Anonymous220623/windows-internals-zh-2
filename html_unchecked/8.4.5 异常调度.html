<h3 class="bt3" id="sigil_toc_id_19">8.4.5　异常调度</h3>
<p class="zw">相比可能在任意时间产生的中断，异常（exception）则是由运行中的程序的执行直接导致的某些状况。Windows使用了一种名为结构化异常处理（structured exception handling）的设施，可让应用程序控制异常的发生。随后，应用程序即可修复相应状况并返回异常发生时的状态，并解除堆栈（借此终止产生异常的子例程的执行）或向系统告知异常未被识别，系统应该继续搜索可能处理该异常的异常处理程序。本节会假设读者已经熟悉Windows结构化异常处理背后的基本概念。对于不熟悉的读者，建议首先阅读Windows SDK中有关Windows API参考文档的概述部分，或者阅读由Jeffrey Richter与Christophe Nasarre合作撰写的<em>Windows via C/C++</em>一书（Microsoft Press，2007年）第23～25章的内容。另外请注意，虽然异常处理可通过语言扩展（例如Microsoft Visual C++中的_<sub>&nbsp;</sub>_try构造）来访问，但这实际上是一种系统机制，因此与具体语言是无关的。</p>
<p class="zw">在x86和x64处理器上，所有异常都有预定义的中断号，该中断号直接对应指向特定异常陷阱处理程序的IDT中的项。表8-12列出了x86定义的异常以及所分配的中断号。由于IDT中的第一个项已经被异常所使用，因此硬件中断会分配表中较为靠后的项，这一点在上文也有所提及。</p>
<p class="表题">表8-12　x86异常及其中断号</p>
<table> 
 <tbody> 
  <tr> 
   <th> <p class="bt">中断号</p> </th> 
   <th> <p class="bt">异常</p> </th> 
   <th> <p class="bt">助记符</p> </th> 
  </tr> 
  <tr> 
   <td> <p class="bg">0</p> </td> 
   <td> <p class="bg">除法错误</p> </td> 
   <td> <p class="bg">#DE</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">1</p> </td> 
   <td> <p class="bg">调试（单步）</p> </td> 
   <td> <p class="bg">#DB</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">2</p> </td> 
   <td> <p class="bg">不可遮蔽中断（NMI）</p> </td> 
   <td> <p class="bg">—</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">3</p> </td> 
   <td> <p class="bg">断点</p> </td> 
   <td> <p class="bg">#BP</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">4</p> </td> 
   <td> <p class="bg">溢出</p> </td> 
   <td> <p class="bg">#OF</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">5</p> </td> 
   <td> <p class="bg">边界检查（范围已超出）</p> </td> 
   <td> <p class="bg">#BR</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">6</p> </td> 
   <td> <p class="bg">无效操作码</p> </td> 
   <td> <p class="bg">#UD</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">7</p> </td> 
   <td> <p class="bg">NPX不可用</p> </td> 
   <td> <p class="bg">#NM</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">8</p> </td> 
   <td> <p class="bg">双重错误</p> </td> 
   <td> <p class="bg">#DF</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">9</p> </td> 
   <td> <p class="bg">NPX段溢出</p> </td> 
   <td> <p class="bg">—</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">10</p> </td> 
   <td> <p class="bg">无效任务状态段（TSS）</p> </td> 
   <td> <p class="bg">#TS</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">11</p> </td> 
   <td> <p class="bg">段不存在</p> </td> 
   <td> <p class="bg">#NP</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">12</p> </td> 
   <td> <p class="bg">栈段错误</p> </td> 
   <td> <p class="bg">#SS</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">13</p> </td> 
   <td> <p class="bg">常规保护</p> </td> 
   <td> <p class="bg">#GP</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">14</p> </td> 
   <td> <p class="bg">页面错误</p> </td> 
   <td> <p class="bg">#PF</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">15</p> </td> 
   <td> <p class="bg">Intel保留</p> </td> 
   <td> <p class="bg">—</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">16</p> </td> 
   <td> <p class="bg">x87浮点</p> </td> 
   <td> <p class="bg">#MF</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">17</p> </td> 
   <td> <p class="bg">对齐检查</p> </td> 
   <td> <p class="bg">#AC</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">18</p> </td> 
   <td> <p class="bg">机器检查</p> </td> 
   <td> <p class="bg">#MC</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">19</p> </td> 
   <td> <p class="bg">SIMD浮点</p> </td> 
   <td> <p class="bg">#XM或#XF</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">20</p> </td> 
   <td> <p class="bg">虚拟化异常</p> </td> 
   <td> <p class="bg">#VE</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">21</p> </td> 
   <td> <p class="bg">控制保护（CET）</p> </td> 
   <td> <p class="bg">#CP</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">除了简单到可以被陷阱处理程序所处理的异常外，其他所有异常都是由一个名为异常调度程序（Exception Dispatcher）的内核模块提供服务的。异常调度程序的作用是查找可以处理异常的异常处理程序。内核定义了很多架构独立的异常，例如内存访问冲突、整数除以零、整数溢出、浮点异常、调试器断点等。要查看架构独立异常的完整清单，请参阅Windows SDK参考文档。</p>
<p class="zw">内核陷阱及其处理程序会使用对用户程序来说透明的方式来处理某些异常。例如，在执行被调试的程序时遇到断点便会产生一个异常，内核会调用调试器处理这样的异常。但内核在处理某些其他异常时也会直接向调用方返回不成功的状态代码。</p>
<p class="zw">少数异常可在未经改动的情况下通过过滤回到用户模式。例如，某些类型的非法内存访问或算术溢出会生成操作系统无法处理的异常。32位应用程序可建立基于帧的异常处理程序来应对这些异常。此处的“基于帧”是指异常处理程序是与特定过程（procedure）的激活关联在一起的。调用某个过程时，代表该过程激活的栈帧会被推送到栈上。一个栈帧可关联一个或多个异常处理程序，其中每个异常处理程序负责保护源程序中特定的代码块。当发生异常时，内核会搜索与当前栈帧关联的异常处理程序。如果没找到，则内核将搜索与上一个栈帧关联的异常处理程序，以此类推，直到找到基于帧的异常处理程序。如果依然未找到任何异常处理程序，则内核将调用自己的默认异常处理程序。</p>
<p class="zw">对于64位应用程序，结构化的异常处理并不使用基于帧的处理程序（基于帧的技术已被证明很容易受到恶意用户攻击）。相反，应用程序编译过程中，会在映像中放置一个表，其中包含每个函数的处理程序。内核会据此查找与每个函数关联的处理程序，这个过程使用了与上文介绍的32位代码处理方式相同的算法。</p>
<p class="zw">内核本身在内部大量使用了结构化异常处理，借此可以安全地确认来自用户模式的指针可以安全地执行读取或写入操作。驱动程序在处理运行I/O控制代码（IOCTL）时发送的指针也可以使用相同的技术。</p>
<p class="zw">另一种异常处理机制叫作矢量异常处理。仅用户模式应用程序可以使用该方法。有关该方法的详细信息可参阅&nbsp;Windows SDK&nbsp;或&nbsp;Microsoft Docs：https://docs.microsoft.com/ windows/win32/debug/vectored-exception-handling。</p>
<p class="zw">当异常（无论是软件显式产生的异常还是硬件隐式产生的异常）发生时，会在内核中引发一系列连锁事件。CPU硬件会将控制权转交给内核陷阱处理程序，后者会（像出现中断时那样）创建一个陷阱帧。在异常解决后，陷阱帧使得系统能够从之前的位置恢复。陷阱处理程序还会创建异常记录，其中包含了出现异常的原因和其他相关信息。</p>
<p class="zw">如果异常出现在内核模式下，异常调度程序会直接调用例程来查找能处理该异常的、基于帧的异常处理程序。由于未处理的内核模式异常会被视为致命的操作系统错误，因此我们可以假设调度程序始终能找到异常处理程序。然而有些陷阱无法找到适合的异常处理程序，因为内核始终会假设此类错误是致命的，只有内核内部代码中非常严重的Bug或驱动程序代码中极严重的不一致问题（这只能通过故意修改底层系统代码导致，驱动程序不应对此负责）才会导致此类错误。此类致命错误会导致系统进行错误检查（Bug Check），并显示UNEXPECTED_KERNEL_MODE_TRAP错误代码。</p>
<p class="zw">如果异常出现在用户模式下，异常调度程序会以更精细的方式执行一些操作。Windows子系统有一个调试器端口（这实际上是一个调试器对象，下文很快将会介绍）和一个异常端口，可用在Windows进程中接收来自用户模式异常的通知（此处的“端口”是指ALPC端口对象，下文将详细介绍）。内核会使用这些端口进行默认的异常处理，如图8-24所示。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx2258.png" style="width: 100%" />
<p class="图题">图8-24　异常的调度</p>
<p class="zw">调试器断点是异常的常见来源。因此，异常调度程序所执行的第一个操作就是查看引起异常的进程是否关联了调试器进程。如果是，异常调度程序则会向该进程关联的调试器对象发送一条调试器对象消息（在内部，系统会将其称为“端口”，这是为了兼容可能依赖Windows 2000中某些行为的程序，因为Windows 2000使用了LPC端口而非调试对象）。</p>
<p class="zw">如果进程未附加调试器进程，或者调试器无法处理该异常，那么异常调度程序会切换至用户模式，将该陷阱帧复制到格式为CONTEXT数据结构（详见Windows SDK）的用户栈中，并调用例程来查找结构化或矢量异常处理程序。如果未找到，或任何处理程序均无法处理该异常，异常分发程序则会重新切换回内核模式，并再次调用调试器，以便让用户进一步执行调试操作（这个过程也叫二次通知，即Second-chance notification）。</p>
<p class="zw">如果调试器未运行并且未找到用户模式的异常处理程序，内核会向与线程的进程相关联的异常端口发送一条消息。该异常端口（如果存在的话）是由控制该线程的环境子系统注册的。该异常端口使得（大概率正在侦听该端口的）环境子系统有机会将异常转换为与该环境相关的信号或异常。然而，如果内核在异常的处理过程中已经进行到这种程度，并且子系统并未处理异常，则内核会向Csrss（Client/Server Run-Time Subsystem，客户端/服务器运行时子系统）中用于Windows错误报告（WER，详见第10章）的系统范围内的错误端口发送一条消息，并执行默认异常处理程序，随后直接终止导致该异常的线程所属的进程。</p>
<h4 class="bt4 sigil_not_in_toc">未经处理的异常</h4>
<p class="zw">所有Windows线程都具备一个能处理“未经处理的异常”的异常处理程序。该异常处理程序是在Windows内部的Start-of-thread函数中声明的。当用户创建进程或任何额外的线程时，便会运行Start-of-thread函数。该函数可调用初始线程上下文结构中所指定的、由环境提供的线程启动例程，随后这个例程会进一步调用CreateThread所指定的、由用户提供的线程启动例程。</p>
<p class="zw">内部Start-of-thread函数的通用代码如下所示：</p>
<pre class="代码无行号"><code>VOID RtlUserThreadStart(VOID) 
{ 
    LPVOID StartAddress = RCX; // Located in the initial thread context structure 
    LPVOID Argument = RDX; // Located in the initial thread context structure 
       LPVOID Win32StartAddr; 
    if (Kernel32ThreadInitThunkFunction != NULL) {
        Win32StartAddr = Kernel32ThreadInitThunkFunction; 
    } else {
        Win32StartAddr = StartAddress; 
    } 
    __try 
    { 
        DWORD ThreadExitCode = Win32StartAddr(Argument); 
        RtlExitUserThread(ThreadExitCode); 
    } 
    __except(RtlpGetExceptionFilter(GetExceptionInformation())) 
    { 
        NtTerminateProcess(NtCurrentProcess(), GetExceptionCode()); 
    } 
} </code></pre>
<p class="zw">请注意，如果线程包含自己无法处理的异常，则会调用Windows未经处理的异常过滤器。该函数的作用是提供系统定义的行为，以便当存在未经处理的异常时能够启动WerFault.exe进程。然而在默认配置下，第10章即将介绍的Windows Error Reporting（Windows错误报告）服务将处理该异常，因此这个未经处理的异常过滤器将永远不被执行。</p>
<p class="zwtsh">实验：查看Windows线程的真实用户起始地址</p>
<p class="zwts1">每个Windows线程都在系统提供的函数（而非用户提供的函数）中开始执行，这个事实解释了为何系统中每个Windows进程的线程0（以及第二个线程）的起始地址都是相同的。我们可以使用Process Explorer或内核调试器查看用户提供的函数地址。</p>
<p class="zwts1">由于Windows进程中的大部分线程都始于系统提供的一个包装器函数（wrapper function），在显示进程中线程的起始地址时，Process Explorer会跳过代表该包装器函数的初始调用帧，并直接显示该栈中的第二个帧。例如，请注意下图所示的Notepad.exe进程的线程起始地址。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx2270.png" style="width: 100%" />
<p class="zwts1">当显示调用栈时，Process Explorer并不会显示完整的调用层次结构。请注意在点击Stack按钮后显示的结果。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx2277.png" style="width: 100%" />
<p class="zwts1">图中第20行是这个栈中的第一个帧，即内部线程包装器的起始位置。第二个帧（第19行）是环境子系统（本例中为Kernel32）的线程包装器，因为我们查看的是一个Windows子系统应用程序。第三个帧（第18行）则是Notepad.exe的主入口点。</p>
<p class="zwts1">要显示正确的函数名称，我们应该为Process Explorer配置合适的符号。为此首先需要安装调试工具，该工具已包含在Windows SDK或WDK中。随后应选择Options</p>
<p class="zwts1">菜单中的Configure Symbols菜单项。dbghelp.dll路径应指向调试器工具文件夹中的文件（通常为C:\Program Files\Windows Kits\10\Debuggers，但请注意，位于C:\Windows\ System32下的dbghelp.dll文件将无法工作），而Symbols路径也需要正确配置，以便从微软的符号存储库将符号下载到本地文件夹。具体配置如下图所示。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx2285.png" style="width: 100%" />

<p class="epubit-contents-id" style="display: none">{"index":4,"parentId":"a89070c3-60d0-4159-89c3-afa07663a88a","id":"2ae83d57-10bb-4211-a291-3449802e40e1"}</p>