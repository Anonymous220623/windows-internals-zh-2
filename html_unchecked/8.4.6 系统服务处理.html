<h3 class="bt3" id="sigil_toc_id_20">8.4.6　系统服务处理</h3>
<p class="zw">如图8-24所示，内核的陷阱处理程序可以调度中断、异常和系统服务调用。8.4.5节已经介绍了中断和异常处理的工作过程，本节将介绍系统服务。系统服务的调度（见图8-25）是通过执行分配给系统服务调度机制的指令所触发的。Windows用于系统服务调度的指令取决于执行时使用的处理器，以及是否启用了虚拟机监控程序代码完整性（Hypervisor Code Integrity，HVCI），下文将介绍这些内容。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx2292.png" style="width: 100%" />
<p class="图题">图8-25　系统服务调度</p>
<h4 class="bt4 sigil_not_in_toc">架构性系统服务调度</h4>
<p class="zw">在大部分x64系统中，Windows使用了Syscall指令，这会导致我们在本章中介绍的一些关键处理器状态产生变化，具体变化则取决于某些预编程的特殊模块寄存器（MSR）：</p>
<p class="zwd"><span style="color: #0092dd">●</span> 0xC0000081，也叫STAR（SYSCALL Target Address Register，SYSCALL目标地址寄存器）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 0xC0000082，也叫LSTAR（Long-Mode STAR，长模式STAR）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 0xC0000084，也叫SFMASK（SYSCALL Flags Mask，SYSCALL标记掩码）。</p>
<p class="zw">当遇到Syscall指令时，处理器会执行下列操作：</p>
<p class="zwd"><span style="color: #0092dd">●</span> 从STAR的第32位到第47位加载代码段（Code Segment，CS），Windows将其设置为0x0010（KGDT64_R0_CODE）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 从STAR的第32位到第47位加载栈段（Stack Segment，SS）并加上“8”，这就得到了0x0018（KGDT_R0_DATA）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 指令指针（Instruction Pointer，RIP）被保存到RCX中，并从LSTAR加载新值，如果未启用Meltdown（KVA影子）缓解措施，Windows会将其设置为KiSystemCall64，否则会设置为KiSystemCall64Shadow。（有关Meltdown漏洞的详情请参阅上文“硬件侧信道漏洞”一节。）</p>
<p class="zwd"><span style="color: #0092dd">●</span> 当前处理器标记（RFLAGS）被保存到R11中，随后使用SFMASK添加掩码，后者被Windows设置为0x4700（陷阱标记、方向标记、中断标记以及嵌套任务标记）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 栈指针（Stack Pointer，RSP）以及所有其他段（DS、ES、FS和GS）被保存在各自的当前用户空间值中。</p>
<p class="zw">因此，尽管指令的执行只占用极少量的处理器周期，但确实会让处理器处于不安全且不稳定的状态：因为用户模式的栈指针依然处于载入状态，GS依然指向了TEB，但Ring级别（也就是CPL）目前为“0”，从而会产生内核模式特权。Windows会快速做出反应，将处理器置于一致的操作环境中。除了可能在老式处理器上发生的与KVA影子有关的操作外，KiSystemCall64必须精确执行如下这些步骤：</p>
<p class="zwd"><span style="color: #0092dd">●</span> 通过使用swapgs指令，现在GS可以指向PCR，该过程在上文已进行了介绍。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 当前栈指针（RSP）会被保存至PCR的UserRsp字段。由于现在GS已被正确加载，因此无须使用任何栈或寄存器即可完成该操作。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 从PRCB（该结构会被保存为PCR的一部分）的RspBase字段加载新的栈指针。</p>
<p class="zw">至此内核栈已成功加载，该函数会使用上文介绍的格式构建一个陷阱帧。这个陷阱帧中包含了被设置为KGDT_R3_DATA（0x2B）的SegSs、来自PCR中UserRsp的Rsp、来自R11的Eflags、被设置为KGDT_R3_CODE（0x33）的SegCs，以及来自RCX的Rip。通常来说，处理器陷阱设置了这些字段，但是Windows必须根据syscall的运行模拟相关行为。</p>
<p class="zw">在从R10加载了RCX后，一般来说，会由x64 ABI要求将任意函数（包括Syscall）的第一个参数放置在RCX中，同时Syscall会要求使用调用方的指令指针重写RCX，这一点在上文中已经介绍了。Windows可以感知到这种行为，并会在发出syscall指令前将RCX复制到R10。很快我们将介绍这步操作会还原相关的值。</p>
<p class="zw">随后的操作与处理器的缓解措施有关，例如监管人模式访问保护（Supervisor Mode Access Prevention，SMAP）（此时会发出Stac指令）以及各种处理器侧信道缓解措施（比如会清空分支跟踪缓冲区（Branch Tracing Buffer，BTB）或返回存储缓冲区（Return Store Buffer，RSB））。此外，对于支持控制流强制技术（Control-flow Enforcement Technology，CET）的处理器，还必须正确地同步线程的影子栈（shadow stack）。除此之外，陷阱帧的其他元素也会被存储起来，例如各种非易失寄存器和调试寄存器，随后开始对系统调用进行非架构性的处理。下面将详细讨论这些内容。</p>
<p class="zw">然而，并非所有的处理器都是x64架构的，对于x86处理器还需要注意一些问题，例如，此时会使用一种名为Sysenter的指令。由于32位处理器已经越来越少见了，我们不准备花费太多篇幅详细介绍该指令，但值得一提的是，该指令的行为是较为类似的：从多种MSR中加载处理器的某些状态，随后由内核执行一些额外的工作，例如设置陷阱帧。更多信息可参阅Intel处理器的相关手册。类似地，ARM架构的处理器使用了Svc指令，该指令有着自己的行为和操作系统级别的处理方式，但目前这些处理器在Windows总装机量中都只占据了很小的比例。</p>
<p class="zw">Windows还必须处理另外一种情况：那些不具备基于模式的执行控制（Mode Base Execution Control，MBEC）功能的处理器，在启用虚拟机监控程序代码完整性（HVCI）的情况下，会由于设计上存在的问题导致无法做到HVCI所提供的承诺（第9章将介绍HVCI和MBEC）。具体来说，攻击者可以分配用户空间的可执行内存，而HVCI允许这种做法（通过将相应的SLAT项标记为可执行），进而导致PTE损坏（无法针对内核篡改提供保护），并让这块虚拟地址显示为内核页。在MMU看来，由于这个页面是内核页，监管人模式执行保护（Supervisor Mode Execution Prevention，SMEP）机制将无法禁止代码的执行，又因为该页面最初是以用户物理页的形式分配的，所以SLAT项也将无法禁止其执行。借此攻击者就可以随意执行任何内核模式代码，这违反了HVCI最基本的原则。</p>
<p class="zw">MBEC及其同类技术（受限用户模式，Restricted User Mode）通过在SLAT项的数据结构中引入不同的内核与用户可执行位解决了这个问题，以此可让虚拟机监控程序（或让安全内核通过VTL1特有的超调用）将用户页标记为“内核不可执行但用户可执行”。遗憾的是，在不具备该功能的处理器上，虚拟机监控程序别无选择，只能用陷阱捕获所有代码特权级别的变更，并在两组不同的SLAT项之间切换，其中一组会将所有用户物理页标记为不可执行，另一组会将其标记为可执行。虚拟机监控程序通过将IDT标记为空（借此可有效地将其限制设置为0）和以解码底层指令的方式来捕获CPL变更，这种操作的开销很大。然而，因为中断可以直接被虚拟机监控程序用陷阱捕获，从而避免了这些开销。因此，如果检测到启用HVCI的系统不具备MBEC这样的功能，那么用户空间中的系统调用调度代码往往会发出中断。共享用户数据（shared user data）结构中的SystemCall位（详见卷1第4章）将决定此时的具体处理。</p>
<p class="zw">因此，当SystemCall被设置为1时，x64 Windows会使用int 0x2e指令，这会产生一个陷阱，包括一个无须操作系统参与的、完整构建的陷阱帧。有趣的是，此时使用的指令与Pentium Pro（奔腾Pro）之前的早期x86处理器所用的指令完全相同。为了与有着三十年以上历史的旧软件（一些此类软件中已经通过硬编码方式写入了这样的指令）实现向后兼容性，x86系统依然支持这些指令。不过在x64系统中，只有在上述情况下可以使用0x2e，因为其他情况下内核并不会填充相关的IDT项。</p>
<p class="zw">无论最终使用哪种指令，用户模式系统调用调度代码时，始终会将系统调用索引存储在一个寄存器中（x86和x64为EAX，32位ARM为R12，ARM64为X8），我们将通过接下来介绍的非架构性系统调用处理代码进一步查看该索引。此外，为了进一步简化相关工作，标准函数调用处理器ABI（Application Binary Interface，应用程序二进制接口）是跨边界维护的，例如，x86系统中的参数会放置在栈上，而x64系统中的RCX（由于受Syscall行为的影响，从技术上来说其实应该是R10）、RDX、R8、R9会在该栈的基础上为这四者加上其他参数。</p>
<p class="zw">调度完成后，处理器该如何返回自己原先的状态呢？对于通过int 0x2e进行的基于陷阱的系统调用，将由iret指令根据栈上的硬件陷阱帧来还原处理器状态。不过对于Syscall和Sysenter，处理器分别通过名为Sysret和Sysexit的专用指令再次利用了我们之前在项上看到的MSR和硬编码寄存器。前者的具体行为如下所示：</p>
<p class="zwd"><span style="color: #0092dd">●</span> 从STAR的第48～63位加载栈段（Stack Segment，SS），Windows将其设置为0x0023（KGDT_R3_DATA）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 从STAR的第48～63位加载代码段（Code Segment，CS）并为其加上0x10，这就得到了0x0033（KGDT64_R3_CODE）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 从RCX加载指令指针（RIP）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 从R11加载处理器标记（RFLAGS）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 栈指针（RSP）和其他段（DS、ES、FS与GS）依然保持当前的内核空间值。</p>
<p class="zw">因此，与系统调用的进入一样，退出机制也必须清理一些处理器状态。也就是说，RSP会从我们之前分析过的进入代码恢复到保存在制造商硬件陷阱帧中的Rsp字段，其他所有保存的寄存器做法都是类似的。RCX寄存器将从保存的Rip加载，R11将从EFlags加载，swapgs指令会在发出sysret指令之前使用。由于DS、ES和FS从未被触及，因此它们依然可以维持各自最初的用户空间值。最后，EDX以及XMM0到XMM5会被归零，所有其他的非易失性寄存器会在执行sysret指令前从陷阱帧中还原。另外还会对Sysexit和ARM64的退出指令（eret）执行等效的操作。此外，如果启用了CET，那么与进入路径类似，在退出路径上，影子栈也必须执行正确的同步。</p>
<p class="zwtsh">实验：定位系统服务调度程序</p>
<p class="zwts1">如上文所述，x64系统调用会基于一系列MSR进行，而这些MSR均可使用调试器命令rdmsr查看。首先请注意STAR，其中显示了KGDT_R0_CODE（0x0010）和KGDT64_R3_DATA（0x0023）。</p>
<pre class="代码无行号"><code>lkd&gt; rdmsr c0000081 
msr[c0000081] = 00230010`00000000 </code></pre>
<p class="zwts1">随后即可开始调查LSTAR，接着就可以使用ln命令来查看它是否指向KiSystemCall64（对于不需要KVA影子的系统）或指向KiSystemCall64Shadow（对于需要KVA影子的系统）：</p>
<pre class="代码无行号"><code>lkd&gt; rdmsr c0000082 
msr[c0000082] = fffff804`7ebd3740 
　
lkd&gt; ln fffff804`7ebd3740 
(fffff804`7ebd3740) nt!KiSystemCall64 </code></pre>
<p class="zwts1">下面查看SFMASK，其中应包含我们之前介绍过的值：</p>
<pre class="代码无行号"><code>lkd&gt; rdmsr c0000084 
msr[c0000084] = 00000000`00004700 </code></pre>
<p class="zwts1">x86系统调用通过Sysenter进行，并使用了一组不同的MSR，包括0x176，其中存储了32位系统调用处理程序：</p>
<pre class="代码无行号"><code>lkd&gt; rdmsr 176 
msr[176] = 00000000'8208c9c0 
　
lkd&gt; ln 00000000'8208c9c0 
(8208c9c0)   nt!KiFastCallEntry </code></pre>
<p class="zwts1">在不具备MBEC但使用了HVCI的x86和x64系统中，可以使用调试器命令!idt 2e查看IDT中注册的int 0x2e处理程序：</p>
<pre class="代码无行号"><code>lkd&gt; !idt 2e 
　
Dumping IDT: fffff8047af03000 
2e:            fffff8047ebd3040 nt!KiSystemService </code></pre>
<p class="zwts1">还可以使用u命令反汇编KiSystemService或KiSystemCall64例程。对于中断处理程序，我们最终会注意到：</p>
<pre class="代码无行号"><code>nt!KiSystemService+0x227: 
fffff804`7ebd3267 4883c408        add     rsp,8 
fffff804`7ebd326b 0faee8          lfence 
fffff804`7ebd326e 65c604255308000000 mov   byte ptr gs:[853h],0 
fffff804`7ebd3277 e904070000      jmp     nt!KiSystemServiceUser (fffff804`7ebd3980)</code></pre>
<p class="zwts1">而MSR处理程序会落入下列内容：</p>
<pre class="代码无行号"><code>nt!KiSystemCall64+0x227: 
fffff804`7ebd3970 4883c408        add     rsp,8 
fffff804`7ebd3974 0faee8          lfence 
fffff804`7ebd3977 65c604255308000000 mov   byte ptr gs:[853h],0 
nt!KiSystemServiceUser: 
fffff804`7ebd3980 c645ab02        mov      byte ptr [rbp-55h],2 </code></pre>
<p class="zwts1">由此可以看到，最终所有代码路径都将抵达KiSystemServiceUser，并由它跨越所有处理器执行大部分通用操作，具体过程将在下一节详细介绍。</p>
<h4 class="bt4 sigil_not_in_toc">非架构性系统服务调度</h4>
<p class="zw">如图8-25所示，内核会使用系统调用编号，在系统服务调度表中定位系统服务信息。在x86系统中，该表类似于上文介绍过的中断调度表（interrupt dispatch table），只是其中的每一项都包含一个指向系统服务（而不是中断处理例程）的指针。在其他平台（包括32位的ARM和ARM64）上，该表的实现方式略有差异，并不是包含指向系统服务的指针，而是包含与表本身相关的偏移量。这种寻址机制更适合x64和ARM64应用程序二进制接口（ABI）和指令编码格式，也更符合ARM处理器的RISC本质特征。</p>
<table> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　不同版本操作系统中的系统服务编号经常会发生变化，微软不仅会偶尔添加或删除系统服务，而且该表还经常会被随机化并乱序排列，这是为了让那些硬编码系统调用编号发起的攻击失效。</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">无论什么架构，系统服务分发程序会在所有平台上执行一些通用操作：</p>
<p class="zwd"><span style="color: #0092dd">●</span> 将额外的寄存器（如调试寄存器或浮点寄存器）保存在陷阱帧中。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 如果线程属于一个微进程（pico process），则将其转发给系统调用的Pico提供程序例程（有关Pico提供程序的详情，请参阅卷1第3章）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 如果线程是一个UMS调度的线程，则会调用KiUmsCallEntry以便与主线程（primary thread）同步（有关UMS的详细介绍请参阅卷1第1章）。对于UMS主线程，会在线程对象中设置UmsPerformingSyscall标记。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 将系统调用的第一个参数存储到线程对象的FirstArgument字段，并将系统调用编号存储到SystemCallNumber。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 调用共享的用户/内核系统调用处理程序（KiSystemServiceStart），由它将线程对象的TrapFrame字段设置为自己所存储的当前栈指针。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 启用中断交付。</p>
<p class="zw">至此，该线程开始正式经历系统调用，其状态完全一致并且可以中断。接下来需要选择正确的系统调用表，并可能将线程升级为GUI线程，具体细节则取决于下一节将要介绍的线程对象中的GuiThread和RestrictedGuiThread字段。随后只要TEB的GdiBatchCount字段非零，就会对GUI线程执行GDI批处理操作。</p>
<p class="zw">系统调用调度程序必须将未通过寄存器（取决于CPU具体架构）传递的任何调用方参数从线程的用户模式栈复制到其内核模式栈。这是为了避免让每个系统调用手动复制参数（可能需要汇编代码和异常处理），并确保内核访问参数时用户无法更改这些参数。该操作在一个特殊的代码块中完成，异常处理程序可以识别该代码块，并将其与用户栈的复制关联在一起，这确保了在攻击者或存在Bug的程序扰乱用户栈后，内核依然不会崩溃。由于系统调用可以接受任意数量的参数（大部分情况下都是这样的），因此下一节将讨论内核如何知道要复制多少个参数。</p>
<p class="zw">这里需要注意，这些参数复制操作是浅层的：如果传递给系统服务的任何参数指向了用户空间中的缓冲区，则必须先探测是否能够安全地访问，随后内核模式的代码才能读取或写入该缓冲区。如果缓冲区被多次访问，则可能需要将其捕获或复制到本地的内核缓冲区中。该探测和捕获操作是由每个系统调用分别进行的，并非由处理程序负责。然而系统调用分发程序还必须执行一个关键操作：设置线程原本的模式（previous mode）。该模式的值可以是KernelMode或UserMode，当当前线程执行陷阱时，这个值必须实现同步，借此才可以识别传入异常、陷阱或系统调用的特权级别。因此，系统调用可以使用ExGetPreviousMode正确地处理用户和内核调用方。</p>
<p class="zw">调度程序的主体还要执行最后两步操作。首先，如果配置了DTrace并启用了系统调用跟踪，则会围绕系统调用来调用相应的进入/退出回调。或者如果启用了ETW跟踪但未启用DTrace，则会围绕系统调用记录相应的ETW事件。抑或DTrace或ETW均未启用，那么这个系统调用就不需要任何额外的逻辑。其次也是最后一步，还需要让PRCB中的KeSystemCalls变量递增，该变量是以性能计数器的形式展现的，我们可以通过性能和可靠性监视器监视该计数器。</p>
<p class="zw">至此，系统调用调度已完成，随后在系统调用退出过程中还将执行相反的步骤。这些步骤会酌情还原并复制用户模式的状态，按需处理用户模式APC的交付，处理与各种架构缓冲区有关的侧信道缓解措施，并最终根据具体平台返回相应的CPU指令。</p>
<h4 class="bt4 sigil_not_in_toc">内核发出的系统调用调度</h4>
<p class="zw">由于系统调用可通过用户模式代码和内核模式代码执行，因此，任何指针、处理程序以及行为均应该被视为来自用户模式，很明显这是不对的。</p>
<p class="zw">为了解决这个问题，内核会将这些调用导出为专用的Zw版本，也就是说，内核会导出为ZwCreateFile而非NtCreateFile。此外，由于Zw函数必须由内核手动导出，因此，只有微软希望供第三方使用的API才能导出。例如，ZwCreateUserProcess就无法按照名称导出，因为内核驱动程序不应该启动用户应用程序。这种导出的API实际上并非为相应的Nt版本简单创建的别名或包装器，它们是相应Nt系统调用的“蹦床”，并且使用了相同的系统调用调度机制。</p>
<p class="zw">与KiSystemCall64类似，它们也构建了一种假的硬件陷阱帧（在栈上推送CPU时收到来自内核模式的中断后生成的数据），并且与陷阱一样，它们也禁用了中断。例如在x64系统中，KGDT64_R0_CODE（0x0010）选择器会作为CS来推送，而当前内核栈会作为RSP来推送。每个这种“蹦床”会将系统调用编号放入相应的寄存器中（例如x86和x64系统中的EAX），再调用KiServiceInternal在陷阱帧中保存额外的数据，读取当前的“原本的模式”并将其保存在陷阱帧中，随后将“原本的模式”设置为KernelMode（这是一个重大的差异）。</p>
<h4 class="bt4 sigil_not_in_toc">用户发出的系统调用调度</h4>
<p class="zw">正如卷1第1章中介绍的那样，Windows执行体服务所用的系统服务调度指令位于系统库Ntdll.dll中。子系统DLL可调用Ntdll中的函数来实现自己的公开功能。但Windows USER和GDI函数（包括DirectX内核图形函数）属于例外，这些系统服务调度指令是在Win32u.dll中实现的，并未涉及Ntdll.dll。这两种情况如图8-26所示。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx2426.png" style="width: 100%" />
<p class="图题">图8-26　系统服务调度</p>
<p class="zw">如图8-26所示，Kernel32.dll中的Windows WriteFile函数会导入并调用API-MS-Win- Core-File-L1-1-0.dll（这是一个MinWin重定向DLL，有关API重定向的详细信息请参阅卷1第3章）中的WriteFile函数，随后会调用KernelBase.dll（实际实现的位置）中的WriteFile函数。在检查与子系统有关的一些参数后，会调用Ntdll.dll中的NtWriteFile函数，该函数接下来执行相应指令来产生系统服务陷阱，并传递代表NtWriteFile函数的系统服务编号。</p>
<p class="zw">Ntoskrnl.exe中的系统服务调度程序（本例中为KiSystemService）会调用真正的NtWriteFile来处理I/O请求。对于Windows USER、GDI和DirectX内核图形函数，系统服务调度会在Windows子系统可加载的内核模式部分（Win32k.sys）调用该函数，随后可能会过滤系统调用或将其转发给相应的模块，例如桌面系统中的Win32kbase.sys或Win32kfull.sys，Windows 10X<sup>[3]</sup>系统中的Win32kmin.sys或DirectX调用中的Dxgkrnl.sys。</p>
<p class="footnote">[3]Windows 10X是Windows 10时期，微软针对双屏幕设备（如双屏幕笔记本电脑，原本的键盘位置被另一块屏幕取代）开发的一种新操作系统。目前该项目已终止，但相关“遗产”已被融入Windows 11中（例如居中显示的开始菜单和任务栏按钮）。——译者注</p>
<h4 class="bt4 sigil_not_in_toc">系统调用的安全性</h4>
<p class="zw">由于内核中包含正确同步系统调用操作的“原本模式”所需的机制，因此每个系统调用服务都可以在处理过程中依赖这个值。上文曾经提到，这些函数必须首先探测指向任何类型用户模式缓冲区的任何参数。这里的“探测”是指：</p>
<p class="zw">1）确保该地址低于MmUserProbeAddress，即比最高的用户模式地址低64&nbsp;KB（例如32位系统中的0x7FFF0000）。</p>
<p class="zw">2）确保该地址与调用方意图访问的数据边界对齐，例如Unicode字符为2字节，64位指针为8字节，以此类推。</p>
<p class="zw">3）如果缓冲区要用于输出，还需要确保当系统调用开始时，该缓冲区实际上是可写的。</p>
<p class="zw">请注意，输出缓冲区可能会在将来的任何时间点变为无效或只读，为了避免内核崩溃，系统调用必须始终使用本章上文介绍过的SEH访问输出缓冲区。出于类似原因，虽然系统不检查输入缓冲区的可读性（因为无论如何，输入缓冲区都可能被迫投入使用），但必须使用SEH来确保输入缓冲区可以被安全地读取。而SEH并不能防止无法对齐或野内核指针（wild kernel pointer）的情况，因此必须执行上文列出的前两个步骤。</p>
<p class="zw">很明显，对任何内核模式调用方进行上述第一项检查都会立即失败，而这也是“原本的模式”开始生效的第一个地方：对非用户模式的调用跳过探测操作，并假定所有缓冲区都是有效的、可读取的或根据需要可写入的。然而，这并非系统调用唯一需要执行的验证类型，因为可能还会出现其他比较危险的情况：</p>
<p class="zwd"><span style="color: #0092dd">●</span> 调用方可能提供了一个对象句柄。内核在引用对象时通常会绕过所有安全访问检查，并且内核还可以完整访问内核句柄（我们将在本章“对象管理器”一节详细介绍），但用户模式代码并不会这样做。“原本的模式”可用于通知对象管理器依然需要执行访问检查，因为该请求来自用户空间。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 更复杂的情况下，驱动程序可使用诸如OBJ_FORCE_ACCESS_CHECK等标记来表明：尽管使用了Zw API（以此将原本的模式设置为KernelMode），但对象管理器依然需要像处理来自UserMode的请求那样对待该请求。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 同理，调用方可能已经指定了一个文件名。在打开文件时，系统调用可能会使用IO_FORCE_ACCESS_CHECKING标记迫使安全引用监视器验证对文件系统的访问，这一点很重要，否则，诸如ZwCreateFile等调用有可能将“原本的模式”更改为KernelMode而绕过访问检查。如果驱动程序需要代表来自用户空间的IRP创建文件，同样也需要这样做。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 对文件系统的访问也可能带来与符号链接或其他类型的重定向攻击有关的风险，此时高特权内核模式代码可能会错误地使用各种与特定进程有关或用户可访问的重分析点。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 一般来说，对于使用Zw接口执行的任何会导致链式系统调用的操作都要注意，该操作会将“原本的模式”重置为KernelMode并酌情做出相应的响应。</p>
<h4 class="bt4 sigil_not_in_toc">服务描述符表</h4>
<p class="zw">上文曾经提到，在执行系统调用前，必须由用户模式或内核模式的“蹦床”首先将系统调用编号放入处理器寄存器（如RAX、R12或X8）中。从技术角度来看，该编号包含两个元素，如图8-27所示。第一个元素存储在低12位中，代表系统调用索引；第二个元素存储在接下来的2位（12～13）中，充当表标识符。很快我们将会介绍，借此内核即可实现最多四种不同类型的系统服务，每种服务都存储在一个表中，而每个表最多可容纳4096个系统调用。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx2433.png" style="width: 100%" />
<p class="图题">图8-27　系统服务编号与系统服务之间的转换</p>
<p class="zw">内核会使用三个可能的数组跟踪系统服务表，这三个数组分别为KeServiceDescriptorTable、KeServiceDescriptorTableShadow以及KeServiceDescriptorTableFilter。每个数组最多包含两个项，其中存储了下列三类数据：</p>
<p class="zwd"><span style="color: #0092dd">●</span> 一个指向该服务表所实现的系统调用数组的指针。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 该服务表中包含的系统调用数量，也称Limit（限制）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 一个指向该服务表中每个系统调用对应的参数字节数组的指针。</p>
<p class="zw">第一个数组中始终只有一项，指向了KiServiceTable和KiArgumentTable，其中可包含略多于450个系统调用（具体数量取决于Windows版本）。默认情况下，所有线程都会发出仅访问该表的系统调用。在x86系统中，这是由线程对象中的ServiceTable指针强制执行的，其他所有平台则会将符号KeServiceDescriptorTable硬编码到系统调用调度程序中。</p>
<p class="zw">当线程发出的系统调用首次超过限制时，内核会调用PsConvertToGuiThread，由此向Win32k.sys中的USER和GDI服务告知该线程的情况，并在成功返回后设置线程对象的GuiThread标记或RestrictedGuiThread标记。具体设置哪个标记取决于是否启用了EnableFilteredWin32kSystemCalls进程缓解选项（有关该选项的详细介绍请参阅卷1第7章）。在x86系统中，取决于具体设置了哪个标记，随后线程对象的ServiceTable指针将会指向KeServiceDescriptorTableShadow或KeServiceDescriptorTableFilter，其他平台上则在每个系统调用时选择一个硬编码的符号（虽然会对性能产生些许影响，但后一种方式可避免产生容易被恶意软件滥用的挂钩点）。</p>
<p class="zw">大家可能已经猜到，其他数组中包含了第二个项，该项代表了在Windows子系统Win32k.sys的内核模式部分所实现的Windows USER和GDI服务。在较新版本的Windows中，该项还代表了由Dxgkrnl.sys实现的DirectX内核子系统服务，不过最初这些服务是通过Win32k.sys传输的。第二项会分别指向W32pServiceTable或W32pServiceTableFilter，以及W32pArgumentTable或W32pArgumentTableFilter，这取决于Windows版本，可包含大约1250个或更多的系统调用。</p>
<table> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　内核并不链接Win32k.sys，因此会导出一个KeAddSystemServiceTable函数，以便在尚未填写KeServiceDescriptorTableShadow和KeServiceDescriptorTableFilter表时能够向这些表中添加额外的项。如果Win32k.sys已经调用了这些API，该函数将会失效，并且一旦调用该函数，PatchGuard就会去保护数组，最终使其结构变为只读状态。</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">Filter项之间唯一的实质性区别在于，它们会使用诸如stub_UserGetThreadState这样的名称指向Win32k.sys中的系统调用，但实际的数组会指向NtUserGetThreadState。前者的存根（Stub）在部分情况下会根据已为进程加载的过滤器集来检查是否为该系统调用启用了Win32k.sys过滤。根据检查结果，如果过滤器集明确禁止，则调用会失败并返回STATUS_ INVALID_SYSTEM_SERVICE，或最终调用原始函数（例如NtUserGetThreadState），这种情况下如果启用了审核，则可能还会返回遥测结果。</p>
<p class="zw">另一方面，参数表可以帮助内核了解要将多少个栈字节从用户栈复制到内核栈，具体过程详见上文的“调度”一节。参数表中的每个项均对应具备该索引并且匹配的系统调用，其中还存储了要复制的字节数量（最多255字节）。然而，x86系统之外其他所有平台的内核还采用了一种名为系统调用表压缩（system call table compaction）的机制，该机制可将调用表中的系统调用指针与参数表中的字节数组合成一个值。该功能的工作原理如下。</p>
<p class="zw">1）获取系统调用函数指针，并从系统调用表本身开头处开始计算32位差值。由于该表是一个全局变量，位于包含了这些函数的同一个模块内，因此，±2&nbsp;GB&nbsp;的范围应该足够了。</p>
<p class="zw">2）从参数表中获取栈字节数并将其除以4，以此将其转换为参数数量（某些函数可能采用8字节参数，但从目的的角度考虑，它们将被直接视为两个“参数”）。</p>
<p class="zw">3）将第1步得到的32位差值左移4位，最终使其成为28位差值（再次提醒，这样做没问题，因为没有内核组件会大于256&nbsp;MB）并执行按位或运算以添加第2步得到的参数数量。</p>
<p class="zw">4）使用第3步获得的值重写系统调用函数指针。</p>
<p class="zw">这种优化方式虽然乍看起来并不好，但实际上有很多优点：通过避免在系统调用过程中在两个不同数组中查找减少了缓存的使用，减少了指针取消引用操作的数量，可充当一个混淆层进而使得更难以针对系统调用表进行挂钩或修补操作，同时也让PatchGuard可以更容易地保护系统调用表。</p>
<p class="zwtsh">实验：将系统调用编号映射为函数和参数</p>
<p class="zwts1">我们可以重现内核在处理系统调用ID时所进行的查找，以此了解哪个函数负责处理该过程以及总共需要多少个参数。在x86系统中，我们可以直接用调试器通过dps命令转储每个系统调用表（如KiServiceTable），“dps”代表dump pointer symbol（转储指针符号），该命令可以代替我们进行查找。此外，也可通过db（dump bytes，转储字节）命令转储KiArgumentTable（或Win32k.sys中的任何系统调用表）。</p>
<p class="zwts1">不过根据上文介绍过的编码方式，更有趣的练习是在ARM64或x64系统中转储这些数据。为此请执行如下操作。</p>
<p class="zwts1">1）只要撤销上文介绍过的压缩操作，即可转储特定的系统调用。获取基准表并将其添加至所需索引中存储的28位偏移量，如下所示，其中内核系统表中的系统调用3会显示为NtMapUserPhysicalPagesScatter：</p>
<pre class="代码无行号"><code>lkd&gt; ?? ((ULONG)(nt!KiServiceTable[3]) &gt;&gt; 4) + (int64)nt!KiServiceTable 
unsigned int64 0xfffff803`1213e030 
　
lkd&gt; ln 0xfffff803`1213e030 
(fffff803`1213e030) nt!NtMapUserPhysicalPagesScatter </code></pre>
<p class="zwts1">2）通过获取4位的参数数量，即可看到该系统调用所接收的基于栈的4字节参数数量：</p>
<pre class="代码无行号"><code>lkd&gt; dx (((int*)&amp;(nt!KiServiceTable))[3] &amp; 0xF) 
(((int*)&amp;(nt!KiServiceTable))[3] &amp; 0xF) : 0 </code></pre>
<p class="zwts1">3）请注意，这并不意味着该系统调用没有参数。因为这是x64系统，调用可以接受0～4之间任意数量的参数，而所有参数都位于寄存器（RCX、RDX、R8和R9）中。</p>
<p class="zwts1">4）我们还可通过调试器数据模型，使用投射创建LINQ谓词并转储整个表，因为KiServiceLimit变量对应了服务描述符表中相同的限制字段（正如影子描述符表中Win32k.sys的W32pServiceLimit项）。输出结果应类似如下所示：</p>
<pre class="代码无行号"><code>lkd&gt; dx @$table = &amp;nt!KiServiceTable 
@$table = &amp;nt!KiServiceTable : 0xfffff8047ee24800 [Type: void *] 
　
lkd&gt; dx (((int(*)[90000])&amp;(nt!KiServiceTable)))-&gt;Take(*(int*)&amp;nt!KiServiceLimit)-&gt;
     Select(x =&gt; (x &gt;&gt; 4) + @$table) 
(((int(*)[90000])&amp;(nt!KiServiceTable)))-&gt;Take(*(int*)&amp;nt!KiServiceLimit)-&gt;Select
     (x =&gt; (x &gt;&gt; 4) + @$table)
   [0]              : 0xfffff8047eb081d0 [Type: void *] 
   [1]              : 0xfffff8047eb10940 [Type: void *] 
   [2]              : 0xfffff8047f0b7800 [Type: void *] 
   [3]              : 0xfffff8047f299f50 [Type: void *] 
   [4]              : 0xfffff8047f012450 [Type: void *] 
   [5]              : 0xfffff8047ebc5cc0 [Type: void *] 
   [6]              : 0xfffff8047f003b20 [Type: void *] </code></pre>
<p class="zwts1">5）我们还可以使用该命令更复杂的版本将指针转换为对应的符号形式，本质上，这等于重新实现了适用于x86 Windows的dps命令：</p>
<pre class="代码无行号"><code>lkd&gt; dx @$symPrint = (x =&gt; Debugger.Utility.Control.ExecuteCommand(".printf \"
    %y\\n\"," + 
    ((unsigned __int64)x).ToDisplayString("x")).First()) 
@$symPrint = (x =&gt; Debugger.Utility.Control.ExecuteCommand(".printf \"%y\\n\"," +
((unsigned __int64)x).ToDisplayString("x")).First()) 
　
lkd&gt; dx (((int(*)[90000])&amp;(nt!KiServiceTable)))-&gt;Take(*(int*)&amp;nt!KiServiceLimit)-&gt;Select
    (x =&gt; @$symPrint((x &gt;&gt; 4) + @$table)) 
(((int(*)[90000])&amp;(nt!KiServiceTable)))-&gt;Take(*(int*)&amp;nt!KiServiceLimit)-&gt;Select(x =&gt;
@$symPrint((x &gt;&gt; 4) + @$table)) 
    [0]              : nt!NtAccessCheck (fffff804`7eb081d0) 
    [1]              : nt!NtWorkerFactoryWorkerReady (fffff804`7eb10940) 
    [2]              : nt!NtAcceptConnectPort (fffff804`7f0b7800) 
    [3]              : nt!NtMapUserPhysicalPagesScatter (fffff804`7f299f50) 
    [4]              : nt!NtWaitForSingleObject (fffff804`7f012450) 
    [5]              : nt!NtCallbackReturn (fffff804`7ebc5cc0) </code></pre>
<p class="zwts1">6）如果只对内核的服务表感兴趣，但对Win32k.sys项不感兴趣，也可以使用调试器的!chksvctbl -v命令，让输出结果包含所有这些数据，同时以此检查可能被Rootkit附加的内联挂钩：</p>
<pre class="代码无行号"><code>lkd&gt; !chksvctbl -v 
#    ServiceTableEntry        DecodedEntryTarget(Address)               CompactedOffset
=======================================================================================
0    0xfffff8047ee24800                 nt!NtAccessCheck(0xfffff8047eb081d0) 0n-52191996
1    0xfffff8047ee24804    nt!NtWorkerFactoryWorkerReady(0xfffff8047eb10940) 0n-51637248
2    0xfffff8047ee24808           nt!NtAcceptConnectPort(0xfffff8047f0b7800) 0n43188226
3    0xfffff8047ee2480c nt!NtMapUserPhysicalPagesScatter(0xfffff8047f299f50) 0n74806528
4    0xfffff8047ee24810         nt!NtWaitForSingleObject(0xfffff8047f012450) 0n32359680</code></pre>
<p class="zwtsh">实验：查看系统服务活动</p>
<p class="zwts1">我们可以通过观察System对象的System Calls/Sec性能计数器来监视系统服务活动。打开性能监视器，点击“<strong style="color:#0092dd">监视工具</strong>”下的“<strong style="color:#0092dd">性能监视器</strong>”，随后点击“<strong style="color:#0092dd">添加</strong>”按钮将计数器添加到图表即可。请选择System对象，选中System Calls/Sec计数器，随后点击“<strong style="color:#0092dd">添加</strong>”按钮将其加入图表。</p>
<p class="zwts1">我们可能还要增大图表的最大值，因为系统中的常态是每秒进行数十万个调用，系统配备的处理器越多，调用数量就越多。下图显示了这些数据在本书作者的计算机上所呈现的样子。</p>
<p class="zw"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx2515.png" style="width: 100%" />

<p class="epubit-contents-id" style="display: none">{"index":5,"parentId":"a89070c3-60d0-4159-89c3-afa07663a88a","id":"2ebf7151-eaf6-45a7-b55f-ffb1338ff23a"}</p>