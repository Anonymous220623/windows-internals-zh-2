<h3 class="bt3" id="sigil_toc_id_25">8.5.4　AMD64平台上的x86模拟</h3>
<p class="zw">AMD64平台上的x86模拟器（Wow64cpu.dll）接口相当简单。模拟器进程初始化函数会根据是否存在软件MBEC（Mode Based Execute Control，基于模式的执行控制，详见第9章）而启用快速系统调用接口。当WoW64核心通过调用模拟器的接口BtCpuSimulate开始模拟时，模拟器会（根据WoW64核心提供的32位CPU上下文）构建WoW64栈帧，为快速系统调用的调度初始化Turbo形式转换数组，并准备FS段寄存器使其指向线程的32位TEB。最后，它还会设置一个以32位段（通常是0x20段）为目标的调用门（call gate），切换栈，并发起到最终32位入口点的远跳（首次执行时，入口点会设置为32位版本的LdrInitializeThunk加载器函数）。当CPU执行该远跳时，会检测到调用门的目标为一个32位段，因此会将CPU执行模式改为32位。只有在调度了中断或系统调用后，代码的执行才会退出32位模式。有关调用门的详细信息请参阅Intel与AMD的软件开发手册。</p>
<table> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　当首次切换至32位模式时，模拟器会使用IRET操作码而不进行远调用（far call）。这是因为所有32位寄存器，包括易失性寄存器和EFLAGS都需要初始化。</p> </td> 
  </tr> 
 </tbody> 
</table>
<h4 class="bt4 sigil_not_in_toc">系统调用</h4>
<p class="zw">对于32位应用程序，WoW64层的行为与NT内核本身类似：特殊的32位版Ntdll.dll、User32.dll以及Gdi32.dll均位于\Windows\Syswow64文件夹中（这里还有其他负责进程间通信的DLL，例如Rpcrt4.dll）。当一个32位应用程序需要操作系统的协助时，会直接调用这些位于特殊的32位版操作系统库中的函数。与相应的64位版等价物类似，操作系统例程可以直接在用户模式下执行自己的任务，或者也可以请求NT内核的协助。在后一种情况下，需要通过存根（stub）函数（例如常规64位Ntdll中实现的函数）调用系统调用。存根会将系统调用索引放入一个寄存器中，但存根并不发出原生的32位系统调用指令，而是会（通过WoW64核心所编译的Wow64Transition变量）调用WoW64系统调用调度程序。</p>
<p class="zw">WoW64系统调用调度程序是在与特定平台相关的模拟器（wow64cpu.dll）中实现的。它会发出另一个远跳以便转换至原生64位执行模式，随后从模拟中退出。二进制转换器会将栈切换至64位模式并保存CPU原本的上下文。随后会捕获与系统调用相关的参数并对其进行转换。这种转换过程也叫“形式转换”（thunking），借此通过32位ABI执行的机器代码就可以与64位代码实现互操作。调用过程的相关约定（由ABI描述）定义了数据结构、指针和值在每个函数参数中传递的方法以及通过机器代码访问的方法。</p>
<p class="zw">模拟器中的形式转换主要通过两种策略执行。对于无须与客户端所提供的复杂数据结构进行交互操作（但需要处理简单的输入/输出值）的API，将由Turbo形式转换（模拟器中实现的一种小型转换例程）负责转换并直接调用原生64位API。其他复杂的API需要Wow64SystemServiceEx例程的协助，由该例程从系统调用索引中提取正确的WoW64系统调用编号，并调用正确的WoW64系统调用函数。WoW64系统调用是在WoW64核心库和Wow64win.dll中实现的，与原生系统调用同名，但名称包含“wh-”前缀（例如NtCreateFile这个WoW64 API可通过whNtCreateFile调用）。</p>
<p class="zw">正确完成转换后，模拟器会发出相应的原生64位系统调用。当原生系统调用返回后，WoW64会在必要时对任何输出参数进行转换或形式转换，将其从64位格式转换为32位格式，并重新启动模拟过程。</p>
<h4 class="bt4 sigil_not_in_toc">异常调度</h4>
<p class="zw">与WoW64系统调用类似，异常调度也会迫使CPU退出模拟。当发生异常时，NT内核会确定该异常是否由执行用户模式代码的线程所产生。如果是，NT内核会在活跃栈上构建一个扩展的异常帧，并通过返回到64位Ntdll中的用户模式KiUserExceptionDispatcher函数来调度该异常。</p>
<p class="zw">请注意，异常产生时，64位异常帧（其中包含捕获的CPU上下文）会被分配到当时处于活动状态的32位栈中。因此需要在调度到CPU模拟器之前对其进行转换。这正是Wow64PrepareForException函数（由WoW64核心库导出）所起的作用：在原生64位栈上分配空间，并将原生异常帧从32位栈复制到64位栈中。随后它会切换至64位栈，并将原生异常和上下文记录转换为相应的32位形式，将结果存储到32位栈中（取代64位异常帧）。至此，WoW64核心即可从32位版的KiUserExceptionDispatcher调度程序函数重启模拟，通过与原生32位Ntdll相同的方式调度异常。</p>
<p class="zw">32位用户模式APC交付也遵循了类似的实现方式。常规的用户模式APC可通过原生Ntdll的KiUserApcDispatcher进行交付。当64位内核即将向WoW64进程调度用户模式APC时，它会将32位APC地址映射至64位地址空间中更高的范围。随后64位Ntdll将调用WoW64核心库所导出的Wow64ApcRoutine例程，借此捕获用户模式的原生APC和上下文记录，并将其重新映射回32位栈。随后它会准备一个32位用户模式APC和上下文记录，并通过32位版的KiUserApcDispatcher函数重启CPU模拟，进而使用与原生32位Ntdll相同的方式调度APC。</p>

<p class="epubit-contents-id" style="display: none">{"index":3,"parentId":"14224151-eb07-4e67-90f1-8b8528879ccb","id":"dadcba35-fc57-4481-85f6-f564e7a39f04"}</p>