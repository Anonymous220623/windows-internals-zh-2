<h3 class="bt3" id="sigil_toc_id_27">8.5.6　内存模型</h3>
<p class="zw">在“硬件侧信道漏洞”一节，我们曾提到缓存一致性协议（cache coherency protocol）的概念，这种协议保证了在被多个处理器访问时，可从一个CPU的核心缓存中观察到相同的数据（MESI就是一种知名的缓存一致性协议）。与缓存一致性协议类似，现代CPU还需要提供内存一致性（或排序）模型，以解决多处理器环境中的另一个问题：内存重排序（memory reordering）。一些架构（例如ARM64）确实可以自由地对内存访问进行重排序，这是为了更高效地使用内存子系统并实现内存访问指令的并行运行（可在访问慢速内存总线时实现更好的性能）。此类架构遵循了一种弱内存模型，这与遵循强内存模型的AMD64架构截然不同，AMD64架构中的内存访问指令一般会按照程序顺序来执行。弱模型可以让处理器以更高效的方式更快速地访问内存，但这会为多处理器软件的开发带来很多与同步有关的问题。作为对比，强模型更直观也更稳定，但其不足在于速度太慢。</p>
<p class="zw">可以进行内存重排序（即遵循弱模型）的CPU提供了一些可充当内存屏障的机器指令。屏障可以防止处理器对屏障前后的内存访问进行重排序，有助于解决多处理器系统的同步问题。内存屏障速度很慢，因此只在Windows中的关键多处理器代码严格需要这种功能时才会使用，尤其是在基元（如自旋锁、互斥、推锁）的同步过程中。</p>
<p class="zw">下一节将会介绍，在多处理器环境中转换x86代码时，ARM64的实时编译总是会用到内存屏障。但实际上，该过程并不能推断将要执行的代码是否可以由多个线程同时并行执行（因此可能会产生同步问题。x86遵循强内存模型，因此不会遇到重排序问题。上一节也从通用的角度介绍了乱序执行问题）。</p>
<table> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　除了CPU，内存重排序也会对编译器产生影响。在编译过程中，出于效率和速度方面的原因，编译器可以重排序（并可能移除）源代码中的内存引用。这种重排序也叫编译器重排序，而上文所描述的主要是处理器重排序。</p> </td> 
  </tr> 
 </tbody> 
</table>

<p class="epubit-contents-id" style="display: none">{"index":5,"parentId":"14224151-eb07-4e67-90f1-8b8528879ccb","id":"fc05ba84-0e1d-407b-9633-74ba260fb4c0"}</p>