<h3 class="bt3" id="sigil_toc_id_31">8.6.1　执行体对象</h3>
<p class="zw">每个Windows环境子系统都会向其应用程序投射不同的操作系统映像。执行体对象和对象服务是环境子系统用来构建自己版本的对象与其他资源的基元。</p>
<p class="zw">执行体对象通常由环境子系统代表用户应用程序创建，或由操作系统的各种组件在其正常操作的过程中创建。例如，若要创建一个文件，Windows应用程序会调用Windows的CreateFileW函数，该函数是在Windows子系统DLL Kernelbase.dll中实现的。经过一些验证和初始化后，CreateFileW函数将调用原生Windows服务NtCreateFile来创建一个执行体文件对象。</p>
<p class="zw">环境子系统为其应用程序提供的对象集可能大于或小于执行体提供的对象集。Windows子系统会使用执行体对象导出自己的对象集，其中很多对象是与执行体对象直接对应的。例如，Windows互斥体（mutex）和信号量（semaphores）就直接基于执行体对象（而执行体对象又基于对应的内核对象）。此外，Windows子系统还提供命名管道和邮件槽（mailslot），这些资源基于执行体文件对象。当使用Windows Subsystem for Linux（WSL）时，其子系统驱动程序（LxCore.sys）会使用执行体对象和服务作为向其应用程序呈现Linux风格进程、管道和其他资源的基础。</p>
<p class="zw">表8-15列出了执行体提供的主要对象，并简单介绍了它们所呈现的内容。本书在描述执行体组件的相关章节里进一步介绍了有关这些执行体对象的详细信息（对于直接导出到Windows的执行体对象，也可参阅Windows API参考文档）。要查看完整的对象类型列表，请在提升权限的命令提示符窗口中运行Winobj并打开ObjectTypes目录。</p>
<table> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　执行体总共实现了约69个对象类型（取决于Windows版本）。其中一些对象仅限于定义了它们的执行体组件使用，并不能被Windows API直接访问，例如Driver、Callback以及Adapter。</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="表题">表8-15　暴露给Windows API的执行体对象</p>
<table> 
 <tbody> 
  <tr> 
   <th> <p class="bt">对象类型</p> </th> 
   <th> <p class="bt">可呈现</p> </th> 
  </tr> 
  <tr> 
   <td> <p class="bg">Process</p> </td> 
   <td> <p class="bg">执行一组线程对象所需的虚拟地址空间和控制信息</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Thread</p> </td> 
   <td> <p class="bg">进程中的可执行实体</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Job</p> </td> 
   <td> <p class="bg">通过作业以单一实体形式管理的进程集合</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Section</p> </td> 
   <td> <p class="bg">共享的内存区域（即Windows中的文件映射对象）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">File</p> </td> 
   <td> <p class="bg">打开的文件或I/O设备实例，例如管道（pipe）或套接字（socket）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Token</p> </td> 
   <td> <p class="bg">进程或线程的安全配置文件（安全ID、用户权利等）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Event<br> KeyedEvent</p> </td> 
   <td> <p class="bg">具有可用于同步或通知的持久状态（有信号或无信号）的对象。后者则可使用全局键来引用底层同步基元，避免消耗内存，通过避免分配操作使其可用于低内存条件下</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Semaphore</p> </td> 
   <td> <p class="bg">一种计数器，可允许最大数量的线程访问被信号量保护的资源，进而提供一种资源门（resource gate）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Mutex</p> </td> 
   <td> <p class="bg">一种用于对资源进行序列化访问的同步机制</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Timer、IRTimer</p> </td> 
   <td> <p class="bg">一种在固定时间流逝后对线程发出通知的机制。后者这种对象也叫Idle Resilient Timers，会被UWP应用程序和某些服务用于创建不受连接待机（connected standby）功能影响的计时器</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">IoCompletion<br> IoCompletionReserve</p> </td> 
   <td> <p class="bg">一种适用于线程的方法，可对I/O操作的完成提供入列和出列通知（在Windows API中被称为I/O完成端口）。后者可用于预先分配端口，以应对内存不足的情况</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Key</p> </td> 
   <td> <p class="bg">一种注册表中数据的引用机制。尽管“键”出现在对象管理器命名空间中，但它们实际是由配置管理器管理的，类似于文件对象是由文件系统驱动程序管理的这种情况。一个键对象可关联零个或多个键值，键值中包含有关该键的数据</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Directory</p> </td> 
   <td> <p class="bg">对象管理器命名空间中的一种虚拟目录，负责包含其他对象或对象目录</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">SymbolicLink</p> </td> 
   <td> <p class="bg">命名空间中对象和其他对象之间的一种虚拟名称重定向链接，例如C:，实际上就是指向\Device\HarddiskVolumeN的符号链接</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">TpWorkerFactory</p> </td> 
   <td> <p class="bg">分配用于执行一组特定任务的线程集合。内核可以管理要通过队列执行的工作项数量，有多少线程负责执行这些工作，并能动态地创建和终止工作线程，同时会遵循调用方设置的某些限制。Windows会通过线程池暴露工作工厂（worker factory）对象</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">TmRm (Resource Manager)<br> TmTx (Transaction)<br> TmTm (Transaction Manager)<br> TmEn (Enlistment)</p> </td> 
   <td> <p class="bg">在资源管理器或事务管理器运行过程中，被内核事务管理器（Kernel Transaction Manager，KTM）用于各种事务或登记的对象。对象可通过CreateTransactionManager、CreateResourceManager、CreateTransaction和CreateEnlistment这些API创建</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">RegistryTransaction</p> </td> 
   <td> <p class="bg">供低层轻量级注册表事务API使用的对象，它们不使用完整的KTM能力，但依然允许对注册表键进行简单的事务型访问</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">WindowStation</p> </td> 
   <td> <p class="bg">包含剪贴板、一系列全局原子和一组Desktop对象的对象</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Desktop</p> </td> 
   <td> <p class="bg">包含在窗口站（window station）中的对象。Desktop对象往往包含逻辑显示表面，并包含窗口、菜单和挂钩</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">PowerRequest</p> </td> 
   <td> <p class="bg">与线程相关联的对象，该线程将执行多种工作，并调用SetThreadExecutionState请求特定的电源变更，如阻止睡眠（例如用户可能正在播放电影）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">EtwConsumer</p> </td> 
   <td> <p class="bg">代表已使用StartTrace API注册（进而可调用ProcessTrace来接收来自对象队列的事件）的已连接ETW实时消耗者</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">CoverageSampler</p> </td> 
   <td> <p class="bg">在特定ETW会话上启用代码覆盖跟踪时，由ETW创建</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">EtwRegistration</p> </td> 
   <td> <p class="bg">代表与已使用EventRegister API注册的用户模式（或内核模式）ETW提供程序有关的注册对象</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">ActivationObject</p> </td> 
   <td> <p class="bg">一种对象，可用于跟踪由Win32k.sys中原始输入管理器（Raw Input Manager）所管理的窗口句柄的前台状态</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">ActivityReference</p> </td> 
   <td> <p class="bg">跟踪由进程生命周期管理器（PLM）管理的进程，并在连接待机期间保持唤醒状态</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">ALPC Port</p> </td> 
   <td> <p class="bg">主要被远程过程调用（Remote Procedure Call，RPC）库用于在使用ncalrpc传输时提供本地RPC（LRPC）能力。也可被内部服务用作进程和内核间的常规IPC机制</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Composition、DxgkCompositionObject<br> DxgkCurrentDxgProcessObject<br> DxgkDisplayManagerObject<br> DxgkSharedBundleObject<br> DxgkSharedKeyedMutexObject<br> DxgkShartedProtectedSessionObject<br> DgxkSharedResource<br> DxgkSwapChainObject<br> DxgkSharedSyncObject</p> </td> 
   <td> <p class="bg">用户空间中的DirectX 12 API将其用作高级着色器和GPGPU能力的一部分，这些执行体对象包装了底层的DirectX句柄</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">CoreMessaging</p> </td> 
   <td> <p class="bg">提供一个CoreMessaging IPC对象，进而使用自己的定制化命名空间和能力去包装ALPC端口，主要被现代的输入管理器（input manager）所使用，但亦可暴露给WCOS系统中的任何MinUser组件</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">EnergyTracker</p> </td> 
   <td> <p class="bg">可暴露给UMPO（User Mode Power）服务，以便跨越不同硬件跟踪并汇总能源使用情况，并将能耗情况关联给每个应用程序</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">FilterCommunicationPort<br> FilterConnectionPort</p> </td> 
   <td> <p class="bg">为过滤器管理器（Filter Manager）API暴露出的基于IRP的接口提供支撑的底层对象，借此可在用户模式服务和应用程序之间实现通信，并实现由过滤器管理器管理的微型过滤器（Mini-filter），例如在使用FilterSendMessage时</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Partition</p> </td> 
   <td> <p class="bg">使内存管理器、缓存管理器和执行体能够从管理的角度，相较于系统内存的其他部分而言，将物理内存区域视作是唯一的，进而提供自己的管理线程、能力、分页、缓存等实例。主要被游戏模式（Game Mode）<sup>[4]</sup>和Hyper-V等功能使用，借此更好地将系统与底层工作负载区分开来</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Profile</p> </td> 
   <td> <p class="bg">由性能分析（Profiling）API使用，可用于捕获基于时间的执行桶，进而跟踪从指令指针（Instruction Pointer，IP）直到PMU计数器中所存储的底层处理器缓存信息等一切内容</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">RawInputManager</p> </td> 
   <td> <p class="bg">绑定到HID设备（如鼠标、键盘或平板电脑）的对象，可借此读取和管理HID设备正在接收的窗口管理器输入内容。主要由现代UI管理代码所使用（例如处理涉及Core Messaging的任务）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Session</p> </td> 
   <td> <p class="bg">这种对象代表了内存管理器对交互式用户会话的视图，并能跟踪I/O管理器有关第三方驱动程序连接/断开/注销/登录操作的通知</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Terminal</p> </td> 
   <td> <p class="bg">仅在启用终端热管理器（terminal thermal manager）的情况下可以启用，代表设备上可由用户模式电源管理（UMPO）机制管理的用户终端</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">TerminalEventQueue</p> </td> 
   <td> <p class="bg">仅在TTM系统上启用，与上述对象类型类似，该类型对象代表了被传递给设备终端的事件，UMPO会借此与内核的电源管理器进行通信</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">UserApcReserve</p> </td> 
   <td> <p class="bg">与IoCompletionReserve类似，可预先创建数据结构，以便在内存不足的时候重复使用，该对象可将APC内核对象（KAPC）封装为执行体对象</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">WaitCompletionPacket</p> </td> 
   <td> <p class="bg">可由用户模式线程池API中引入的全新异步等待功能所使用，该对象可将已完成的调度程序的等待包装为可传递到I/O完成端口的I/O数据包</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">WmiGuid</p> </td> 
   <td> <p class="bg">被Windows Management Instrumentation（WMI）API在用户模式或内核模式下，按照GUID在打开WMI数据块时使用（例如使用IoWMIOpenBlock打开时）</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="footnote">[4]游戏模式（Game Mode）是Windows 10中曾经提供过的一种功能，将系统置于该模式下可暂时禁用一些后台系统服务和任务，进而改善计算机游戏游玩体验。——译者注</p>
<table> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　因为Windows NT最初需要支持OS/2操作系统，因此其互斥（Mutex）必须与S/2的互斥对象（Mutual-exclusion object）设计保持兼容，这种设计要求线程能够放弃对象，并使其无法访问。由于在此类对象看来这种行为是不寻常的，因此又创建了另一种内核对象：Mutant（突变体）。最终，Windows NT放弃了对OS/2的支持，Windows 32子系统开始以Mutex的名称使用此类对象（但内部依然将其称为Mutant）。</p> </td> 
  </tr> 
 </tbody> 
</table>

<p class="epubit-contents-id" style="display: none">{"index":0,"parentId":"6399eadf-b329-4125-b132-dff6515a2e34","id":"fde5d927-a395-468e-a2bf-8c4dd7576cf7"}</p>