<h3 class="bt3" id="sigil_toc_id_32">8.6.2　对象结构</h3>
<p class="zw">如图8-31所示，每个对象都有一个对象头（object header）、一个对象主体（object body），并且可能还有一个对象尾（object footer）。对象管理器控制着对象头和对象尾，而拥有它们的执行体组件控制着自己所创建对象类型的对象主体。每个对象头还包含一个特殊对象的索引，该对象名为类型（Type）对象，其中包含与每个对象实例有关的共同信息。此外，最多还存在8个可选的子头（Subheader）：名称信息对象头、配额信息对象头、进程信息对象头、句柄信息对象头、审核信息对象头、填充信息对象头、扩展信息对象头，以及创建者信息对象头。如果存在扩展信息对象头，这意味着该对象也有对象尾，并且对象头会包含指向对象尾的指针。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3164.png" style="width: 100%" />
<p class="图题">图8-31　对象的结构</p>
<h4 class="bt4 sigil_not_in_toc">对象头和对象主体</h4>
<p class="zw">对象管理器使用存储在对象头中的数据来管理对象，这一过程并不考虑对象本身的类型。表8-16简要介绍了对象头字段，而表8-17介绍了可选对象子头中包含的字段。</p>
<p class="zw">除了对象头中包含可适用于任何类型对象的信息外，子头中还包含与特定对象有关的可选信息。请注意，这些结构位于从对象头开始处不同的偏移位置上，具体的值则取决于主对象头所关联的子头数量（但上文提到的创建者信息除外）。对于所存在的每个子头，InfoMask字段都会进行必要的更新以反映其存在。当对象管理器检查特定子头时，它会检查InfoMask字段是否设置了对应的位，随后会使用剩余的位在全局ObpInfoMaskToOffset表中选择正确的偏移量，进而找到从对象头开始处计算的子头偏移量。</p>
<p class="表题">表8-16　对象头字段</p>
<table> 
 <tbody> 
  <tr> 
   <th> <p class="bt">字段</p> </th> 
   <th> <p class="bt">用途</p> </th> 
  </tr> 
  <tr> 
   <td> <p class="bg">Handle count</p> </td> 
   <td> <p class="bg">维护对象当前打开的句柄数量计数</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Pointer count</p> </td> 
   <td> <p class="bg">维护对象的引用计数（包括每个句柄一个引用），以及每个句柄的使用引用计数（32位系统最多32个，64位系统最多32768个）。内核模式组件可通过指针引用对象，无须句柄</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Security descriptor</p> </td> 
   <td> <p class="bg">决定谁可以使用对象以及可用来做什么。请注意，根据定义，未具名对象无法设置安全性</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Object type index</p> </td> 
   <td> <p class="bg">包含了Type对象的索引，而Type对象包含了该类型对象共有的属性。所有类型的对象均存储在ObTypeIndexTable表中。为了提供一些安全缓解能力，该索引会使用一个动态生成并且存储在ObHeaderCookie中的Sentinel值，与对象头本身地址的最后8位一起进行异或运算（XOR）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Info mask</p> </td> 
   <td> <p class="bg">位掩码（Bitmask）描述了表8-17中列出的可选子头结构中哪些是实际存在的，但创建者信息子头除外，如果该子头存在，那么将始终位于对象前端。位掩码会使用ObpInfoMaskToOffset表转换为一个负的偏移量，使得每个子头都与一个相对于其他已存在子头相关的1字节索引相关联</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Flags</p> </td> 
   <td> <p class="bg">对象的特征和对象属性。所有对象标记的完整列表请参阅表8-20</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Lock</p> </td> 
   <td> <p class="bg">在修改对象头或其任意子头所包含的字段时使用的锁，可应用于每个对象</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Trace Flags</p> </td> 
   <td> <p class="bg">与跟踪和调试工具有关的其他标记，详见表8-20</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Object Create Info</p> </td> 
   <td> <p class="bg">在对象被完全插入命名空间之前所存储的、有关对象创建过程的临时信息。创建完毕后，该字段会被转换为指向配额块（Quota Block）的指针</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">当子头以任何一种组合方式出现时都会存在这些偏移量，但由于只要存在子头，就会始终以固定且恒定的顺序进行分配，因此特定对象头仅具备与先于对象头的子头数量最大值相等的可能位置数。例如，由于名称信息子头始终是最先分配的，因此只有一个可能的偏移量，而句柄信息子头（第三个被分配）就会有三个可能的位置，因为它可能在配额子头之后分配了，也可能未分配，该子头也可能是在名称信息之后分配的。表8-17列出了所有的可选对象子头及其位。至于创建者信息子头，会通过对象头标记中的一个值来决定该子头是否存在（有关这些标记的详细信息请参阅表8-20）。</p>
<p class="表题">表8-17　可选对象子头及其位</p>
<table> 
 <tbody> 
  <tr> 
   <th> <p class="bt">名称</p> </th> 
   <th> <p class="bt">用途</p> </th> 
   <th> <p class="bt">位</p> </th> 
   <th> <p class="bt">偏移量</p> </th> 
  </tr> 
  <tr> 
   <td> <p class="bg">Creator information</p> </td> 
   <td> <p class="bg">将对象链接至同一类型所有对象的列表中，并以可回溯形式记录对象的创建过程</p> </td> 
   <td> <p class="bg">0 (0x1)</p> </td> 
   <td> <p class="bg">ObpInfoMaskToOffset[0])</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Name information</p> </td> 
   <td> <p class="bg">包含对象名称，负责让对象能对其他进程可见以便进行共享，并提供指向对象目录的指针，该目录为存储的对象名称提供了层次结构</p> </td> 
   <td> <p class="bg">1 (0x2)</p> </td> 
   <td> <p class="bg">ObpInfoMaskToOffset[InfoMask &amp; 0x3]</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Handle information</p> </td> 
   <td> <p class="bg">通过项数据库（或单独的一个项）包含了针对该对象已打开句柄的所有进程信息（以及每进程句柄数）</p> </td> 
   <td> <p class="bg">2 (0x4)</p> </td> 
   <td> <p class="bg">ObpInfoMaskToOffset[InfoMask &amp; 0x7]</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Quota information</p> </td> 
   <td> <p class="bg">当进程打开对象的句柄时，列出对该进程征收的资源费用</p> </td> 
   <td> <p class="bg">3 (0x8)</p> </td> 
   <td> <p class="bg">ObpInfoMaskToOffset[InfoMask &amp; 0xF]</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Process information</p> </td> 
   <td> <p class="bg">对于独占对象，包含了指向所拥有进程的指针。下文将详细介绍独占对象</p> </td> 
   <td> <p class="bg">4 (0x10)</p> </td> 
   <td> <p class="bg">ObpInfoMaskToOffset[InfoMask &amp; 0x1F]</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Audit information</p> </td> 
   <td> <p class="bg">包含指向最初创建对象时使用的原始安全描述符的指针。在启用审核时，这会被File对象使用，以保证一致性</p> </td> 
   <td> <p class="bg">5 (0x20)</p> </td> 
   <td> <p class="bg">ObpInfoMaskToOffset[InfoMask &amp; 0x3F]</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Extended information</p> </td> 
   <td> <p class="bg">为需要对象尾的对象（例如File和Silo Context对象）存储了指向对象尾的指针</p> </td> 
   <td> <p class="bg">6 (0x40)</p> </td> 
   <td> <p class="bg">ObpInfoMaskToOffset[InfoMask &amp; 0x7F]</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Padding information</p> </td> 
   <td> <p class="bg">未存储任何内容（空的垃圾空间），如果有必要，可在缓存边界上实现对象主体的对齐</p> </td> 
   <td> <p class="bg">7 (0x80)</p> </td> 
   <td> <p class="bg">ObpInfoMaskToOffset[InfoMask &amp; 0xFF]</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">上述每个子头都是可选的，并且只在系统引导或对象创建的特定条件下出现。表8-18列出了所有这些条件。</p>
<p class="表题">表8-18　需要对象子头出现的不同条件</p>
<table> 
 <tbody> 
  <tr> 
   <th> <p class="bt">名称</p> </th> 
   <th> <p class="bt">条件</p> </th> 
  </tr> 
  <tr> 
   <td> <p class="bg">Creator information</p> </td> 
   <td> <p class="bg">对象类型必须启用Maintain type list标记。如果驱动程序验证程序已启用，那么驱动程序对象会设置该标记。启用Maintain object type list这个全局标记（详见上文讨论）会应用给所有对象。Type对象会始终设置该标记</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Name information</p> </td> 
   <td> <p class="bg">对象创建时必须已有名称</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Handle information</p> </td> 
   <td> <p class="bg">对象类型必须启用Maintain handle count标记。File对象、ALPC对象、WindowStation对象以及Desktop对象已经在各自的对象类型结构中设置了该标记</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Quota information</p> </td> 
   <td> <p class="bg">对象必须不是由初始（或闲置）系统进程创建的</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Process information</p> </td> 
   <td> <p class="bg">对象创建时必须设置了Exclusive object标记（有关对象标记的详情请参阅表8-20）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Audit Information</p> </td> 
   <td> <p class="bg">对象必须是File对象，并且必须为文件对象事件启用审核</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Extended information</p> </td> 
   <td> <p class="bg">对象必须有对象尾，这可能是为了处理撤销信息（被File和Key对象使用），或者为了扩展用户上下文信息（被Silo Context对象使用）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Padding Information</p> </td> 
   <td> <p class="bg">对象类型必须启用Cache aligned标记。进程和线程对象已设置了该标记</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">如上文所述，如果存在扩展信息对象头，那么在对象主体的尾部还会分配对象尾。与对象子头不同，对象尾是一种静态大小的结构，会为所有可能的对象尾类型进行预分配。此类对象尾有两种，如表8-19所示。</p>
<p class="表题">表8-19　对象尾的存在条件</p>
<table> 
 <tbody> 
  <tr> 
   <th> <p class="bt">名称</p> </th> 
   <th> <p class="bt">条件</p> </th> 
  </tr> 
  <tr> 
   <td> <p class="bg">Handle Revocation Information</p> </td> 
   <td> <p class="bg">必须使用ObCreateObjectEx创建对象，并在OB_EXTENDED_CREATION_INFO结构中传入AllowHandleRevocation。File和Key对象都是这样创建的</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Extended User Information</p> </td> 
   <td> <p class="bg">必须使用ObCreateObjectEx创建对象，并在OB_EXTENDED_CREATION_INFO结构中传入AllowExtendedUserInfo。Silo Context对象是这样创建的</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">最后，一些属性和标记决定了对象在创建时或某些操作过程中所体现出的行为。每当创建任何新对象时，对象管理器就会以一种名为对象属性（object attribute）的结构收到这些标记。该结构定义了对象名称、对象应插入的根对象目录、对象的安全描述符，以及对象属性标记（object attribute flag）。表8-20列出了可关联到对象的不同标记。</p>
<table> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　当通过Windows子系统中的API（例如CreateEvent或CreateFile）创建对象时，调用方无须指定任何对象属性，子系统DLL会在后台处理这些工作。因此，通过Win32创建的所有具名对象，无论是全局实例还是每个会话实例，都会进入BaseNamedObjects目录，因为这是Kernelbase.dll在对象属性结构中指定的根对象目录。有关BaseNamedObjects的详细信息以及它与每个会话命名空间之间的关系，请参阅下文的介绍。</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="表题">表8-20　对象标记</p>
<table> 
 <tbody> 
  <tr> 
   <th> <p class="bt">属性标记</p> </th> 
   <th> <p class="bt">对象头标记位</p> </th> 
   <th> <p class="bt">用途</p> </th> 
  </tr> 
  <tr> 
   <td> <p class="bg">OBJ_INHERIT</p> </td> 
   <td> <p class="bg">保存在句柄表项中</p> </td> 
   <td> <p class="bg">决定了该对象的句柄是否被子进程继承，以及进程是否可以使用DuplicateHandle来创建副本</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">OBJ_PERMANENT</p> </td> 
   <td> <p class="bg">PermanentObject</p> </td> 
   <td> <p class="bg">定义了与下文将介绍的引用计数有关的对象保留行为</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">OBJ_EXCLUSIVE</p> </td> 
   <td> <p class="bg">ExclusiveObject</p> </td> 
   <td> <p class="bg">指定了该对象只能被创建它的进程所使用</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">OBJ_CASE_INSENSITIVE</p> </td> 
   <td> <p class="bg">不存储，运行时使用</p> </td> 
   <td> <p class="bg">指定了在名称空间中查找该对象需要区分大小写。该设置可被对象类型的Case insensitive标记覆盖</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">OBJ_OPENIF</p> </td> 
   <td> <p class="bg">不存储，运行时使用</p> </td> 
   <td> <p class="bg">指定了如果对象已存在，针对该对象名称的创建操作应产生打开操作，而不应直接失败</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">OBJ_OPENLINK</p> </td> 
   <td> <p class="bg">不存储，运行时使用</p> </td> 
   <td> <p class="bg">指定了对象管理器应打开符号链接的句柄，而非目标的句柄</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">OBJ_KERNEL_HANDLE</p> </td> 
   <td> <p class="bg">KernelObject</p> </td> 
   <td> <p class="bg">指定了该对象的句柄应当是内核句柄（详见下文介绍）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">OBJ_FORCE_ACCESS<br> _CHECK</p> </td> 
   <td> <p class="bg">不存储，运行时使用</p> </td> 
   <td> <p class="bg">指定了即使从内核模式打开了该对象，也要执行完整的访问检查</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">OBJ_KERNEL_EXCLUSIVE</p> </td> 
   <td> <p class="bg">KernelOnlyAccess</p> </td> 
   <td> <p class="bg">禁止任何用户模式进程打开对象句柄，可用于保护\Device\ PhysicalMemory和\Win32kSessionGlobals节对象</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">OBJ_IGNORE_<br> IMPERSONATED<br> _DEVICEMAP</p> </td> 
   <td> <p class="bg">不存储，运行时使用</p> </td> 
   <td> <p class="bg">代表在模拟令牌时不应使用源用户的DOS设备映射，而应维护当前模拟进程的DOS设备映射来进行对象查找。这是针对某些基于文件的重定向攻击所提供的安全缓解措施</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">OBJ_DONT_REPARSE</p> </td> 
   <td> <p class="bg">不存储，运行时使用</p> </td> 
   <td> <p class="bg">禁用任何类型的重分析操作（符号链接、NTFS重分析点、注册表重定向），并在发生上述任何一种情况时返回STATUS_REPARSE_POINT_ ENCOUNTERED。这是针对某些路径重定向攻击所提供的安全缓解措施</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">N/A</p> </td> 
   <td> <p class="bg">DefaultSecurityQuota</p> </td> 
   <td> <p class="bg">指定该对象的安全描述符使用了默认的2&nbsp;KB配额</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">N/A</p> </td> 
   <td> <p class="bg">SingleHandleEntry</p> </td> 
   <td> <p class="bg">指定了句柄信息子头仅包含一个项，而非一个数据库</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">N/A</p> </td> 
   <td> <p class="bg">NewObject</p> </td> 
   <td> <p class="bg">指定了对象已创建但尚未插入对象命名空间</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">N/A</p> </td> 
   <td> <p class="bg">DeletedInline</p> </td> 
   <td> <p class="bg">指定了对象并未通过延迟删除工作线程删除，而是通过调用ObDereferenceObject(Ex)以内联方式删除的</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">除了对象头，每个对象还包含一个对象主体，每一类对象主体的格式与内容均是唯一的，相同类型的所有对象共享相同的对象主体格式。通过创建对象类型并为其提供服务，执行体组件可以控制该类型所有对象主体中数据的相关操作。因为对象头的大小是静态且已知的，对象管理器可以轻松查找某个对象的对象头，为此只需要从对象指针的大小中减去对象头的大小即可。正如上文所述，为了访问子头，对象管理器还会从对象头指针中减去另一个已知的值。对于对象尾，可以使用扩展信息子头来查找指向对象尾的指针。</p>
<p class="zw">由于对象头、对象尾以及子头的结构均已实现了标准化，对象管理器可以提供一小部分通用服务，所以可对存储在任何对象头中的属性进行操作，并将其用于任何类型的对象（不过一些通用服务对某些对象来说是无意义的）。Windows子系统会将某些此类通用服务提供给Windows应用程序使用，这些服务的相关信息请参阅表8-21。</p>
<p class="表题">表8-21　通用对象服务</p>
<table> 
 <tbody> 
  <tr> 
   <th> <p class="bt">服务</p> </th> 
   <th> <p class="bt">用途</p> </th> 
  </tr> 
  <tr> 
   <td> <p class="bg">Close</p> </td> 
   <td> <p class="bg">关闭对象句柄，如果允许的话（详见下文）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Duplicate</p> </td> 
   <td> <p class="bg">通过复制句柄并将其提供给另一个进程来共享对象，如果允许的话（详见下文）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Inheritance</p> </td> 
   <td> <p class="bg">如果句柄被标记为可继承，并且在启用句柄继承的情况下创建了子进程，则该行为类似于从这些句柄进行复制</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Make permanent/temporary</p> </td> 
   <td> <p class="bg">更改对象的保留（详见下文）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Query object</p> </td> 
   <td> <p class="bg">获取与对象标准属性有关的信息，并在对象管理器层面上获得其他可管理的细节信息</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Query security</p> </td> 
   <td> <p class="bg">获取对象的安全描述符</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Set security</p> </td> 
   <td> <p class="bg">更改对象的保护措施</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Wait for a single object</p> </td> 
   <td> <p class="bg">将等待块（wait block）与一个对象关联，随后该对象即可同步线程的执行，或者通过等待完成数据包与I/O完成端口建立关联</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Signal an object and wait for<br> another</p> </td> 
   <td> <p class="bg">向对象发出信号，在支撑对象的调度对象上执行唤醒语义，随后照此方法等待一个对象。从调度程序的角度来看，唤醒/等待操作是以原子性的方式实现的</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Wait for multiple objects</p> </td> 
   <td> <p class="bg">将等待块与一个或多个（最多可达64个）对象关联，随后这些对象即可同步线程的执行，或通过等待完成数据包与I/O完成端口建立关联</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">虽然大部分对象类型并不会实现所有服务，但它们至少会提供创建、打开、基本管理等服务。例如，I/O系统会为自己的文件对象提供“创建文件”服务，进程管理器会为自己的进程对象提供“创建进程”服务。</p>
<p class="zw">某些对象可能不会直接暴露此类服务，并且它们可能是由用户的某些操作而在内部创建的。例如，在用户模式下打开WMI数据块时会创建一个WmiGuid对象，但不会向应用程序暴露任何能用于关闭或查询服务的句柄。这里需要注意的重点是：并不存在某种单一的通用创建例程。</p>
<p class="zw">这样的例程可能会相当复杂。举例来说，初始化一个文件对象所需的一系列参数，肯定会不同于初始化一个进程对象所需的参数。此外，当线程调用一个对象服务来确定句柄所引用的对象类型并调用相应版本的服务时，对象管理器都会产生额外的处理开销。</p>
<h4 class="bt4 sigil_not_in_toc">类型对象</h4>
<p class="zw">对象头包含所有对象的共有数据，但对于对象的每个实例可能会采用不同的值。例如，每个对象都有一个唯一的名称，并可能有唯一的安全描述符。然而，对象还可能包含一些对特定类型的所有对象都保持不变的数据。举例来说，在打开某类型对象的句柄后，即可针对该类型对象独有的一系列访问权限进行选择。执行体为线程对象提供了终止和挂起等访问权限，并为文件对象提供了读取、写入、追加和删除等访问权限。下文很快将要介绍的同步，也是一个与特定类型对象有关的属性范例。</p>
<p class="zw">为了节省内存，对象管理器只会在新建某个对象类型时，将这些静态的、与对象类型有关的属性存储一次。对象管理器会使用自己独有的一种类型对象来记录这些数据。如图8-32所示，如果已经设置了对象跟踪调试标记（详见下文“Windows全局标记”一节），则类型对象会与相同类型的所有对象链接在一起（例如图中的进程类型），这样对象管理器就可以在需要时找到并枚举所有对象。该功能用到了上文介绍过的创建者信息子头。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3340.png" style="width: 100%" />
<p class="图题">图8-32　进程对象和进程类型对象</p>
<p class="zwtsh">实验：查看对象头和类型对象</p>
<p class="zwts1">我们可以通过内核调试器查看进程对象类型的数据结构，为此，首先需要使用调试器数据模型命令dx @$cursession.Processes识别出进程对象：</p>
<pre class="代码无行号"><code>lkd&gt; dx -r0 &amp;@$cursession.Processes[4].KernelObject 
&amp;@$cursession.Processes[4].KernelObject :         0xffff898f0327d300 [Type: _EPROCESS *]</code></pre>
<p class="zwts1">随后使用进程对象的地址作为参数执行!object命令：</p>
<pre class="代码无行号"><code>lkd&gt; !object 0xffff898f0327d300 
Object: ffff898f0327d300 Type: (ffff898f032954e0) Process 
    ObjectHeader: ffff898f0327d2d0 (new version) 
    HandleCount: 6 PointerCount: 215645 </code></pre>
<p class="zwts1">请注意，在32位Windows中，对象头始于对象主体开头位置之前的0x18（十进制等于24）字节处，而在64位Windows中，始于对象头本身大小之前的0x30（十进制等于48）字节处。我们可通过下列命令查看对象头：</p>
<pre class="代码无行号"><code>lkd&gt; dx (nt!_OBJECT_HEADER*)0xffff898f0327d2d0 
(nt!_OBJECT_HEADER*)0xffff898f0327d2d0     : 0xffff898f0327d2d0 [Type: _OBJECT_HEADER *]
    [+0x000] PointerCount     : 214943 [Type: __int64] 
    [+0x008] HandleCount      : 6 [Type: __int64] 
    [+0x008] NextToFree       : 0x6 [Type: void *] 
    [+0x010] Lock             [Type: _EX_PUSH_LOCK] 
    [+0x018] TypeIndex        : 0x93 [Type: unsigned char] 
    [+0x019] Traceflags       : 0x0 [Type: unsigned char] 
    [+0x019 ( 0: 0)] DbgRefTrace      : 0x0 [Type: unsigned char] 
    [+0x019 ( 1: 1)] DbgTracePermanent : 0x0 [Type: unsigned char]
    [+0x01a] InfoMask         : 0x80 [Type: unsigned char]
    [+0x01b] flags            : 0x2 [Type: unsigned char]
    [+0x01b ( 0: 0)] NewObject        : 0x0 [Type: unsigned char]
    [+0x01b ( 1: 1)] KernelObject     : 0x1 [Type: unsigned char]
    [+0x01b ( 2: 2)] KernelOnlyAccess : 0x0 [Type: unsigned char]
    [+0x01b ( 3: 3)] ExclusiveObject  : 0x0 [Type: unsigned char]
    [+0x01b ( 4: 4)] PermanentObject  : 0x0 [Type: unsigned char]
    [+0x01b ( 5: 5)] DefaultSecurityQuota : 0x0 [Type: unsigned char]
    [+0x01b ( 6: 6)] SingleHandleEntry : 0x0 [Type: unsigned char]
    [+0x01b ( 7: 7)] DeletedInline    : 0x0 [Type: unsigned char]
    [+0x01c] Reserved         : 0xffff898f [Type: unsigned long]
    [+0x020] ObjectCreateInfo : 0xfffff8047ee6d500 [Type: _OBJECT_CREATE_INFORMATION *]
    [+0x020] QuotaBlockCharged : 0xfffff8047ee6d500 [Type: void *]
    [+0x028] SecurityDescriptor : 0xffffc704ade03b6a [Type: void *]
    [+0x030] Body             [Type: _QUAD]
    ObjectType       : Process
    UnderlyingObject [Type: _EPROCESS]</code></pre>
<p class="zwts1">随后可复制刚才用!object命令显示的指针来查看对象类型的数据结构：</p>
<pre class="代码无行号"><code>lkd&gt; dx (nt!_OBJECT_TYPE*)0xffff898f032954e0 
(nt!_OBJECT_TYPE*)0xffff898f032954e0         : 0xffff898f032954e0 [Type: _OBJECT_TYPE *]
    [+0x000] TypeList         [Type: _LIST_ENTRY]
    [+0x010] Name             : "Process" [Type: _UNICODE_STRING]
    [+0x020] DefaultObject     : 0x0 [Type: void *]
    [+0x028] Index            : 0x7 [Type: unsigned char]
    [+0x02c] TotalNumberOfObjects : 0x2e9 [Type: unsigned long]
    [+0x030] TotalNumberOfHandles : 0x15a1 [Type: unsigned long]
    [+0x034] HighWaterNumberOfObjects : 0x2f9 [Type: unsigned long]
    [+0x038] HighWaterNumberOfHandles : 0x170d [Type: unsigned long]
    [+0x040] TypeInfo         [Type: _OBJECT_TYPE_INITIALIZER]
    [+0x0b8] TypeLock         [Type: _EX_PUSH_LOCK]
    [+0x0c0] Key              : 0x636f7250 [Type: unsigned long]
    [+0x0c8] CallbackList     [Type: _LIST_ENTRY] </code></pre>
<p class="zwts1">输出结果显示的对象类型结构包含对象类型名称、跟踪到的此类型活跃对象的总数，以及跟踪到的此类型句柄和对象峰值数量。CallbackList还会跟踪与此类型对象相关的对象管理器过滤回调。TypeInfo字段则存储了为所有该类型对象保存通用属性、标记和设置的数据结构，以及指向对象类型的自定义方法的指针，下文很快将介绍这些内容：</p>
<pre class="代码无行号"><code>lkd&gt; dx ((nt!_OBJECT_TYPE*)0xffff898f032954e0)-&gt;TypeInfo 
((nt!_OBJECT_TYPE*)0xffff898f032954e0)-&gt;TypeInfo         [Type: _OBJECT_TYPE_INITIALIZER]
    [+0x000] Length           : 0x78 [Type: unsigned short]
    [+0x002] ObjectTypeflags  : 0xca [Type: unsigned short]
    [+0x002 ( 0: 0)] CaseInsensitive  : 0x0 [Type: unsigned char]
    [+0x002 ( 1: 1)] UnnamedObjectsOnly : 0x1 [Type: unsigned char]
    [+0x002 ( 2: 2)] UseDefaultObject : 0x0 [Type: unsigned char]
    [+0x002 ( 3: 3)] SecurityRequired : 0x1 [Type: unsigned char]
    [+0x002 ( 4: 4)] MaintainHandleCount : 0x0 [Type: unsigned char]
    [+0x002 ( 5: 5)] MaintainTypeList : 0x0 [Type: unsigned char] 
    [+0x002 ( 6: 6)] SupportsObjectCallbacks : 0x1 [Type: unsigned char] 
    [+0x002 ( 7: 7)] CacheAligned     : 0x1 [Type: unsigned char] 
    [+0x003 ( 0: 0)] UseExtendedParameters : 0x0 [Type: unsigned char] 
    [+0x003 ( 7: 1)] Reserved         : 0x0 [Type: unsigned char] 
    [+0x004] ObjectTypeCode   : 0x20 [Type: unsigned long] 
    [+0x008] InvalidAttributes : 0xb0 [Type: unsigned long] 
    [+0x00c] GenericMapping   [Type: _GENERIC_MAPPING] 
    [+0x01c] ValidAccessMask  : 0x1fffff [Type: unsigned long] 
    [+0x020] RetainAccess     : 0x101000 [Type: unsigned long] 
    [+0x024] PoolType         : NonPagedPoolNx (512) [Type: _POOL_TYPE] 
    [+0x028] DefaultPagedPoolCharge : 0x1000 [Type: unsigned long] 
    [+0x02c] DefaultNonPagedPoolCharge : 0x8d8 [Type: unsigned long] 
    [+0x030] DumpProcedure    : 0x0 [Type: void (__cdecl*)(void *,_OBJECT_DUMP_CONTROL *)]
    [+0x038] OpenProcedure    : 0xfffff8047f062f40 [Type: long (__cdecl*) 
                  (_OB_OPEN_REASON,char,_EPROCESS *,void *,unsigned long *,unsigned long)]
    [+0x040] CloseProcedure   : 0xfffff8047F087a90 [Type: void (__cdecl*) 
                                   (_EPROCESS *,void *,unsigned __int64,unsigned __int64)]
    [+0x048] DeleteProcedure  : 0xfffff8047f02f030 [Type: void (__cdecl*)(void *)] 
    [+0x050] ParseProcedure   : 0x0 [Type: long (__cdecl*)(void *,void *,_ACCESS_STATE *,
                           char,unsigned long,_UNICODE_STRING *,_UNICODE_STRING *,void *,
                                                 _SECURITY_QUALITY_OF_SERVICE *,void * *)]
    [+0x050] ParseProcedureEx : 0x0 [Type: long (__cdecl*)(void *,void *,_ACCESS_STATE *,
                           char,unsigned long,_UNICODE_STRING *,_UNICODE_STRING *,void *, 
                 _SECURITY_QUALITY_OF_SERVICE *,_OB_EXTENDED_PARSE_PARAMETERS *,void * *)]
    [+0x058] SecurityProcedure : 0xfffff8047eff57b0 [Type: long (__cdecl*) 
                 (void *,_SECURITY_OPERATION_CODE,unsigned long *,void *,unsigned long *, 
                                             void * *,_POOL_TYPE,_GENERIC_MAPPING *,char)]
    [+0x060] QueryNameProcedure : 0x0 [Type: long (__cdecl*)(void *,unsigned char,_
                            OBJECT_NAME_INFORMATION *,unsigned long,unsigned long *,char)]
    [+0x068] OkayToCloseProcedure : 0x0 [Type: unsigned char (__cdecl*)(_EPROCESS *, 
                                                                      void *,void *,char)]
    [+0x070] WaitObjectflagMask : 0x0 [Type: unsigned long] 
    [+0x074] WaitObjectflagOffset : 0x0 [Type: unsigned short] 
    [+0x076] WaitObjectPointerOffset : 0x0 [Type: unsigned short] </code></pre>
<p class="zw">类型对象无法从用户模式操作，因为对象管理器没有为它们提供服务。不过类型对象所定义的一些属性对某些原生服务以及Windows API例程是可见的。类型初始化程序中所存储的信息如表8-22所示。</p>
<p class="表题">表8-22　类型初始化程序字段</p>
<table> 
 <tbody> 
  <tr> 
   <th> <p class="bt">属性</p> </th> 
   <th> <p class="bt">用途</p> </th> 
  </tr> 
  <tr> 
   <td> <p class="bg">Type name</p> </td> 
   <td> <p class="bg">此类型对象的名称（Process、Event、ALPC Port等）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Pool type</p> </td> 
   <td> <p class="bg">表示此类型对象应该从已分页内存还是未分页内存中分配</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Default quota charges</p> </td> 
   <td> <p class="bg">要向进程配额“计费”的默认分页和未分页池数值</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Valid access mask</p> </td> 
   <td> <p class="bg">当打开到此类型对象句柄时，线程可请求的访问类型（读取、写入、终止、挂起等）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Generic access rights mapping</p> </td> 
   <td> <p class="bg">四个常规访问权限（读取、写入、执行、全部）与特定类型访问权限之间的映射</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Retain access</p> </td> 
   <td> <p class="bg">永远无法被任何第三方对象管理器回调（详见上文提供的回调列表）移除的访问权限</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Flags</p> </td> 
   <td> <p class="bg">代表对象是否永远不能拥有名称（例如进程对象），其名称是否应该区分大小写，是否需要安全描述符，是否需要与缓存对齐（需要填充的子头），是否支持对象过滤回调，以及是否应该维护句柄数据库（Handle information子头）和类型列表链接（Creator information子头）。Use default object标记还定义了本表下文列出的Default object字段的行为。最后，Use extended parameters标记可启用下文介绍的Extended parse procedure（扩展解析过程）方法</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Object type code</p> </td> 
   <td> <p class="bg">用于描述该对象的类型（需要与已知的名称值进行比较）。文件对象会将其设置为1，同步对象会将其设置为2，线程对象会将其设置为4。ALPC还可使用该字段存储与消息相关的句柄属性信息</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Invalid attributes</p> </td> 
   <td> <p class="bg">指定了对此类型对象无效的对象属性标记（详见表8-20）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Default object</p> </td> 
   <td> <p class="bg">指定了在等待该对象时，对象类型的创建者发出请求之后要使用的内部对象管理器事件。请注意，某些对象（例如文件对象和ALPC端口对象）已经包含了内嵌的调度程序对象，此时该字段会用作标记，代表应转为使用的等待对象掩码/偏移量/指针字段</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Wait object flags, pointer, offset</p> </td> 
   <td> <p class="bg">如果针对该对象调用了上文介绍的任何一种常规等待服务（WaitForSingleObject等），可供对象管理器大致定位要为同步使用的底层内核调度程序对象</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Methods</p> </td> 
   <td> <p class="bg">在对象生命周期内的某一刻，或为了响应某些用户模式调用，对象管理器可自动调用的一个或多个例程</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">作为Windows应用程序可见的属性之一，同步（synchronization）是指线程通过等待对象改变自己的状态而对执行过程实现同步的能力。线程可以与执行体作业、进程、线程、文件、事件、信号量、互斥、计时器以及很多其他不同类型的对象保持同步。不过其他执行体对象并不支持同步。对象对同步的支持能力基于下列三种可能：</p>
<p class="zwd"><span style="color: #0092dd">●</span> 执行体对象是调度程序对象的封装，包含调度程序头，这种内核结构将在下文“低IRQL同步”中介绍。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 对象类型的创建者请求了一个默认对象，随后对象管理器提供了这个对象。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 执行体对象包含内嵌的调度程序对象，例如对象主体内部的某些事件，并且对象的所有者在注册该对象类型（详见表8-14）时向对象管理器提供了自己的偏移量（或指针）。</p>
<h4 class="bt4 sigil_not_in_toc">对象方法</h4>
<p class="zw">表8-22中的最后一个属性Methods由一系列内部例程组成，这些例程类似于C++构造函数和解析函数，也就是说，在创建或销毁对象时会自动调用这些例程。对象管理器还会在其他情况下调用对象方法，进而对这种设计进行扩展，例如，当某人打开或关闭对象句柄，或者某人试图更改对象的保护机制时。一些对象类型指定了这些方法，但其他一些对象类型并未指定，这主要取决于对象类型的使用方式。</p>
<p class="zw">当执行体组件新建对象类型时，可以向对象管理器注册一个或多个方法。随后，对象管理器即可在此类型的对象生命周期内某些明确的时间点上调用这些方法，这通常会发生在以某种方式创建、删除或修改对象时。对象管理器可支持的方法如表8-23所示。</p>
<p class="表题">表8-23　对象方法</p>
<table> 
 <tbody> 
  <tr> 
   <th> <p class="bt">方法</p> </th> 
   <th> <p class="bt">方法调用时机</p> </th> 
  </tr> 
  <tr> 
   <td> <p class="bg">Open</p> </td> 
   <td> <p class="bg">创建、打开、复制或继承对象句柄时</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Close</p> </td> 
   <td> <p class="bg">关闭对象句柄时</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Delete</p> </td> 
   <td> <p class="bg">对象管理器删除对象之前</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Query name</p> </td> 
   <td> <p class="bg">线程请求对象的名称时</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Parse</p> </td> 
   <td> <p class="bg">对象管理器搜索对象名称时</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Dump</p> </td> 
   <td> <p class="bg">未使用时</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Okay to close</p> </td> 
   <td> <p class="bg">对象管理器接到指示要关闭句柄时</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Security</p> </td> 
   <td> <p class="bg">进程读取或更改对象（例如位于辅助对象命名空间中的文件）的保护机制时</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">使用这些对象方法的原因之一是为了解决一些明显的问题：某些对象操作是通用的（关闭、复制、安全等）。完全概括这些通用例程要求对象管理器的设计者必须预测所有对象类型。这不仅会给内核带来极大的复杂性，而且必须由内核导出创建对象类型所需的这些例程。由于这会允许外部内核组件创建自己的对象类型，内核将无法预测潜在的自定义行为。不过这样的能力并未以文档的形式提供给驱动程序开发者，仅Pcw.sys、Dxgkrnl.sys、Win32k.sys、FltMgr.sys等内部驱动程序可以由此定义WindowStation、Desktop、PcwObject、Dxgk*、FilterCommunication/ConnectionPort、NdisCmState等对象。借助对象方法的可扩展性，这些驱动程序可以通过定义例程来处理诸如删除和查询等操作。</p>
<p class="zw">使用这些方法的另一个原因在于，可以在对象生命周期的管理过程中实现一种虚拟构造函数和解析函数机制。借此，底层组件即可在句柄的创建、关闭和对象销毁的过程中执行额外操作。在需要时，这些机制甚至可用于实现禁止句柄的关闭和创建操作，例如卷1第3章中介绍的受保护进程机制，就利用了自定义句柄创建方法来防止低保护级别的进程打开高保护级别进程的句柄。这些方法还针对对象管理器内部API提供了可见性，例如通过通用服务实现的复制和继承。</p>
<p class="zw">最后，由于这些方法还可覆盖名称解析和查询功能，因此可用于在对象管理器的范围之外实现一种辅助命名空间。实际上File和Key对象就是这样工作的：它们的命名空间由文件系统驱动程序和配置管理器负责内部管理，对象管理器仅能看到\REGISTRY和\Device\HarddiskVolumeN对象。稍后我们将详细介绍这些方法的细节和用例。</p>
<p class="zw">对象管理器只有在其类型初始化程序的指针未设置为NULL的情况下才会调用例程，但有一个例外：安全例程，该例程默认会设置为SeDefaultObjectMethod。该例程不需要知道对象的内部结构，因为它只处理对象的安全描述符，并且之前已经提过，安全描述符的指针会存储在通用对象头中，而非对象主体中。然而，如果某个对象确实需要自行进行额外的安全检查，则会定义一种自定义安全例程，它会像File和Key对象一样工作，即使用一种能够由文件系统或配置管理器直接管理的方式存储安全信息。</p>
<p class="zw">在创建、打开、复制或继承对象时，对象管理器会在创建对象句柄时调用Open方法。例如，WindowStation和Desktop对象就提供了Open方法。实际上，WindowStation对象类型需要Open方法，以便让Win32k.sys能够将内存共享给充当桌面相关内存池的进程。</p>
<p class="zw">我们可以用I/O系统中使用的Close方法作为另一个例子。I/O管理器会为文件对象类型注册一个Close方法，当对象管理器关闭一个文件对象句柄时，它会调用该Close方法。这个Close方法会检查正在关闭文件句柄的进程是否拥有文件上任何未完成的锁，如果有，则会删除这些锁。检查文件锁，这并非对象管理器本身能够或应该做的事情。</p>
<p class="zw">在从内存中删除临时对象之前，对象管理器会调用Delete方法（如果已注册这样的方法）。例如，内存管理器会为节对象类型注册一个Delete方法，用来释放被该节占用的物理页面，同时还可验证节对象被删除之前，内存管理器曾为该节分配的所有内部数据结构是否均已删除。需要再次提醒的是，对象管理器无法执行这项工作，因为它不了解内存管理器的内部工作。其他类型对象的Delete方法也是按照类似方式工作的。</p>
<p class="zw">当发现有对象存在于对象管理器的命名空间范围以外时，Parse方法（以及类似的Query name方法）可以让对象管理器将查找对象的控制权转交给辅助（secondary）对象管理器。当对象管理器查找对象名称时，如果遇到关联了Parse方法的路径，此时查找工作将会暂停。随后对象管理器会调用Parse方法，并将自己正在查找的对象名称的剩余查找工作传递给该方法。除了对象管理器的命名空间外，Windows中还有两个命名空间：包含了配置管理器实现的注册表命名空间，以及I/O管理器在文件系统驱动程序的帮助下所实现的文件系统命名空间（有关配置管理器的详情请参阅第10章，有关I/O管理器和文件系统驱动程序的详情请参阅卷1第6章）。</p>
<p class="zw">例如，当一个进程打开了名为\Device\HarddiskVolume1\docs\resume.doc的对象句柄时，对象管理器会遍历其名称树，直到自己到达名为HarddiskVolume1的设备对象。在看到该对象关联了Parse方法后，对象管理器会调用该方法，并将自己正在搜索的对象名称的其余部分传递给该方法，本例中所传递的为字符串docs\resume.doc。设备对象的Parse方法是一种I/O例程，因为I/O管理器定义了设备对象的类型并为其注册了Parse方法。I/O管理器的Parse例程会接收该名称字符串，并将其传递给相应的文件系统，由文件系统找到并打开磁盘中的文件。</p>
<p class="zw">与Parse方法类似，I/O系统还会使用Security方法。当有线程试图查询或更改用于保护文件的安全信息时，都会调用Security方法。文件对象与其他对象的安全信息有所差异，因为安全信息存储在文件本身而非内存中。因此，必须调用I/O系统来查找安全信息，随后才能读取或更改这些信息。</p>
<p class="zw">最后，Okay to close方法可充当额外保护层，防止系统工作使用的句柄被恶意（或错误地）关闭。例如，每个进程都有一个指向Desktop对象或指向自己线程的可见窗口所在对象的句柄。在标准安全模型下，这些对象可以关闭自己的桌面句柄，因为进程可以完全控制自己的对象。但这种情况会导致线程最终没有与之关联的桌面，违背了窗口模型。为防止产生这种情况，Win32k.sys会为Desktop和WindowStation对象注册一个Okay to close例程。</p>
<h4 class="bt4 sigil_not_in_toc">对象句柄和进程句柄表</h4>
<p class="zw">当进程按照名称创建或打开对象时，它会收到一个句柄，该句柄代表了自己对该对象的访问。使用句柄引用对象，这种方式比使用名称引用速度更快，因为对象管理器可以跳过名称查找环节直接找到对象。正如上文所述，在创建进程的时候，进程还可以通过继承句柄的方式获得对象句柄（前提是创建者在CreateProcess调用中指定了继承句柄标记且句柄被标记为可继承，或者在创建时或创建后使用Windows的SetHandleInformation函数）。另外，进程还可以从其他进程复制句柄（详见Windows的DuplicateHandle函数）。</p>
<p class="zw">所有用户模式进程必须先拥有一个对象句柄，随后进程的线程才能使用该对象。使用句柄操作系统资源并不是一种新做法。例如，C和C++运行时库就可以返回指向已打开文件的句柄。句柄可以充当指向系统资源的间接指针，这种间接性使得应用程序无法直接操作系统数据结构。</p>
<p class="zw">对象句柄还提供了其他的优点。首先，除了所引用指代的目标外，文件句柄、事件句柄和进程句柄之间没有任何区别。这种相似性为引用的（无论任何类型的）对象提供了一种统一的接口。其次，对象管理器拥有创建句柄和定位句柄所引用对象的专有权利。这意味着对象管理器可以对对象产生影响的每一个用户模式操作进行仔细检查，并查看调用方的安全配置文件是否允许针对目标对象执行所请求的操作。</p>
<table> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　执行体组件和设备驱动程序可以直接访问对象，这是因为它们运行在内核模式下，因此可以访问系统内存中的对象结构。然而，它们必须增加对象的引用计数，用来声明自己对这些对象的使用，这样对象才不会在依然使用的过程中被撤销分配（详情可参阅下文“对象保留”一节）。但是要成功使用对象，设备驱动程序需要知道对象的内部结构定义，可大部分对象并未提供这些信息。因此，我们需要尽量让设备驱动程序使用相应的内核API来修改或读取对象的此类信息。例如，设备驱动程序可以获得指向Process对象（EPROCESS）的指针，但其结构是不透明的，而必须使用Ps* API代替。对于其他对象，类型本身也是不透明的（例如大部分执行体对象会包装一个调度程序对象，如事件或互斥）。对于这些对象，驱动程序必须使用与用户模式应用程序最终调用相同的系统调用（如ZwCreateEvent），并使用句柄而不是对象指针。</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zwtsh">实验：查看打开的句柄</p>
<p class="zwts1">运行Process Explorer并确保底部窗格已启用，随后即可通过配置查看打开的句柄。（点击View→Lower Pane View，然后点击Handles。）随后打开命令提示符窗口即可查看新创建的Cmd.exe进程的句柄表。我们应当可以看到代表当前目录的打开文件句柄。例如，假设当前目录为C:\Users\Public，Process Explorer会显示如下内容。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3567.jpg" style="width: 100%" />
<p class="zwts1">随后按下空格键，或选择View→Update Speed，再选择Pause Now，这样可以暂停Process Explorer的运行。接下来使用cd命令更改当前目录，并按下F5刷新显示结果。我们可以在Process Explorer中看到指向上一个当前目录的句柄已关闭，并且打开了一个指向新的当前目录的新句柄。之前的句柄会使用红色强调显示，新句柄则会用绿色突出显示。</p>
<p class="zwts1">Process Explorer的将差异之处用不同颜色突出显示的功能，让我们可以轻松发现句柄表中的变化。举例来说，如果某个进程正在泄漏句柄，使用Process Explorer查看句柄表就可以快速发现已经打开但没有关闭的句柄（一般来说，我们会看到同一个对象包含很长的句柄列表）。这些信息可以帮助程序员发现句柄泄漏。</p>
<p class="zwts1">资源监视器也可以针对我们选择的进程显示所有打开的具名句柄，为此只需选择进程名称旁边的复选框。下图展示了命令提示符进程所打开的句柄。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3574.png" style="width: 100%" />
<p class="zwts1">我们还可以使用Sysinternals的命令行工具Handle查看打开的句柄表。例如，下列精简后的Handle输出结果展示了在更改目录前后，Cmd.exe进程的句柄表中所包含的文件对象句柄。默认情况下，Handle会过滤掉所有非文件句柄，除非使用–a开关，使用后可以像Process Explorer那样显示进程中的所有句柄。</p>
<pre class="代码无行号"><code>C:\Users\aione&gt;\sysint\handle.exe -p 8768 -a users 
Nthandle v4.22 - Handle viewer 
Copyright (C) 1997-2019 Mark Russinovich 
Sysinternals - www.sysinternals.com 
cmd.exe            pid: 8768 type: File            150: C:\Users\Public </code></pre>
<p class="zw">对象句柄可以看成该对象相关句柄表的索引，由执行体进程（EPROCESS）块（详见本书卷1第3章）进行指向。将该索引乘以4（移动2位）即可为某些API行为所使用的每个句柄位腾出空间，例如禁止I/O完成端口的通知或更改进程调试的工作方式。因此第一个句柄索引为4，第二个为8，以此类推。使用句柄5、6、7将直接重定向至与句柄4相同的对象，而句柄9、10、11则引用了与句柄8相同的对象。</p>
<p class="zw">进程句柄表包含指向进程当前已打开句柄的所有对象的指针，并且句柄值会尽可能地重用，这样下一个新的句柄索引将会尽可能地利用现有的已关闭句柄索引。如图8-33所示，句柄表实现了一种三级结构，这种结构类似于传统x86内存管理单元所实现的虚拟到物理地址转换机制，但出于兼容性方面的原因，其上限为24位，这导致每个进程最多可以有16777215（2<sup>24</sup>−1）个句柄。图8-34展示了Windows的句柄表中每个条目的布局。为节约内核内存成本，创建进程时只分配最底层的句柄表，其他层级将按照需求创建。子句柄表（Subhandle table）包含一个内存页可装下尽可能多数量的条目，但需要减去一个用于审核的条目。例如，对于64位系统，一个内存页为4096字节，除以句柄表一个条目的大小（16字节）得到256，再减去1得到255，也就是说，最底层的句柄表共可包含255个条目。中层句柄表可包含一整页指向子句柄表的指针，因为子句柄表的数量取决于内存页的大小以及平台指针的大小。同样以64位系统为例，只需计算4096/8即可得知共包含512个条目。但由于存在24位的上限，因此顶级指针表只能包含32个条目。由这些数量相乘可知，总共可以包含32×512×255，即16711680个句柄。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3581.png" style="width: 100%" />
<p class="图题">图8-33　Windows进程句柄表的架构</p>
<p class="zwtsh">实验：创建最大数量的句柄</p>
<p class="zwts1">Sysinternals提供的测试程序Testlimit包含了一个选项，可以打开尽可能多的对象句柄，直到无法继续打开。我们可以此查看自己系统中的一个进程最多可以创建多少个句柄。由于句柄表是从分页缓冲池中分配的，因此我们可能在实际达到一个进程可创建的句柄数量最大值之前，就遇到分页缓冲池耗尽的情况。要查看自己系统可以创建多少句柄，可执行如下步骤：</p>
<p class="zwts1">1）根据32/64位Windows版本下载对应的Testlimit可执行文件：https://docs. microsoft.com/sysinternals/downloads/testlimit。</p>
<p class="zwts1">2）运行Process Explorer，点击View，再点击System Information。接下来点击Memory选项卡。请留意分页缓冲池的当前大小和最大大小（要显示缓冲池大小的最大值，需要将Process Explorer配置为能够正确访问内核映像，即Ntoskrnl.exe的符号）。为了在运行Testlimit程序时可以看到缓冲池的使用量，请不要关闭该系统信息界面。</p>
<p class="zwts1">3）打开一个命令提示符窗口。</p>
<p class="zwts1">4）使用-h开关运行Testlimit程序（运行testlimit –h）。当Testlimit无法继续打开新句柄时，会显示自己已经创建的句柄总数。如果该数值小于约1600万，那么可能意味着在达到每线程句柄数的理论最大值之前，分页缓冲池就已耗尽。</p>
<p class="zwts1">5）关闭命令提示符窗口，这样即可直接终止Testlimit进程，进而关闭所有打开的句柄。</p>
<p class="zw">如图8-34所示，在32位系统中，每个句柄表条目由一种具备两个32位成员的结构组成：一个指向对象的指针（该指针包含3个标记，因此消耗了最低的3位，又因为所有对象都是8字节对齐的，因此这些位可以假定为0），以及所授予的访问掩码（访问掩码只需要25位，因为通用权限永远不会存储在句柄条目中）。此外，还有另外两个标记和引用使用量计数，下文将会介绍这些内容。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3589.png" style="width: 100%" />
<p class="图题">图8-34　32位句柄表条目的结构</p>
<p class="zw">64位系统中存在相同的基本数据段，但编码方式有所差异。举例来说，64位系统只需要44位即可对指针对象进行编码（假设处理器具备四级分页和48位虚拟内存），因为对象是16字节对齐的，因此现在可以假设最低的4位为0。借此即可将“Protect from close”（保护防止关闭）标记编码到上文提到的32位系统最初所使用的3个标记中，因此总共可以使用4个标记。另一个变化在于，引用使用量计数会被编码至指针旁边的剩余16位中，而不再编码到访问掩码旁。最后，“No rights upgrade”（无升级权限）标记依然保留在访问掩码旁，但剩余的6位是空闲的，并且依然有32位的对齐是空闲的，因此总共需要16字节。对于具有五级分页的LA57系统<sup>[5]</sup>，情况又产生了变化，此时指针必须为53位，而使用量计数位将仅剩7位。</p>
<p class="footnote">[5]LA57系统是指处理器的Linear Address（线性地址）为57位的系统，这是通过Intel EM64T模式下的x86_64处理器新增的一种五级分页模式实现的。顾名思义，五级分页可通过一种包含五个层级的分页结构来转译处理器的线性地址，相比原本的四级分页，可将处理器线性地址由48位扩展至57位，进而让处理器和应用程序可以访问更大容量的内存。——译者注</p>
<p class="zw">既然已经提到了各种标记，那么接下来一起看看这些标记是做什么用的。首先，第一个标记是一个锁定位，代表对应的条目当前是否正被使用。从技术上来看，这个位代表“解锁”，意味着我们通常期待这个最低位已被正常设置。第二个标记是继承标志，决定了该进程创建的其他进程能否在自己的句柄表中获得该句柄的一个副本。如上文所述，句柄能否继承，可在创建句柄时指定，或在句柄创建完毕后使用SetHandleInformation函数设置。第三个标记代表关闭该对象是否要生成审核消息（该标记并未暴露给Windows，仅供对象管理器在内部使用）。随后的“Protect from close”位决定了是否允许调用方关闭该句柄（该标记也可使用SetHandleInformation函数设置）。最后的“No rights upgrade”位决定了如果句柄被复制给具备更高特权的进程，是否应该同步地升级访问权限。</p>
<p class="zw">后4个标记可通过传递给ObReferenceObjectByHandle等API的OBJECT_HANDLE_ INFORMATION结构暴露给驱动程序，并能映射至OBJ_INHERIT (0x2)、OBJ_AUDIT_ OBJECT_CLOSE (0x4)、OBJ_PROTECT_CLOSE (0x1)和OBJ_NO_RIGHTS_UPGRADE (0x8)，这也正好与上文提到的在创建对象时设置的OBJ_attribute定义中的“缺口”完全对应。因此，运行时的对象属性最终可对某对象的特定行为及特定对象的句柄所表现的特定行为进行编码。</p>
<p class="zw">最后，我们还曾提过，对象头的指针计数器字段的编码和句柄表条目中都存在引用使用量计数器。这个方便的功能可将预先存在的引用的缓存数量（基于可用位的数量）编码为每个句柄表条目的一部分，随后将具有相同对象句柄的所有进程的使用量计数相加后放入对象头的指针计数器中。因此指针计数器的数值是句柄数、通过ObReferenceObject产生的内核引用数，以及每个句柄缓存的引用数三者的总和。</p>
<p class="zw">每当进程用完一个对象时，只需取消对句柄的引用（基本上，这是通过调用任意可接受句柄作为输入，并最终将其转换为对象的Windows API实现的）即可减少缓存的引用数，也就是说，这会让计数器的数值减少1，直到数值最终归零，随后将不再对其进行跟踪。由此我们可以通过特定进程的句柄准确推断特定对象被使用/访问/管理的次数。</p>
<p class="zw">将调试器命令!trueref与-v标记配合使用，即可显示引用对象的每个句柄，以及准确的使用次数（但需要同时统计已使用/已丢弃用量计数器的数值）。在下文的一个实验中，我们将使用该命令进一步了解对象的使用情况。</p>
<p class="zw">系统组件和设备驱动程序通常需要打开用户模式应用程序无法访问或从一开始就根本不应绑定到特定进程的对象句柄。为此可在与System进程关联的内核句柄表（内部以ObpKernelHandleTable名称引用）中创建句柄。该表中的句柄只能从内核模式以任意进程上下文访问，这意味着内核模式函数可在任意进程上下文中引用该句柄而不影响性能。</p>
<p class="zw">当句柄的高位被设置（即当内核句柄表中的句柄引用数量在32位系统中大于0x80000000，或在64位系统中大于0xFFFFFFFF80000000）时，对象管理器即可从内核句柄表中识别对句柄的引用（从数据类型的角度来看，因为句柄实际上被定义为指针，因此编译器会强制进行符号扩展）。</p>
<p class="zw">内核句柄表还充当了System进程和最小化进程的句柄表，因此System进程创建的所有句柄（例如System线程中运行的代码）都被隐式地作为内核句柄，因为这些进程EPROCESS结构的ObjectTable已设置了ObpKernelHandleTable符号。理论上，这意味着具备足够特权的用户模式进程可以使用DuplicateHandle API将内核句柄提取到用户模式中，但自Windows Vista引入了受保护进程的概念（详见本书卷1）后，以这种方式发起的攻击已经得到了缓解。</p>
<p class="zw">此外，作为一种安全缓解措施，任何由内核驱动程序创建的句柄，只要将“原本的模式”设置为KernelMode，就会在新版Windows中自动被转换为内核句柄，这样即可防止句柄被无意泄漏给用户模式下的应用程序。</p>
<p class="zwtsh">实验：使用内核调试器查看句柄表</p>
<p class="zwts1">内核调试器中的!handle命令可接收三个参数：</p>
<pre class="代码无行号"><code>!handle &lt;handle index&gt; &lt;flags&gt; &lt;processid&gt; </code></pre>
<p class="zwts1">“handle index”（句柄索引）代表句柄表中的句柄条目（“0”意味着“显示所有句柄”）。第一个句柄的索引为4，第二个为8，以此类推。例如，输入!handle 4可显示当前进程的第一个句柄。</p>
<p class="zwts1">“flags”则是一种位掩码，其中“位0”意味着“仅显示句柄条目中的信息”，“位1”意味着“显示可用句柄（而非仅显示已使用句柄）”，“位2”意味着“显示句柄所引用对象的相关信息”。下列命令可显示ID为0x1540的进程在句柄表中的完整信息：</p>
<pre class="代码无行号"><code>lkd&gt; !handle 0 7 1540 
　
PROCESS ffff898f239ac440 
    SessionId: 0 Cid: 1540    Peb: 1ae33d000 ParentCid: 03c0 
    DirBase: 211e1d000 ObjectTable: ffffc704b46dbd40 HandleCount: 641. 
    Image: com.docker.service 
　
Handle table at ffffc704b46dbd40 with 641 entries in use 
　
0004: Object: ffff898f239589e0 GrantedAccess: 001f0003 (Protected) (Inherit) Entry:
ffffc704b45ff010 
Object: ffff898f239589e0 Type: (ffff898f032e2560) Event 
    ObjectHeader: ffff898f239589b0 (new version) 
        HandleCount: 1 PointerCount: 32766 
　
0008: Object: ffff898f23869770 GrantedAccess: 00000804 (Audit) Entry: ffffc704b45ff020
Object: ffff898f23869770 Type: (ffff898f033f7220) EtwRegistration 
    ObjectHeader: ffff898f23869740 (new version) 
        HandleCount: 1 PointerCount: 32764 </code></pre>
<p class="zwts1">并不需要记住所有这些位的含义并将进程ID转换为十六进制，也可以借助调试器数据模型，使用进程的Io.Handles命名空间来访问句柄。例如，输入dx @$curprocess. Io.Handles[4]即可显示当前进程的第一个句柄，包括访问权和名称。下列命令可以显示PID为5440（即0x1540）进程的所有句柄的详细信息：</p>
<pre class="代码无行号"><code>lkd&gt; dx -r2 @$cursession.Processes[5440].Io.Handles 
@$cursession.Processes[5440].Io.Handles 
    [0x4] 
        Handle           : 0x4 
        Type             : Event 
        GrantedAccess    : Delete | ReadControl | WriteDac | WriteOwner | Synch |
QueryState | ModifyState 
        Object           [Type: OBJECTHEADER] 
    [0x8] 
        Handle           : 0x8 
        Type            : EtwRegistration 
        GrantedAccess 
        Object          [Type: _OBJECT_HEADER] 
    [0xc] 
        Handle          : 0xc 
        Type            : Event 
        GrantedAccess   : Delete | ReadControl | WriteDac | WriteOwner | Synch |
QueryState | ModifyState 
        Object          [Type: _OBJECT_HEADER] </code></pre>
<p class="zwts1">还可以使用支持LINQ谓词的调试器数据模型执行更有趣的搜索，例如查找可读取/写入的具名节对象映射：</p>
<pre class="代码无行号"><code>lkd&gt; dx @$cursession.Processes[5440].Io.Handles.Where(h =&gt; (h.Type == "Section") &amp;&amp;
(h.GrantedAccess.MapWrite) &amp;&amp; (h.GrantedAccess.MapRead)).Select(h =&gt; h.ObjectName)
@$cursession.Processes[5440].Io.Handles.Where(h =&gt; (h.Type == "Section") &amp;&amp; 
(h.GrantedAccess.MapWrite) &amp;&amp; (h.GrantedAccess.MapRead)).Select(h =&gt; h.ObjectName)
    [0x16c]         : "Cor_Private_IPCBlock_v4_5440" 
    [0x170]         : "Cor_SxSPublic_IPCBlock" 
    [0x354]         : "windows_shell_global_counters" 
    [0x3b8]         : "UrlZonesSM_DESKTOP-SVVLOTP$" 
    [0x680]         : "NLS_CodePage_1252_3_2_0_0" </code></pre>
<p class="zwtsh">实验：使用内核调试器搜索打开的文件</p>
<p class="zwts1">虽然可以使用Process Hacker、Process Explorer、Handle以及OpenFiles.exe工具搜索打开的文件句柄，但在查看故障转储或进行远程分析时，这些工具可能并非总是可用。此时也可以使用!devhandles命令搜索特定卷上打开的文件句柄（有关设备、文件和卷的详细信息请参阅第11章）。</p>
<p class="zwts1">1）选择感兴趣的盘符，并获得指向其Device对象的指针，为此可使用!object命令，如下所示：</p>
<pre class="代码无行号"><code>lkd&gt; !object \Global??\C: 
Object: ffffc704ae684970 Type: (ffff898f03295a60) SymbolicLink 
    ObjectHeader: ffffc704ae684940 (new version) 
    HandleCount: 0  PointerCount: 1 
    Directory Object: ffffc704ade04ca0 Name: C: 
    flags: 00000000 ( Local ) 
    Target String is '\Device\HarddiskVolume3' 
    Drive Letter Index is 3 (C:) </code></pre>
<p class="zwts1">2）使用!object命令获得目标卷Device对象的名称：</p>
<pre class="代码无行号"><code>1: kd&gt; !object \Device\HarddiskVolume1 
Object: FFFF898F0820D8F0 Type: (fffffa8000ca0750) Device </code></pre>
<p class="zwts1">3）将Device对象的指针与!devhandles命令配合使用，所显示的每个对象都会指向一个文件：</p>
<pre class="代码无行号"><code>lkd&gt; !devhandles 0xFFFF898F0820D8F0 
　
Checking handle table for process 0xffff898f0327d300 
Kernel handle table at ffffc704ade05580 with 7047 entries in use 
 
PROCESS ffff898f0327d300 
    SessionId: none Cid: 0004    Peb: 00000000 ParentCid: 0000 
    DirBase: 001ad000 ObjectTable: ffffc704ade05580 HandleCount: 7023. 
    Image: System 
　
019c: Object: ffff898F080836a0 GrantedAccess: 0012019f (Protected) (Inherit) 
(Audit) Entry: ffffc704ade28670 
Object: ffff898F080836a0 Type: (ffff898f032f9820) File 
    ObjectHeader: ffff898F08083670 (new version) 
        HandleCount: 1 PointerCount: 32767 
        Directory Object: 00000000 Name: \$Extend\$RmMetadata\$TxfLog\ 
                                         $TxfLog.blf {HarddiskVolume4} </code></pre>
<p class="zwts1">尽管该扩展可以正常生效，但大家可能注意到需要等待30秒到1分钟才能开始看到前几个句柄。实际上，我们可以使用支持LINQ谓词的调试器数据模型实现相同的效果，这种方式可以立刻显示返回的结果：</p>
<pre class="代码无行号"><code>lkd&gt; dx -r2 @$cursession.Processes.Select(p =&gt; p.Io.Handles.Where(h =&gt; 
     h.Type == "File").Where(f =&gt; f.Object.UnderlyingObject.DeviceObject == 
     (nt!_DEVICE_OBJECT*)0xFFFF898F0820D8F0).Select(f =&gt; 
     f.Object.UnderlyingObject.FileName)) 
@$cursession.Processes.Select(p =&gt; p.Io.Handles.Where(h =&gt; h.Type == "File"). 
Where(f =&gt; f.Object.UnderlyingObject.DeviceObject == (nt!_DEVICE_OBJECT*)
0xFFFF898F0820D8F0).Select(f =&gt; f.Object.UnderlyingObject.FileName))
   [0x0]
   [0x19c]    : "\$Extend\$RmMetadata\$TxfLog\$TxfLog.blf" [Type: _UNICODE_STRING]
   [0x2dc]    : "\$Extend\$RmMetadata\$Txf:$I30:$INDEX_ALLOCATION" [Type: _UNICODE_STRING]
   [0x2e0]    : "\$Extend\$RmMetadata\$TxfLog\$TxfLogContainer00000000000000000002"
                [Type: _UNICODE_STRING]</code></pre>
<h4 class="bt4 sigil_not_in_toc">保留对象</h4>
<p class="zw">对象可以代表从事件到文件再到进程间消息的一切东西，因此，应用程序和内核代码创建对象的能力，对任何一段Windows代码的正常运行及运行时需要表现的行为都至关重要。如果对象分配失败，通常会导致功能丢失（进程无法打开文件）甚至数据丢失或系统崩溃（进程无法分配同步对象）等各种问题。更糟糕的是，在某些情况下，对象创建失败所导致的错误报告行为本身也需要分配新的对象。为了处理这种情况，Windows实现了两个特殊的保留对象：用户APC保留对象（user APC reserve object）和I/O完成数据包保留对象（I/O completion packet reserve object）。请注意，保留对象机制是完全可扩展的，未来版本的Windows可能增加其他保留对象类型，从广义上来看，保留对象机制可以将任何内核模式的数据结构包装为对象（具备关联的句柄、名称和安全性）以供后续使用。</p>
<p class="zw">正如上文所述，APC可用于诸如挂起、终止和I/O完成等操作，并与希望提供异步回调的用户模式应用程序进行通信。当用户模式应用程序请求一个以其他线程为目标的用户&nbsp;APC&nbsp;时，需要用到&nbsp;Kernelbase.dll&nbsp;中的&nbsp;QueueUserApc API，以此调用NtQueueApcThread这个系统调用。在内核中，该系统调用会尝试着分配一块分页缓冲池，并在其中存储与APC关联的KAPC控制对象结构。在内存不足的情况下，该操作会失败，从而阻止APC的交付，根据该APC的用途，这可能导致数据丢失或功能丢失。</p>
<p class="zw">为了防止这种情况，用户模式应用程序可以在启动时使用NtAllocateReserveObject这个系统调用请求内核预分配KAPC结构。随后应用程序可以使用另一个系统调用NtQueueApcThreadEx，该系统调用包含一个额外的参数，可用于存储保留对象的句柄。这样，内核就不需要分配新的结构，而是可以尝试着获取保留对象（通过将其InUse位设置为True）并一直使用该保留对象，直到不再需要KAPC对象，此时该保留对象会被释放回系统中。目前，为防止第三方开发者无法妥善管理系统资源，保留对象API仅在内部通过操作系统组件的系统调用使用。例如，RPC库可使用保留的APC对象来保证当内存不足时，异步回调依然可以正常返回。</p>
<p class="zw">当应用程序需要以无故障方式交付I/O完成端口的消息或数据包时，也可能发生类似的情况。一般来说，可以使用Kernelbase.dll中的PostQueuedCompletionStatus API（该API会调用NtSetIoCompletion API）发送数据包。与用户APC类似，内核必须分配一个I/O管理器结构来包含完成数据包的相关信息，如果该分配失败，则将无法创建数据包。借助保留对象，应用程序可以在启动时使用NtAllocateReserveObject API让内核预分配I/O完成数据包，并使用系统调用NtSetIoCompletionEx为该保留对象提供句柄，以此保证提供成功操作的路径。与用户APC保留对象类似，该功能同样是为系统组件保留的，RPC库和Windows Peer-To-Peer BranchCache服务可以使用该功能保证异步I/O操作能够成功完成。</p>
<h4 class="bt4 sigil_not_in_toc">对象安全性</h4>
<p class="zw">当打开一个文件时，必须指定自己是要进行读取还是写入操作。如果试图针对一个以读取访问方式打开的文件执行写入操作，那么将会收到错误信息。同理，在执行体中，当进程创建对象或打开现有对象的句柄时，进程也必须指定一系列自己需要的访问权限，也就是说，需要指定自己希望对该对象执行怎样的操作。进程可以请求一组可适用于所有对象类型的标准访问权限（例如读取、写入、执行），或者指定对特定对象类型执行不同权限的访问。例如，进程可以对文件对象请求删除或附加访问，同样也可以针对线程对象请求挂起或终止的权限。</p>
<p class="zw">当进程打开对象句柄时，对象管理器会调用安全引用监视器（安全系统在内核模式中的一部分）并传递进程的一组所需访问权限。安全引用监视器会检查该对象的安全描述符是否允许执行进程所请求的访问类型。如果允许，则安全引用监视器会返回一组访问权限并将其授予该进程，随后对象管理器会将这些权限存储在自己创建的对象句柄中。本书卷1第7章曾介绍过安全系统是如何确定谁可以访问哪些对象的。</p>
<p class="zw">随后，每当进程的线程通过服务调用的方式使用该句柄时，对象管理器都可以快速检查句柄中所存储的已授予的访问权限是否与线程调用的对象服务所暗含的用法相匹配。举例来说，如果调用方请求对一个节对象进行读取访问，但随后调用了一个服务试图进行写入访问，那么该操作将会失败。</p>
<p class="zwtsh">实验：查看对象的安全性</p>
<p class="zwts1">我们可以使用Process Hacker、Process Explorer、WinObj、WinObjEx64或AccessChk（这些均为Sysinternals提供的工具，或发布到GitHub的开源工具）来查看对象的各种访问权限。下面一起查看对象访问控制列表（ACL）的不同方法：</p>
<p class="zwts1"><span style="color: #0092dd">●</span> 我们可以使用WinObj或WinObjEx64查看系统中的任何对象（包括对象目录），</p>
<p class="zwts1">为此只需右键点击对象并选择Properties。例如，选择BaseNamedObjects目录，选择Properties，随后打开Security选项卡，就可以看到一个类似下图所示的对话框。由于WinObjEx64支持更广泛的对象类型，因此可以通过该对话框查看更多类型系统资源的相关信息。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3601.png" style="width: 100%" />
<p class="zwts1">检查该对话框中的设置可以发现一些有趣的情况，例如Everyone组没有该目录的删除访问权限，但SYSTEM账户有该权限（因为具备SYSTEM特权的Session 0服务会将自己的对象存储在这里）。</p>
<p class="zwts1"><span style="color: #0092dd">●</span> 除了使用WinObj或WinObjEx64，我们也可以按照上文“查看打开的句柄”实验中介绍的方法，使用Process Explorer查看进程的句柄表，或者使用Process Hacker查看此类信息。在查看Explorer.exe进程的句柄表时会发现一个指向\Sessions\n\BaseNamedObjectsdirectory目录的Directory对象句柄（其中n是在引导时定义的任意数字的会话编号，下文很快将介绍会话命名空间）。双击该对象句柄后打开Security选项卡即可看到类似的对话框（不过显示了更多用户和授予的权限）。</p>
<p class="zwts1"><span style="color: #0092dd">●</span> 还可以使用AccessChk配合-o开关查询任意对象的安全信息，输出结果如下文所示。请注意，使用AccessChk还可以查看对象的完整性级别（有关完整性级别和安全引用监视器的详细信息，请参阅本书卷1第7章）。</p>
<pre class="代码无行号"><code>C:\sysint&gt;accesschk -o \Sessions\1\BaseNamedObjects 
　
Accesschk v6.13 - Reports effective permissions for securable objects 
Copyright (C) 2006-2020 Mark Russinovich 
Sysinternals - www.sysinternals.com 
　
\Sessions\1\BaseNamedObjects 
  Type: Directory 
  RW Window Manager\DWM-1 
  RW NT AUTHORITY\SYSTEM 
  RW DESKTOP-SVVLOTP\aione 
  RW DESKTOP-SVVLOTP\aione-S-1-5-5-0-841005 
  RW BUILTIN\Administrators 
  R  Everyone 
     NT AUTHORITY\RESTRICTED </code></pre>
<p class="zw">Windows还支持Ex（扩展）版本的API（例如CreateEventEx、CreateMutexEx、CreateSemaphoreEx），并能添加另一个参数来指定访问掩码。这样，应用程序就可以使用随机访问控制列表（Discretionary Access Control List，DACL）正确地保护自己的对象，而不会破坏自己使用创建对象API打开对象句柄的能力。有人可能会纳闷客户端应用程序为何不直接使用OpenEvent，毕竟它们也可以支持所需的访问参数。在处理失败的打开调用时，使用打开对象API会造成一种固有的竞争状况，即客户端应用程序会试图在事件创建出来之前打开该事件。在大部分这种类型的应用程序中，失败都是因为打开API后紧跟了创建API。然而，我们无法保证这个创建操作符合原子性的要求，也就是说，无法保证创建操作只发生一次。</p>
<p class="zw">实际上，多个线程或进程可能同时执行创建API，并且它们会试图同时创建事件。这种竞争状况及处理这种情况所额外需要的复杂性，使得打开对象API并不适合成为这种问题的解决方案，因此会使用Ex API代替。</p>
<h4 class="bt4 sigil_not_in_toc">对象的保留</h4>
<p class="zw">对象可分为两种类型：临时对象和永久对象。大部分对象都是临时对象，也就是说，会在使用过程中保留临时对象，但会在用完后释放。永久对象则会在明确释放之前始终被保留。由于大部分对象是临时对象，因此后续内容将介绍对象管理器如何实现对象的保留，即只在需要的过程中保留临时对象，在不需要时将其删除。</p>
<p class="zw">由于所有需要访问对象的用户模式进程必须先打开对象句柄，因此对象管理器可以轻松地跟踪进程数量，以及有多少进程正在使用某一个对象。这些句柄的跟踪工作也是实现保留对象的工作之一。对象管理器会通过两个环节实现对象保留。第一个环节叫作名称保留，由已存在对象的打开句柄数控制。每次有进程打开一个对象句柄后，对象管理器会增大对象头中打开句柄计数器的数值。当进程用完该对象并关闭句柄后，对象管理器会减小打开句柄计数器的数值。当该计数器数值归零后，对象管理器就会将该对象的名称从自己的全局命名空间中删除。这种删除操作可防止进程继续打开该对象的句柄。</p>
<p class="zw">对象保留的第二个环节是当对象不再被使用时，停止维持对象本身（即彻底删除对象）。操作系统代码通常会使用指针而非句柄来访问对象，因此对象管理器还必须记录自己已经分配给操作系统进程的对象指针数量。每次发出一个对象指针时，对象管理器都会增大该对象引用计数器的数值，这个计数器也叫指针计数器。当内核模式组件用完指针后，会调用对象管理器减小该对象的引用计数器数值。系统也会在增大句柄计数器数值的同时增大引用计数器的数值，并在减小句柄计数器数值的同时减小引用计数器的数值，因为句柄也是对对象的引用，必须加以跟踪。</p>
<p class="zw">最后，我们还要介绍使用量引用计数器，该计数器可以缓存指针计数器的引用数量，数值会在每次进程使用句柄时减小。出于性能原因，Windows 8开始增加了使用量引用计数器。当内核被要求从自己的句柄中获取对象指针时，内核能在无须获取全局句柄表锁的情况下进行解析。这意味着在较新版本的Windows中，上文“对象句柄和进程句柄表”一节介绍的句柄表条目将包含一个使用量引用计数器，该计数器会在应用程序或内核驱动程序首次“使用”对象句柄时进行初始化。请注意，在该语境中，“使用”这个词是指通过句柄解析对象指针的行为，该操作是由ObReferenceObjectByHandle等API在内核中执行的。</p>
<p class="zw">让我们通过图8-35这个例子来看看这三个计数器。该图中描绘了64位系统中使用的两个事件对象。进程A创建了第一个事件，并获得了该事件的句柄。该事件具备名称，这也意味着对象管理器会将其插入正确的目录对象（例如\BaseNamedObjects）中，并为其分配初始引用计数器“2”和句柄数“1”。初始化操作完成后，进程A等待第一个事件，该操作使得内核可以使用（或引用）事件句柄，并将句柄的使用量引用计数器分配为32767（十六进制的0x7FFF，将第15位设置为1）。该数值会被添加到第一个事件对象的引用计数器中，使得该计数器的数值加一，因此最终值变为32770（此时句柄计数器的值依然为1）。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3612.png" style="width: 100%" />
<p class="图题">图8-35　句柄和引用计数器</p>
<p class="zw">进程B初始化，创建第二个具名事件并发出信号。最后一个操作将使用（引用）第二个事件，使其引用计数器数值也达到32770。随后，进程B打开第一个事件（由进程A分配）。该操作会让内核创建一个新句柄（仅在进程B的地址空间内有效），这会让第一个事件对象的句柄计数器和引用计数器的数值增加到2和32771（注意，此时新句柄表条目的使用量引用计数器尚未初始化）。进程B在向第一个事件发送信号之前，会将自己的句柄使用三次：第一个操作会将句柄的使用量引用计数器初始化为32767，并将该数值添加到对象引用计数器中，让该计数器进一步增加1个单位，并让总体值最终达到65539。针对句柄的后续操作则会在不影响对象的引用计数器前提下减小使用量引用计数器的值。当内核用完该对象后，总是会取消对对象指针的引用，而该操作会释放内核对象的引用计数器。因此使用4次（包括信号发送操作）之后，第一个对象的句柄计数器变成了2，引用计数器变成了65535。此外，第一个事件还会被某些内核模式的结构所引用，因此其最终的引用计数器将变为65536。</p>
<p class="zw">当进程关闭一个对象的句柄时（该操作会导致在内核中执行NtClose例程），对象管理器知道自己需要从对象的引用计数器中减去句柄使用量引用计数器的数值。这样即可正确地取消对句柄的引用。在上述例子中，即使进程A和进程B同时关闭了自己第一个对象的句柄，该对象也可以继续存在，因为其引用计数器会变为1（但其句柄计数器会变为0）。然而，当进程B关闭了第二个事件对象的句柄后，该对象将被撤销分配，因为其引用计数器归零了。</p>
<p class="zw">这种行为意味着即便对象的打开句柄计数器归零，对象的引用计数器可能依然保持为正数，操作系统依然在以某种方式使用着这个对象。最终，只有当引用计数器归零后，对象管理器才会从内存中删除该对象。该删除操作需要遵守某些规则，并且在某些情况下还需要调用方的配合。例如，因为对象可以存在于分页和非分页内存池中（取决于对象类型中的设置），如果在DISPATCH_LEVEL的IRQL或更高层面上发生了取消引用操作，并且该操作导致指针计数器归零，那么系统在试图立即释放分页池中对象占用的内存时将立即崩溃（回想一下可以知道，这种访问其实是非法的，因为永远不应该为页面错误提供服务）。这种情况下，对象管理器会执行延迟删除操作，将操作放入被动级别（IRQL 0）运行的工作线程队列中。下面将详细介绍系统工作线程。</p>
<p class="zw">另一个需要延迟删除的场景是处理内核事务管理器（Kernel Transaction Manager，KTM）对象。某些情况下，一些驱动程序可能持有与这种对象有关的锁，删除这种对象会导致系统试图获取锁。然而，驱动程序可能永远没机会释放自己的锁，从而导致死锁。处理KTM对象时，驱动程序开发者必须使用ObDereferenceObjectDeferDelete，以便在忽略IRQL级别的情况下强制进行延迟删除。最后，I/O管理器会将这种机制用作一种优化措施，以此让某些I/O操作可以更快速地完成，而无须等待对象管理器删除对象。</p>
<p class="zw">由于对象的保留会通过这种方式起效，应用程序只需要维持一个打开的对象句柄，即可保证对象及其名称始终保留在内存中。如果开发者需要编写包含两个或更多协作进程的应用程序，那么完全无须担心一个进程可能在其他进程还在使用的情况下删除了某个对象。此外，只要操作系统还在使用某个对象，那么关闭应用程序的对象句柄并不会导致该对象被删除。例如，一个进程可能会创建第二个进程以便在后台执行程序，随后该进程立即关闭了进程句柄。由于操作系统需要通过第二个进程来运行程序，因此会维持其进程对象的引用。只有当后台程序运行完毕，对象管理器减小了第二个进程的引用计数后，该进程对象才会被删除。</p>
<p class="zw">由于可能会泄漏内核池内存并最终导致整个系统范围的内存不足，甚至以某些微妙的方式破坏应用程序，对象泄漏会对系统造成极大的危险。Windows包含了一系列调试机制，我们可以通过这些机制监视、分析、调试与句柄和对象有关的问题。此外，WinDbg也提供了两个可以纳入这些机制的扩展，进而提供更简单的图形化分析能力。表8-24介绍了这些调试机制。</p>
<p class="表题">表8-24　适用于对象句柄的调试机制</p>
<table> 
 <tbody> 
  <tr> 
   <th> <p class="bt">机制</p> </th> 
   <th> <p class="bt">启用方式</p> </th> 
   <th> <p class="bt">内核调试器扩展</p> </th> 
  </tr> 
  <tr> 
   <td> <p class="bg">句柄跟踪数据库</p> </td> 
   <td> <p class="bg">在Gflags.exe中选中User Stack Trace（用户栈跟踪）选项以便对整个系统和每个进程进行内核栈跟踪</p> </td> 
   <td> <p class="bg">!htrace &lt;handle value&gt;<br> &lt;process ID&gt;</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">对象引用跟踪</p> </td> 
   <td> <p class="bg">每进程名称或每对象类型池标记，通过Gflags.exe配置Object Reference Tracing（对象引用跟踪）选项</p> </td> 
   <td> <p class="bg">!obtrace &lt;object pointer&gt;</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">对象引用标记</p> </td> 
   <td> <p class="bg">驱动程序必须调用相应的API</p> </td> 
   <td> <p class="bg">不适用</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">当试图了解每个句柄在应用程序或系统上下文中的使用情况时，启用句柄跟踪数据库将能为我们提供巨大的帮助。调试器扩展!htrace可以显示特定句柄被打开时所捕获的栈跟踪结果。在发现句柄泄漏后，可通过栈跟踪确定创建该句柄的代码，并可分析是否缺少对某些函数（如CloseHandle）的调用。</p>
<p class="zw">对象引用跟踪!obtrace扩展通过展示每个新建句柄的栈跟踪结果，以及内核每次引用（以及每次打开、复制或继承）并取消引用句柄时的栈跟踪结果进行更多的监视。通过分析这些模式，即可在系统层面上更轻松地对对象的滥用情况进行调试。此外，这些引用跟踪也为我们提供了一种方法，可用于理解在处理某些对象时的系统行为。例如，通过跟踪进程，可显示系统中所有已经注册回调通知的驱动程序（如Process Monitor）的引用情况，并有助于检测可能在内核模式下引用句柄但从不取消引用的恶意或有Bug的第三方驱动程序。</p>
<table> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　在为特定对象类型启用对象引用跟踪时，只需使用dx命令查看OBJECT_TYPE结构的关键成员即可了解池标记的名称。系统中的每个对象类型都有一个引用该结构的全局变量，例如PsProcessType。此外，我们也可以使用!object命令查看指向该结构的指针。</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">与前两种机制不同，对象引用标记并非一种必须通过全局标记或调试器启用的调试功能，而是一系列API，可以让设备驱动程序开发者使用这些API（包括ObReferenceObjectWithTag和ObDereferenceObjectWithTag）引用对象或取消引用。与池标记类似（有关池标记的详细信息请参阅本书卷1第5章），这些API可供开发者提供一个四字符的标记，以此区分每个引用/取消引用对。在使用上文提到的!obtrace扩展时，也会显示出每个引用和取消引用操作的标记，这就避免了仅使用调用栈这种机制来找出可能存在的泄漏或引用不足等问题，尤其是当驱动程序将特定调用执行了数千次时。</p>
<h4 class="bt4 sigil_not_in_toc">资源记账</h4>
<p class="zw">与对象保留类似，资源记账（resource accounting）也与对象句柄的使用密切相关。打开的句柄数为正数时意味着有进程正在使用该资源，同时也意味着一些进程正在为对象所占用的内存而“计费”。当对象的句柄数和引用计数归零后，曾经使用该对象的进程将不再为此“计费”。</p>
<p class="zw">很多操作系统会使用类似配额的系统限制进程对系统资源的访问。然而，强加给进程的配额有时候是多种多样并且复杂的，用于跟踪配额的代码会分散在操作系统各处。例如，在某些操作系统中，I/O组件可能会记录并限制进程打开的文件数量，而内存组件可能限制进程的线程分配的内存数量，进程组件可能会限制用户创建的新进程的最大数量或限制一个进程中可以包含的线程最大数量。这些限制中的每一个都是在操作系统的不同部分跟踪执行的。</p>
<p class="zw">相比之下，Windows对象管理器为资源的记账提供了一种中央设施。每个对象头都包含一个名为Quota charges的属性，以此记录当进程中的线程打开一个对象句柄时，对象管理器从该进程所分配的分页或非分页内存池配额中扣减的配额数量。</p>
<p class="zw">Windows中的每个进程都会指向一种配额结构，其中记录了非分页池、分页池和分页文件使用量的限制和当前值。这些配额默认为0（无限制），但可通过修改注册表值的方式修改（需要添加/编辑注册表HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\ Memory Management下的NonPagedPoolQuota、PagedPoolQuota和PagingFileQuota）。请注意，同一个交互式会话中的所有进程将共享同一个配额块（没有公开的方法可供我们用进程自己的配额块来创建进程）。</p>
<h4 class="bt4 sigil_not_in_toc">对象名称</h4>
<p class="zw">当创建大量对象时，考虑的一个重要因素是需要设想一个成功的系统来跟踪所有对象。对象管理器需要通过以下信息来帮助我们做到这一点：</p>
<p class="zwd"><span style="color: #0092dd">●</span> 一种将对象相互区分的方式。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 一种寻找和检索特定对象的方法。</p>
<p class="zw">第一个要求是通过为对象分配名称来实现的。这是一种大多数操作系统都会提供的扩展，例如为特定的资源、文件、管道或共享内存块命名的能力。相比之下，执行体也允许由对象代表的任何资源具备名称。第二个要求，即查找和获取对象的方法，也是通过对象名称满足的。只要对象管理器按照名称存储对象，即可按照名称来查找对象。</p>
<p class="zw">对象名称还可用于满足第三个要求：允许进程共享对象。执行体的对象命名空间是一种全局命名空间，对系统中的所有进程可见。进程可以创建对象并将其名称放入这个全局命名空间，随后另一个进程即可通过指定对象名称的方式打开该对象的句柄。如果对象不以这种方式共享，那么对象的创建者就不应该为对象分配名称。</p>
<p class="zw">为提高效率，对象管理器不会在每次有人使用对象时都查找对象的名称。相反，对象管理器只会在两种情况下查找名称。首先是当进程创建了具名对象时，此时对象管理器会查找名称以验证该名称尚未被使用，随后才会将这个新名称存储在全局命名空间中。其次是当进程打开具名对象的句柄时，对象管理器会查找该名称，找到对象，随后将对象句柄返回给调用方，进而调用方就可以使用句柄引用这个对象。在查找名称时，对象管理器可允许调用方选择进行区分大小写或不区分大小写的搜索功能，该功能为&nbsp;Windows Subsystem for Linux（WSL）和其他需要区分大小写文件名的环境提供了必要的支持。</p>
<h4 class="bt4 sigil_not_in_toc">对象目录</h4>
<p class="zw">对象管理器会使用对象目录（object directory）对象来为具备层次结构的命名机制提供支持。该对象类似于文件系统目录，可包含其他对象的名称，甚至可以包含其他对象目录。对象目录对象维持了足够的信息，借助这些信息可将对象名称转换为指向对象自身对象头的指针。对象管理器使用这些指针来构造返回给用户模式调用方的对象句柄。内核模式代码（包括执行体组件和设备驱动程序）和用户模式代码（例如子系统）都可以创建对象目录并在其中存储对象。</p>
<p class="zw">对象可以存储在命名空间中的任何位置，但某些对象类型始终会出现在特定目录中，因为它们是由专门的组件以特定的方式创建的。例如，I/O管理器会创建名为\Driver的对象目录，其中包含了代表已加载的非文件系统的内核模式驱动程序的对象名称。由于I/O管理器是唯一负责（使用IoCreateDriver API）创建驱动程序对象的组件，因此这里只应该包含驱动程序对象。</p>
<p class="zw">表8-25列出了所有Windows系统中都具备的标准对象目录，以及这些目录中可以存储的对象类型。在下列所有目录中，仅\AppContainerNamedObjects、\BaseNamedObjects和\Global??是可供符合公开API要求的标准Win32或UWP应用程序普遍使用的（详情请参阅“会话命名空间”一节）。</p>
<p class="表题">表8-25　标准对象目录</p>
<table> 
 <tbody> 
  <tr> 
   <th> <p class="bt">目录</p> </th> 
   <th> <p class="bt">存储的对象名称类型</p> </th> 
  </tr> 
  <tr> 
   <td> <p class="bg">\AppContainerNamedObjects</p> </td> 
   <td> <p class="bg">仅出现在非会话0的交互式会话的\Sessions对象目录下，包含在应用容器（App Container）中运行的进程使用Win32或UWP API创建的具名内核对象</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\ArcName</p> </td> 
   <td> <p class="bg">将ARC样式的路径映射为NT样式路径的符号链接</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\BaseNamedObjects</p> </td> 
   <td> <p class="bg">全局互斥、事件、信号量、可等待计时器、作业、ALPC端口、符号链接以及节对象</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\Callback</p> </td> 
   <td> <p class="bg">回调对象（仅驱动程序可以创建）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\Device</p> </td> 
   <td> <p class="bg">大部分驱动程序（文件系统和过滤器管理器设备除外）所拥有的设备对象，外加VolumesSafeForWriteAccess事件和某些符号链接（如SystemPartition和BootPartition）。此外还包含可供内核组件直接访问RAM的PhysicalMemory节对象。最后，还包含某些对象目录，例如Http.sys加速器驱动程序使用的Http，以及每个物理硬盘驱动器的HarddiskN目录</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\Driver</p> </td> 
   <td> <p class="bg">类型非“File System Driver”或“File System Recognizer”（SERVICE_FILE_SYSTEM_ DRIVER或SERVICE_RECOGNIZER_DRIVER）的驱动程序对象</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\DriverStore(s)</p> </td> 
   <td> <p class="bg">可安装和管理操作系统驱动程序的位置对应的符号链接。一般来说，至少会有SYSTEM指向\SystemRoot，但在Windows 10X设备上可包含更多条目</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\FileSystem</p> </td> 
   <td> <p class="bg">文件系统驱动程序对象（SERVICE_FILE_SYSTEM_DRIVER）和文件系统识别程序（SERVICE_RECOGNIZER_DRIVER）驱动程序与设备对象。过滤器管理器也会在Filters对象目录下创建自己的设备对象</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\GLOBAL??</p> </td> 
   <td> <p class="bg">代表MS-DOS设备名称的符号链接对象（\Sessions\0\DosDevices\&lt;LUID&gt;\Global目录是到该目录的符号链接）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\KernelObjects</p> </td> 
   <td> <p class="bg">包含指示内核池资源状况、某些操作系统任务的完成，以及代表每个交互式会话的会话对象（至少会话0）和每个内存分区的分区对象（至少MemoryPartition0）。此外还包含用于对引导配置数据库（BC）进行同步访问所需的互斥。最后，还包含动态符号链接，这些符号链接可以使用自定义回调引用物理内存中正确的分区并提交资源状况，同时还可用于检测内存错误</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\KnownDlls</p> </td> 
   <td> <p class="bg">SMSS启动时映射的已知DLL的节对象，以及包含已知DLL路径的符号链接</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\KnownDlls32</p> </td> 
   <td> <p class="bg">在64位Windows中，\KnownDlls包含原生64位二进制文件，因此该目录可用于存储这些DLL的WoW64 32位版本</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\NLS</p> </td> 
   <td> <p class="bg">已映射的国家语言支持（National Language Support，NLS）表的节对象</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\ObjectTypes</p> </td> 
   <td> <p class="bg">ObCreateObjectTypeEx所创建的每个对象类型的对象类型对象</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\RPC Control</p> </td> 
   <td> <p class="bg">使用本地RPC（ncalrpc）时，创建并用于代表远程过程调用（RPC）端点的ALPC端口。其中包括显式命名的端点以及自动生成的COM（OLEXXXXX）端口名称和未命名端口（LRPC-XXXX，其中XXXX是随机生成的十六进制值）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\Security</p> </td> 
   <td> <p class="bg">特定安全子系统对象使用的ALPC端口和事件</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\Sessions</p> </td> 
   <td> <p class="bg">每会话命名空间目录（参见下一节的介绍）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\Silo</p> </td> 
   <td> <p class="bg">如果已经创建了至少一个Windows Server容器，例如，使用Docker for Windows以及非虚拟机容器，那么此处可包含每个Silo ID（容器的根作业的作业ID）的对象目录，这样随后即可包含Silo本地的对象命名空间</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\UMDFCommunicationPorts</p> </td> 
   <td> <p class="bg">用户模式驱动程序框架（User-Mode Driver Framework，UMDF）所使用的ALPC端口</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\VmSharedMemory</p> </td> 
   <td> <p class="bg">在启动遗留Win32应用程序时，由Win32k.sys的虚拟化实例（VAIL）和Windows 10X中的其他窗口管理器组件使用的节对象。此外也包含代表连接对端的Host对象目录</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">\Windows</p> </td> 
   <td> <p class="bg">Windows子系统ALPC端口、共享节以及WindowStations对象目录中的窗口站。对于会话0以外的会话，桌面窗口管理器（DWM）会将自己的ALPC端口、事件以及共享节存储在该目录中。最后，这里还存储了Themes服务节对象</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">对象名称对计算机（或对多处理器计算机中的所有处理器）来说是全局的，但跨越网络时不可见。不过对象管理器的解析方法可以让我们访问另一台计算机中的具名对象。例如，提供文件对象服务的I/O管理器可将对象管理器的功能拓展给远程文件。当要求打开远程文件对象时，对象管理器会调用一种解析方法，进而让I/O管理器拦截请求并将其交付给网络重定向器（可跨越网络访问文件的驱动程序）。远程Windows系统中的服务器代码会调用自己所在系统中的对象管理器和I/O管理器找到文件对象，并跨越网络返回相关信息。</p>
<p class="zw">由于非应用容器进程通过Win32和UWP API创建的内核对象（例如互斥、事件、信号量、可等待计时器以及节）都将自己的名称存储在单个对象目录中，因此这些对象中的任意两个都不能使用相同名称，哪怕它们属于不同类型。这种限制使得我们必须更慎重地选择名称，以避免与其他名称的冲突。例如，我们可以为名称添加GUID作为前缀，以及/或者将名称与用户的安全标识符（SID）相结合，但即便如此也只能让每个用户的单一应用程序实例受益。</p>
<p class="zw">名称冲突问题看似无关紧要，但在处理具名对象时必须注意一个与安全性有关的问题：对象名称的恶意抢注。虽然不同会话中的对象名称相互间会受到保护，但当前会话命名空间内部并不具备可通过标准Windows API来设置的标准保护措施。这会使得与特权应用程序在同一个会话中运行的非特权应用程序有可能访问高特权应用程序的对象，导致上文对象安全性一节中提到的问题。不幸的是，即便对象创建者使用适当的DACL保护自己的对象，也无法防止恶意抢注攻击，在这种攻击中，非特权应用程序会先于特权应用程序创建对象，从而拒绝合法应用程序的访问。</p>
<p class="zw">为了缓解这种问题，Windows提供了私有命名空间（private namespace）的概念。私有命名空间可以让用户模式应用程序通过CreatePrivateNamespace API创建对象目录，并将这些目录与使用CreateBoundaryDescriptor API创建的边界描述符（boundary descriptor，一种可保护目录的特殊数据结构）关联在一起。这些描述符中包含的SID指定了允许访问对象目录的安全主体。通过这种方式，特权应用程序就可以确信非特权应用程序将无法对自己的对象发起拒绝服务攻击（虽然这种方式无法阻止特权应用程序针对非特权应用程序发起这样的攻击，但这样的攻击毫无意义）。此外，边界描述符还可以包含完整性级别，借此根据进程的完整性级别，保护可能与应用程序属于相同用户账户的其他对象（有关完整性级别的详细信息请参阅卷1第7章）。</p>
<p class="zw">边界描述符可有效缓解恶意抢注攻击的原因之一在于，与对象不同，边界描述符的创建者（在SID和完整性级别两方面）必须具备边界描述符的访问权限。因此非特权应用程序只能创建非特权边界描述符。同理，当一个应用程序想要打开私有命名空间中的对象时，必须使用创建该命名空间的相同边界描述符来打开命名空间。因此，特权应用程序或服务提供的特权边界描述符将无法与非特权应用程序创建的相匹配。</p>
<p class="zwtsh">实验：查看基础具名对象和私有对象</p>
<p class="zwts1">我们可以使用Sysinternals提供的WinObj工具或WinObjEx64来查看具名基础对象列表。不过在本实验中，我们会使用WinObjEx64，因为它支持额外的对象类型，并且可以显示私有命名空间。运行Winobjex64.exe，点击树状列表中的BaseNamedObjects节点，随后可以看到类似下图所示的内容。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3811.png" style="width: 100%" />
<p class="zwts1">右侧列出了具名对象，图标代表了不同的对象类型。</p>
<p class="zwts1"><span style="color: #0092dd">●</span> 互斥会显示为停止符号。</p>
<p class="zwts1"><span style="color: #0092dd">●</span> 节（Windows文件映射对象）会显示为内存芯片。</p>
<p class="zwts1"><span style="color: #0092dd">●</span> 事件会显示为感叹号。</p>
<p class="zwts1"><span style="color: #0092dd">●</span> 信号量会显示为类似交通信号灯的图标。</p>
<p class="zwts1"><span style="color: #0092dd">●</span> 符号链接会显示弯曲的箭头图标。</p>
<p class="zwts1"><span style="color: #0092dd">●</span> 文件夹代表对象目录。</p>
<p class="zwts1"><span style="color: #0092dd">●</span> 电源/网络插头代表ALPC端口。</p>
<p class="zwts1"><span style="color: #0092dd">●</span> 计时器会显示为钟表。</p>
<p class="zwts1"><span style="color: #0092dd">●</span> 各种类型的齿轮、锁、芯片等图标代表其他类型的对象。</p>
<p class="zwts1">随后在Extras菜单下选择Private Namespaces，将能看到类似下图所示的列表。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3819.png" style="width: 100%" />
<p class="zwts1">对于每个对象，我们可以看到边界描述符的名称（例如Installing这个互斥就是LoadPerf边界的一部分）以及相关的一个或多个SID与完整性级别（本例中未明确设置完整性，并且SID包含在Administrators组中）。请注意，为了正常使用该功能，我们必须在运行该工具的计算机上启用（本地或远程）内核调试，因为WinObjEx64需要使用WinDbg的本地内核调试驱动程序读取内核内存。</p>
<p class="zwtsh">实验：篡改单实例应用程序的“单开”行为</p>
<p class="zwts1">Windows Media Player以及Microsoft Office等应用程序是通过具名对象实现单实例运行方式最常见的例子。我们发现，当启动Wmplayer.exe可执行文件时，Windows Media Player只会出现一次，再次尝试启动只能让已经启动的窗口切换至最前端。我们可以使用Process Explorer篡改句柄列表，将计算机变成混音器！方法如下。</p>
<p class="zwts1">1）启动Windows Media Player和Process Explorer，查看句柄表（点击View-Lower Pane View&nbsp;和&nbsp;Handles）。随后应该能看到一个名称中包含Microsoft_WMP_70_ CheckForOtherInstanceMutex的句柄，如下图所示。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3826.png" style="width: 100%" />
<p class="zwts1">2）右键点击该句柄并选择Close Handle，询问时确认该操作。注意，需要以管理员身份启动Process Explorer才能关闭其他进程的句柄。</p>
<p class="zwts1">3）再次运行Windows Media Player，这次会创建第二个进程。</p>
<p class="zwts1">4）分别在每个实例中播放不同的歌曲。我们也可以使用系统托盘中的混音器（点击<strong style="color:#0092dd">音量</strong>图标）增大任意一个进程的音量，进而产生混音的效果。</p>
<p class="zwts1">应用程序可以先于Windows Media Player运行并创建具备相同名称的对象，而非关闭具名对象的句柄。这种情况下，Windows Media Player将永远无法运行，因为它会以为自己已经在系统中运行了。</p>
<h4 class="bt4 sigil_not_in_toc">符号链接</h4>
<p class="zw">在某些文件系统（例如NTFS，以及Linux和macOS的文件系统）中，符号链接（symbolic link）可以让用户创建一种文件名或目录名，在使用这些名称时，操作系统会将名称转换为不同的文件或目录名。符号链接是一种简单的方法，可以帮助用户以间接的方式共享文件或目录内容，在原本具备层级的目录结构的不同目录之间创建交叉链接。</p>
<p class="zw">对象管理器实现了一种名为符号链接的对象，这种对象可对自己对象命名空间中的名称产生类似的作用。符号链接可以出现在对象名称字符串中的任意位置。当调用方引用符号链接的对象名称时，对象管理器会遍历其对象命名空间，直到抵达符号链接对象。对象管理器会查看符号链接的内容，查找可替代该符号链接名称的字符串，然后重新开始查找名称。</p>
<p class="zw">执行体会在一个地方使用符号链接对象：将MS-DOS样式的设备名称转换为Windows内部设备名称。在Windows中，用户可以使用“C:”“D:”这样的名称代表硬盘驱动器，并使用“COM1”“COM2”这样的名称代表串口。Windows子系统会创建这些符号链接对象，并将其放置在对象管理器命名空间的\Global??目录下，也可以通过DefineDosDevice API为其他驱动器盘符执行类似的操作。</p>
<p class="zw">某些情况下，符号链接的底层目标并非静态的，而是可能取决于调用方的上下文。例如，旧版本Windows在\KernelObjects目录下有一个名为LowMemoryCondition的事件，但由于内存分区（详见卷1第5章）的引入，事件信号的条件现在取决于调用方具体是在哪个分区中运行（以及能看到哪些分区）的。因此，现在每个内存分区都有一个LowMemoryCondition事件，调用方必须重定向至自己所在分区对应的事件。这是通过对象上一个特殊的标记、缺乏目标字符串，以及对象管理器每次解析链接时执行的符号链接回调多方因素共同作用实现的。借助WinObjEx64，我们可以看到已注册的回调，如图8-36所示（此外也可以在调试器中运行!object \KernelObjects\LowMemoryCondition命令并使用dx命令转储_OBJECT_SYMBOLIC_LINK结构）。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3835.png" style="width: 100%" />
<p class="图题">图8-36　LowMemoryCondition符号链接重定向回调</p>
<h4 class="bt4 sigil_not_in_toc">会话命名空间</h4>
<p class="zw">服务可以完整访问全局（global）命名空间，该全局命名空间也是命名空间的第一个实例。随后，常规的用户应用程序即可对这个全局命名空间进行读/写（但无法删除）访问（但也有少量例外，下文将会介绍）。然而接下来，交互式用户会话会被分配一个该命名空间的“会话专用”视图，这也叫本地（local）命名空间。本地命名空间为会话中运行的所有应用程序提供了基础具名对象的读取/写入访问权限，并可用于隔离与某些Windows子系统有关的对象（特权对象）。每个会话的本地化命名空间包括\DosDevices、\Windows、\BaseNamedObjects以及\AppContainerNamedObjects。</p>
<p class="zw">为命名空间中相同的部分创建单独副本，这个过程也叫命名空间的实例化（instancing）。对\DosDevices进行实例化，即可让用户获得不同的网络驱动器盘符和Window对象（例如串口）。在Windows中，全局\DosDevices目录名为\Global??，\DosDevices实际上就指向了这个目录，本地\DosDevices目录则是由登录会话ID加以区分的。</p>
<p class="zw">Win32k.sys会将Winlogon创建的交互式窗口站\WinSta0插入\Windows目录中。一个终端服务环境可以为多个交互式用户提供支持，但每个用户需要通过单独版本的WinSta0来维持一种“错觉”，让用户以为自己正在访问Windows中预定义的交互式窗口站。最后，常规的Win32应用程序和系统还会在\BaseNamedObjects中创建共享的对象，包括事件、互斥及内存节。如果两个用户正在运行同一个会创建具名对象的应用程序，那么每个用户会话必须具备该对象的私有版本，这样该应用程序的两个实例才不会因为访问同一个对象而相互干扰。然而，如果通过AppContainer运行Win32应用程序，或应用程序属于UWP应用程序，沙盒机制会阻止应用程序访问\BaseNamedObjects，此时将使用\AppContainerNamedObjects这个对象目录代替，而该目录也进一步包含更多子目录，其名称完全与AppContainer的Package SID保持对应（有关AppContainer和Windows沙盒模型的详细信息，请参阅本书卷1第7章）。</p>
<p class="zw">通过在\Sessions\n（其中n是会话标识符）下与用户会话相关的目录中创建上文提到的4个目录的私有版本，对象管理器实现了本地命名空间。例如，当远程会话2中的一个Windows应用程序创建了一个具名事件后，Win32子系统（作为Kernelbase.dll中BaseGetNamedObjectDirectory API的一部分）会以透明的方式将对象名称从\BaseNamedObjects重定向为\Sessions\2\BaseNamedObjects，或者对于AppContainer会重定向为\Sessions\2\ AppContainerNamedObjects\&lt;PackageSID&gt;\。</p>
<p class="zw">访问具名对象的另一种方法是使用一项名为基础具名对象隔离（Base Named Object Isolation）的安全功能。父进程可以使用ProcThreadAttributeBnoIsolation进程属性启动子进程（有关进程启动属性的详情可参阅卷1第3章），并提供自定义对象目录前缀。这也使得KernelBase.dll能够创建目录并初始化一组对象（例如符号链接）为其提供支持，随后让NtCreateUserProcess在子进程的Token对象中通过原生版本进程属性数据设置前缀和相关初始句柄（更具体来说需要设置BnoIsolationHandlesEntry字段）。</p>
<p class="zw">随后，BaseGetNamedObjectDirectory会查询Token对象以检查BNO隔离是否已启用，如果已启用，则会将该前缀附加给任何具名对象操作，举例来说，这会让\Sessions\2\ BaseNamedObjects变为\Sessions\2\BaseNamedObjects\IsolationExample。因此，无须使用AppContainer功能即可为进程创建沙盒。</p>
<p class="zw">所有与命名空间管理有关的对象管理器功能均能感知实例化的目录，并参与营造出一种所有会话都使用了同一个命名空间的“假象”。由Windows应用程序传递的Windows子系统DLL前缀名会使用\??来引用\DosDevices目录中的对象（例如C:\Windows会变为\??\C:\Windows）。当对象管理器看到特殊的\??前缀后，随后要执行的操作取决于具体的Windows版本，但始终会依赖执行体进程对象（EPROCESS，详见卷1第3章）中一个名为DeviceMap的字段，该字段会指向同一个会话中其他进程共享的数据结构。</p>
<p class="zw">DeviceMap结构的DosDevicesDirectory字段会指向代表进程本地\DosDevices的对象管理器目录。当对象管理器看到对\??的引用后，便会使用DeviceMap结构的DosDevicesDirectory字段定位进程的本地\DosDevices。如果对象管理器在该目录中未找到对象，随后会检查目录对象的DeviceMap字段。如果该字段有效，则会在DeviceMap结构的GlobalDosDevicesDirectory字段所指向的目录（始终为\Global??）中查找对象。</p>
<p class="zw">在某些情况下，即使应用程序运行在另一个会话中，可感知会话的应用程序可能依然需要访问全局会话中的对象。应用程序这样做，可能是为了与自己运行在远程会话中的其他实例，或与控制台会话（即会话0）同步。对于这些情况，对象管理器提供了一种特殊的覆盖\Global，应用程序可以在任何对象名称前添加前缀，进而访问该全局命名空间。例如，当会话&nbsp;2&nbsp;中的应用程序打开一个名为\Global\ApplicationInitialized&nbsp;的对象时，会被重定向至\BaseNamedObjects\ApplicationInitialized，而非\Sessions\2\BaseNamedObjects\ApplicationInitialized。</p>
<p class="zw">希望访问全局\DosDevices目录中对象的应用程序，只要对象并非存在于自己的本地\DosDevices目录中，就无须使用\Global前缀。这是因为，如果在本地目录中找不到，那么对象管理器会自动在全局目录中查找对象。不过应用程序也可以使用\GLOBALROOT来强制在全局目录中查找。</p>
<p class="zw">会话目录之间会彼此隔离，但正如上文所述，常规的用户应用程序也可以创建带有\Global前缀的全局对象。不过这方面还存在一个重要的安全缓解措施，即节和符号链接对象无法以全局方式创建，除非调用方运行在会话0中；或者如果调用方具备一个名为Create global object的特殊权限，除非对象的名称被包含在一个“未保护名称”授权列表中（该列表存储在注册表HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\kernel键的ObUnsecureGlobalNames值中）。默认情况下，这些名称通常包括：</p>
<p class="zwd"><span style="color: #0092dd">●</span> netfxcustomperfcounters.1.0；</p>
<p class="zwd"><span style="color: #0092dd">●</span> SharedPerfIPCBlock；</p>
<p class="zwd"><span style="color: #0092dd">●</span> Cor_Private_IPCBlock；</p>
<p class="zwd"><span style="color: #0092dd">●</span> Cor_Public_IPCBlock_。</p>
<p class="zwtsh">实验：查看命名空间的实例化</p>
<p class="zwts1">我们登录后即可看到会话0命名空间与其他会话命名空间之间所存在的隔离。原因在于第一个控制台用户会登录至会话1（服务则运行在会话0中）。以管理员身份运行Winobj.exe并点击\Sessions目录，随后即可看到一个子目录，其中列出了每个活跃会话的数值名称。如果打开其中一个目录，就可以看到名为DosDevices、Windows、AppContainerNamedObjects以及BaseNamedObjects的子目录，这些就是对应会话的本地命名空间子目录。本地命名空间如下图所示。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3842.png" style="width: 100%" />
<p class="zwts1">随后运行Process Explorer，选择我们自己会话中的一个进程（例如Explorer.exe）并查看其句柄表（点击View→Lower Pane View，随后点击Handles）。我们应该可以在\Sessions\n（其中“n”是会话ID）下看到一个到\Windows\WindowStations\WinSta0的句柄。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3849.jpg" style="width: 100%" />
<h4 class="bt4 sigil_not_in_toc">对象过滤</h4>
<p class="zw">Windows在对象管理器中包含了一个过滤器模型，该模型有些类似于将在第10章介绍的文件系统微型过滤器模型以及注册表回调。该过滤模型所提供的主要价值之一在于，借此能够使用现有过滤技术中使用的海拔高度（altitude）概念<sup>[6]</sup>，这意味着在整个过滤栈上，可以由多个驱动程序在相应的位置对对象管理器的事件进行过滤。此外，该模型还可以让驱动程序拦截诸如NtOpenThread和NtOpenProcess之类的调用，甚至可以修改从进程管理器处获取的访问掩码。以此可防止对打开的句柄执行某些操作，例如防止恶意软件终止善意的安全进程或阻止密码转储应用程序，以获取对LSA进程内存进行读取的权限。不过要注意，由于兼容性方面的原因，读取操作是无法彻底阻止的，例如，无法借此让任务管理器不能查询命令行或进程的映像名。</p>
<p class="footnote">[6]此处所说的“海拔高度”是一种以十进制数字形式表示的无限精度字符串，决定了微型过滤器驱动程序在系统启动时的加载位置。简单来说，可以将从最底层物理硬件到最上层应用的整个I/O栈看成一座山，海拔高度数值越低的驱动程序，加载到的位置越靠近“地面”。当数据沿着I/O栈传输时，可被不同海拔高度的驱动程序按顺序依次过滤处理。——译者注</p>
<p class="zw">此外，驱动程序还可以充分利用前回调（pre callback）和后回调（post callback），进而在某个操作发生之前为其做好准备，并在操作发生后做出反应或确定最终信息。每个操作都可以指定这些回调（目前仅支持打开、创建和复制），并且可以针对每种对象类型进行指定（目前仅支持进程、线程和桌面对象）。对于每个回调，驱动程序可以指定自己的内部上下文值，该值可跨越所有调用返回给驱动程序，甚至跨越前后回调对。这些回调可以使用ObRegisterCallbacks API注册，并使用ObUnregisterCallbacks API撤销注册，驱动程序需要负责保证切实执行了取消注册操作。</p>
<p class="zw">这些API的使用仅限符合下列这些特征的映像：</p>
<p class="zwd"><span style="color: #0092dd">●</span> 即使在32位计算机上，也必须根据内核模式代码签名（KMCS）策略中规定的相同规则对映像签名。映像编译时需使用/integritycheck链接器标记，该标记会在PE头中设置IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY值。借此可以让内存管理器检查映像签名，而无须考虑其他默认设置是否会导致不进行检查。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 必须使用包含可执行代码加密后每页面哈希的编录对映像签名，这样系统即可检测出加载到内存中之后的映像是否产生了什么变化。</p>
<p class="zw">在执行回调前，对象管理器会在目标函数指针上调用MmVerifyCallbackFunction，进而定位与拥有该地址的模块关联的加载器数据表条目，并验证LDRP_IMAGE_INTEGRITY_ FORCED标记是否已设置。</p>

<p class="epubit-contents-id" style="display: none">{"index":1,"parentId":"6399eadf-b329-4125-b132-dff6515a2e34","id":"6dad815e-21c8-4d08-8905-fc4abf917989"}</p>