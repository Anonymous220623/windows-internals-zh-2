<h2 class="bt2" id="sigil_toc_id_33"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/bt2.png" style=""> 8.7　同步</h2>
<p class="zw">互相排斥（mutual exclusion）是操作系统开发过程中的一个关键概念。互相排斥是指确保同一时间有且仅有一个线程可以访问特定资源。当资源本身不适合共享访问或共享可能导致不可预测的结果时，互相排斥就很有必要了。举例来说，如果两个线程同时将一个文件复制到打印机端口，则可能会输出相互穿插的结果。类似地，如果当一个线程读取某个内存位置的同时，另一个线程在写入该内存位置，第一个线程将会收到无法预测的数据。一般来说，可写资源不能无限制地共享，而无须修改的资源是可以这样共享的。图8-37展示了当运行在不同处理器上的两个线程同时向一个循环队列写入数据会发生的事情。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3856.png" style="width: 100%" />
<p class="图题">图8-37　内存的错误共享方式</p>
<p class="zw">因为第二个线程在第一个线程更新操作完成前已经获得了队列尾部指针的值，所以它将自己的数据插入第一个线程所在的相同位置，进而覆盖数据并导致一个队列位置为空。虽然图8-37展示的是多处理器系统中可能发生的情况，但如果操作系统在第一个线程更新队列尾部指针之前就将上下文切换到第二个线程，单处理器系统也会发生类似的问题。</p>
<p class="zw">访问不可共享资源的代码片段，也可称为临界区（critical section）。为保证代码正确，临界区中一次只能执行一个线程。当一个线程正在写入文件、更新数据库或修改共享的变量时，其他线程均不能访问相同的资源。图8-37所示的伪代码就是一个在不存在互相排斥的情况下以错误方式访问共享数据结构的临界区。</p>
<p class="zw">尽管互相排斥问题对大部分操作系统来说都很重要，但对Windows这种紧密耦合的对称多处理器（SMP）操作系统来说尤其重要（且非常复杂）。因为在这种操作系统中，相同的系统代码会同时运行在多个处理器上，且需要共享存储全局内存中的某些数据结构。Windows内核的作用是提供一种机制，系统代码可以通过这种机制防止两个线程同时修改同一个数据。内核提供了互相排斥的基元，内核与执行体的其他部分可以实现全局数据结构的同步访问。</p>
<p class="zw">由于调度程序需要在DPC/Dispatch这个IRQL级别上对其数据结构进行同步访问，因此，当IRQL为DPC/Dispatch级别或更高级别（提升级别或高IRQL级别）时，内核与执行体将无法依赖那些可能导致页面错误或需要通过重调度操作实现数据同步访问的同步机制。下文将介绍当IRQL为高级别时，内核与执行体如何使用互相排斥机制保护自己的全局数据结构，以及当IRQL为低级别（低于DPC/Dispatch级别）时内核与执行体会使用怎样的互相排斥与同步机制。</p>

<p class="epubit-contents-id" style="display: none">{"index":6,"parentId":"18136782-cc9e-4447-8382-748342e5e95c","id":"43511468-38ec-4124-81b4-e83ab1356f97"}</p>