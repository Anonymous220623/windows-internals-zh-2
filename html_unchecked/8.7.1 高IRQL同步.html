<h3 class="bt3" id="sigil_toc_id_34">8.7.1　高IRQL同步</h3>
<p class="zw">在执行过程的不同阶段，内核必须保证同一时间有且仅有一个进程正在临界区中执行。内核临界区是一种可以修改全局数据结构（例如内核的调度程序数据库或其DPC队列）的代码片段。除非内核能保证线程能够以互相排斥的方式访问这些数据结构，否则操作系统将无法正常运行。</p>
<p class="zw">这方面最大的担忧来自中断。举例来说，内核可能正在更新全局数据结构，但此时发生的一个中断，其中断处理例程也更改了这个结构。简单的单处理器操作系统有时会禁止这种操作，为此只需要在自己访问全局数据时禁用所有中断即可，但Windows内核使用了一种更成熟的解决方案。在使用全局资源之前，内核会暂时屏蔽同样会使用该资源的中断处理程序所对应的中断。为此，内核会将处理器的IRQL提高至有可能访问该全局数据的任何潜在中断来源使用的最高IRQL级别。例如，一个位于DPC/Dispatch级别的中断会导致调度程序通过调度程序数据库开始运行，因此，内核中任何需要使用调度程序数据库的其他部分，只要将IRQL提高至DPC/Dispatch级别，就可以在自己使用调度程序数据库之前屏蔽所有DPC/Dispatch级别的中断。</p>
<p class="zw">这种策略适合单处理器系统，但并不适合多处理器系统。在一个处理器上提高IRQL并不能防止其他处理器产生中断。内核还需要保证能跨越多个处理器实现互相排斥的访问。</p>
<h4 class="bt4 sigil_not_in_toc">互锁操作</h4>
<p class="zw">同步机制的最简单形式依赖于硬件对整数值的多处理器安全操作和执行比较能力所提供的支持。这些支持包括InterlockedIncrement、InterlockedDecrement、InterlockedExchange以及InterlockedCompareExchange等函数。举例来说，InterlockedDecrement函数会使用x86和x64的Lock指令前缀（如lock xadd），借此在执行加法操作期间锁定多处理器总线，进而让另一个同时修改该内存位置以进行减法操作的处理器在“减法处理器读取原始值”和“将相减后的值写入”这两个操作之间无法修改内存。内核与驱动程序都使用了这种形式的基本同步。在目前的微软编译器套件中，这些函数也被称为内部函数，因为这些函数的代码是在编译阶段通过内联汇编器直接生成的，而非通过函数调用生成（将参数推送到栈中，调用函数，将参数复制到寄存器，随后将参数从栈中取出并返回给调用方，这一系列操作的开销很可能远高于这些函数最初实际需要承担的工作）。</p>
<h4 class="bt4 sigil_not_in_toc">自旋锁</h4>
<p class="zw">内核用于实现多处理器互相排斥的机制叫作自旋锁（spinlock）。自旋锁是一种与全局数据结构关联的锁定基元，例如，图8-38所示的DPC队列就是一种自旋锁。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx3864.png" style="width: 100%" />
<p class="图题">图8-38　自旋锁的使用</p>
<p class="zw">在进入图8-38所示的任何一个临界区之前，内核必须获得与受保护DPC队列相关的自旋锁。如果自旋锁非空闲，内核会持续尝试获取锁，直到成功。自旋锁之所以使用这个名称是因为内核（以及处理器）会等待它“旋转”，直到自己获得该锁。</p>
<p class="zw">自旋锁与它所保护的数据结构一样，都位于映射到系统地址空间的非分页内存中。获取和释放自旋锁的代码使用汇编语言编写，这主要是为了提高速度并充分利用底层处理器架构所提供的各种锁定机制。在很多体系结构中，自旋锁是通过硬件支撑的测试和设置（test-and-set）操作实现的，会测试锁变量的值，并通过一条原子指令获取锁。通过一条指令测试并获取锁，可以防止第二个线程在“第一个线程测试变量”以及“第一个线程获得锁”两个操作期间得到该锁。另外，诸如上文提到的Lock这样的硬件指令也可用于测试和设置操作，进而让x86和x64处理器的lock bts操作码组合在一起，同样可用于锁定多处理器总线，否则，可能会有许多个处理器将以原子化的方式执行该操作（如果不使用锁，则只能在当前处理器上保证该操作的原子性）。类似地，在ARM处理器上，也可以用类似的方式使用ldrex和strex等指令。</p>
<p class="zw">Windows中的所有内核自旋锁都有一个关联的IRQL，并且始终处于DPC/Dispatch级别或更高级别。因此，当线程试图获取自旋锁时，该处理器上所有与自旋锁处于相等或更低IRQL的操作都将停止。由于线程的调度是在DPC/Dispatch级别上进行的，因此，持有自旋锁的线程将永远不会被抢占，因为该IRQL会屏蔽调度机制。这种屏蔽使得在受到自旋锁保护的临界区中运行的代码可以继续执行，只有这样，才能更快地释放锁。内核对自旋锁的使用非常慎重，会最大限度地减少在持有自旋锁情况下执行的指令数量。任何试图获取自旋锁的处理器基本上都会很繁忙，会陷入无尽的等待，消耗电量（繁忙的等待会导致CPU 100%占用率），但无法执行任何实际工作。</p>
<p class="zw">在x86和x64处理器上，可以在繁忙的等待循环中插入一个特殊的Pause汇编指令；而在ARM处理器上，可通过Yield实现类似效果。这个指令可以告知处理器正在处理的循环指令是自旋锁（或类似构造）获取循环的一部分。这种指令可以提供三个好处。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 通过让核心略微延迟而非不断循环，可显著降低能耗。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 在SMT内核上，可以让CPU意识到旋转逻辑内核所做的“工作”并不是非常重要的，因而可将更多的CPU时间分配给第二个逻辑内核。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 由于繁忙的等待循环会导致从发出等待的线程到总线的读取请求风暴（可能是乱序生成的），因此，CPU在检测到写入操作（也就是当拥有锁的线程释放锁）之后，会试图尽快纠正内存乱序的情况。因此，一旦自旋锁被释放，CPU就会对任何挂起的内存读取操作重排序，以保证顺序的正确。这个重排序会导致系统性能的巨大损耗，但可通过Pause指令避免。</p>
<p class="zw">如果内核检测到自己运行在可支持自旋锁启发（详见第9章）且兼容Hyper-V的虚拟机监控程序中，当检测到自旋锁当前由另一个CPU拥有时，自旋锁设施可以使用HvlNotifyLongSpinWait库函数，而无须继续旋转并使用Pause指令。该函数会发出一个HvCallNotifyLongSpinWait虚拟化调用（Hypercall），借此告知虚拟机监控程序调度器，应该由另一个虚拟处理器接管，而不应模拟旋转。</p>
<p class="zw">内核通过一组内核函数（包括KeAcquireSpinLock和KeReleaseSpinLock）让自旋锁可被执行体的其他部分所用。例如，设备驱动程序需要自旋锁来保证，设备寄存器和其他全局数据结构一次只能被设备驱动程序的一个部分（并且仅通过一个处理器）访问。自旋锁无法被用户程序使用，用户程序应该使用下一节将要介绍的对象。设备驱动程序还需要保护自己的数据结构不受相关中断的影响。由于自旋锁API通常只将IRQL提升至DPC/ Dispatch级别，这还不足以防止中断。因此，内核还会导出KeAcquireInterruptSpinLock和KeReleaseInterruptSpinLock API，它们可将本章开头介绍的KINTERRUPT对象作为参数。系统会在中断对象内部查找与中断关联的DIRQL，并将IRQL提升至适当的级别以确保能正确地访问与ISR共享的结构。</p>
<p class="zw">设备还可以使用KeSynchronizeExecution API将整个函数与ISR同步，而不仅仅只同步一个临界区。任何情况下，中断自旋锁保护的代码都必须以极快的速度执行，任何延迟会导致高于正常的中断延迟，并会大幅影响性能。</p>
<p class="zw">内核自旋锁对使用自己的代码进行了一定限制。如上文所述，由于自旋锁始终具备DPC/Dispatch或更高级别的IRQL，因此，如果试图让调度器执行调度操作，或如果导致页面错误，持有自旋锁的代码会让整个系统崩溃。</p>
<h4 class="bt4 sigil_not_in_toc">队列自旋锁</h4>
<p class="zw">为提高自旋锁的可扩展性，很多情况下会使用一种名为队列自旋锁（queued spinlock）的特殊自旋锁来替代标准自旋锁，尤其是在预计会发生争用且需要保证公平性的情况下。</p>
<p class="zw">队列自旋锁工作方式如下：当处理器想要获取当前正被其他处理器持有的队列自旋锁时，会将自己的标识符放入一个与该自旋锁关联的队列中。当持有该自旋锁的处理器释放锁后，该锁会被交给队列中标识出的下一个处理器。同时，如果处理器正在等待忙碌的自旋锁，它并不会检查自旋锁本身的状态，而是会检查该队列中排在自己前面的每个处理器所设置的每处理器标记的状态，以此了解自己的等待何时会结束。</p>
<p class="zw">队列自旋锁会在每个处理器标记上旋转，而非在全局自旋锁上旋转，这一事实会产生两个影响。首先，多处理器的总线不会被处理器之间的同步严重占用，并且位的内存位置不在单个NUMA节点中，因此必须通过每个逻辑处理器的缓存才能窥探。其次，不再只能由等待组中的随机处理器获得自旋锁，队列自旋锁强制让处理器以先进先出（FIFO）的顺序获得锁。FIFO顺序意味着当多个处理器访问同一个锁时可以实现更一致的性能（公平性）。虽然减小总线流量和提高公平性都是很大的好处，但队列自旋锁也会产生额外的开销，包括额外的互锁操作都会增加成本。开发者必须权衡管理负担和好处，以决定是否值得使用队列自旋锁。</p>
<p class="zw">Windows使用了两种类型的队列自旋锁。第一类仅用于内核内部，第二类还能被外部和第三方驱动程序使用。首先，Windows定义了一系列全局队列自旋锁，为此会将指向这些自旋锁的指针存储到每个处理器的处理器控制区（PCR）所包含的数组中。例如在x64系统中，这些指针会被存储在KPCR数据结构的LockArray字段。</p>
<p class="zw">全局自旋锁可通过调用KeAcquireQueuedSpinLock获取，并需指定指向存储了自旋锁指针的数组索引。全局自旋锁的数量最初在每个版本的操作系统中都有所增加，但随着时间的推移，开始使用更高效的锁层级，不再需要全局每处理器锁定（global per-processor locking）。我们可以在WDK头文件Wdm.h的KSPIN_LOCK_QUEUE_NUMBER枚举中查看这些锁的索引定义表，然而请注意，通过设备驱动程序获取这样的一个队列自旋锁，已经是一种不受支持且不建议使用的操作。毕竟这些锁是为内核的内部使用而保留的。</p>
<p class="zwtsh">实验：查看全局队列自旋锁</p>
<p class="zwts1">我们可以使用内核调试器命令!qlocks来查看全局队列自旋锁（被每个处理器的PCR中的队列自旋锁数组指向的自旋锁）的状态。在下列范例中请注意，任何处理器都没有获得任何锁，对于进行实时调试的本地系统来说，这是一种非常标准的情况。</p>
<pre class="代码无行号"><code>lkd&gt; !qlocks 
Key: O = Owner, 1-n = Wait order, blank = not owned/waiting, C = Corrupt
　
                       Processor Number 
    Lock Name         0  1  2  3  4  5  6  7 
　
KE   - Unused Spare 
MM   - Unused Spare 
MM   - Unused Spare 
MM   - Unused Spare 
CC   - Vacb 
CC   - Master 
EX   - NonPagedPool 
IO   - Cancel 
CC   - Unused Spare </code></pre>
<h4 class="bt4 sigil_not_in_toc">队列自旋锁的入栈</h4>
<p class="zw">设备驱动程序可通过KeAcquireInStackQueuedSpinLock和KeReleaseInStackQueuedSpinLock函数使用动态分配的队列自旋锁。一些组件（包括缓存管理器、执行体池管理器以及NTFS）会使用此类锁，而不是全局队列自旋锁。</p>
<p class="zw">KeAcquireInStackQueuedSpinLock可接收指向自旋锁数据结构的指针和自旋锁队列的句柄。自旋锁队列的句柄实际上是一种数据结构，内核会在其中存储有关锁状态的信息，包括锁的所有者，以及正在排队等待该锁变为可用状态的处理器。因此，该句柄不应是全局变量，它通常是一种栈变量，能对调用方线程提供有保证的本地性，并负责自旋锁的InStack部分以及API名称。</p>
<h4 class="bt4 sigil_not_in_toc">读取方/写入方自旋锁</h4>
<p class="zw">虽然使用队列自旋锁可大幅改善高争用情况下的延迟，但Windows还支持另一种自旋锁，可消除很多情况下的争用，进一步提供更多好处。多读单写自旋锁也叫执行自旋锁（executive spinlock），是对常规自旋锁增强后的产物，可通过ExAcquireSpinLockExclusive、ExAcquireSpinLockShared API及其ExReleaseXxx等价物暴露。此外还有可用于更多高级用例的ExTryAcquireSpinLockSharedAtDpcLevel和ExTryConvertSharedSpinLockToExclusive函数。</p>
<p class="zw">顾名思义，此类锁可在不存在写入方的情况下以非争用共享的方式获取自旋锁。如果锁具备写入方，读取方最终必须释放锁，并且在写入方活跃的情况下不允许进一步产生读取方（也不会有其他写入方）。举例来说，如果驱动程序开发者发现自己经常需要对链表进行迭代，但很少需要插入或删除内容，则大部分情况下都可通过此类锁消除争用，从而避免使用更复杂的队列自旋锁。</p>
<h4 class="bt4 sigil_not_in_toc">执行体互锁操作</h4>
<p class="zw">为执行更高级的操作（如在单链表和双链表中添加和删除条目），内核提供了一些在自旋锁基础上构建的简单同步函数。例如用于单链表的ExInterlockedPopEntryList和ExInterlockedPushEntryList，以及用于双链表的ExInterlockedInsertHeadList和ExInterlockedRemoveHeadList。此外还有其他函数，如ExInterlockedAddUlong和ExInterlockedAddLargeInteger。所有这些函数都要将一个标准自旋锁作为参数，并在整个内核与设备驱动程序代码中使用。</p>
<p class="zw">这些函数并不依赖标准API来获取和释放自旋锁参数，而是会将所需代码嵌入函数中，并使用不同的排序方案。为此，Ke自旋锁API会首先测试并设置位，以查看该锁是否已被释放；随后会以原子性的方式执行一个锁测试和设置操作，以便获取该锁，这些例程会禁用处理器上的中断并立即尝试进行原子性的测试与设置。如果最初的尝试失败，则会再次启用中断，并继续使用标准的忙碌等待算法，直到测试和设置操作返回“0”，此时整个函数都会再次重启动。由于存在这些细微差异，用于执行体互锁函数的自旋锁绝对不能与上文介绍过的标准内核API结合使用。当然，非互锁操作也不能与互锁操作混用。</p>
<table> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　某些执行体互锁操作会在可能的情况下静默地忽略自旋锁。例如ExInterlockedIncrementLong或ExInterlockedCompareExchange API会使用与标准互锁函数和内部函数相同的锁前缀。这些函数在锁操作不适合或不可用的老系统（如非x86系统）中很有用。因此这些调用现已被弃用，并以静默的方式通过内联为内部函数提供支持。</p> </td> 
  </tr> 
 </tbody> 
</table>

<p class="epubit-contents-id" style="display: none">{"index":0,"parentId":"43511468-38ec-4124-81b4-e83ab1356f97","id":"8d8c4ed8-d27d-4df1-bbdb-bfb3e83bd4ca"}</p>