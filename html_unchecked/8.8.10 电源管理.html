<h3 class="bt3" id="sigil_toc_id_46">8.8.10　电源管理</h3>
<p class="zw">正如上文提到的，在供电能力有限的环境（如移动平台）中运行时，Windows会通过多种技术更好地管理能耗和处理器可用性，例如，在支持的架构（如&nbsp;ARM64&nbsp;的big.LITTLE<sup>[7]</sup>）上采用异构处理，以及通过新型待机等方式进一步降低系统在轻量级负载下的能耗。</p>
<p class="footnote">[7]即所谓的“大小核”：在一个“处理器”中同时配备多个“性能核（大核）”和“能效核（小核）”，并根据需求动态地选择适合的内核来运行。目前一些较新的处理器均采用了类似技术，如ARM64的big.LITTLE以及Intel的Performance Hybrid Architecture（性能混合架构）。——译者注</p>
<p class="zw">为了更好地支持这些机制，ALPC额外实现了两个功能：ALPC客户端将唤醒引用（wake reference）推送至自己ALPC服务器唤醒通道的能力，以及Work On Behalf Of（代表xxx工作）这一新属性。后者是一个属性，当发送方需要将请求与当前工单关联在一起，或新建工单来描述发送消息的线程时，即可选择为消息关联该属性。</p>
<p class="zw">这种工单的用法如下：举例来说，当发送方目前是作业对象的一部分（可能因为作业位于Silo/Windows容器中，或发送方是异构调度系统和新型待机系统的一部分）时，发送方与线程的关联会导致系统多个部分将CPU周期、I/O请求数据包、磁盘/网络带宽的使用，以及能耗的估测值归因于“所代表”的线程，而非实际承担工作的线程。</p>
<p class="zw">此外，为避免big.LITTLE优先级倒置问题（出现这种问题时，RPC线程会仅仅因为自己是后台服务而被卡在小核心上），系统还会采取前台优先级捐赠和其他调度步骤。通过使用工单，线程会被强行调度至大核心，并获得一个“捐助”而来的前台提升。</p>
<p class="zw">最后，还可以使用唤醒引用来避免系统进入新型待机（也叫现代待机，详见卷1第6章）状态时，或者当UWP应用程序成为被挂起的目标时遭遇死锁。这些引用可将拥有ALPC端口的进程寿命“固定起来”，以此防止进程生命周期管理器（或电源管理器，针对Win32应用程序）试图针对这些进程强制执行挂起/深度冻结操作。一旦消息传递并处理完毕，唤醒引用即可被丢弃，这样，如果需要，就可以让进程挂起了（回想一下可知，终止进程不会造成问题，因为向已终止进程/已关闭端口发送消息，会通过特殊的PORT_CLOSED回复立即唤醒发送方，而不会阻塞并等待一个永远不会到来的回应）。</p>

<p class="epubit-contents-id" style="display: none">{"index":9,"parentId":"e3feacd9-ccbb-4c83-b36b-bb1c5293963c","id":"587db4a6-f18f-48f3-a18e-817bb5689ae5"}</p>