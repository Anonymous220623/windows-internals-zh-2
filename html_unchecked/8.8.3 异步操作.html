<h3 class="bt3" id="sigil_toc_id_39">8.8.3　异步操作</h3>
<p class="zw">ALPC的同步模型与早期NT设计中的原始LPC架构有所关联，并且与诸如Mach端口等其他阻塞式IPC机制较为类似。尽管设计上很简单，但阻塞式IPC算法包含很多死锁的可能性，为了应对这些情况，产生了很多复杂代码，因而需要更灵活的异步（非阻塞）模型。因此ALPC主要设计为同时也能支持异步操作，这是可扩展的RPC和其他用途所必需的，例如，在用户模式驱动程序中支持挂起I/O。ALPC还有一项基本功能，即阻塞具备超时参数的调用，这在最初的LPC中并未实现。借此，遗留应用程序即可避免某些死锁场景。</p>
<p class="zw">然而，ALPC也为异步消息进行了优化，并为异步通知提供了三种不同的模型。第一种模型实际上并不通知客户端或服务器，而是直接复制数据载荷。在该模型下，需要由实现方来选择可靠的同步方法。例如，客户端和服务器可以共享同一个通知事件对象，或者客户端可以轮询抵达的数据。该模型使用的数据结构是ALPC完成列表（请不要将它与Windows I/O完成端口相混淆）。ALPC完成列表是一种高效、非阻塞的数据结构，可以在客户端之间进行原子性的数据传递，下文的“性能”一节将进一步介绍其内部结构。</p>
<p class="zw">另一种通知模型是使用Windows完成端口机制（位于ALPC完成列表基础之上）的等待模型。这使得线程能够一次检索多个载荷，控制并发请求的最大数量，并充分利用原生的完成端口功能。用户模式线程池的实现提供了内部API，进程可以使用这些API管理与同样使用该模型实现的工作线程所在相同基础结构中的ALPC消息。Windows中的RPC系统在（通过ncalrpc）使用本地RPC时，也会通过该功能，进而充分利用内核所提供的支持来提供高效的消息传递，而Msrpc.sys中的内核模式RPC运行时也是如此。</p>
<p class="zw">因为驱动程序可在任意上下文中运行，并且通常不会为自己的运行创建专用系统线程，ALPC也提供了另一种机制，借此使用执行体回调对象实现一种更基础、基于内核的通知。驱动程序可使用NtSetInformationAlpcPort注册自己的回调和上下文，随后每当收到消息，自己就会被调用。例如，内核中的电源相关性协调器（Power Dependency Coordinator，Pdc.sys）就会通过该机制与自己的客户端通信。值得注意的是，使用执行体回调对象能在性能方面带来一些优势，但也会产生一些安全风险。因为回调是以阻塞的方式（在接到信号后）执行的，并且与信号代码内联，因此总会在ALPC消息发送方的上下文中运行（即与调用NtAlpcSendWaitReceivePort的用户模式线程内联）。这意味着内核组件可能有机会检查其客户端的状态，而无须付出上下文切换的成本，并且还有可能在发送方的上下文中直接使用消息的载荷。</p>
<p class="zw">然而，这并非绝对的保证（如果实现方不了解这种情况，这本身也会成为一种风险），原因在于多个客户端可能同时向同一个端口发送消息，而现有消息可能是客户端在服务器注册自己的执行体回调对象之前发出的。另外，当服务器还在处理其他客户端之前发送的消息时，另一个客户端也有可能发出了另一条消息。在这些情况下，服务器可能运行在发送了消息的客户端上下文中，但实际分析的消息可能来自另一个客户端。服务器应该区分这种情况（因为发送端的客户端ID已编码到消息的PORT_HEADER中），并附加或分析正确的发送端状态（可能需要付出上下文切换的成本）。</p>

<p class="epubit-contents-id" style="display: none">{"index":2,"parentId":"e3feacd9-ccbb-4c83-b36b-bb1c5293963c","id":"7ca5e62d-4779-4728-affe-401fcba6dcbb"}</p>