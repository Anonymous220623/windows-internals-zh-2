<h3 class="bt3" id="sigil_toc_id_44">8.8.8　安全性</h3>
<p class="zw">为防止基于IPC常规解析Bug发起的攻击，ALPC实现了多种安全机制、完整的安全边界，以及相关缓解措施。在基础层面上，ALPC端口对象将由负责管理对象安全性的同一个对象管理器接口进行管理，借此可防止非特权应用程序通过ACL得到服务器端口句柄。在此基础上，ALPC提供了基于SID的信任模型，该模型继承自最初的LPC设计，可供客户端凭借端口名称之外的其他因素验证自己所连接的服务器。客户端进程可通过安全端口向内核提交自己所期待连接的对端服务器进程SID。在连接时，内核会验证该客户端是否真的连接到自己期待的服务器，借此缓解命名空间仿冒攻击（在这种攻击中，不可信的服务器会伪造真正服务器的端口）。</p>
<p class="zw">ALPC还可让客户端与服务器以符合原子性、唯一性的方式标识负责每条消息的线程和进程。它还能通过NtAlpcImpersonateClientThread API支持完整的Windows模拟（Impersonation）模型。其他API则使ALPC能查询与所有已连接客户端有关的SID，并查询客户端安全令牌中的LUID（本地唯一标识符详见卷1第7章）。</p>
<h4 class="bt4 sigil_not_in_toc">ALPC端口所有权</h4>
<p class="zw">端口所有权的概念对ALPC非常重要，它为感兴趣的客户端和服务器提供了各种安全保证。首先最重要的是，仅ALPC连接端口的所有者可以接收该端口的连接。这确保了如果端口句柄被以某种方式复制或继承给其他进程，其他进程也无法非法地接收传入连接。此外，在直接或间接使用句柄属性的情况下，无论当前由谁解析消息，句柄属性都能始终在端口所有者进程的上下文中复制。</p>
<p class="zw">当内核组件与客户端使用ALPC通信时，这些检查必不可少，此时内核组件可能被附加至一个完全不同的进程（甚至作为System进程的一部分，使用系统线程运行，借此使用ALPC端口消息），获知端口的所有者，意味着ALPC不会错误地依赖当前进程。</p>
<p class="zw">然而反过来看，对内核组件来说，不考虑当前进程是什么，在一个端口上任意接收传入连接，这种行为可能是有益的。一个明显的例子是：在使用执行体回调对象进行消息传送时。在这种情况下，因为回调是一个或多个发送方进程上下文中的同步调用，而内核连接端口很可能是在System上下文（例如DriverEntry）中执行时创建的，那么在接收该连接时，当前进程和端口所有者进程可能出现不匹配的情况。ALPC提供了一种只能由内核调用方使用的特殊端口属性标记，该标记使得连接端口成为一种系统端口，此时将忽略对端口所有者的检查。</p>
<p class="zw">端口所有权的另一个重要用例是：通过执行服务器SID验证来检查客户端是否发出了请求，详见上文“安全性”一节。该验证总是会通过检查连接端口所有者令牌的方式完成，此时并不考虑谁正在监听该端口的消息。</p>

<p class="epubit-contents-id" style="display: none">{"index":7,"parentId":"e3feacd9-ccbb-4c83-b36b-bb1c5293963c","id":"cf621b07-119b-45c9-88d3-6977ff459e77"}</p>