<h2 class="bt2" id="sigil_toc_id_49"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/bt2.png" style=""> 8.9　Windows通知设施</h2>
<p class="zw">Windows通知设施（Windows Notification Facility，WNF）是一种无须注册的现代化发布/订阅机制的核心支撑，最早于Windows 8中引入，主要是为了解决系统架构方面的一些缺陷问题，例如，向感兴趣的各方通知某些操作、事件或状态的存在，并提供与这些状态变化有关的数据载荷。</p>
<p class="zw">为了说明其具体用途，请考虑这样的情况：服务A想要通知潜在客户端B、C和D，告诉它们磁盘已经过扫描可安全地执行写操作，同时告知扫描过程中发现的损坏扇区数量（如果有的话）。但因为无法保证客户端B、C和D会在服务A之后启动，实际上，它们有很大概率先于服务A启动。这种情况下，如果它们继续执行，就将成为一种不安全的做法，正确的做法是等待服务A执行并报告磁盘已经可以安全地进行写操作。但如果服务A尚未运行呢？其他方又该如何从一开始就进行等待？</p>
<p class="zw">一种典型的解决方案是让B创建一个CAN_I_WAIT_FOR_A_YET事件，然后让A在启动后查找该事件，创建一个A_SAYS_DISK_IS_SAFE事件并发送CAN_I_WAIT_FOR_ A_YET信号，这样B就知道已经可以安全地等待A_SAYS_DISK_IS_SAFE了。在只有一个客户端的情况下这是一种可行的做法，但如果还要同时考虑C和D，情况就变得更复杂，因为它们可能需要经历相同的逻辑，并可能在CAN_I_WAIT_FOR_A_YET事件的创建方面展开竞争，进而打开现有事件（本例中该事件由B创建）并等待该事件收到的信号。虽然这也可以做到，但如何保证该事件真的是由B创建的呢？这就造成一种围绕名称所进行的恶意“仿冒”以及以此为基础导致的拒绝服务攻击。最终，我们可以设计一种安全的协议，但这需要A、B、C和D的开发者做大量复杂的工作。如果还要同时考虑坏扇区数量这件事，情况还将变得更复杂。</p>

<p class="epubit-contents-id" style="display: none">{"index":8,"parentId":"18136782-cc9e-4447-8382-748342e5e95c","id":"97a97022-321b-4466-8ae6-32bec914067f"}</p>