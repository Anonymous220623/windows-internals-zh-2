<h3 class="bt3" id="sigil_toc_id_50">8.9.1　WNF功能</h3>
<p class="zw">上述场景是操作系统设计中一个很常见的问题，而该问题显然不应交由单独的开发者来处理。操作系统的部分工作正是为这种与架构有关的常见挑战提供简单、可扩展、高性能的解决方案，现代Windows平台中的WNF正是以此为目标诞生的，它提供了：</p>
<p class="zwd"><span style="color: #0092dd">●</span> 定义状态名称的能力，该状态名称可订阅或发布给任意线程，这一点可由标准的Windows安全描述符（通过DACL和SACL）来保证。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 将此类状态名称与最多4&nbsp;KB载荷关联在一起的能力，该载荷能够与所订阅状态发生的变化一起检测到（并能将变化一起发布出去）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 拥有众所周知的状态名称的能力，这些名称由操作系统提供，无须由发布者创建，并可能与使用者产生竞争，这样，即使发布者尚未启动，使用者也可以对状态变化通知进行阻塞。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 在系统重启后持久保存状态数据的能力，这样，使用者即可看到之前发布的数据，哪怕自己当时尚未启动。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 为每个状态名称分配状态变化时间戳的能力，这样，即使系统重启动，使用者无须激活也可以知道新数据是否在某个时间点发布（以及是否需要针对之前发布的数据采取行动）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 为特定状态名称分配范围的能力，这样，同一个状态名称的多个实例即可存在于一个交互式会话ID、一个服务器Silo（容器）、特定用户令牌/SID，甚至一个单独的进程中。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 在跨越内核/用户边界的同时，执行与WNF状态名称有关的所有发布和使用工作的能力，这样组件就可以与另一端的其他组件进行交互。</p>

<p class="epubit-contents-id" style="display: none">{"index":0,"parentId":"97a97022-321b-4466-8ae6-32bec914067f","id":"c223ccf5-b34c-44c9-a38e-1d5d3d4f7ccc"}</p>