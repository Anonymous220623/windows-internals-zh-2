<h3 class="bt3" id="sigil_toc_id_72">9.1.3　虚拟机监控程序内存管理器</h3>
<p class="zw">相比NT或安全内核的内存管理器，虚拟机监控程序内存管理器相对较简单。虚拟机监控程序以内存隔间（memory compartment）为单位管理一系列物理内存页面。在虚拟机监控程序启动前，虚拟机监控程序加载器（Hvloader.dll）会分配虚拟机监控程序加载器块，并预计算虚拟机监控程序正确启动和创建根分区所需的物理页面数量最大值。该数值取决于初始化IOMMU以存储内存范围结构、系统PFN数据库、SLAT页表还有HAL VA空间所需的页面数量。虚拟机监控程序加载器会预分配计算出的物理页面数量最大值，将其标记为保留，并将这个页面列表的数组附加到加载器块。随后，当虚拟机监控程序启动时，会使用由虚拟机监控程序加载器分配的页表创建根隔间。</p>
<p class="zw">内存隔间的数据结构布局如图9-7所示。该数据结构可跟踪隔间中“存档”的物理页面总数，随后这些页面可分配到某些地方或直接释放。隔间会将物理页面存储在按照NUMA节点进行排序的各种列表中，但只有每个列表的头部会存储在隔间内。每个物理页面的状态及其在NUMA列表中的链接是通过PFN数据库中的项维持的。隔间还会跟踪自己与根的关系。新隔间可以使用属于父分区（或根分区）的物理页面来创建。类似地，当隔间被删除后，所有残留的物理页面也会返回给父分区。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx705.png" style="width: 100%" />
<p class="图题">图9-7　虚拟机监控程序的内存隔间。全局区域的虚拟地址空间会从隔间数据结构的末端开始保留</p>
<p class="zw">当虚拟机监控程序需要一些物理内存来执行某些工作时，会从活跃隔间（取决于具体分区）进行分配。这意味着该分配有可能失败。如果失败，则可能会出现如下两种情况。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 如果是为虚拟机监控程序的内部服务发出的分配请求（通常这是代表根分区进行的），则不应失败，而是应该让系统直接崩溃（这也解释了为何最初计算的要分配给根隔间的页面总数必须精确）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 如果是代表子分区进行的分配（通常通过虚拟化调用进行），则虚拟机监控程序会让请求失败并返回INSUFFICIENT_MEMORY状态。根分区检测到该错误并分配一些物理页面（更多详情请参阅下文“虚拟化栈”一节），这些页面将通过HvDepositMemory虚拟化调用存入子隔间。随后即可重新初始化分配操作，并且通常将会成功。</p>
<p class="zw">从隔间分配的物理页面通常会使用虚拟地址映射至虚拟机监控程序。在创建隔间时，会分配一个足以映射新隔间、隔间的PDE位图及其全局区域的虚拟地址范围（大小为4&nbsp;GB或8&nbsp;GB，取决于这是根隔间还是子隔间）。</p>
<p class="zw">虚拟机监控程序的区域（zone）中可封装一个私有VA范围，该范围不会与虚拟机监控程序的整个地址空间共享（详见下文“地址空间隔离”一节）。虚拟机监控程序会使用一个根页表来执行（与NT内核使用KVA影子的方法完全不同）。根页表中有两个保留项，保留的目的是在每个区域和虚拟处理器的地址空间之间动态切换。</p>
<h4 class="bt4 sigil_not_in_toc">分区的物理地址空间</h4>
<p class="zw">正如上一节所述，在最初创建分区时，虚拟机监控程序会为之分配物理地址空间。物理地址空间包含硬件将分区的客户机物理地址（GPA）转换为系统物理地址（SPA）所需的全部数据结构。实现这种转换的硬件功能通常称为二级地址转换（Second Level Address Translation，SLAT）。SLAT这个术语无关于具体平台，硬件制造商使用不同的名称来称呼它：Intel称之为EPT，即扩展页表（Extended Page Table）；AMD称之为NPT，即嵌套页表（Nested Page Table）；AMD直接将其称为第2阶地址转换（Stage 2 Address Translation）。</p>
<p class="zw">SLAT的实现方式通常与x64页表的实现方式类似，用到了四级转换（x64虚拟地址转换的详细介绍请参阅卷1第5章）。分区中运行的操作系统会像在裸机硬件上运行那样使用相同的虚拟地址转换。然而，对于分区中运行的操作系统，物理处理器通常需要执行两级转换：一级适用于虚拟地址，另一级用于转换物理地址。图9-8展示了客户机分区的SLAT设置。在客户机分区中，GPA通常会被转换为不同的SPA。但根分区并不会这样做。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx713.png" style="width: 100%" />
<p class="图题">图9-8　客户机分区的地址转换</p>
<p class="zw">虚拟机监控程序创建根分区时，会通过标识映射建立初始物理地址空间。在这种模型下，每个GPA都对应于相同的SPA（例如，根分区中的客户机帧0x1000会映射至裸机物理帧0x1000）。虚拟机监控程序会预分配将计算机完整物理地址空间映射至所有允许的根分区虚拟信任级别（VTL）所需的内存（具体数量由Windows加载器使用UEFI服务发现，详见第12章），根分区通常支持两个VTL。分区所属每个VTL的SLAT页表包含相同的GPA和SPA项，但通常会设置不同的保护级别。应用给每个分区物理帧的保护级别可用于创建互相隔离的不同安全域（VTL）。VTL的详细介绍请参阅“安全内核”一节。虚拟机监控程序页会被标记为硬件保留，不会映射至分区的SLAT表（实际上，它们是通过一个指向假PFN的无效入口点来映射的）。</p>
<table> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　出于性能方面的考虑，虚拟机监控程序在构建物理内存映射时，可以检测大块的连续物理内存，并且会使用类似于虚拟内存那样的做法，使用大页面来映射这些块。如果由于某种原因，分区中运行的操作系统决定对物理页面应用更细化的保护，那么虚拟机监控程序将使用保留的内存打破SLAT表中的大页面。</p> <p class="zwzy">老版本虚拟机监控程序还支持通过另一种技术来映射分区的物理地址空间：影子页（shadow paging）。影子页主要被不支持SLAT的计算机使用。该技术会产生极高的性能开销，因此现在已不再支持（在不支持SLAT的计算机上，虚拟机监控程序将拒绝启动）。</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">根的SLAT表是在创建分区时构建的，但区客户机分区来说情况略有不同。在创建子分区时，虚拟机监控程序会为其创建初始物理地址空间，但只为每个分区的VTL分配根页表（PML4）。在新虚拟机启动前，VID驱动程序（虚拟化栈的一部分）会通过从根分区分配的方式保留该虚拟机所需的物理页面，页面的具体数量取决于虚拟机内存大小（请注意，这里说的是物理内存，只有驱动程序可以分配物理页面）。VID驱动程序维护着一个物理页面列表，该列表会被分析并拆分成大页面，随后通过HvMapGpaPages这个Rep虚拟化调用<sup>[1]</sup>发送给虚拟机监控程序。</p>
<p class="footnote">[1]虚拟化调用（Hypercall）可分为两类：简单（Simple）和重复（Rep，Repeat的缩写）。简单虚拟化调用只能执行一个操作，其输入和输出参数集的大小是固定的。重复虚拟化调用可执行一系列简单虚拟化调用。除了可以使用固定大小的输入和输出参数集外，重复虚拟化调用还可以调用固定大小的输入和输出元素列表。——译者注</p>
<p class="zw">在发送映射请求前，VID驱动程序会调用虚拟机监控程序来创建所需的SLAT页表以及内部物理内存空间的数据结构。分区中每个可用VTL还会被分配SLAT页表层次结构（该操作也叫预提交）。这个操作有可能失败，例如，新分区的隔间未包含足够的物理页面时。在这种情况下，根据上一节的介绍，VID驱动程序会从根分区分配更多的内存，并将其存入子分区的隔间。随后，VID驱动程序就可以自由地映射子分区的所有物理页面。虚拟机监控程序会构建并编译所需的全部SLAT页表，并根据VTL级别分配不同的保护（大页面需要的间接级别数量会少一个）。至此，子分区的物理地址空间创建工作完成。</p>
<h4 class="bt4 sigil_not_in_toc">地址空间隔离</h4>
<p class="zw">现代CPU中发现的预测执行漏洞（Meltdown、Spectre或Foreshadow）可以让攻击者通过推测性方式读取CPU缓存中的陈旧数据，进而读取到更高执行特权上下文中保存的机密数据。这意味机客户虚拟机中运行的软件有可能以推测性方式，读取隶属于虚拟机监控程序或更高特权根分区的私有内存。Spectre、Meltdown以及所有此类侧信道漏洞的技术细节以及Windows的缓解措施详见第8章。</p>
<p class="zw">通过实施HyperClear缓解措施，虚拟机监控程序也可以缓解大部分此类攻击。HyperClear缓解措施依赖这三个关键组件来保证虚拟机之间的强隔离：核心调度器、虚拟处理器地址空间隔离以及敏感数据擦除。在现代多核心CPU中，通常会由不同的SMT线程共享同一个CPU缓存（有关核心调度器和对称多线程的详细介绍请参阅“Hyper-V调度器”一节）。在虚拟化环境中，一个核心中的SMT线程可以根据自己的活动，独立地进入或退出虚拟机监控程序上下文。例如，中断之类的事件可能导致SMT线程宾客户机虚拟处理器上下文的运行中切出，并开始在虚拟机监控程序的上下文中运行。每个SMT线程都可能独立执行这种操作，因此，一个SMT线程可能正在虚拟机监控程序上下文中执行，但同时其同胞SMT线程依然在虚拟机宾客户机虚拟处理器上下文中运行。借此，攻击者通过一个SMT线程在信任度较低的虚拟机的虚拟处理器上下文中运行的代码，就有可能通过侧信道漏洞窃取同胞SMT线程运行的虚拟机监控程序上下文中所包含的敏感数据。</p>
<p class="zw">虚拟机监控程序通过为每宾客户机SMT线程（这种线程支撑了虚拟处理器）维持相互独立的虚拟地址范围，提供了强大的数据隔离机制，借此防范有恶意机客户虚拟机。当虚拟机监控程序上下文进入特定的SMT线程时，任何机密数据都是无法寻址的。此时唯一可以进入CPU缓存的数据是与当宾客户机虚拟处理器相关联的数据，或虚拟机监控程序共享的数据。如图9-9所示，当SMT线程运行的虚拟处理器进入虚拟机监控程序时，根调度器会强制要求其他虚拟处理器上正在运行的同胞LP必须属于同一个虚拟机。此外，共享的机密数据也不会映射至虚拟机监控程序。当虚拟机监控程序需要访问机密数据时，需要保证其他同胞SMT线程中没有别的已调度虚拟处理器。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx789.png" style="width: 100%" />
<p class="图题">图9-9　HyperClear缓解措施</p>
<p class="zw">与NT内核不同，虚拟机监控程序总是通过一个页表根来运行，这就形成一个全局虚拟地址空间。虚拟机监控程序定义了私有地址空间的概念，但其名称容易让人误解。实际上，为了映射私有地址空间或取消其映射，虚拟机监控程序保留了两个全局根页表项（PML4项，可生成一个1&nbsp;TB的虚拟地址范围）。虚拟机监控程序在最开始构建虚拟处理器时，会分配两个私有页表根项。这些项将用于映射虚拟处理器的机密数据，例如，它的栈以及包含私有数据的数据结构。切换地址空间意味着在全局页表根中写入这两个项（这也解释了为何“私有地址空间”的名称这么有误导性，实际上，该名称代表的是私有地址“范围”）。虚拟机监控程序只会在两种情况下切换私有地址空间：新建虚拟处理器时，以及切换线程时（别忘了，线程是由虚拟处理器支撑的，而核心调度器会保证同胞SMT线程不会在不同的分区中执行虚拟处理器）。运行过程中，虚拟机监控程序线程只会映射自己虚拟处理器的私有数据，而无法访问其他机密数据。</p>
<p class="zw">私有地址空间中机密数据的映射是借助由MM_ZONE数据结构所代表的内存区域实现的。内存区域可以封装私有地址空间的私有VA子范围，虚拟机监控程序通常会将每个虚拟处理器的机密存储在这里。</p>
<p class="zw">这种内存区域的工作方式与私有地址空间类似。内存区域并不会映射全局页表根中的根页表项，而是会映射私有地址空间所使用的两个根项中包含的私有页目录。内存区域维持了一个页目录数组，该数组可映射至私有地址空间或解除映射，此外还包含一个用于跟踪已使用页表的位图。图9-10展示了私有地址空间和内存区域之间的关系。内存区域可以按需映射至私有地址空间或解除映射，但通常只会在创建虚拟处理器时切换。实际上，虚拟机监控程序无须在切换线程时切换内存区域，私有地址空间封装了内存区域所暴露的VA范围。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx796.png" style="width: 100%" />
<p class="图题">图9-10　虚拟机监控程序的私有地址空间和私有内存区域</p>
<p class="zw">在图9-10中，页表中与私有地址空间有关的结构填充了斜线，与内存区域有关的结构显示为灰色，隶属于虚拟机监控程序的共享结构使用了虚线外框。私有地址空间的切换是一种开销很低的操作，只需要更改虚拟机监控程序页表根中的两个PML4项。从私有地址空间附加或分离内存区域则只需要修改区域的PDPTE（区域的VA大小是可变的，而PDTPE总是会连续分配）。</p>
<h4 class="bt4 sigil_not_in_toc">动态内存</h4>
<p class="zw">虚拟机可按照百分率使用为自己分配物理内存。例如，一些虚拟机只使用了为自己分配宾客户机物理内存中的一小部分，导致大量已分配物理内存被释放或归零。而当内存压力较高时，其他虚拟机的性能可能会受到一定影响，因为分配宾客户机物理内存不足，导致需要大量使用页面文件。为了防止出现这种情况，虚拟机监控程序和虚拟化栈支持了动态内存这一概念。动态内存是指以动态的方式为虚拟机分配或移除物理内存的功能。该功能由多个组件提供。</p>
<p class="zwd"><span style="color: #0092dd">●</span> NT内核的内存管理器，为物理内存的热添加和热移除提供了支持（这也适用于裸机系统）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 虚拟机监控程序，通过SLAT提供支持（由地址管理器负责管理）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 虚拟机工作进程，可使用动态内存控制器模块（Vmdynmem.dll）与子分区中运行的VMBus动态内存VSC驱动程序（Dmvsc.sys）建立的连接。</p>
<p class="zw">为了准确介绍动态内存，我们应该首先简要看看NT内核是如何创建页面帧编号（Page Frame Number，PFN）数据库的。Windows会使用PFN数据库跟踪物理内存，详细介绍可参阅卷1第5章。为了创建PFN数据库，NT内核首先需要计算映射物理地址可能的最大值所需的理论大小（标准64位系统为256&nbsp;TB），随后将映射所需的VA空间完全标记为保留空间，并将基址存储到MmPfnDatabase全局变量中。请注意，这个保留的VA空间中目前尚未分配页表。NT内核会（使用UEFI服务）在启动管理器所发现的物理内存描述符之间循环，将它们聚合在尽可能长的范围内，并使用大页面为每个范围映射底层的PFN数据库项。这会产生一个非常重要的含义：如图9-11所示，PFN数据库拥有最大可能的物理内存数量，但只有其中很小的一个子集会被映射至真正的物理内存（这种技术也叫作稀疏内存）。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx862.png" style="width: 100%" />
<p class="图题">图9-11　部分物理内存被移除后的PFN数据库范例</p>
<p class="zw">物理内存热添加和热移除的实现要归功于这一原则。将新的物理内存添加到系统后，即插即用内存驱动程序（Pnpmem.sys）检测到这一情况并调用NT内核导出的MmAddPhysicalMemory例程。该例程会启动一个复杂的过程来计算新范围中确切的页数以及这些页面所属的NUMA节点，随后在保留的VA区域中创建必要的页表，借此将新的PFN项映射至数据库。随后新增的物理页面会被加入空闲列表（详见卷1第5章）。</p>
<p class="zw">当一些物理内存被热移除后，系统会执行一个相反的过程：首先检查这些页面所属的正确物理页面列表，更新内部内存计数器（例如物理页面的总数），最终释放对应的PFN项，意味着这些项会被标记为“损坏”。随后，内存管理器将永远不再使用带有这种标记的物理页面。实际的虚拟空间不会从PFN数据库中解除映射，释放的PFN所描述的物理内存还可以在未来重新添加。</p>
<p class="zw">被启发的虚拟机启动后，动态内存驱动程序（Dmvsc.sys）会检测这个子虚拟机是否支持热添加功能。如果支持，该驱动程序会创建一个工作线程来协商协议并连接到VSP的VMBus通道（有关VSC和VSP的详情请参阅“虚拟化栈”一节）。VMBus连接通道可以将子分区中运行的动态内存驱动程序连接至动态内存控制器模块（Vmdynmem. dll），该模块会在根分区的虚拟机工作进程中进行映射。随后将启动一个消息交换协议。在每一秒，子分区通过查询内存管理器暴露的各种性能计数器（全局页面文件使用量、可用/已提交/脏页面数量、每秒页面错误数量、已释放和已归零页面列表中的页面数量）来获得一份内存压力报告，该报告随后会发送给根分区。</p>
<p class="zw">根分区中的虚拟机工作进程会使用VMMS均衡器（VmCompute服务的一个组件）暴露出的服务进行必要的计算，借此判断需要执行热添加操作的概率。如果根分区的内存状态支持热添加操作，则VMMS均衡器会计算需要存入子分区的页面数量，并通过COM回调虚拟机工作进程，由该进程在VID驱动程序的协助下开始执行热添加操作。</p>
<p class="zw">1）在根分区中保留适当数量的物理内存。</p>
<p class="zw">2）调用虚拟机监控程序，借此将根分区保留的系统物理页面映射至子虚拟机中映射的某些客户机物理页面，并设置必要的保护。</p>
<p class="zw">3）向动态内存驱动程序发送一条消息，进而针对虚拟机监控程序先前映射的客户机物理页面执行热添加操作。</p>
<p class="zw">子分区中的动态内存驱动程序会使用NT内核暴露出的MmAddPhysicalMemory API来执行热添加操作。该API可以映射PFN数据库中用于描述新增客户机物理内存的PFN项，并在需要时为该数据库添加新的支撑页面。</p>
<p class="zw">通过类似方式，当VMMS均衡器检测到子虚拟机有大量的可用物理页面时，可能会要求子分区（依然通过虚拟机工作进程来要求）热移除某些物理页面。动态内存驱动程序会使用MmRemovePhysicalMemory API执行热移除操作。NT内核会验证均衡器所指定范围内的每个页面已经处于归零或空闲列表中，或这些页面位于可以安全换出的栈中。如果所有条件都适用，那么动态内存驱动程序会将“热移除”页面范围重新发送回虚拟机工作进程，该进程会使用VID驱动程序提供的服务从子分区中解除对这些物理页面的映射，并将其释放回NT内核。</p>
<table width="99%"> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　启用嵌套虚拟化之后将无法支持动态内存功能。</p> </td> 
  </tr> 
 </tbody> 
</table>

<p class="epubit-contents-id" style="display: none">{"index":2,"parentId":"ea2ec385-5fa3-4b0f-b598-9bcb1e169157","id":"226da58c-1d31-4886-9590-db12169e3f42"}</p>