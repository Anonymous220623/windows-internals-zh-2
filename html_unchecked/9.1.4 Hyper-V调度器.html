<h3 class="bt3" id="sigil_toc_id_73">9.1.4　Hyper-V调度器</h3>
<p class="zw">虚拟机监控程序是一种在根分区的操作系统（Windows）中运行的微型操作系统。因此，它能决定哪个线程（支撑了虚拟处理器）应该由哪个物理处理器执行。如果系统中运行了多个虚拟机，并且虚拟机所使用的虚拟处理器的总数已经超过物理处理器的数量，那么这个功能更为重要。虚拟机监控程序调度器的作用是：在当前分配的时间切片结束后，选择在物理CPU上执行的下一个线程。Hyper-V 可以使用三种调度器。为了正确管理所有这些调度器，虚拟机监控程序暴露了调度器API，以及一系列可以进入虚拟机监控程序调度器的例程。它们的唯一用途是将API调用重定向至特定的调度器实现。</p>
<p class="zwtsh">实验：控制虚拟机监控程序的调度器类型</p>
<p class="zwts1">客户端版本的Windows默认会使用根调度器启动，而Windows Server 2019默认使用核心调度器运行。在这个实验中，我们将查看自己系统所启用的虚拟机监控程序调度器，并了解如何在从下次重启动系统时切换至其他虚拟机监控程序调度器。</p>
<p class="zwts1">Windows虚拟机监控程序会在确定要启用的调度器后记录一条系统事件。我们可以使用事件查看器工具搜索已记录的事件，为此请在搜索框中输入<strong>eventvwr</strong>。启动事件查看器后，请展开“<strong style="color:#0092dd"><strong>Windows</strong>日志</strong>”节点并点击“<strong style="color:#0092dd">系统日志</strong>”。随后请搜索ID为2、事件来源为Hyper-V-Hypervisor的事件。请点击窗口右侧的“<strong style="color:#0092dd">过滤当前日志</strong>”按钮，或点击“<strong style="color:#0092dd">事件</strong>ID”列，随后即可用ID降序排列所有事件（该操作可能需要执行一段时间）。双击找到的事件，即可看到类似下图所示的窗口。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx907.png" style="width: 100%" />
<p class="zwts1">ID为2的事件揭示了所使用的虚拟机监控程序调度器类型，其中：</p>
<p class="zwts1">1 = 经典调度器，SMT被禁用</p>
<p class="zwts1">2 = 经典调度器</p>
<p class="zwts1">3 = 核心调度器</p>
<p class="zwts1">4 = 根调度器</p>
<p class="zwts1">上述示例截图来自一台运行Windows Server的系统，该系统默认使用核心调度器运行。若要将调度器类型改为经典（或根）调度器，请以管理员身份打开命令提示符窗口（在搜索框中输入<strong>cmd</strong>，并选择“<strong style="color:#0092dd">以管理员身份运行</strong>”），随后运行下列命令：</p>
<pre class="代码无行号"><code>bcdedit /set hypervisorschedulertype &lt;<em>Type</em>&gt; </code></pre>
<p class="zwts1">其中：&lt;Type&gt;设置为“Classic”可使用经典调度器，设置为“Core”可使用核心调度器，设置为“Root”可使用根调度器。设置完毕后需要重启动系统并再次查看新生成的来自&nbsp;Hyper-V-Hypervisor、ID&nbsp;为&nbsp;2&nbsp;的事件。也可以在使用管理员身份运行的PowerShell窗口中使用下列命令查看当前启用的虚拟机监控程序调度器：</p>
<pre class="代码无行号"><code>Get-WinEvent -FilterHashTable @{ProviderName="Microsoft-Windows-Hyper-V-<br>Hypervisor"; ID=2} -MaxEvents 1 </code></pre>
<p class="zwts1">上述命令可从系统事件日志中提取最新的ID为2的事件。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx915.png" style="width: 100%" />
<h4 class="bt4 sigil_not_in_toc">经典调度器</h4>
<p class="zw">自Hyper-V发布以来，所有版本的Hyper-V都默认使用经典调度器。经典调度器在默认配置中实现了一种简单的轮询策略，让当前执行状态（执行状态取决于系统中运行的虚拟机总数）中的任何虚拟处理器都能获得相等的调度概率。经典调度器还支持为虚拟处理器设置相关性，并在考虑到物理处理器NUMA节点的情况下执行调度决策。经典调度器不知道客户虚拟处理器当前在执行什么，唯一的例外由自旋锁启发来定义。当分区中运行的Windows内核要针对自旋锁执行主动等待时，会发出一个虚拟化调用，借此通知虚拟机监控程序（高IRQL同步机制详见第8章）。经典调度器可以抢占当前执行的虚拟处理器（如果该虚拟处理器尚未用完分配给自己的时间切片）并能调度另一个虚拟处理器。借此即可节省活跃CPU的旋转周期。</p>
<p class="zw">经典调度器默认为每个虚拟处理器分配相等的时间切片。这意味着在超额订阅了较高工作负载的系统中，因为有多个虚拟处理器会试图执行，而物理处理器已经非常繁忙，性能可能会快速降低。为了解决这种问题，经典调度器支持多种调优选项（如图9-12所示），借此可修改其内部的调度决策。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">虚拟处理器保留</strong>。用户可以代表客户机提前保留CPU容量。通过这种保留，可以指定当客户机被调度运行时，为该计算机预留的物理处理器的容量百分比。借此，Hyper-V只会在CPU可用容量最小值满足该比例时才会调度虚拟处理器运行（这意味着提供可保证的已分配时间切片）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">虚拟处理器限制</strong>。与虚拟处理器保留类似，用户也可以限制虚拟处理器可以使用的物理CPU容量比例。这意味着在高负载情况下，会减少分配给特定虚拟处理器的可用时间切片。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">虚拟处理器权重</strong>。该选项控制了当保留条件被满足时，虚拟处理器能被调度的概率。在默认配置中，每个虚拟处理器具备相等的执行概率。当用户对某个虚拟机所属的虚拟处理器配置了权重后，会根据用户选择的相对权重系数来决定调度决策。例如，假设一个包含四个CPU的系统需要同时运行三个虚拟机，第一个虚拟机的权重系数为100，第二个为200，第三个为300。假设系统的所有物理处理器都分配了统一数量的虚拟处理器，那么第一个虚拟机的虚拟处理器被调度的概率就是17%，第二个虚拟机的为33%，第三个虚拟机的为50%。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx922.png" style="width: 100%" />
<p class="图题">图9-12　经典调度器的调优设置属性页，该页面仅在启用经典调度器的情况下可用</p>
<h4 class="bt4 sigil_not_in_toc">核心调度器</h4>
<p class="zw">通常来说，传统CPU的核心只有一条执行流水线，指令流会通过这条流水线一个接一个地执行。一个指令进入管道，通过包含多个环节的步骤（如加载数据、计算、存储数据）执行处理，随后从管道中退出。不同类型的指令会用到CPU核心的不同部分。现代CPU的核心通常能以乱序（相对于进入管道的顺序而言属于“乱序”）的方式执行指令流中的多个连续指令。支持乱序执行的现代CPU通常会实现一种名为对称多线程（Symmetric MultiThreading，SMT）的机制：CPU的一个核心有两个执行管线，会向系统提供一个以上的逻辑处理器，因此，可通过一个共享的执行引擎以并排的方式执行两个指令流（如缓存等核心资源是共享使用的）。这两个执行流水线可作为一个独立处理器（CPU）暴露给软件。从现在开始，我们将使用逻辑处理器（LP）这个术语来代表SMT核心暴露给Windows、可充当独立CPU使用的执行流水线（SMT详见卷1第2章和第4章）。</p>
<p class="zw">这种硬件实现导致了很多安全问题：由一个共享的逻辑CPU执行的指令可能干扰并影响其他同胞LP所执行的指令。此外，因为物理核心的缓存也是共享的，LP将能修改缓存内容，导致其他同胞CPU有可能通过测量处理器访问同一个缓存行内存寻址所花费的时间来探测缓存中存储的数据，进而窥探其他逻辑处理器所访问的“机密数据”（详见第8章中的“侧信道攻击”一节）。经典调度器通常可以选择属于不同虚拟机的两个线程，随后由同一个处理器核心的两个逻辑处理器执行。这显然是不可接受的，因为在这种情况下，第一个虚拟机可能会读取到其他虚拟机的数据。</p>
<p class="zw">为了解决这个问题，并且为了以可预测的性能运行启用SMT的虚拟机，Windows Server 2016引入了核心调度器。核心调度器可以利用SMT属性为客户机虚拟处理器提供隔离和更强的安全边界。启用核心调度器后，Hyper-V会将虚拟核心调度到物理核心上，并能保证属于不同虚拟机的虚拟处理器永远不会调度到物理核心的同胞SMT线程上。核心调度器使得虚拟机能够更充分地使用SMT。暴露给虚拟机的虚拟处理器可以是一个SMT集的组成部分，客户虚拟机中运行的操作系统和应用程序可以使用SMT行为和编程接口（API）控制SMT线程并实现跨线程调度，一切与非虚拟化方式下的运行完全一样。</p>
<p class="zw">图9-13展示了在两个CPU核心上分布了四个逻辑处理器的SMT系统范例。图中运行了三个虚拟机，第一个和第二个虚拟机各有四个虚拟处理器，这四个虚拟处理器各自组成两组，而第三个虚拟机只有一个虚拟处理器。虚拟机中的虚拟处理器组分别标记为A、B、C、D和E。每个组中的闲置虚拟处理器（未执行代码）被填充为较深的颜色。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx930.png" style="width: 100%" />
<p class="图题">图9-13　包含两个处理器核心，运行了三个虚拟机的SMT系统范例</p>
<p class="zw">每个核心有一个运行列表，其中包含了准备执行的虚拟处理器组；此外还有一个延迟列表，其中包含了准备运行但尚未添加到核心运行列表的虚拟处理器组。虚拟处理器组会在物理核心上执行。如果一个组中的所有虚拟处理器都处于闲置状态，该虚拟处理器组会被取消调度，不再出现在任何运行列表中（图9-13中的虚拟处理器组D就是这种情况）。虚拟处理器组E刚刚脱离了闲置状态，其中的虚拟处理器被分配到CPU核心 2。图9-13中还显示了一个假的同胞虚拟处理器，这是因为核心2的逻辑处理器从未调度过其他任何虚拟处理器，而该核心的同胞逻辑处理器正在执行隶属于虚拟机3的虚拟处理器。同样，如果逻辑处理器组中的一个虚拟处理器变为闲置但其他虚拟处理器依然在执行（例如组A），其他虚拟处理器也不会调度到物理核心上。每个核心会执行自己运行列表中处于首位的虚拟处理器组。如果没有可执行的虚拟处理器组，核心将变为闲置状态，开始等待虚拟处理器组被放入自己的延迟运行列表。发生这种情况后，核心会从闲置状态唤醒并清空自己的延迟运行列表，将内容放入自己的运行列表中。</p>
<p class="zw">核心调度器是由不同组件实现的（见图9-14），这些组件之间实现了严格的分层。核心调度器的中心是调度单元，它可代表一个虚拟核心或一组SMT虚拟处理器（对于非SMT虚拟机，可代表一个虚拟处理器）。根据虚拟机的类型，调度单元可绑定一个或两个线程。虚拟机监控程序的进程拥有一个调度单元列表，该列表拥有为虚拟机的虚拟处理器提供支撑的线程。调度单元是核心调度器进行调度的一种单位，运行期间，调度设置（如保留、权重以及上限）都将应用到调度单元这一层面上。在时间切片时段内，调度单元始终维持活跃，可被阻断并解除阻断，可在不同的物理处理器核心之间迁移。这方面有个重要概念：调度单元类似于经典调度器中的线程，但不具备可在其中运行的栈或虚拟处理器上下文。调度单元是与运行在物理处理器核心上的调度单元绑定的线程之一，线程组调度器则是每个调度单元的仲裁者。作为一种实体，仲裁者决定了活跃调度单元中的哪个线程会被物理处理器核心中的哪个逻辑处理器执行，它会执行线程的相关性，应用线程调度策略，并更新每个线程的相关计数器。</p>
<p class="zw">物理处理器核心的每个逻辑处理器都包含一个与之相关的逻辑处理器调度程序实例。逻辑处理器调度程序负责切换线程、维持计时器并为当前线程刷新VMCS（或VMCB，取决于具体架构）。逻辑处理器调度程序由核心调度程序所拥有，每个核心调度程序代表物理处理器上的一个核心，拥有两个SMT逻辑处理器。核心调度程序管理着当前活跃的调度单元。单元调度器会被绑定给自己的核心调度程序，它决定了接下来将由哪个调度单元在单元调度器所属的物理处理器核心上运行。调度管理器是核心调度器的最后一个重要组件，它拥有系统中所有的单元调度器，并对其状态有一个全局的视图。它可以为单元调度器提供负载均衡和理想核心分配服务。</p>
<h4 class="bt4 sigil_not_in_toc">根调度器</h4>
<p class="zw">根调度器（也叫集成调度器）最初在Windows 10于2018年4月的更新（RS4）中引入，旨在让根分区能够调度隶属于客户机分区的虚拟处理器（VP）。根调度器的设计目标是为Windows Defender应用程序防护所使用的轻量级容器提供支持。此类容器（内部称之为Barcelona容器或Krypton容器）必须由根分区管理，并应尽可能减少对内存和存储空间的用量（有关Krypton容器的详细介绍已超出了本书内容范围。有关服务器容器的详细介绍请参阅卷1第3章）。此外，根操作系统调度器可以随时收集有关容器内部工作负载CPU利用率的指标，并将这些数据作为输入，应用于系统中所有其他工作负载的相同调度策略。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx939.png" style="width: 100%" />
<p class="图题">图9-14　核心调度器的组件</p>
<p class="zw">根分区操作系统实例中的NT调度器管理着系统逻辑处理器调度工作的方方面面。为此，VID驱动程序内部的集成调度器根组件会在根分区内部（新VMMEM进程的上下文中）为每个客户机虚拟处理器创建一个虚拟处理器调度线程（本章下文将详细介绍VA支持的虚拟机）。根分区中的NT调度器会将虚拟处理器调度线程作为常规线程对象那样进行调度，但会遵守VM/VP特定调度策略和启发。每个VP调度线程会运行一个VP调度循环，直到VID驱动程序终止对应的虚拟处理器。</p>
<p class="zw">当虚拟机工作线程（VMWP，详见本章下文“虚拟化栈”一节）通过SETUP_PARTITION IOCTL请求创建了分区和虚拟处理器后，VID驱动程序将创建VP调度线程。VID驱动程序会与WinHvr驱动程序通信，后者将初始化虚拟机监控程序的客户机分区创建工作（通过HvCreatePartition虚拟化调用）。如果所创建的分区代表由VA支持的虚拟机，或系统中的根调度器处于活跃状态，VID驱动程序将通过一个内核扩展调用NT内核，借此创建与新建客户机分区关联的VMMEM最小进程。VID驱动程序还会为属于该分区的每个虚拟处理器创建一个VP调度线程。该VP调度线程是在VID驱动程序以及WinHvr中实现的，会在内核模式下通过VMMEM进程的上下文执行（VMMEM中不包含用户模式代码）。如图9-15所示，每个VP调度线程会运行一个VP调度循环，直到VID终止相应的虚拟处理器，或客户机分区产生了拦截。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx950.png" style="width: 100%" />
<p class="图题">图9-15　根调度器的VP调度线程以及负责处理虚拟机监控程序消息的相关VmWp工作线程</p>
<p class="zw">在VP调度循环中，VP调度线程负责下列工作。</p>
<p class="zw">1）调用虚拟机监控程序新增的HvDispatchVp虚拟化调用接口，以将VP调度到当前处理器。在每个HvDispatchVp虚拟化调用中，虚拟机监控程序会试图将上下文从当前根VP切换至指定的客户机VP并让它运行客户机代码。这个虚拟化调用最重要的特征之一在于：它发出的代码应该以PASSIVE_LEVEL IRQL级别运行。虚拟机监控程序会让客户机VP持续运行，直到VP自愿阻塞、VP为根生成了一个拦截，或产生了一个以根VP为目标的中断。时钟中断依然由根分区处理。当客户机VP耗尽分配给自己的所有时间切片后，该VP支撑的线程会被NT调度器抢占。发生上述三种事件中的任何一个后，虚拟机监控程序都会重新切换回根VP并完成HvDispatchVp虚拟化调用，随后返回到根分区。</p>
<p class="zw">2）如果虚拟机监控程序中相应的VP被阻塞，则会阻塞VP调度事件。当客户机VP在任何时候自愿被阻塞时，VP调度线程都会在VP调度事件上阻塞自身，直到虚拟机监控程序解除对相应客户机VP的阻塞并通知VID驱动程序。VID驱动程序会向VP调度事件发信号，随后NT调度器解除对VP调度线程的阻塞，从而可以进行另一个HvDispatchVp虚拟化调用。</p>
<p class="zw">3）在从调度虚拟化调用返回时，处理由虚拟机监控程序报告的所有拦截。如果客户机虚拟处理器为根生成了拦截，VP调度线程将在从HvDispatchVp虚拟化调用返回时处理该拦截请求，并在VID处理完该拦截后发出另一个HvDispatchVp请求。每个拦截的管理方式各异。如果拦截需要由用户模式的VMWP进程处理，WinHvr驱动程序会退出循环并返回到VID，VID可以为提供支撑的VMWP线程发送事件信号，并等待拦截消息被VMWP进程处理，随后才会重新启动循环。</p>
<p class="zw">为了正确地将发给VP调度线程的信号从虚拟机监控程序交付给根，集成调度器提供了一种调度器消息交换机制。虚拟机监控程序会通过共享页面向根分区发送调度器消息。当新消息准备好交付时，虚拟机监控程序会向根分区注入一个SINT中断，根分区会将其交付给WinHvr驱动程序中相应的ISR处理程序，由该处理程序将消息路由至VID拦截回调（VidInterceptIsrCallback）。该拦截回调会试图直接处理来自VID驱动程序的拦截消息。如果无法直接处理，则会向一个同步事件发送信号，借此让调度循环退出，进而让一个VmWp工作线程在用户模式下调度该拦截。</p>
<p class="zw">相比虚拟机监控程序的其他调度器实现，在启用根调度器的情况下，上下文切换会产生较高的开销。例如当系统在两个客户机虚拟处理器之间切换时，总是需要产生两个到根分区的出口。集成调度器会以不同方式处理虚拟机监控程序的根VP线程和客户机VP线程（尽管在内部，它们由同一个TH_THREAD数据结构表示）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 只有根VP线程可以让客户机VP线程在自己的物理处理器上排队。根VP线程的优先级高于正在运行或已调度的任何客户机VP。如果根VP未被阻塞，集成调度器会尝试着尽快将上下文切换至根VP线程。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 客户机VP线程有两组状态：线程内部状态和线程根状态。线程根状态反映了虚拟机监控程序与根分区通信所用的VP调度线程的状态。集成调度器为每个客户机VP线程维持了这些状态，借此可以知道何时为相应的VP调度线程向根发送唤醒信号。</p>
<p class="zw">只有根VP可以对自己处理器上的客户机VP进行调度。这一点得以实现，可能是由于HvDispatchVp虚拟化调用的存在（这种情况下，我们可以说虚拟机监控程序正在处理“外部工作”），或者其他虚拟化调用需要向目标客户机VP发送同步请求（这就是所谓的“内部工作”）。如果客户机VP最后一次运行于当前物理处理器上，调度器即可立即调度客户机VP线程。否则调度器需要向客户机VP最后运行使用的处理器发送一个刷新请求，并等待远程处理器刷新VP上下文。后一种情况也叫作“迁移”，这种情况需要由虚拟机监控程序（借助线程本地状态和根状态，这里不再详述）进行跟踪。</p>
<p class="zwtsh">实验：操作根调度器</p>
<p class="zwts1">NT调度器决定何时选择并运行隶属于某个虚拟机的虚拟处理器，以及需要运行多久。该实验将演示上文讨论过的情况：所有VP调度线程都会在由VID驱动程序创建的VMMEM进程上下文中执行。若要完成该实验，我们需要一台安装Windows 10的2018年4月更新（RS4）或后续版本系统的计算机，在该计算机中安装Hyper-V角色，并创建一台安装了操作系统、可以正常运行的虚拟机。创建虚拟机的详细过程请参阅https:// docs.microsoft.com/virtualization/hyper-v-on-windows/quick-start/quick-create-virtual-machine。</p>
<p class="zwts1">首先我们需要确认根调度器已启用。本章“控制虚拟机监控程序的调度器类型”实验中介绍了具体做法。实验所用的虚拟机应处于关机状态。</p>
<p class="zwts1">右击任务栏并选择“<strong style="color:#0092dd">任务管理器</strong>”以打开任务管理器窗口，随后点击“<strong style="color:#0092dd">详细信息</strong>”</p>
<p class="zwts1">选项卡，确认运行中的活跃VMMEM进程数量。如果没有虚拟机正在运行，那么应该不会出现该进程。如果安装了Windows Defender应用程序防护（WDAG）角色，那么应该有一个现有的VMMEM进程实例，该进程承载了预加载的WDAG容器（此类虚拟机会在下文“VA支持的虚拟机”一节详细介绍）。如果VMMEM进程实例已存在，请留意它的进程ID（PID）。</p>
<p class="zwts1">在搜索框中输入<strong>Hyper-V Manager</strong>后打开Hyper-V管理器，并启动虚拟机。虚拟机和客户机操作系统成功启动后，重新切换到任务管理器并查找新出现的VMMEM进程。点击这个新增的VMMEM进程并展开“<strong style="color:#0092dd">用户名</strong>”一列，随后可以看到该进程已经关联给以该虚拟机GUID作为用户名的令牌。我们可以在管理员身份运行的PowerShell窗口中通过下列命令获取自己虚拟机的GUID（请将“&lt;VmName&gt;”替换为虚拟机的名称）：</p>
<pre class="代码无行号"><code>Get-VM -VmName "&lt;<em>VmName</em>&gt;" | ft VMName, VmId</code></pre>
<p class="zwts1">虚拟机ID与VMMEM进程的用户名应该相同，如下图所示。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx965.png" style="width: 100%" />
<p class="zwts1">安装Process Explorer（可从https://docs.microsoft.com/sysinternals/downloads/process- explorer 下载）并以管理员身份运行。搜索上一步确定的正确VMMEM进程的PID（本例中为27312），右击并选择<strong>Suspend</strong>。VMMEM进程的CPU选项卡随后会显示“Suspended”，而不再显示正确的CPU时间。</p>
<p class="zwts1">重新切换回该虚拟机会发现，虚拟机会无法响应并且彻底卡住。根源是我们刚才挂起的进程，它承载了该虚拟机所包含的所有虚拟处理器的调度线程。这会导致NT内核无法调度这些线程，进而也就使得WinHvr驱动程序无法发出恢复VP执行所需的HvDispatchVp虚拟化调用。</p>
<p class="zwts1">如果右键点击挂起的VMMEM并选择<strong>Resume</strong>，该虚拟机即可恢复执行并继续正常运行。</p>

<p class="epubit-contents-id" style="display: none">{"index":3,"parentId":"ea2ec385-5fa3-4b0f-b598-9bcb1e169157","id":"37e0109a-e3ac-444c-976d-cc3a9394e51b"}</p>