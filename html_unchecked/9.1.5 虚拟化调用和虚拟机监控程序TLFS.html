<h3 class="bt3" id="sigil_toc_id_74">9.1.5　虚拟化调用和虚拟机监控程序TLFS</h3>
<p class="zw">虚拟化调用为根分区或子分区中运行的操作系统提供了一种从虚拟机监控程序中请求服务的机制。虚拟化调用有一套明确定义的输入和输出参数。虚拟机监控程序顶级功能规范（Top Level Functional Specification，TLFS）可在线获取（https://docs.microsoft.com/ virtualization/hyper-v-on-windows/reference/tlfs），该规范定义了在指定这些参数时不同的调用惯例。此外，它还列出了虚拟机监控程序所有公开可用的功能、分区属性、虚拟机监控程序，以及VSM接口。</p>
<p class="zw">虚拟化调用之所以可用，是因为与平台无关的操作码（Opcode）的存在（Intel系统中叫作VMCALL，AMD系统中叫作VMMCALL，ARM64中叫作HVC），调用这种操作码会导致虚拟机监控程序产生VM_EXIT。VM_EXIT是一个事件，会导致虚拟机监控程序重启动以在虚拟机监控程序特权级别下执行自己的代码，这一特权级别高于系统中运行的任何其他软件（固件的SMM上下文除外），在这一过程中，虚拟处理器处于挂起状态。很多情况下会产生VM_EXIT事件。在特定平台的VMCS（或VMCB）不透明数据结构中，可以通过硬件维护的一个索引记录VM_EXIT的退出原因。如果是因为虚拟化调用引起了退出，那么当虚拟机监控程序得到该索引后，它会读取调用方（对于64位的Intel和AMD系统，通常来自于CPU的通用寄存器RCX）指定的虚拟化调用输入值。虚拟化调用的输入值（请参考图9-16）是一个64位值，指定了虚拟化调用代码、属性，以及用于该虚拟化调用的调用约定。调用约定分为三类。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">标准虚拟化调用</strong>。在8字节对齐的客户机物理地址（GPS）中存储输入和输出参数。操作系统会通过通用寄存器（Intel和AMD 64位平台上的RDX和R8）传递这两个地址。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">快速虚拟化调用</strong>。通常不允许使用输出参数，而是使用标准虚拟化调用中所用的那两个通用寄存器，只将输入参数传递给虚拟机监控程序（最大16字节）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong style="color:#0092dd">可扩展快速虚拟化调用</strong>（或XMM快速虚拟化调用）。与快速虚拟化调用类似，但此类调用会使用额外的6个浮点寄存器，以便让调用方传输最大112字节的输入参数。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx972.png" style="width: 100%" />
<p class="图题">图9-16　虚拟化调用输入值（来自虚拟机监控程序TLFS）</p>
<p class="zw">虚拟化调用分为两类：简单和重复。简单虚拟化调用只能执行一个操作，其输入和输出参数集的大小是固定的。重复虚拟化调用可以执行一系列简单虚拟化调用。当调用方使用重复虚拟化调用时，可以通过Rep计数器代表输入或输出元素列表中包含的元素数量。调用方还可以指定Rep起始索引，借此代表要使用的下一个输入或输出参数。</p>
<p class="zw">所有虚拟化调用都可以返回另一个名为虚拟化调用结果值的64位值（如图9-17所示）。一般来说，结果值描述了操作的结果，但重复虚拟化调用的结果值描述了已完成的总次数。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx980.png" style="width: 100%" />
<p class="图题">图9-17　虚拟化调用结果值（来自虚拟机监控程序TLFS）</p>
<p class="zw">虚拟化调用的完成需要花费一些时间。对主机来说，保留一个不会接收中断的物理CPU是一种危险的做法。例如，Windows会通过一个机制检测CPU是否在超过16毫秒的时间里没有接收其时钟周期中断。如果检测到这种情况，系统会停止运行并显示蓝屏死机（BSOD）错误。因此对于某些虚拟化调用（包括全部的重复虚拟化调用），虚拟机监控程序会依赖一种虚拟化调用延续机制。如果一个虚拟化调用无法在规定时间（通常为50毫秒）内完成，控制权将（通过一种名为VM_ENTRY的操作）返回给调用方，但指令指针不会越过调用该虚拟化调用的指令。借此，尚未完成的中断即可继续处理，并能继续调度其他虚拟处理器。当最初的调用方线程恢复执行后，即可重新执行虚拟化调用指令，借此推动操作继续完成。</p>
<p class="zw">驱动程序通常绝对不会直接通过平台相关的操作码发出虚拟化调用。相反，驱动程序会使用Windows虚拟机监控程序接口驱动程序所暴露的服务。该驱动程序分为两个版本。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong>WinHvr.sys</strong>。如果操作系统在根分区中运行并且暴露了可供根分区和子分区使用的虚拟化调用，那么该驱动程序会在系统启动时加载。</p>
<p class="zwd"><span style="color: #0092dd">●</span> <strong>WinHv.sys</strong>。只在操作系统在子分区中运行时加载，暴露了仅供子分区使用的虚拟化调用。</p>
<p class="zw">虚拟化栈广泛使用了Windows虚拟机监控程序接口驱动程序所导出的例程和数据结构，尤其是VID驱动程序，正如上文所述，它在整个Hyper-V平台中起到了关键作用。</p>

<p class="epubit-contents-id" style="display: none">{"index":4,"parentId":"ea2ec385-5fa3-4b0f-b598-9bcb1e169157","id":"ef15cfff-5ff5-4d44-9cf8-5dc7fe53963c"}</p>