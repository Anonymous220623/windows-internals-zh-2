<h3 class="bt3" id="sigil_toc_id_86">9.2.6　VA支持的虚拟机</h3>
<p class="zw">虚拟机的用途有很多，其中一种是在隔离的环境（容器）中正确运行传统软件（服务器Silo和应用程序Silo就是容器的两种类型，详见卷1第3章）。完整隔离的容器（内部命名为Xenon和Krypton）需要能快速启动，开销低，并且尽可能减少内存占用。此类虚拟机的客户机物理内存通常会被多个容器共享。例如Windows Defender Application Guard就提供了一种容器，该功能可以通过容器提供完整隔离的浏览器或Windows沙盒，并借助容器获得完全隔离的虚拟化环境。通常来说，容器会共用相同的虚拟机固件、操作系统，并且通常还会共用某些相同的应用程序（这些共享组件组成了容器的基础层）。在专用的客户机物理内存空间中运行每个容器，这种做法并不可行，可能会极大地浪费物理内存。</p>
<p class="zw">为了解决这个问题，虚拟化堆栈为VA支持的虚拟机提供了支持。VA支持的虚拟机可以使用宿主机操作系统的内存管理器为客户机分区的物理内存提供高级功能，如内存去重、内存修剪、直接映射、内存克隆，以及最重要的分页功能（所有这些概念均在卷1第5章进行了详细介绍）。对于传统的虚拟机来说，客户机内存是由VID驱动程序分配的，为此需要静态分配来自宿主机的系统页面，并将其映射至虚拟机的GPA空间，随后才能让虚拟处理器有机会开始执行；但对于VA支持的虚拟机来说，GPA空间和SPA空间之间添加了一个新的中间层，此时不再需要将SPA页面直接映射到GPA空间，VID可以创建一个初始为空的GPA空间，同时创建一个用户模式最小化进程（名为VMMEM）来承载VA空间，并使用MicroVM设置GPA到VA的映射。MicroVM是NT内核的一个新组件，它与NT内存管理器紧密集成，可负责GPA到VA的映射（由VID维护）以及VA到SPA的映射（由NT内存管理器维护），最终实现GPA到SPA的映射。</p>
<p class="zw">这个新增的中间层可以让VA支持的虚拟机充分利用原本供Windows进程使用的大部分高级内存管理功能。正如上一节所述，虚拟机工作进程在启动虚拟机时，需要让VID驱动程序创建分区的内存块。如果是VA支持的虚拟机，则会创建内存块范围GPA映射位图，借此跟踪为新虚拟机的RAM提供支持的已分配虚拟页面。随后虚拟机工作进程还会创建分区的RAM内存，这是由一个大范围的VA空间支持的。VA空间通常会与虚拟机已分配的RAM内存容量一样大（但这并非必要条件：不同的VA范围可映射为不同的GPA范围），并且会在VMMEM进程的上下文中使用原生的NtAllocateVirtualMemory API进行保留。</p>
<p class="zw">如果“延迟提交”优化未启用（详见下一节），VID驱动程序将再次调用NtAllocateVirtualMemory API，这是为了提交整个VA范围。正如卷1第5章所述，提交的内存会消耗系统的提交限制，但依然不会分配任何物理页面（所有描述整个范围的PTE项都是无效的PTE）。VID驱动程序在这个阶段会使用Winhvr要求虚拟机监控程序将整个分区的GPA映射至一个特殊的无效SPA（为此需要使用与标准分区一样的HvMapGpaPages虚拟化调用）。如果客户机分区访问的客户机物理内存是由这个特殊的无效SPA映射到SLAT表所产生的，此时会向虚拟机监控程序发出一个VMEXIT，使其可以识别这个特殊值并向根分区注入内存拦截。</p>
<p class="zw">VID驱动程序最后会调用VmCreateMemoryRange例程向MicroVM告知VA支持的GPA的新范围（MicroVM服务由NT内核通过一个内核扩展公开给VID驱动程序）。MicroVM将分配并初始化一个VM_PROCESS_CONTEXT数据结构，其中包含了两个重要的红黑树：一个描述虚拟机中分配的GPA范围，一个描述根分区中对应的系统虚拟地址（SVA）范围。随后一个指向已分配数据结构的指针会被保存到VMMEM实例的EPROCESS中。</p>
<p class="zw">当虚拟机工作进程希望写入VA支持的虚拟机的内存时，或由于GPA到SPA的无效转换产生了内存拦截时，VID驱动程序会调用MicroVM页面错误处理程序（VmAccessFault）。该处理程序会执行两个重要操作：首先，它会在描述出错虚拟页面的页表中插入一个有效PTE来解决错误（详见卷1第5章），然后会更新子虚拟机的SLAT表（为此需要调用WinHvr驱动程序，由它发出另一个HvMapGpaPages虚拟化调用）。随后，虚拟机的客户机物理页面即可直接换出，因为私有进程内存通常都是可分页的。这就产生了一个重要的影响：要求MicroVM的大部分函数都以被动IRQL级别来运行。</p>
<p class="zw">NT内存管理器的多个服务均可用于VA支持的虚拟机。尤其是克隆模板允许将VA支持的两个虚拟机的内存进行快速克隆，直接映射可以让共享的可执行映像或数据文件的节对象映射至VMMEM进程以及指向VA区域的GPA范围。底层物理页面可在不同虚拟机和宿主机进程之间共享，进而可大幅提高内存密度。</p>
<h4 class="bt4 sigil_not_in_toc">VA支持的虚拟机的优化措施</h4>
<p class="zw">如上一节所述，如果客户机访问缺乏支持的动态内存，或不具备所需权限，此时的访问成本将会相当高：如果客户机企图访问不可访问的内存，将发出VMEXIT，这需要虚拟机监控程序挂起客户机虚拟处理器，调度根分区的虚拟处理器，并向其中注入一个内存拦截消息。VID的拦截回调处理程序需要在高IRQL级别下调用，但处理该请求并调用MicroVM需要在PASSIVE_LEVEL级别下进行。因此需要将DPC放入队列。DPC例程通过设置事件来唤醒负责处理拦截的相应线程。当MicroVM页面错误处理程序解决该错误并调用虚拟机监控程序以更新SLAT项（这要使用另一个虚拟化调用，并产生另一个VMEXIT）之后，才能恢复客户机虚拟处理器的运行。</p>
<p class="zw">运行时产生大量内存拦截会导致性能受到巨大影响。为了避免这种问题，系统以客户机启发（或一些简单配置）的方式实现了很多优化措施。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 内存清零启发。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 内存访问提示。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 启发式页面错误。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 延迟提交和其他优化措施。</p>
<p class="zw">内存清零启发为避免将原本由根分区或其他虚拟机使用的内存构件中包含的信息泄露给另一个虚拟机，内存支持的客户机RAM必须首先清零，然后才能通过映射供其他客户机访问。一般来说，操作系统会在启动过程中将所有物理内存清零，因为在物理系统中，这些内容是非确定性（nondeterministic）的。对于虚拟机，这意味着内存需要清零两次：一次由虚拟化宿主机清零，一次由客户机操作系统清零。对于以物理形式支持的虚拟机，这顶多浪费了CPU周期；但对于VA支持的虚拟机，客户机操作系统进行的清零会产生代价高昂的内存拦截。为避免无谓的拦截，虚拟机监控程序提供了内存清零启发。</p>
<p class="zw">当Windows加载器加载主操作系统时，会使用UEFI固件提供的服务得到计算机的物理内存图。当虚拟机监控程序启动VA支持的虚拟机时，会公开HvGetBootZeroedMemory的虚拟化调用，Windows加载器可以借此查询实际上已经清零的物理内存范围列表。在将执行转向NT内核之前，Windows加载器会将获得的已清零页面与通过EFI服务获得的物理内存描述符合并，并将结果存储到加载器块（有关启动机制的详情请参阅第12章）中。NT内核通过跳过初始内存清零操作，即可将合并后的描述符直接插入已清零的页面列表中。</p>
<p class="zw">虚拟机监控程序也通过类似方式为热添加内存的清零启发提供了支持，这是通过一种简单的实现做到的：当动态内存VSC驱动程序（dmvsc.sys）向NT内核发起添加物理内存的请求时，会指定MM_ADD_PHYSICAL_MEMORY_ALREADY_ZEROED标记，这会提示内存管理器（MM）直接将新页面添加到清零后的页面列表。</p>
<h4 class="bt4 sigil_not_in_toc">内存访问提示</h4>
<p class="zw">对于以物理形式支持的虚拟机，根分区对于客户机内存管理器将如何使用物理页面所能提供的信息极为有限。对于这些虚拟机，这类信息大多都是不相关的，因为几乎所有的内存和GPA映射都是在虚拟机启动时创建的，随后将保持静态映射。对于VA支持的虚拟机，这类信息则非常有用，因为宿主机内存管理器所管理的最小化进程的工作集中就包含了虚拟机的内存（VMMEM）。</p>
<p class="zw">这样的热提示可以让客户机表明要将一组物理页面映射至客户机，因为这些页面很快就要访问，或者需要频繁访问。这也意味着页面会被添加到最小化进程的工作集中。VID处理这类提示的方法是告诉MicroVM立即对物理页面进行错误处理，而不要将其从VMMEM进程的工作集中移除。</p>
<p class="zw">冷提示也可以通过类似方式让客户机表明一组物理页面应该从客户机中取消映射，因为很快就不再使用了。VID驱动程序处理此类提示的方法是将其转发给MicroVM，进而立即将页面从工作集中移除。通常来说，客户机会为已经被后台清零页面线程清零的页面使用冷提示（详见卷1第5章）。</p>
<p class="zw">VA支持的客户机分区可以使用HvMemoryHeatHint虚拟化调用为页面指定内存提示。</p>
<h4 class="bt4 sigil_not_in_toc">启发式页面错误</h4>
<p class="zw">启发式页面错误（Enlightened Page Fault，EPF）处理是一种可以让VA支持的客户机分区重新调度虚拟处理器上线程的功能，该功能会导致VA支持的GPA页面产生内存拦截。通常来说，此类页面的内存拦截处理方式为：以同步方式解决根分区的访问错误，并在访问错误完成后恢复虚拟处理器的运行。当启用了EPF并且VA支持的GPA页面发生内存拦截后，根分区中的VID驱动程序会创建一个后台工作线程，由该线程调用MicroVM页面错误处理程序并向客户机虚拟处理器发出一个同步异常（不要将它与异步中断混淆），这样就可以告知当前线程导致了内存拦截。</p>
<p class="zw">客户机重新调度该线程，同时宿主机正在处理访问错误。访问错误完成后，VID驱动程序会将原先导致故障的GPA添加到一个完成队列中，并向客户机发出一个异步中断。该中断会导致客户机检查完成队列，并解除对正在等待EPF完成的任何线程所进行的封锁。</p>
<h4 class="bt4 sigil_not_in_toc">延迟提交和其他优化措施</h4>
<p class="zw">启用延迟提交这项优化措施，会迫使VID驱动程序在首次访问前不要提交每一个支持页面。这有可能在无须增大页面文件的情况下同时运行更多虚拟机，但因为提供支持的VA空间只是保留空间，并未提交，所以虚拟机在运行过程中可能因达到根分区的提交限额而崩溃。这种情况下已经没有更多可用内存了。</p>
<p class="zw">我们还可以通过其他优化措施设置由MicroVM页面错误处理程序分配的页面大小（可分配“大”或“小”页面），并在首次访问时固定支持页面，这样可以防止老化和修剪，通常可实现更一致的性能，但代价是需要消耗更多的内存，并且会降低内存密度。</p>
<h4 class="bt4 sigil_not_in_toc">VMMEM进程</h4>
<p class="zw">VMMEM进程的存在主要出于以下两个原因。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 在启用根调度器的情况下承载虚拟处理器调度线程循环，并代表客户机虚拟处理器的调度单元。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 为VA支持的虚拟机承载VA空间。</p>
<p class="zw">VMMEM进程由VID驱动程序在创建虚拟机分区时创建。与普通分区（详见上一节）一样，虚拟机工作进程会通过VID.dll库初始化虚拟机的设置，该库可通过IOCTL调用VID。如果VID驱动程序检测到新分区由VA支持，则它会通过VsmmNtSlatMemoryProcessCreate函数调用MicroVM来创建最小化进程。MicroVM使用的PsCreateMinimalProcess函数可分配进程，创建地址空间，并将该进程插入进程列表。随后它会保留地址空间中底部的4&nbsp;GB，以确保直接映射的映像最终不会出现在这里（这会降低客户机的熵和安全性）。VID驱动程序会为新的VMMEM进程应用一个特定的安全描述符，仅SYSTEM和虚拟机工作进程可以访问该进程（虚拟机工作进程会使用特定令牌启动，该令牌的所有者会被设置为使用虚拟机的唯一GUID生成的SID）。这一点非常重要，如果不这样做，VMMEM进程的虚拟地址空间将会被所有人访问。通过读取进程虚拟内存，恶意用户有可能读取到虚拟机专用的客户机物理内存。</p>

<p class="epubit-contents-id" style="display: none">{"index":5,"parentId":"27c847dd-3f08-4fa4-ad0f-10c10f9d2714","id":"2244c46a-7f9d-471f-b7df-eb68c0337002"}</p>