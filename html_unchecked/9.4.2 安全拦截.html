<h3 class="bt3" id="sigil_toc_id_92">9.4.2　安全拦截</h3>
<p class="zw">在有些情况下，安全内核可能需要阻止以较低的VTL运行的NT内核访问某些关键系统资源。例如，对某些处理器的MSR进行写入的功能可能会被用来发起攻击，进而使虚拟机监控程序失效或破坏它的一些保护措施。VSM提供了一种机制，可以让较高的VTL锁定关键系统资源，阻止较低的VTL的访问。该机制称为安全拦截。</p>
<p class="zw">安全拦截是通过在安全内核中注册综合中断来实现的，该中断由虚拟机监控程序提供（会在安全内核中重映射至向量0xF0）。随后，在某些事件导致VMEXIT后，虚拟机监控程序会向触发该拦截的虚拟处理器上较高的VTL注入一个综合中断。截至撰写这部分内容，安全内核会为下列类型的拦截事件向虚拟机监控程序进行注册。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 写入某些重要的处理器MSR（Star、Lstar、Cstar、Efer、Sysenter、Ia32Misc以及AMD64架构中的APIC）和特殊寄存器（GDT、IDT、LDT）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 写入某些控制寄存器（CR0、CR4以及XCR0）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 写入某些I/O端口（例如端口0xCF8和0xCFC，这种拦截还管理着PCI设备的重配置）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 对受保护客户机物理内存的无效访问。</p>
<p class="zw">当VTL 0软件引发一个会提升至VTL 1的拦截时，安全内核需要从自己的中断服务例程中识别出拦截的类型。为此，安全内核会使用SynIC为“拦截”综合中断源而分配的消息队列（有关SynIC和SINT的详情，请参阅上文“分区间通信”一节）。安全内核可以通过检查由虚拟机监控程序虚拟化的SIMP综合MSR来发现并映射物理内存页面。物理页面的映射是在VTL 1中的安全内核初始化时执行的。安全内核的启动过程详见下文。</p>
<p class="zw">为了保护常规NT内核中的敏感部分，HyperGuard大量使用了拦截功能。如果NT内核中安装的恶意Rootkit程序试图通过将特定值写入受保护寄存器（如Syscall处理程序、CSTAR和LSTAR，或特定模型的寄存器）而篡改系统，安全内核拦截处理程序（ShvlpInterceptHandler）会过滤寄存器的新值，如果发现这些值不可接受，就会向VTL 0的NT内核注入一个常规保护错误（General Protection Fault，GPF）不可屏蔽异常。这会导致立即出现Bug检查操作，进而让系统停止运行。如果写入的值可接受，安全内核会使用虚拟机监控程序，通过HvSetVpRegisters虚拟化调用写入新的值（此时安全内核是将对寄存器的访问充当代理）。</p>
<h4 class="bt4 sigil_not_in_toc">对虚拟化调用的控制</h4>
<p class="zw">安全内核与虚拟机监控程序注册的最后一种拦截类型为虚拟化调用拦截。虚拟化调用拦截的处理程序会检查VTL 0代码向虚拟机监控程序发出的虚拟化调用是否合法，是否源自操作系统本身，而非某些外部模块。当任何一个VTL发出虚拟化调用时，都会导致虚拟机监控程序产生VMEXIT（设计特性）。虚拟化调用是每个VTL的内核组件相互之间（以及虚拟机监控程序本身）请求服务时使用的基础服务。只有在使用虚拟化调用向虚拟机监控程序直接请求服务时，虚拟机监控程序才会向较高的VTL注入综合拦截中断，并会跳过与安全内核之间进行安全调用和常规调用的所有虚拟化调用。</p>
<p class="zw">如果虚拟化调用未被识别为有效，则完全不会被执行：此时，安全内核会更新较低的VTL的寄存器，以便发出虚拟化调用错误的信号。系统不会崩溃（不过这种行为在未来可能产生变化），发出调用的代码可以决定如何处理该错误。</p>

<p class="epubit-contents-id" style="display: none">{"index":1,"parentId":"235e6070-2914-47dd-bdb6-a375816a60a3","id":"5dee9e8e-7bde-421e-813c-53941edcc61a"}</p>