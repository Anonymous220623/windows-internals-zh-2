<h3 class="bt3" id="sigil_toc_id_94">9.4.4　安全线程和调度</h3>
<p class="zw">正如我们将在下文“隔离用户模式”中讨论的那样，VSM的执行单位是安全线程，安全线程位于安全进程所描述的地址空间中。安全线程可以是内核模式或用户模式的线程。VSM会在每个用户模式安全线程和VTL 0中的常规线程之间维持严格的对应关系。</p>
<p class="zw">实际上，安全内核线程调度完全依赖于常规的NT内核，安全内核不包含任何专有的调度器（按照设计，安全内核的表面需要尽可能小）。在卷1第3章中，我们介绍了NT内核创建进程和相关初始线程的方式，在描述阶段4“创建初始线程及其堆栈和上下文”一节，我们解释过线程的创建过程分为两个步骤。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 创建执行体线程对象，分配内核和用户堆栈。需要调用KeInitThread例程为用户模式线程设置初始线程上下文。KiStartUserThread将会是新线程上下文中执行的第一个例程，它可以降低线程的IRQL并调用PspUserThreadStartup。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 将执行控制返回给NtCreateUserProcess，由它在后续阶段调用PspInsertThread完成线程的初始化工作，并将其插入对象管理器命名空间。</p>
<p class="zw">作为工作的一部分，当PspInsertThread检测到线程属于安全进程后，它会调用VslCreateSecureThread，顾名思义，借此可使用Create Thread安全服务调用来要求安全内核创建相关的安全线程。安全内核会验证参数并获取进程的安全映像数据结构（详见下文）。随后它会分配安全线程对象及其TEB，创建初始线程的上下文（运行的第一个例程为SkpUserThreadStartup），并最终让该线程可以被调度。此外，在将该线程标记为已就绪可运行后，VTL 1中的安全服务处理程序会返回一个特定的线程Cookie，并将其存储在ETHREAD数据结构中。</p>
<p class="zw">新的安全线程依然在&nbsp;VTL 0&nbsp;中启动。正如卷&nbsp;1&nbsp;第&nbsp;3&nbsp;章的“阶段&nbsp;7”一节所述，PspUserThreadStartup会在新的上下文中执行用户线程的最终初始化工作。如果它判断线程的拥有者进程是一个Trustlet，则PspUserThreadStartup将调用VslStartSecureThread函数，并由后者通过VTL 0中的VslpEnterIumSecureMode例程调用安全调用调度循环（传递由Create Thread安全服务处理程序返回的安全线程Cookie）。调度循环向安全内核请求的第一个操作将会是恢复安全线程的执行（这依然是通过HvVtlCall虚拟化调用做到的）。</p>
<p class="zw">在切换到VTL 0之前，安全内核会在常规调用调度程序循环（SkCallNormalMode）中执行代码。由常规内核执行的虚拟化调用会重启动在同一个循环例程中的执行。VTL 1调度程序循环会识别出新线程的恢复请求，随后它会将自己的执行上下文切换至新的安全线程，附加到该线程的地址空间，并使该线程可以运行。在上下文切换过程中，还会选择一个新的栈（该栈在此之前由Create Thread安全调用完成初始化）。这个新的栈包含第一个安全线程系统函数（SkpUserThreadStartup）的地址，与常规NT线程的情况类似，这个函数可以设置运行映像加载器初始化例程（Ntdll.dll中的LdrInitializeThunk）所需的初始形式转换（Thunk）上下文。</p>
<p class="zw">启动之后，新的安全线程即可返回到常规模式，这主要出于两个原因：发出了需要在VTL 0下处理的常规调用请求，或VINA中断抢占了代码的执行。虽然这两种情况的处理方式略有差异，但都会导致执行常规调用调度程序循环（SkCallNormalMode）。</p>
<p class="zw">正如我们在卷1第4章的“线程”一节讨论的那样，NT调度器的正常运行离不开处理器时钟，当系统时钟触发（通常每15.6毫秒一次）时，处理器时钟会产生一个中断。时钟中断服务例程会更新处理器计时器并计算线程的量程是否已过期。该中断以VTL 0为目标，因此，当虚拟处理器在VTL 1下执行代码时，虚拟机监控程序会向安全内核注入一个VINA中断，如图9-36所示。该VINA中断可以抢占当前正在执行的代码，将IRQL降低到之前被抢占代码的IRQL值，并发出进入VTL 0所需的VINA常规调用请求。</p>
<p class="zw">作为常规调用调度的标准过程，在安全内核发出HvVtlReturn虚拟化调用之前，它会从虚拟处理器的PRCB中选择当前的执行线程。这一点很重要：VTL 1中的虚拟处理器不再与任何线程上下文绑定，在下一个循环周期里，安全内核可以切换到不同的线程，或决定重新调度当前线程的执行。</p>
<p class="zw">VTL切换后，NT内核会恢复在安全调用调度循环中的执行，此时依然会在新线程的上下文中执行。在有机会执行任何代码前，代码会被时钟中断服务例程抢占，该例程会计算新的量程值，如果量程值已过期，则会切换执行另一个线程。当发生上下文切换，并且另一个线程进入VTL 1时，根据安全线程Cookie的值，常规调用调度循环会调度另一个安全线程。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 如果常规NT内核为了调度安全调用已进入VTL 1，则从安全线程池中选择一个安全线程（此时安全线程Cookie为0）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 如果线程的执行已重新调度，则选择一个新创建的安全线程（安全线程Cookie为有效值）。如图9-36所示，这个新线程也可以被其他虚拟处理器（本例中为VP3）重新调度。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx2305.png" style="width: 100%" />
<p class="图题">图9-36　安全线程调度结构</p>
<p class="zw">按照上述方案，所有调度决策都只在VTL 0下进行。安全调用循环和常规调用循环会相互配合，以便将安全线程上下文正确地切换到VTL 1中。所有安全线程都在常规内核中有一个相关线程，但反之未必如此。如果VTL 0下的一个常规线程决定发出安全调用请求，安全内核会使用来自线程池的任意线程上下文来调度该请求。</p>

<p class="epubit-contents-id" style="display: none">{"index":3,"parentId":"235e6070-2914-47dd-bdb6-a375816a60a3","id":"78442c6d-1014-4cb6-b2c1-d55fd670f675"}</p>