<h3 class="bt3" id="sigil_toc_id_96">9.4.6　UEFI运行时虚拟化</h3>
<p class="zw">在启用HVCI的情况下，安全内核提供的另一项服务是为UEFI运行时服务提供虚拟化和保护。正如将在第12章介绍的那样，UEFI固件服务主要是通过一个大型函数指针表实现的。当操作系统拿到控制权并调用ExitBootServices函数时，该表的部分内容将从内存中删除，但表中的另一部分代表了运行时服务，会始终维持映射状态，甚至在操作系统全面控制计算机后也会保持这种状态。这是必要的，因为有时候操作系统需要与UEFI配置和服务进行交互。</p>
<p class="zw">每个硬件供应商都实现了自己的UEFI固件。在HVCI的帮助下，固件可以相互配合为自己的每个可执行内存页面提供不可写的状态（任何固件页面都不能在VTL 0中映射为读取、写入和执行状态）。UEFI固件驻留的内存范围由多个MEMORY_DESCRIPTOR数据结构描述，这些数据结构位于EFI内存图中。Windows加载器会解析这些数据，借此为UEFI固件的内存提供适当保护。然而，在UEFI的原始实现中，代码和数据会混合存储在同一个（或多个）节中，并由相应的内存描述符来描述。此外，一些设备驱动程序会直接通过UEFI的内存区域读/写配置数据，这明显与HVCI的要求不符。</p>
<p class="zw">为了解决这些问题，安全内核采取了下列两种策略。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 由新版UEFI固件（遵守UEFI 2.6和后续版本的规范）维持了一个名为内存属性表（Memory Attribute Table，MAT）的全新配置表（链接到启动服务表）。MAT非常细化地定义了UEFI内存区域中的不同节，这些节均为EFI内存图所定义的内存描述符的子节。每个节永远不可能同时获得可执行和可写入的保护特性。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 对于旧的固件，安全内核会在VTL 0中使用只读访问权限映射整个UEFI固件区域的物理内存。</p>
<p class="zw">对于第一种策略，在启动时，Windows加载器会将EFI内存图和MAT中找到的信息合并在一起形成一个内存描述符数组，该数组精确描述了整个固件区域。随后加载器会将其复制到VTL 1中一个保留的缓冲区中（用于休眠路径），并验证每个固件的节是否违反W^X做出的假设。如果不违反，那么当安全内核启动时，会对属于底层UEFI固件区域的每个内存页应用适当的SLAT保护。物理页面会受到SLAT保护，但其在VTL 0中的虚拟地址空间依然会被完全标记为RWX。确保虚拟内存获得RWX保护，这一点很重要，因为当应用给MAT项的保护可能被更改的情况下，安全内核依然要能为从休眠中恢复的场景提供支持。此外，这样也可以与需要直接读/写UEFI内存区域的旧版本驱动程序保持兼容性，确保这类驱动程序能直接对相应的节执行写操作（此外，UEFI代码应该还能写入映射至VTL 0的自己的内存）。该策略可以让安全内核避免将任何固件代码映射至VTL 1，而VTL 1中唯一存留的固件代码仅仅只是运行时函数表本身。将该表留在VTL 1，可让从休眠状态恢复使用的代码直接更新UEFI运行时服务的函数指针。</p>
<p class="zw">第二种策略并非最佳策略，只会用于确保旧系统在启用HVCI后可以正常运行。如果安全内核在固件中未找到任何MAT，此时将别无选择，只能将整个UEFI运行时服务代码映射至VTL 1。历史上，UEFI固件代码（尤其是SMM中）曾被检测到包含很多Bug，将固件映射至VTL 1可能是一种危险的做法，但这是此时唯一能兼容HVCI的解决方案（如上文所述，新系统绝不会将任何UEFI固件代码映射至VTL 1）。启动时，NT Hal检测到HVCI已启用，并且固件被完全映射至VTL 1。此时它会将自己内部EFI服务表的指针切换到一个名为UEFI包装表（UEFI wrapper table）的新表。该包装表中的项所包含的存根例程可以使用INVOKE_EFI_RUNTIME_SERVICE安全调用进入VTL 1。安全内核会对参数进行封送，执行固件调用，并将结果输出到VTL 0。这种情况下，描述整个UEFI固件的全部物理内存依然会以只读模式映射至VTL 0。这是为了让驱动程序能够正确地从UEFI固件内存区域读取信息（如ACPI表）。这种情况下，需要直接写入UEFI内存区域的旧驱动程序将无法兼容HVCI。</p>
<p class="zw">当安全内核从休眠状态恢复时，会更新内存中的UEFI服务表，以指向新服务的位置。此外，对于具备新版UEFI固件的系统，安全内核会对映射至VTL 0的每个内存区域应用SLAT保护（Windows加载器可在需要时更改区域的虚拟地址）。</p>

<p class="epubit-contents-id" style="display: none">{"index":5,"parentId":"235e6070-2914-47dd-bdb6-a375816a60a3","id":"bbbee94e-7464-43f8-a39d-39eebc493f35"}</p>