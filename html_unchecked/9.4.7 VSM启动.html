<h3 class="bt3" id="sigil_toc_id_97">9.4.7　VSM启动</h3>
<p class="zw">我们会在第12章完整介绍Windows的启动和关闭机制，本节将介绍安全内核与整个VSM基础架构的启动方式。安全内核的正常启动离不开虚拟机监控程序、Windows加载器以及NT内核。我们会在第12章介绍Windows加载器和虚拟机监控程序加载器，以及这两个模块在VTL 0中对安全内核进行初始化的前期阶段。本节将重点介绍securekernel.exe二进制文件中所实现的VSM启动方法。</p>
<p class="zw">securekernel.exe二进制文件执行的第一段代码依然运行在VTL 0下，此时虚拟机监控程序已经启动，VTL 1所用的页表也已创建完成。安全内核会在VTL 0中初始化下列组件。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 内存管理器的初始化函数存储了VTL 0根级页级结构的PFN，保存代码完整性数据，并启用HVCI、MBEC（基于模块的执行控制）、内核CFG以及热修补。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 共享特定架构的CPU组件，如GDT和IDT。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 常规调用和安全系统调用调度表（初始化并压缩）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 启动处理器。启动处理器的启动过程需要安全内核分配自己的内核与中断堆栈，初始化与架构有关并且无法在不同组件之间共享的组件（如TSS），并最终分配处理器的SKPRCB。后者是一个重要的数据结构，与VTL 0的PRCB数据结构类似，可用于存储与每个CPU有关的重要信息。</p>
<p class="zw">安全内核初始化代码已经准备好首次进入VTL 1。虚拟机监控程序子系统初始化函数（ShvlInitSystem例程）连接到虚拟机监控程序（通过虚拟机监控程序CPUID类，详见上一节）并检查可支持的启发。随后它会保存VTL 1的页表（之前由Windows加载器创建）以及已分配的虚拟化调用页面（用于保存虚拟化调用参数）。最终它会以下列方式初始化并进入VTL 1。</p>
<p class="zw">1）通过HvEnablePartitionVtl虚拟化调用为当前虚拟机监控程序分区启用VTL 1。虚拟机监控程序会将常规VTL中的现有SLAT表复制到VTL 1，并为该分区启用MBEC和新的VTL 1。</p>
<p class="zw">2）通过HvEnableVpVtl虚拟化调用为启动处理器启用VTL 1。虚拟化监控程序会初始化一个新的每级别VMCS数据结构，编译该数据结构，并设置SLAT表。</p>
<p class="zw">3）要求虚拟机监控程序提供平台相关的VtlCall和VtlReturn虚拟化调用代码的位置。执行VSM调用所需的CPU操作码会隐藏安全内核的实现，这样安全内核的大部分代码均可与平台无关。最后，安全内核执行HvVtlCall虚拟化调用转换至VTL 1。虚拟机监控程序为新的VTL加载VMCS并进行切换（将其激活）。至此，新的VTL就已经可以运行了。</p>
<p class="zw">安全内核会在VTL 1中进行复杂的初始化过程，但依然需要依赖Windows加载器以及NT内核。需要注意，在这个阶段，VTL 1内存依然需要映射至VTL 0，安全内核及其附属模块依然可以被常规世界所访问。在切换至VTL 1后，安全内核会开始初始化启动过程。</p>
<p class="zw">1）获取综合中断控制器共享页、TSC以及虚拟处理器辅助页的虚拟地址，这些地址均由虚拟机监控程序提供，可用于在虚拟机监控程序和VTL 1代码之间共享数据。虚拟化调用页面会被映射至VTL 1。</p>
<p class="zw">2）阻断其他系统虚拟处理器被较低VTL启动的可能性，请求内存在重启动时被虚拟机监控程序清零。</p>
<p class="zw">3）初始化并填充启动过程中断描述符表（IDT）。配置IPI、回调以及安全计时器中断处理程序，并将当前安全线程设置为默认的SKPRCB线程。</p>
<p class="zw">4）启动VTL 1安全内存管理器，由它创建启动表映射并在VTL 1中映射启动加载器的内存，创建安全PFN数据库和系统超空间（Hyperspace），初始化对安全内存池的支持，读取VTL 0加载器块以复制安全内核导入映像（Skci.dll、Cnf.sys、Vmsvcext.sys）的模块描述符。最后，还需要查看NT已加载模块列表以建立每个驱动程序的状态，为每个驱动程序创建NAR（Normal Address Range，常规地址范围）数据结构，并为组成启动驱动程序的节的每个页面编译常规表项（Normal Table Entry，NTE）。另外，安全内存管理器初始化函数还会为每个驱动程序的节应用适当的VTL 0 SLAT保护。</p>
<p class="zw">5）初始化HAL、安全线程池、进程子系统、综合APIC、安全PNP以及安全PCI。</p>
<p class="zw">6）为安全内核页面应用只读的VTL 0 SLAT保护，配置MBEC，为启动处理器启用VINA虚拟中断。</p>
<p class="zw">这部分初始化工作结束后，安全内核会解除对启动加载内存的映射。正如上一节所述，安全内存管理器依赖VTL 0内存管理器分配并释放VTL 1内存。VTL 1不拥有任何物理内存。在这个阶段，VTL 1依赖之前（由Windows加载器）分配的物理页面来满足内存分配请求。当NT内核稍后启动后，安全内核会执行常规调用以向VTL 0内存管理器请求内存服务。因此，安全内核一些部分的初始化必须延迟到NT内核启动后进行。执行流会返回至VTL 0下的Windows加载器，由Windows加载器负责加载并启动NT内核。安全内核初始化的最后一部分工作发生在NT内核初始化的阶段0和阶段1中（详见第12章）。</p>
<p class="zw">NT内核初始化的阶段0中依然没有可用的内存服务，此时也是安全内核依旧完全信任常规世界的最后一刻。启动时加载的驱动程序依然未初始化，而初始启动过程应该已经受到安全启动功能的保护。PHASE3_INIT这个安全调用处理程序会修改属于安全内核及其附属模块的所有物理页面的SLAT保护，使其无法在VTL 0下访问。此外，它还会为内核CFG位图应用只读保护。在这个阶段，安全内核将启用对页面文件完整性的支持，创建初始系统进程及其地址空间，保存共享的CPU寄存器（如IDT、GDT、Syscall MSR等）的所有“可信任”的值。共享的寄存器所指向的数据结构会被（通过NTE数据库）验证。最后，安全线程池启动，对象管理器、安全代码完整性模块（Skci.dll）以及HyperGuard均被初始化（有关HyperGuard的详细信息请参阅卷1第7章）。</p>
<p class="zw">当执行流返回到VTL 0后，NT内核即可启动所有其他应用程序处理器（Application Processor，AP）。安全内核被启用后，将以略微有变的方式进行AP的初始化（下一节将讨论AP的初始化）。</p>
<p class="zw">作为NT内核初始化阶段1工作的一部分，系统会启动I/O管理器。如卷1第6章所述，I/O管理器是I/O系统的核心，定义了将I/O请求以何种模型传递给设备驱动程序。I/O管理器的职责之一是初始化并启动引导加载的驱动程序以及ELAM驱动程序。在创建用于映射用户模式系统DLL所需的特殊节之前，I/O管理器初始化函数会发出PHASE4_INIT安全调用以启动安全内核的初始化的最后阶段。在这个阶段，安全内核已经不再信任VTL 0，但依然可以使用NT内存管理器提供的服务。安全内核会初始化安全用户共享（Secure User Shared）数据页的内容（这些页面会同时映射到VTL 1用户模式和内核模式）并完成执行体子系统初始化工作。它还会回收启动过程中保留的所有资源，调用自己依赖的每个模块（尤其是先于其他常规启动驱动程序启动的cng.sys和vmsvcext.sys）的入口点。它会为休眠文件、崩溃转储文件以及分页文件的加密以及内存页面完整性分配必要的资源，最后，它还会读取并映射VTL 1内存中的API集Schema文件。至此，VSM的初始化全部完成。</p>
<h4 class="bt4 sigil_not_in_toc">应用程序处理器启动</h4>
<p class="zw">安全内核提供的安全功能之一是应用程序处理器（AP）的启动。AP是指不用于启动系统的处理器。当系统启动时，Intel和AMD的x86与AMD64架构规范定义了一种精确的算法，用于在多处理器系统中选择启动处理器（Boot Strap Processor，BSP）。启动处理器始终以16位实模式（只能访问1&nbsp;MB物理内存）启动，通常还要负责执行计算机的固件代码（大部分情况下为UEFI），而这些代码需要位于特定的物理内存位置（这个位置也叫复位向量）。启动处理器执行了几乎全部的操作系统、虚拟机监控程序以及安全内核初始化工作。为了启动“启动处理器”外的其他处理器，系统需要向属于每个处理器的本地APIC发送一个特殊的IPI（Inter-Processor Interrupt，处理器间中断）。启动IPI（SIPI）向量包含处理器启动块的物理内存地址，这种代码块包含执行下列基本操作的指令。</p>
<p class="zw">1）加载GDT并从16位实模式切换至32位受保护模式（不启用分页）。</p>
<p class="zw">2）设置一个基础页表，启用分页，进入64位长模式。</p>
<p class="zw">3）加载64位IDT和GDT，设置适当的处理器寄存器，跳转至操作系统启动函数（KiSystemStartup）。</p>
<p class="zw">这个过程很容易受到恶意攻击。处理器启动代码在AP处理器上执行时，可能会被外部实体修改（NT内核此时还无法施加控制）。在这种情况下，VSM所带来的各种安全承诺都可能被轻松绕过。在启用虚拟机监控程序和安全内核后，应用程序处理器依然由NT内核启动，但会使用虚拟机监控程序来启动。</p>
<p class="zw">NT内核初始化的阶段1（详见第12章）会调用KeStartAllProcessors函数，借此可以启动所有AP，构建一个共享的IDT，并查询多APIC描述表（Multiple APIC Description Table，MADT）这个ACPI表，借此枚举所有可用处理器。对于被检测到的每个处理器，还会为PRCB和内核与DPC栈的所有私有CPU数据结构分配内存。如果VSM已启用，随后则会向安全内核发出START_PROCESSOR安全调用以启动AP。安全内核会验证为新处理器分配和填充的所有数据结构是否有效，包括处理器寄存器的初始值和启动例程（KiSystemStartup），确保AP可以按顺序启动，并且每次只启动一个处理器。随后，它会初始化新的应用程序处理器需要的VTL 1数据结构（尤其是SKPRCB），并使用PRCB线程将安全调用调度给新处理器的上下文，同时使用SLAT保护VTL 0 CPU数据结构。最后，安全内核会为新应用程序处理器启用VTL 1，并使用HvStartVirtualProcessor虚拟化调用启动这些AP。虚拟机监控程序会使用与本节开头介绍的类似方式启动AP（发送启动IPI）。不过这种情况下，AP会在虚拟机监控程序上下文中开始执行，随后切换至64位长模式执行，并返回到VTL 1。</p>
<p class="zw">应用程序处理器执行的第一个函数位于VTL 1中。安全内核的CPU初始化例程会映射每处理器VP辅助页面和SynIC控制页面，配置MBEC，并启用VINA。随后它会通过HvVtlReturn虚拟化调用返回VTL 0。VTL 0中执行的第一个例程是KiSystemStartup，该例程可以初始化NT内核管理AP所需的数据结构，初始化HAL，并跳转至空闲循环（详见第12章）。第一个安全调用执行完成后，将由常规NT内核初始化安全调用调度循环。</p>
<p class="zw">这种情况下，攻击者无法修改处理器的启动块或CPU寄存器和数据结构的任何初始值。在上述安全AP启动过程的帮助下，任何修改都会被安全内核检测到，随后系统将进入Bug检查模式，进而挫败任何可能的攻击企图。</p>

<p class="epubit-contents-id" style="display: none">{"index":6,"parentId":"235e6070-2914-47dd-bdb6-a375816a60a3","id":"6725ceb1-2d3c-42f6-ba30-5424ca027ae4"}</p>