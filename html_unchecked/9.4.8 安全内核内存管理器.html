<h3 class="bt3" id="sigil_toc_id_98">9.4.8　安全内核内存管理器</h3>
<p class="zw">安全内核内存管理器严重依赖NT内存管理器以及Windows Loader内存管理器的启动代码。安全内核内存管理器的完整介绍已超出了本书的范围。此处我们只讨论安全内核中最重要的概念和数据结构。</p>
<p class="zw">如上一节所述，安全内核内存管理器初始化过程可分为三个阶段。在最重要的阶段1，内存管理器会执行下列操作。</p>
<p class="zw">1）映射VTL 1中的启动加载器固件内存描述符列表，扫描该列表，确定可用于分配初始启动过程所需内存的第一个物理页面（此类内存也叫SLAB）。将VTL 0的页表映射至VTL 1页表前恰好512&nbsp;GB处的虚拟地址中。这样安全内核即可在NT虚拟地址和安全内核的虚拟地址之间进行快速转换。</p>
<p class="zw">2）初始化PTE范围数据结构。PTE范围包含了一个位图，该位图描述了已分配的虚拟地址范围块，可以帮助安全内核为自己的地址空间分配PTE。</p>
<p class="zw">3）创建安全PFN数据库并初始化内存池。</p>
<p class="zw">4）初始化稀疏NT地址表。对于每个引导加载的驱动程序，还会创建并填充一个NAR，验证二进制文件的完整性，填充热修补信息。如果启用了HVCI，还会使用SLAT保护驱动程序的每个可执行节。随后会在内存映像的每个PTE以之间进行循环，并在NT地址表中写入一个NT地址表项（Address Table Entry，NTE）。</p>
<p class="zw">5）初始化页面捆绑（page bundle）。</p>
<p class="zw">安全内核会跟踪常规NT内核使用的内存。安全内核内存管理器使用NAR数据结构描述包含可执行代码的内核虚拟地址范围。NAR包含有关该范围的一些信息（如范围的基址和大小）以及一个指向SECURE_IMAGE数据结构的指针，该数据结构被用于描述载入VTL 0的运行时驱动程序（一般来说，会使用安全HVCI验证映像，包括Trustlet使用的用户模式的映像）。引导加载的驱动程序并不使用SECURE_IMAGE数据结构，因为NT内存管理器会将其视作包含可执行代码的私有页面。后一种数据结构包含与NT内核中所加载映像有关的信息（由SKCI进行验证），例如入口点的地址、重定位表的副本（用于处理Retpoline和导入优化）、指向其共享原型PTE的指针、热修补信息，以及一个指定了内存页面授权用途的数据结构。SECURE_IMAGE数据结构非常重要，因为安全内核要借此来跟踪并验证运行时驱动程序使用的共享内存页面。</p>
<p class="zw">安全内核会使用NTE数据结构跟踪VTL 0内核私有页面。在VTL 0地址空间中，每个需要安全内核监管的虚拟页面都有一个NTE，它通常会被用于私有页面。NTE可跟踪VTL 0虚拟页面的PTE并存储页面状态和保护措施。启用HVCI的情况下，NTE表会将所有虚拟页面划分为特权页和非特权页。特权页表示NT内核无法自行碰触的内存页（因为这类页面受到SLAT保护，通常对应于一个可执行页或内核CFG只读页）；非特权页表示NT内核可以完整控制的所有其他类型内存页。安全内核会使用无效的NTE来代表非特权页。在禁用HVCI的情况下，所有私有页都是非特权页（NT内核可以对所有页面具备完整控制权）。</p>
<p class="zw">在启用HVCI的系统中，NT内存管理器无法修改任何受保护的页面。否则虚拟机监控程序会产生EPT违规异常并导致系统崩溃。当这样的系统完成引导阶段后，安全内核已经处理完所有不可执行的物理页面，即使用SLAT保护它们只能进行读取或写入访问。这种情况下，只有当目标代码已被安全HVCI验证之后，才能分配新的可执行页面。</p>
<p class="zw">当系统、应用程序或即插即用管理器需要加载新的运行时驱动程序时，将启动一个复杂的过程来调用NT和安全内核的内存管理器，全过程概括如下。</p>
<p class="zw">1）NT内存管理器创建一个节对象，分配并填充一个新的控制区域（有关NT内存管理器的详情请参阅卷1第5章），读取二进制文件的第一个页面，并调用安全内核以创建相应的安全映像，该映像描述了新加载的模块。</p>
<p class="zw">2）安全内核创建SECURE_IMAGE数据结构，解析二进制文件的所有节，并填充安全原型PTE数组。</p>
<p class="zw">3）NT内核将整个二进制文件读取到不可执行的共享内存（由控制区域的原型PTE指向），调用安全内核，安全内核将使用安全HVCI在二进制映像的每个节之间循环，并计算最终的映像哈希。</p>
<p class="zw">4）如果计算出的文件哈希与数字签名中存储的哈希相符，则NT内存管理器将查看整个映像，并为每个页面调用安全内核，由安全内核验证页面（每个页面哈希已经在上一个阶段计算出来了），应用所需的隔离（ASLR、Retpoline以及导入优化），并应用新的SLAT保护，让页面可以执行但不再可以写入。</p>
<p class="zw">5）节对象已创建。NT内存管理器需要将驱动程序映射到自己的地址空间。它会调用安全内核来分配所需的特权PTE，借此描述驱动程序的虚拟地址范围。安全内核会创建NAR数据结构，随后映射驱动程序的物理页面，这些页面之前已经使用MiMapSystemImage例程验证过了。</p>
<table> 
 <tbody> 
  <tr> 
   <td style="vertical-align:top;border:none;"> <p class="cxtu"><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tu.png" style=""></p> </td> 
   <td style="vertical-align:top;border:none;"> <p class="zwzy"><strong style="color:#0092dd">注意</strong>　在为运行时驱动程序初始化NAR时，为描述新驱动程序的地址空间，NTE表的一部分会被填充。NTE并不用于跟踪运行时驱动程序的虚拟地址范围（其虚拟页面是共享的、非私有的），因此，NT地址表中的相应部分会使用无效的“保留”NTE来填充。</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">当VTL 0内核虚拟地址范围使用NAR数据结构来表示时，安全内核会使用安全VAD（Virtual Address Descriptor，虚拟地址描述符）来跟踪VTL 1中的用户模式的虚拟地址。每次进行新的私有虚拟分配，将二进制映像映射至Trustlet（安全进程）的地址空间，以及创建VBS隔区或模块被映射至地址空间时，都会创建安全VAD。安全VAD类似于NT内核VAD，其中包含一个VA范围描述符、一个引用计数器、一些标记，以及一个指向（由SKCI创建的）安全节的指针（如果安全VAD描述了私有虚拟分配，该安全节指针会被设置为0）。有关Trustlet和VBS隔区的详细信息请参阅下文。</p>
<h4 class="bt4 sigil_not_in_toc">页面完整性和安全PFN数据库</h4>
<p class="zw">当驱动程序被加载并正确映射至VTL 0内存后，NT内存管理器需要能管理它的内存页面（出于多种原因，例如将可分页驱动程序的节换出，创建私有页面，为应用程序进行私有修复等，详见卷1第5章）。每当NT内存管理器针对受保护的内存进行操作时，都需要安全内核的配合。为了让NT内存管理器可以操作特权内存，安全内核主要提供了两项安全服务：受保护页面的复制和受保护页面的移除。</p>
<p class="zw">PAGE_IDENTITY数据结构可以充当“胶水”，让安全内核持续跟踪所有不同类型的页面。该数据结构包含两个字段：一个地址上下文（address context）和一个虚拟地址（virtual address）。每当NT内核调用安全内核来操作特权页面时，它需要指定物理页面编号以及一个描述物理页面用途的有效PAGE_IDENTITY数据结构）。通过这种数据结构，安全内核可以验证所请求的页面用途并决定是否允许该请求。</p>
<p class="zw">表9-4展示了PAGE_IDENTITY数据结构（第二列和第三列），以及安全内核对不同内存页面进行的所有验证类型。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 如果安全内核收到一个需要复制或释放运行时驱动程序共享可执行页面的请求，它会验证安全映像句柄（由调用方指定）并获取其相对数据结构（SECURE_ IMAGE）。随后它会使用相对虚拟地址（Relative Virtual Address，RVA）作为安全原型数组的索引来获取驱动程序共享页面的物理页帧（Physical Page Frame，PFN）。如果找到的PFN等于调用方指定的那个，安全内核将允许该请求；否则请求会被阻止。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 按照类似方式，如果NT内核请求对Trustlet或隔区页面（有关Trustlet或安全隔区的详细信息请参阅本章下文）进行操作，安全内核将使用调用方指定的虚拟地址来验证安全进程页表中的安全PTE是否包含正确的PFN。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 如上文“安全内核内存管理器”一节所述，对于私有内核页面，安全内核会从调用方指定的虚拟地址开始定位NTE，并验证它是否包含有效的PFN，该PFN必须与调用方指定的一致。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 占位页（placeholder page）是一种受SLAT保护的空闲页面，安全内核会使用PFN数据库验证占位页的状态。</p>
<p class="表题">表9-4　安全内核管理的不同页面标识</p>
<table> 
 <tbody> 
  <tr> 
   <th> <p class="bt">页面类型</p> </th> 
   <th> <p class="bt">地址上下文</p> </th> 
   <th> <p class="bt">虚拟地址</p> </th> 
   <th> <p class="bt">验证结构</p> </th> 
  </tr> 
  <tr> 
   <td> <p class="bg">内核共享</p> </td> 
   <td> <p class="bg">安全映像句柄</p> </td> 
   <td> <p class="bg">页面的RVA</p> </td> 
   <td> <p class="bg">安全原型PTE</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">Trustlet/隔区</p> </td> 
   <td> <p class="bg">安全进程句柄</p> </td> 
   <td> <p class="bg">安全进程的虚拟地址</p> </td> 
   <td> <p class="bg">安全PTE</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">内核私有</p> </td> 
   <td> <p class="bg">0</p> </td> 
   <td> <p class="bg">页面的内核虚拟地址</p> </td> 
   <td> <p class="bg">NT地址表项（NTE）</p> </td> 
  </tr> 
  <tr> 
   <td> <p class="bg">占位</p> </td> 
   <td> <p class="bg">0</p> </td> 
   <td> <p class="bg">0</p> </td> 
   <td> <p class="bg">PFN项</p> </td> 
  </tr> 
 </tbody> 
</table>
<p class="zw">安全内核内存管理器维护的PFN数据库可代表每个物理页面的状态。安全内核中的PFN项远小于NT内核中的等效项，基本上只包含页面状态和共享计数器。从安全内核的角度来看，物理页面可处于下列一种状态：无效、空闲、共享、I/O、安全或映像（安全的NT私有）。</p>
<p class="zw">上述“安全”状态可用于对安全内核来说属于私有的物理页面（NT内核永远不能申领），或用于已经被NT内核分配随后又被安全内核使用SLAT保护，以存储经由安全HVCI验证的可执行代码的物理页面。仅安全的非私有物理页面具备页面标识。</p>
<p class="zw">当NT内核要将受保护页面换出时，它会要求安全内核执行页面移除操作。安全内核会分析指定的页面标识并（按照上文介绍的过程）进行验证。如果页面标识代表隔区或安全页面，安全内核首先加密页面内容，随后将其释放给NT内核，并由NT内核将其存储在分页文件中。这样，NT内核依然无法获取私有内存中的真正内容。</p>
<h4 class="bt4 sigil_not_in_toc">安全内存分配</h4>
<p class="zw">如上文所述，安全内核最初启动时，它会解析固件的内存描述符列表，这样才能分配供自己使用的物理内存。在初始化的阶段1中，安全内核无法使用NT内核提供的内存服务（此时NT内核还未初始化），因此它会使用固件内存描述符列表中的空闲项保留2&nbsp;MB的SLAB。SLAB是一种2&nbsp;MB的连续物理内存，可由虚拟机监控程序中的一个嵌套页表目录项映射而来。所有SLAB页面都可获得相同的SLAT保护。SLAB在设计上充分考虑了性能问题。通过使用虚拟机监控程序中的单个嵌套页表项映射一个2&nbsp;MB的物理内存块，可以加快其他硬件内存地址转换的速度，并降低SLAT表缓存未命中的概率。</p>
<p class="zw">第一个安全内核页面捆绑会使用已分配的1&nbsp;MB SLAB内存来填充。页面捆绑是一种数据结构，如图9-37所示，其中包含了连续可用的物理页帧编号（PFN）列表。当安全内核自己需要内存时，它会从捆绑的PFN数组尾部移除一个或多个空闲页帧，借此从页面捆绑中分配物理页面。这种情况下，安全内核无须检查固件内存描述符列表，除非页面捆绑已彻底耗尽。当安全内核初始化的阶段3完成后，NT内核的内存服务已经可用，因此安全内核会释放所有启动内存描述符列表，并保留之前位于页面捆绑中的物理内存页面。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx2499.png" style="width: 100%" />
<p class="图题">图9-37　包含80个可用页面的安全页面捆绑。页面捆绑由一个头部和一个空闲PFN数组组成</p>
<p class="zw">后续的安全内存分配将通过NT内核提供的常规调用来进行。页面捆绑在设计上可最大限度地减少内存分配所需的常规调用的次数。在一个捆绑被全部分配后，其中将不包含任何页面（所有页面已被分配出去），此时可以向NT内核申请1MB的连续物理页面（通过常规调用ALLOC_PHYSICAL_PAGES）新建一个捆绑。NT内核将从适当的SLAB中分配物理内存。</p>
<p class="zw">以同样的方式，每当安全内核释放自己的私有内存时，都会将相应的物理页面存储到对应的捆绑中，为此会将PFN数组增大，直到达到256个空闲页面的上限。当该数组被完全填满后，页面捆绑将变为空闲状态，一个新的工作项会被加入队列中。该工作项会清零所有的页面并发出一个FREE_PHYSICAL_PAGES常规调用，最终这会导致执行NT内存管理器的MmFreePagesFromMdl函数。</p>
<p class="zw">每当有足够的页面被移入或移出页面捆绑时，这些页面都会受到VTL 0使用SLAT提供的全面保护（这个过程也叫“捆绑保护”）。安全内核支持三类捆绑，它们会从不同的SLAB（不可访问、只读、读取执行）分配内存。</p>

<p class="epubit-contents-id" style="display: none">{"index":7,"parentId":"235e6070-2914-47dd-bdb6-a375816a60a3","id":"32456d1a-9490-4e85-8394-14522a3c814b"}</p>