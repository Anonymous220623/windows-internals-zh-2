<h3 class="bt3" id="sigil_toc_id_99">9.4.9　热修补</h3>
<p class="zw">多年前，32位版本的Windows支持对操作系统组件进行热修补（hot patch）。可修补的函数会在自己的序言（prolog）中包含一个冗余的2字节操作码，并在函数本身之前放置一些填充字节（padding byte）。这样，NT内核即可使用间接跳转动态替换初始操作码，并使用填充字节提供的可用空间将代码转移至另一个模块中修补后的函数。Windows Update大量使用了该功能，借此让系统无须立即重启动即可安装更新。但在转移到64位架构后，因为各种问题的存在，该技术已不再可行。内核修补防护（kernel patch protection）就是一个很好的例子。此时已经无法通过可靠的方式修改受保护的内核模式二进制文件，并让PatchGuard在不公开自己的一些私有接口的前提下进行更新，毕竟公开的PatchGuard接口很容易被攻击者利用并让这种保护措施失效。</p>
<p class="zw">安全内核解决了与64位架构有关的所有这些问题，让操作系统再次获得了对内核二进制文件进行热修补的能力。在启用安全内核的情况下，可对下列类型的可执行映像进行热修补。</p>
<p class="zwd"><span style="color: #0092dd">●</span> VTL 0用户模式模块（可执行文件和二进制文件）。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 内核模式驱动程序、HAL、NT内核二进制文件，无论是否受到PatchGuard的保护。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 运行在VTL 1内核模式下的安全内核二进制文件及其依赖模块。</p>
<p class="zwd"><span style="color: #0092dd">●</span> 虚拟机监控程序（Intel、AMD以及ARM版本）。</p>
<p class="zw">修补VTL 0下运行的软件二进制文件的补丁叫作常规修补，修补其他内容的补丁叫作安全修补。如果安全内核未启用，则只有用户模式应用程序可以修补。</p>
<p class="zw">热修补映像是一种标准的可移植可执行的（PE）二进制文件，其中包含热修补表，以及用于跟踪修补函数的数据结构。热修补表会通过映像加载配置数据目录与二进制文件链接，其中包含的一个或多个描述符描述了每个可修补的基础映像，映像可通过其校验值和时间日期戳加以识别（这保证了热修补只能兼容正确的基础映像，系统无法将修补应用给错误的映像）。热修补表还包含一个列表，其中列出了基础映像或修补映像中需要更新的函数或全局数据块。下文很快将介绍修补引擎。该列表中的每一项都包含函数在基础映像和修补映像中的偏移量，以及所要替换的基础函数最初的字节位置。</p>
<p class="zw">一个基础映像可应用多个修补，但修补的效果是幂等的：同一个修补可应用多次，不同修补可依次应用，但无论如何最后应用的修补都将是基础映像的活跃修补。当系统需要应用热修补时，会通过NtManageHotPatch系统调用来安装、移除、管理热修补（该系统调用支持使用不同的“修补信息”类来描述各种可能的操作）。热修补可针对整个系统进行全局安装，如果是适用于用户模式代码（VTL 0）的修补，则会安装给特定用户会话所属的全部进程。</p>
<p class="zw">当系统请求应用修补时，NT内核会在补丁的二进制文件中定位并验证热修补表，随后使用DETERMINE_HOT_PATCH_TYPE安全调用，安全地确定修补类型。安全修补只能由安全内核应用，此时将使用APPLY_HOT_PATCH安全调用，NT内核无须执行其他处理。其他情况下，则由NT内核首先尝试着将修补应用给内核驱动程序，它会在每个已加载内核模块之间循环，搜索校验值与补丁映像的热修补描述符匹配的基础映像。</p>
<p class="zw">仅当HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\ Memory Management\HotPatchTableSize注册表值是标准内存页大小（4096）的倍数时，才能启用热修补。实际上，在热修补被启用后，每个映射到虚拟地址空间的映像都需要在映像本身之后近邻的位置保留一定量的虚拟地址空间。该保留空间用于保存映像的热修补地址表（HPAT，不要将其与热修补表混淆）。HPAT用于存储被修补映像中新函数的地址，借此最大限度地减小每个映像需要填充的数量。</p>
<p class="zw">当修补一个函数时，将使用HPAT位置执行从基础映像中原始函数到修补映像中被修补函数的间接跳转（请注意，为了兼容Retpoline，会使用另一种类型的Retpoline例程代替间接跳转）。</p>
<p class="zw">NT内核找到适合修补的内核模式驱动程序后，会在内核地址空间中加载并映射补丁的二进制文件并创建相关的加载器数据表项（详见第12章）。随后它会扫描基础映像和补丁映像的每个内存页面，并在内存中锁定与热修补有关的页面（这很重要，保证了页面不会在修补进行过程中被换出到磁盘）。最后它会发出APPLY_HOT_PATCH安全调用。</p>
<p class="zw">真正的修补应用过程是在安全内核中开始的。安全内核会捕获并验证补丁映像的热修补表（通过将补丁映像重映射至VTL 1），并定位基础映像的NAR（NAR的详细信息请参阅上文“安全内核内存管理器”一节），借此安全内核还能知道映像是否受到PatchGuard的保护。随后，安全内核会验证映像HPAT是否有足够的保留空间。如果有，则它会分配一个或多个空闲的物理页面（可从安全页面捆绑中获取，或使用ALLOC_PHYSICAL_PAGES常规调用）并将其映射至保留空间。随后，如果基础映像受到保护，则安全内核会开始执行一个复杂的过程来为修补后的新映像更新PatchGuard的内部状态，并最终调用修补引擎。</p>
<p class="zw">内核的修补引擎会执行下列操作，这些操作均由热修补表中不同类型的项来描述。</p>
<p class="zw">1）修补补丁映像中所有被修补函数的调用，借此跳转至基础映像中对应的函数。这保证了所有未修补代码始终在原始基础映像中执行。举例来说，如果函数A调用基础映像中的函数B，补丁更改了函数A但未更改函数B，那么修补引擎将更新补丁中的函数B，以跳转至基础映像中的函数B。</p>
<p class="zw">2）在被修补函数中修补对全局变量的必要引用，以便在基础映像中指向相应的全局变量。</p>
<p class="zw">3）从基础映像复制相应的IAT项，借此在修补映像中修补必要的导入地址表（Import Address Table，IAT）引用。</p>
<p class="zw">4）以原子化的方式修补基础映像中的必要函数，以便跳转至补丁映像中对应的函数。在对基础映像中的特定函数完成该操作后，对该函数的所有新调用将会用补丁映像中修补后的新函数代码来执行。当修补后的函数返回时，将返回到基础映像中原始函数的调用方。</p>
<p class="zw">由于新函数的指针宽度为64位（8字节），修补引擎会将每个指针放入HPAT，使其位于二进制文件的末尾。这样，只需要5字节就能将间接跳转放在位于每个函数开头处的填充空间内（该过程已被简化。Retpoline兼容的热修补需要可兼容的Retpoline，此外HPAT会被分为代码页和数据页）。</p>
<p class="zw">如图9-38所示，修补引擎可兼容不同类型的二进制文件。如果NT内核未找到任何可修补的内核模式模块，则它会对所有用户模式进程进行重新搜索，并通过类似的过程对可兼容的用户模式可执行文件或二进制文件进行正确的修补。</p>
<p class="图"></p>
<img src="../res/pubcloud/5B0A982E/ushu/UBda647ada3435/online/FBOLda82494f5f9f/Images/tx2506.png" style="width: 100%" />
<p class="图题">图9-38　热修补引擎针对不同类型二进制文件的执行方案</p>

<p class="epubit-contents-id" style="display: none">{"index":8,"parentId":"235e6070-2914-47dd-bdb6-a375816a60a3","id":"3755121c-c919-4a28-a273-7c39eeae7354"}</p>