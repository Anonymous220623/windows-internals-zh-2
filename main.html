<!DOCTYPE html>
<html lang="zh-CN" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"><head>
	<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<style>
		@font-face { font-family: "FZFangSong-Z02"; src:local("FZFangSong-Z02"), url("https://imgcdn.umiwi.com/ttf/fangzhengfangsong_gbk.ttf"); }
		@font-face { font-family: "FZKai-Z03"; src:local("FZFangSong-Z02S"), url("https://imgcdn.umiwi.com/ttf/0315911813008928624065681028886857980055.ttf"); }
		@font-face { font-family: "FZKai-Z03"; src:local("FZKai-Z03"), url("https://imgcdn.umiwi.com/ttf/fangzhengkaiti_gbk.ttf"); }
		@font-face { font-family: "PingFang SC"; src:local("PingFang SC"); }
		@font-face { font-family: "DeDaoJinKai"; src:local("DeDaoJinKai"), url("https://imgcdn.umiwi.com/ttf/dedaojinkaiw03.ttf");}
		@font-face { font-family: "Source Code Pro"; src:local("Source Code Pro"), url("https://imgcdn.umiwi.com/ttf/0315911806889993935644188722660020367983.ttf"); }
		table, tr, td, th, tbody, thead, tfoot {page-break-inside: avoid !important;}
		img { page-break-inside: avoid; max-width: 100% !important;}
		img.epub-footnote { margin-right:5px;display: inline;font-size: 12px;}
	</style>
</head>
<body>
	<p style="page-break-after: always;">
</p><div id="cover.xhtml">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b34a3dbfdea24105ba11770bbf818b21.jpg" alt="" title=""></div>
<div id="toc">
		<p style="page-break-after: always;">
		</p><p><span style="font-size:24px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';">目 录</span></p>
		<p><a href="#magic_copyright_title" style="font-size:20px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">版权信息</a></p>
		<p><a href="#sigil_toc_id_1" style="font-size:20px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">内容提要</a></p>
		<p><a href="#sigil_toc_id_2" style="font-size:20px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">作者简介</a></p>
		<p><a href="#sigil_toc_id_3" style="font-size:20px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">序</a></p>
		<p><a href="#sigil_toc_id_4" style="font-size:20px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">前言</a></p>
		<p><a href="#sigil_toc_id_5" style="font-size:20px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">第8章 系统机制</a></p>
		<p><a href="#sigil_toc_id_6" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    8.1 处理器执行模型</a></p>
		<p><a href="#sigil_toc_id_7" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.1.1 段</a></p>
		<p><a href="#sigil_toc_id_8" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.1.2 任务状态段</a></p>
		<p><a href="#sigil_toc_id_9" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    8.2 硬件侧信道漏洞</a></p>
		<p><a href="#sigil_toc_id_10" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.2.1 乱序执行</a></p>
		<p><a href="#sigil_toc_id_11" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.2.2 CPU分支预测器</a></p>
		<p><a href="#sigil_toc_id_12" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.2.3 CPU缓存</a></p>
		<p><a href="#sigil_toc_id_13" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.2.4 侧信道攻击</a></p>
		<p><a href="#sigil_toc_id_14" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    8.3 Windows中的侧信道缓解措施</a></p>
		<p><a href="#sigil_toc_id_15" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.3.1 KVA影子</a></p>
		<p><a href="#sigil_toc_id_16" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.3.2 硬件间接分支控制（IBRS、IBPB、STIBP、SSBD）</a></p>
		<p><a href="#sigil_toc_id_17" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.3.3 Retpoline和导入优化</a></p>
		<p><a href="#sigil_toc_id_18" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.3.4 STIBP配对</a></p>
		<p><a href="#sigil_toc_id_19" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    8.4 陷阱调度</a></p>
		<p><a href="#sigil_toc_id_20" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.4.1 中断调度</a></p>
		<p><a href="#sigil_toc_id_21" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.4.2 基于线的中断和基于消息信号的中断</a></p>
		<p><a href="#sigil_toc_id_22" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.4.3 计时器处理</a></p>
		<p><a href="#sigil_toc_id_23" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.4.4 系统工作线程</a></p>
		<p><a href="#sigil_toc_id_24" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.4.5 异常调度</a></p>
		<p><a href="#sigil_toc_id_25" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.4.6 系统服务处理</a></p>
		<p><a href="#sigil_toc_id_26" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    8.5 WoW64（Windows-on-Windows）</a></p>
		<p><a href="#sigil_toc_id_27" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.5.1 WoW64核心</a></p>
		<p><a href="#sigil_toc_id_28" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.5.2 文件系统重定向</a></p>
		<p><a href="#sigil_toc_id_29" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.5.3 注册表重定向</a></p>
		<p><a href="#sigil_toc_id_30" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.5.4 AMD64平台上的x86模拟</a></p>
		<p><a href="#sigil_toc_id_31" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.5.5 ARM</a></p>
		<p><a href="#sigil_toc_id_32" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.5.6 内存模型</a></p>
		<p><a href="#sigil_toc_id_33" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.5.7 ARM64平台上的ARM32模拟</a></p>
		<p><a href="#sigil_toc_id_34" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.5.8 ARM64平台上的x86模拟</a></p>
		<p><a href="#sigil_toc_id_35" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    8.6 对象管理器</a></p>
		<p><a href="#sigil_toc_id_36" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.6.1 执行体对象</a></p>
		<p><a href="#sigil_toc_id_37" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.6.2 对象结构</a></p>
		<p><a href="#sigil_toc_id_38" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    8.7 同步</a></p>
		<p><a href="#sigil_toc_id_39" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.7.1 高IRQL同步</a></p>
		<p><a href="#sigil_toc_id_40" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.7.2 低IRQL同步</a></p>
		<p><a href="#sigil_toc_id_41" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    8.8 高级本地过程调用</a></p>
		<p><a href="#sigil_toc_id_42" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.8.1 连接模型</a></p>
		<p><a href="#sigil_toc_id_43" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.8.2 消息模型</a></p>
		<p><a href="#sigil_toc_id_44" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.8.3 异步操作</a></p>
		<p><a href="#sigil_toc_id_45" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.8.4 视图、区域和节</a></p>
		<p><a href="#sigil_toc_id_46" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.8.5 属性</a></p>
		<p><a href="#sigil_toc_id_47" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.8.6 Blob、句柄和资源</a></p>
		<p><a href="#sigil_toc_id_48" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.8.7 句柄的传递</a></p>
		<p><a href="#sigil_toc_id_49" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.8.8 安全性</a></p>
		<p><a href="#sigil_toc_id_50" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.8.9 性能</a></p>
		<p><a href="#sigil_toc_id_51" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.8.10 电源管理</a></p>
		<p><a href="#sigil_toc_id_52" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.8.11 ALPC直接事件属性</a></p>
		<p><a href="#sigil_toc_id_53" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.8.12 调试和跟踪</a></p>
		<p><a href="#sigil_toc_id_54" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    8.9 Windows通知设施</a></p>
		<p><a href="#sigil_toc_id_55" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.9.1 WNF功能</a></p>
		<p><a href="#sigil_toc_id_56" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.9.2 WNF用户</a></p>
		<p><a href="#sigil_toc_id_57" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.9.3 WNF状态名称和存储</a></p>
		<p><a href="#sigil_toc_id_58" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.9.4 WNF事件聚合</a></p>
		<p><a href="#sigil_toc_id_59" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    8.10 用户模式调试</a></p>
		<p><a href="#sigil_toc_id_60" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.10.1 内核支持</a></p>
		<p><a href="#sigil_toc_id_61" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.10.2 原生支持</a></p>
		<p><a href="#sigil_toc_id_62" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.10.3 Windows子系统支持</a></p>
		<p><a href="#sigil_toc_id_63" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    8.11 打包的应用程序</a></p>
		<p><a href="#sigil_toc_id_64" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.11.1 UWP应用程序</a></p>
		<p><a href="#sigil_toc_id_65" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.11.2 Centennial应用程序</a></p>
		<p><a href="#sigil_toc_id_66" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.11.3 主机活动管理器</a></p>
		<p><a href="#sigil_toc_id_67" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.11.4 状态存储库</a></p>
		<p><a href="#sigil_toc_id_68" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.11.5 依赖项小型存储库</a></p>
		<p><a href="#sigil_toc_id_69" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.11.6 后台任务和代理基础架构</a></p>
		<p><a href="#sigil_toc_id_70" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.11.7 打包应用程序的安装和启动</a></p>
		<p><a href="#sigil_toc_id_71" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.11.8 程序包激活</a></p>
		<p><a href="#sigil_toc_id_72" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        8.11.9 程序包注册</a></p>
		<p><a href="#sigil_toc_id_73" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    8.12 总结</a></p>
		<p><a href="#sigil_toc_id_74" style="font-size:20px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">第9章 虚拟化技术</a></p>
		<p><a href="#sigil_toc_id_75" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    9.1 Windows虚拟机监控程序</a></p>
		<p><a href="#sigil_toc_id_76" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.1.1 分区、进程和线程</a></p>
		<p><a href="#sigil_toc_id_77" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.1.2 虚拟机监控程序的启动</a></p>
		<p><a href="#sigil_toc_id_78" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.1.3 虚拟机监控程序内存管理器</a></p>
		<p><a href="#sigil_toc_id_79" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.1.4 Hyper-V调度器</a></p>
		<p><a href="#sigil_toc_id_80" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.1.5 虚拟化调用和虚拟机监控程序TLFS</a></p>
		<p><a href="#sigil_toc_id_81" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.1.6 拦截</a></p>
		<p><a href="#sigil_toc_id_82" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.1.7 综合中断控制器</a></p>
		<p><a href="#sigil_toc_id_83" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.1.8 Windows虚拟机监控程序平台API和EXO分区</a></p>
		<p><a href="#sigil_toc_id_84" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.1.9 嵌套虚拟化</a></p>
		<p><a href="#sigil_toc_id_85" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.1.10 ARM64上的Windows虚拟机监控程序</a></p>
		<p><a href="#sigil_toc_id_86" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    9.2 虚拟化栈</a></p>
		<p><a href="#sigil_toc_id_87" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.2.1 虚拟机管理器服务和工作进程</a></p>
		<p><a href="#sigil_toc_id_88" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.2.2 VID驱动程序和虚拟化栈内存管理器</a></p>
		<p><a href="#sigil_toc_id_89" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.2.3 虚拟机的诞生</a></p>
		<p><a href="#sigil_toc_id_90" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.2.4 VMBus</a></p>
		<p><a href="#sigil_toc_id_91" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.2.5 虚拟硬件支持</a></p>
		<p><a href="#sigil_toc_id_92" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.2.6 VA支持的虚拟机</a></p>
		<p><a href="#sigil_toc_id_93" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    9.3 基于虚拟化的安全性</a></p>
		<p><a href="#sigil_toc_id_94" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.3.1 虚拟信任级别和虚拟安全模式</a></p>
		<p><a href="#sigil_toc_id_95" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.3.2 VSM提供的服务及其要求</a></p>
		<p><a href="#sigil_toc_id_96" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    9.4 安全内核</a></p>
		<p><a href="#sigil_toc_id_97" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.4.1 虚拟中断</a></p>
		<p><a href="#sigil_toc_id_98" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.4.2 安全拦截</a></p>
		<p><a href="#sigil_toc_id_99" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.4.3 VSM系统调用</a></p>
		<p><a href="#sigil_toc_id_100" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.4.4 安全线程和调度</a></p>
		<p><a href="#sigil_toc_id_101" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.4.5 虚拟机监控程序实施的代码完整性</a></p>
		<p><a href="#sigil_toc_id_102" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.4.6 UEFI运行时虚拟化</a></p>
		<p><a href="#sigil_toc_id_103" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.4.7 VSM启动</a></p>
		<p><a href="#sigil_toc_id_104" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.4.8 安全内核内存管理器</a></p>
		<p><a href="#sigil_toc_id_105" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.4.9 热修补</a></p>
		<p><a href="#sigil_toc_id_106" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    9.5 隔离用户模式</a></p>
		<p><a href="#sigil_toc_id_107" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.5.1 Trustlet的创建</a></p>
		<p><a href="#sigil_toc_id_108" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.5.2 安全设备</a></p>
		<p><a href="#sigil_toc_id_109" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.5.3 基于VBS的隔区</a></p>
		<p><a href="#sigil_toc_id_110" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        9.5.4 系统防护运行时认证</a></p>
		<p><a href="#sigil_toc_id_111" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    9.6 总结</a></p>
		<p><a href="#sigil_toc_id_112" style="font-size:20px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">第10章 管理、诊断和跟踪</a></p>
		<p><a href="#sigil_toc_id_113" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    10.1 注册表</a></p>
		<p><a href="#sigil_toc_id_114" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.1.1 查看和更改注册表</a></p>
		<p><a href="#sigil_toc_id_115" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.1.2 注册表的使用</a></p>
		<p><a href="#sigil_toc_id_116" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.1.3 注册表数据类型</a></p>
		<p><a href="#sigil_toc_id_117" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.1.4 注册表的逻辑结构</a></p>
		<p><a href="#sigil_toc_id_118" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.1.5 应用程序配置单元</a></p>
		<p><a href="#sigil_toc_id_119" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.1.6 事务型注册表（TxR）</a></p>
		<p><a href="#sigil_toc_id_120" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.1.7 监控注册表活动</a></p>
		<p><a href="#sigil_toc_id_121" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.1.8 进程监视器的内部原理</a></p>
		<p><a href="#sigil_toc_id_122" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.1.9 注册表的内部原理</a></p>
		<p><a href="#sigil_toc_id_123" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.1.10 配置单元重组</a></p>
		<p><a href="#sigil_toc_id_124" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.1.11 注册表的命名空间和操作</a></p>
		<p><a href="#sigil_toc_id_125" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.1.12 稳定存储</a></p>
		<p><a href="#sigil_toc_id_126" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.1.13 注册表过滤</a></p>
		<p><a href="#sigil_toc_id_127" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.1.14 注册表虚拟化</a></p>
		<p><a href="#sigil_toc_id_128" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.1.15 注册表优化</a></p>
		<p><a href="#sigil_toc_id_129" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    10.2 Windows服务</a></p>
		<p><a href="#sigil_toc_id_130" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.2.1 服务应用程序</a></p>
		<p><a href="#sigil_toc_id_131" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.2.2 服务账户</a></p>
		<p><a href="#sigil_toc_id_132" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.2.3 服务控制管理器</a></p>
		<p><a href="#sigil_toc_id_133" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.2.4 服务控制程序</a></p>
		<p><a href="#sigil_toc_id_134" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.2.5 自启动服务的启动</a></p>
		<p><a href="#sigil_toc_id_135" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.2.6 延迟的自启动服务</a></p>
		<p><a href="#sigil_toc_id_136" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.2.7 触发启动的服务</a></p>
		<p><a href="#sigil_toc_id_137" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.2.8 启动错误</a></p>
		<p><a href="#sigil_toc_id_138" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.2.9 接受启动和最近一次的正确配置</a></p>
		<p><a href="#sigil_toc_id_139" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.2.10 服务故障</a></p>
		<p><a href="#sigil_toc_id_140" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.2.11 服务关闭</a></p>
		<p><a href="#sigil_toc_id_141" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.2.12 共享服务进程</a></p>
		<p><a href="#sigil_toc_id_142" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.2.13 服务标签</a></p>
		<p><a href="#sigil_toc_id_143" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.2.14 用户服务</a></p>
		<p><a href="#sigil_toc_id_144" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.2.15 打包的服务</a></p>
		<p><a href="#sigil_toc_id_145" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.2.16 受保护服务</a></p>
		<p><a href="#sigil_toc_id_146" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    10.3 任务计划和UBPM</a></p>
		<p><a href="#sigil_toc_id_147" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.3.1 任务计划程序</a></p>
		<p><a href="#sigil_toc_id_148" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.3.2 统一后台进程管理器</a></p>
		<p><a href="#sigil_toc_id_149" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.3.3 任务计划程序COM接口</a></p>
		<p><a href="#sigil_toc_id_150" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    10.4 Windows管理规范</a></p>
		<p><a href="#sigil_toc_id_151" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.4.1 WMI架构</a></p>
		<p><a href="#sigil_toc_id_152" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.4.2 WMI提供程序</a></p>
		<p><a href="#sigil_toc_id_153" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.4.3 通用信息模型和托管对象格式语言</a></p>
		<p><a href="#sigil_toc_id_154" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.4.4 类关联</a></p>
		<p><a href="#sigil_toc_id_155" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.4.5 WMI的实现</a></p>
		<p><a href="#sigil_toc_id_156" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.4.6 WMI的安全性</a></p>
		<p><a href="#sigil_toc_id_157" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    10.5 Windows事件跟踪</a></p>
		<p><a href="#sigil_toc_id_158" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.5.1 ETW初始化</a></p>
		<p><a href="#sigil_toc_id_159" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.5.2 ETW会话</a></p>
		<p><a href="#sigil_toc_id_160" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.5.3 ETW提供程序</a></p>
		<p><a href="#sigil_toc_id_161" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.5.4 提供事件</a></p>
		<p><a href="#sigil_toc_id_162" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.5.5 ETW记录器线程</a></p>
		<p><a href="#sigil_toc_id_163" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.5.6 事件的消费</a></p>
		<p><a href="#sigil_toc_id_164" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.5.7 系统记录器</a></p>
		<p><a href="#sigil_toc_id_165" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.5.8 ETW的安全性</a></p>
		<p><a href="#sigil_toc_id_166" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    10.6 动态跟踪</a></p>
		<p><a href="#sigil_toc_id_167" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.6.1 内部架构</a></p>
		<p><a href="#sigil_toc_id_168" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.6.2 DTrace类型库</a></p>
		<p><a href="#sigil_toc_id_169" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    10.7 Windows错误报告</a></p>
		<p><a href="#sigil_toc_id_170" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.7.1 用户应用程序崩溃</a></p>
		<p><a href="#sigil_toc_id_171" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.7.2 内核模式（系统）崩溃</a></p>
		<p><a href="#sigil_toc_id_172" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.7.3 进程挂起检测</a></p>
		<p><a href="#sigil_toc_id_173" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    10.8 全局标记</a></p>
		<p><a href="#sigil_toc_id_174" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    10.9 内核填充码</a></p>
		<p><a href="#sigil_toc_id_175" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.9.1 填充码引擎初始化</a></p>
		<p><a href="#sigil_toc_id_176" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.9.2 填充码数据库</a></p>
		<p><a href="#sigil_toc_id_177" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.9.3 驱动程序填充码</a></p>
		<p><a href="#sigil_toc_id_178" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        10.9.4 设备填充码</a></p>
		<p><a href="#sigil_toc_id_179" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    10.10 总结</a></p>
		<p><a href="#sigil_toc_id_180" style="font-size:20px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">第11章 缓存和文件系统</a></p>
		<p><a href="#sigil_toc_id_181" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    11.1 术语</a></p>
		<p><a href="#sigil_toc_id_182" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    11.2 缓存管理器的重要功能</a></p>
		<p><a href="#sigil_toc_id_183" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.2.1 单一集中化系统缓存</a></p>
		<p><a href="#sigil_toc_id_184" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.2.2 内存管理器</a></p>
		<p><a href="#sigil_toc_id_185" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.2.3 缓存的一致性</a></p>
		<p><a href="#sigil_toc_id_186" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.2.4 虚拟块缓存</a></p>
		<p><a href="#sigil_toc_id_187" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.2.5 基于流的缓存</a></p>
		<p><a href="#sigil_toc_id_188" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.2.6 可恢复文件系统支持</a></p>
		<p><a href="#sigil_toc_id_189" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.2.7 NTFS MFT工作集的增强</a></p>
		<p><a href="#sigil_toc_id_190" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.2.8 内存分区支持</a></p>
		<p><a href="#sigil_toc_id_191" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    11.3 缓存虚拟内存管理</a></p>
		<p><a href="#sigil_toc_id_192" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    11.4 缓存大小</a></p>
		<p><a href="#sigil_toc_id_193" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.4.1 缓存虚拟大小</a></p>
		<p><a href="#sigil_toc_id_194" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.4.2 缓存工作集大小</a></p>
		<p><a href="#sigil_toc_id_195" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.4.3 缓存物理大小</a></p>
		<p><a href="#sigil_toc_id_196" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    11.5 缓存数据结构</a></p>
		<p><a href="#sigil_toc_id_197" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.5.1 系统级缓存数据结构</a></p>
		<p><a href="#sigil_toc_id_198" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.5.2 每文件缓存数据结构</a></p>
		<p><a href="#sigil_toc_id_199" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    11.6 文件系统接口</a></p>
		<p><a href="#sigil_toc_id_200" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.6.1 向/从缓存复制</a></p>
		<p><a href="#sigil_toc_id_201" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.6.2 通过映射和固定接口进行缓存</a></p>
		<p><a href="#sigil_toc_id_202" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.6.3 通过直接内存访问接口进行缓存</a></p>
		<p><a href="#sigil_toc_id_203" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    11.7 快速I/O</a></p>
		<p><a href="#sigil_toc_id_204" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    11.8 预读取和延后写入</a></p>
		<p><a href="#sigil_toc_id_205" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.8.1 智能预读取</a></p>
		<p><a href="#sigil_toc_id_206" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.8.2 预读取的增强</a></p>
		<p><a href="#sigil_toc_id_207" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.8.3 回写缓存和惰性写入</a></p>
		<p><a href="#sigil_toc_id_208" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.8.4 为某个文件禁用惰性写入</a></p>
		<p><a href="#sigil_toc_id_209" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.8.5 强制缓存直接写入磁盘</a></p>
		<p><a href="#sigil_toc_id_210" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.8.6 刷新映射的文件</a></p>
		<p><a href="#sigil_toc_id_211" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.8.7 写入限流</a></p>
		<p><a href="#sigil_toc_id_212" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.8.8 系统线程</a></p>
		<p><a href="#sigil_toc_id_213" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.8.9 激进的后写入和低优先级惰性写入</a></p>
		<p><a href="#sigil_toc_id_214" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.8.10 动态内存</a></p>
		<p><a href="#sigil_toc_id_215" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.8.11 缓存管理器的磁盘I/O记账</a></p>
		<p><a href="#sigil_toc_id_216" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    11.9 文件系统</a></p>
		<p><a href="#sigil_toc_id_217" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.1 Windows文件系统格式</a></p>
		<p><a href="#sigil_toc_id_218" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.2 CDFS</a></p>
		<p><a href="#sigil_toc_id_219" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.3 UDF</a></p>
		<p><a href="#sigil_toc_id_220" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.4 FAT12、FAT16和FAT32</a></p>
		<p><a href="#sigil_toc_id_221" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.5 exFAT</a></p>
		<p><a href="#sigil_toc_id_222" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.6 NTFS</a></p>
		<p><a href="#sigil_toc_id_223" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.7 ReFS</a></p>
		<p><a href="#sigil_toc_id_224" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.8 文件系统驱动程序架构</a></p>
		<p><a href="#sigil_toc_id_225" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.9 本地FSD</a></p>
		<p><a href="#sigil_toc_id_226" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.10 远程FSD</a></p>
		<p><a href="#sigil_toc_id_227" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.11 文件系统操作</a></p>
		<p><a href="#sigil_toc_id_228" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.12 显式文件I/O</a></p>
		<p><a href="#sigil_toc_id_229" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.13 内存管理器的已修改和已映射页写入器</a></p>
		<p><a href="#sigil_toc_id_230" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.14 缓存管理器的惰性写入器</a></p>
		<p><a href="#sigil_toc_id_231" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.15 缓存管理器的预读取线程</a></p>
		<p><a href="#sigil_toc_id_232" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.16 内存管理器的页面错误处理程序</a></p>
		<p><a href="#sigil_toc_id_233" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.17 文件系统过滤器驱动程序和微过滤器</a></p>
		<p><a href="#sigil_toc_id_234" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.18 过滤命名管道和邮件槽</a></p>
		<p><a href="#sigil_toc_id_235" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.19 控制重分析点的行为</a></p>
		<p><a href="#sigil_toc_id_236" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.9.20 进程监视器</a></p>
		<p><a href="#sigil_toc_id_237" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    11.10 NT文件系统</a></p>
		<p><a href="#sigil_toc_id_238" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.1 高端文件系统的要求</a></p>
		<p><a href="#sigil_toc_id_239" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.2 可恢复性</a></p>
		<p><a href="#sigil_toc_id_240" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.3 安全性</a></p>
		<p><a href="#sigil_toc_id_241" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.4 数据冗余和容错</a></p>
		<p><a href="#sigil_toc_id_242" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.5 NTFS的高级功能</a></p>
		<p><a href="#sigil_toc_id_243" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.6 多数据流</a></p>
		<p><a href="#sigil_toc_id_244" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.7 基于Unicode的名称</a></p>
		<p><a href="#sigil_toc_id_245" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.8 通用索引设施</a></p>
		<p><a href="#sigil_toc_id_246" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.9 动态坏簇重映射</a></p>
		<p><a href="#sigil_toc_id_247" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.10 硬链接</a></p>
		<p><a href="#sigil_toc_id_248" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.11 符号（软）链接和交叉</a></p>
		<p><a href="#sigil_toc_id_249" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.12 压缩和稀疏文件</a></p>
		<p><a href="#sigil_toc_id_250" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.13 变更日志记录</a></p>
		<p><a href="#sigil_toc_id_251" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.14 每用户卷配额</a></p>
		<p><a href="#sigil_toc_id_252" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.15 链接跟踪</a></p>
		<p><a href="#sigil_toc_id_253" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.16 加密</a></p>
		<p><a href="#sigil_toc_id_254" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.17 POSIX风格的删除语义</a></p>
		<p><a href="#sigil_toc_id_255" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.18 碎片整理</a></p>
		<p><a href="#sigil_toc_id_256" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.19 动态分区</a></p>
		<p><a href="#sigil_toc_id_257" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.10.20 NTFS对分层卷的支持</a></p>
		<p><a href="#sigil_toc_id_258" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    11.11 NTFS驱动程序</a></p>
		<p><a href="#sigil_toc_id_259" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    11.12 NTFS的磁盘结构</a></p>
		<p><a href="#sigil_toc_id_260" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.1 卷</a></p>
		<p><a href="#sigil_toc_id_261" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.2 簇</a></p>
		<p><a href="#sigil_toc_id_262" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.3 主文件表</a></p>
		<p><a href="#sigil_toc_id_263" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.4 文件记录号</a></p>
		<p><a href="#sigil_toc_id_264" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.5 文件记录</a></p>
		<p><a href="#sigil_toc_id_265" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.6 文件名</a></p>
		<p><a href="#sigil_toc_id_266" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.7 隧道</a></p>
		<p><a href="#sigil_toc_id_267" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.8 常驻和非常驻属性</a></p>
		<p><a href="#sigil_toc_id_268" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.9 数据压缩和稀疏文件</a></p>
		<p><a href="#sigil_toc_id_269" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.10 压缩稀疏数据</a></p>
		<p><a href="#sigil_toc_id_270" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.11 非稀疏数据的压缩</a></p>
		<p><a href="#sigil_toc_id_271" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.12 稀疏文件</a></p>
		<p><a href="#sigil_toc_id_272" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.13 变更日志文件</a></p>
		<p><a href="#sigil_toc_id_273" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.14 索引</a></p>
		<p><a href="#sigil_toc_id_274" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.15 对象ID</a></p>
		<p><a href="#sigil_toc_id_275" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.16 配额跟踪</a></p>
		<p><a href="#sigil_toc_id_276" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.17 综合安全性</a></p>
		<p><a href="#sigil_toc_id_277" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.18 重分析点</a></p>
		<p><a href="#sigil_toc_id_278" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.19 存储保留和NTFS预留</a></p>
		<p><a href="#sigil_toc_id_279" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.20 事务支持</a></p>
		<p><a href="#sigil_toc_id_280" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.21 隔离</a></p>
		<p><a href="#sigil_toc_id_281" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.22 事务型API</a></p>
		<p><a href="#sigil_toc_id_282" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.23 磁盘上的实现</a></p>
		<p><a href="#sigil_toc_id_283" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.12.24 日志记录的实现</a></p>
		<p><a href="#sigil_toc_id_284" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    11.13 NTFS恢复支持</a></p>
		<p><a href="#sigil_toc_id_285" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.13.1 设计</a></p>
		<p><a href="#sigil_toc_id_286" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.13.2 元数据日志记录</a></p>
		<p><a href="#sigil_toc_id_287" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.13.3 日志文件服务</a></p>
		<p><a href="#sigil_toc_id_288" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.13.4 日志记录类型</a></p>
		<p><a href="#sigil_toc_id_289" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.13.5 恢复</a></p>
		<p><a href="#sigil_toc_id_290" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.13.6 分析扫描</a></p>
		<p><a href="#sigil_toc_id_291" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.13.7 重做扫描</a></p>
		<p><a href="#sigil_toc_id_292" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.13.8 撤销扫描</a></p>
		<p><a href="#sigil_toc_id_293" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.13.9 NTFS坏簇恢复</a></p>
		<p><a href="#sigil_toc_id_294" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.13.10 自治愈</a></p>
		<p><a href="#sigil_toc_id_295" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.13.11 联机磁盘检查和快速修复</a></p>
		<p><a href="#sigil_toc_id_296" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    11.14 加密文件系统</a></p>
		<p><a href="#sigil_toc_id_297" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.14.1 首次加密文件</a></p>
		<p><a href="#sigil_toc_id_298" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.14.2 解密过程</a></p>
		<p><a href="#sigil_toc_id_299" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.14.3 备份加密的文件</a></p>
		<p><a href="#sigil_toc_id_300" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.14.4 复制加密的文件</a></p>
		<p><a href="#sigil_toc_id_301" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.14.5 BitLocker加密卸载</a></p>
		<p><a href="#sigil_toc_id_302" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.14.6 联机加密支持</a></p>
		<p><a href="#sigil_toc_id_303" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    11.15 直接访问磁盘</a></p>
		<p><a href="#sigil_toc_id_304" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.15.1 DAX驱动程序模型</a></p>
		<p><a href="#sigil_toc_id_305" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.15.2 DAX卷</a></p>
		<p><a href="#sigil_toc_id_306" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.15.3 DAX卷上缓存和未缓存的I/O</a></p>
		<p><a href="#sigil_toc_id_307" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.15.4 可执行映像的映射</a></p>
		<p><a href="#sigil_toc_id_308" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.15.5 块卷</a></p>
		<p><a href="#sigil_toc_id_309" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.15.6 文件系统过滤器驱动程序和DAX</a></p>
		<p><a href="#sigil_toc_id_310" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.15.7 刷新DAX模式的I/O</a></p>
		<p><a href="#sigil_toc_id_311" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.15.8 大型页和巨型页的支持</a></p>
		<p><a href="#sigil_toc_id_312" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.15.9 虚拟PM磁盘和存储空间支持</a></p>
		<p><a href="#sigil_toc_id_313" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    11.16 复原文件系统</a></p>
		<p><a href="#sigil_toc_id_314" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.16.1 Minstore架构</a></p>
		<p><a href="#sigil_toc_id_315" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.16.2 B+树的物理布局</a></p>
		<p><a href="#sigil_toc_id_316" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.16.3 分配器</a></p>
		<p><a href="#sigil_toc_id_317" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.16.4 页表</a></p>
		<p><a href="#sigil_toc_id_318" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.16.5 Minstore I/O</a></p>
		<p><a href="#sigil_toc_id_319" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.16.6 ReFS架构</a></p>
		<p><a href="#sigil_toc_id_320" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.16.7 ReFS在磁盘上的结构</a></p>
		<p><a href="#sigil_toc_id_321" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.16.8 对象ID</a></p>
		<p><a href="#sigil_toc_id_322" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.16.9 安全性和变更日志</a></p>
		<p><a href="#sigil_toc_id_323" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    11.17 ReFS高级功能</a></p>
		<p><a href="#sigil_toc_id_324" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.17.1 文件块克隆（快照支持）和稀疏VDL</a></p>
		<p><a href="#sigil_toc_id_325" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.17.2 ReFS直写</a></p>
		<p><a href="#sigil_toc_id_326" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.17.3 ReFS恢复支持</a></p>
		<p><a href="#sigil_toc_id_327" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.17.4 泄漏检测</a></p>
		<p><a href="#sigil_toc_id_328" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.17.5 叠瓦式磁记录卷</a></p>
		<p><a href="#sigil_toc_id_329" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.17.6 ReFS对分层卷和SMR的支持</a></p>
		<p><a href="#sigil_toc_id_330" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.17.7 容器压实</a></p>
		<p><a href="#sigil_toc_id_331" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.17.8 压缩和幻象</a></p>
		<p><a href="#sigil_toc_id_332" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    11.18 存储空间</a></p>
		<p><a href="#sigil_toc_id_333" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.18.1 存储空间的内部架构</a></p>
		<p><a href="#sigil_toc_id_334" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        11.18.2 存储空间提供的服务</a></p>
		<p><a href="#sigil_toc_id_335" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    11.19 总结</a></p>
		<p><a href="#sigil_toc_id_336" style="font-size:20px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">第12章 启动和关机</a></p>
		<p><a href="#sigil_toc_id_337" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    12.1 引导过程</a></p>
		<p><a href="#sigil_toc_id_338" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.1 UEFI引导</a></p>
		<p><a href="#sigil_toc_id_339" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.2 BIOS引导过程</a></p>
		<p><a href="#sigil_toc_id_340" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.3 安全启动</a></p>
		<p><a href="#sigil_toc_id_341" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.4 Windows启动管理器</a></p>
		<p><a href="#sigil_toc_id_342" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.5 启动菜单</a></p>
		<p><a href="#sigil_toc_id_343" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.6 运行启动应用程序</a></p>
		<p><a href="#sigil_toc_id_344" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.7 测量启动</a></p>
		<p><a href="#sigil_toc_id_345" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.8 可信执行</a></p>
		<p><a href="#sigil_toc_id_346" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.9 Windows操作系统加载器</a></p>
		<p><a href="#sigil_toc_id_347" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.10 从iSCSI启动</a></p>
		<p><a href="#sigil_toc_id_348" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.11 虚拟机监控程序加载器</a></p>
		<p><a href="#sigil_toc_id_349" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.12 VSM启动策略</a></p>
		<p><a href="#sigil_toc_id_350" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.13 安全运行</a></p>
		<p><a href="#sigil_toc_id_351" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.14 初始化内核与执行体子系统</a></p>
		<p><a href="#sigil_toc_id_352" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.15 内核初始化阶段1</a></p>
		<p><a href="#sigil_toc_id_353" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.16 Smss、Csrss和Wininit</a></p>
		<p><a href="#sigil_toc_id_354" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.17 ReadyBoot</a></p>
		<p><a href="#sigil_toc_id_355" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.18 自动启动的映像</a></p>
		<p><a href="#sigil_toc_id_356" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.19 关机</a></p>
		<p><a href="#sigil_toc_id_357" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.20 休眠和快速启动</a></p>
		<p><a href="#sigil_toc_id_358" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.21 Windows恢复环境（WinRE）</a></p>
		<p><a href="#sigil_toc_id_359" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.22 安全模式</a></p>
		<p><a href="#sigil_toc_id_360" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.23 安全模式下加载的驱动程序</a></p>
		<p><a href="#sigil_toc_id_361" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.24 可感知安全模式的用户程序</a></p>
		<p><a href="#sigil_toc_id_362" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">        12.1.25 启动状态文件</a></p>
		<p><a href="#sigil_toc_id_363" style="font-size:18px;color:rgb(0, 0, 0);font-family:'PingFang SC';text-decoration: none;">    12.2 总结</a></p>
</div>
	<p style="page-break-after: always;">
</p><div id="copyright.xhtml">
</div><div class="header0"><h1><span id="magic_copyright_title" style="font-size:22px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';display: block;text-align:center;"><b>版</b><b>权</b><b>信</b><b>息</b></span></h1></div>
<div class="part">
	<p><span id="magic_copyright_entitle" style="font-size:9px;font-weight: bold;color:rgb(120, 120, 120);font-family:'PingFang SC';display: block;text-align:center;"><b>C</b><b>O</b><b>P</b><b>Y</b><b>R</b><b>I</b><b>G</b><b>H</b><b>T</b></span></p>
	<p><span id="bookname" style="font-size:16px;font-family:'PingFang SC';">书名：深入解析Windows操作系统（第7版）（卷2）</span></p>
	<p><span id="author" style="font-size:16px;font-family:'PingFang SC';">作者：【美】安德里亚·阿列维；亚历克斯·伊奥尼斯库；马克·E. 鲁辛诺维奇；大卫·A. 所罗门</span></p>
	<p><span id="interpreter" style="font-size:16px;font-family:'PingFang SC';">译者：刘晖</span></p>
	<p><span id="press" style="font-size:16px;font-family:'PingFang SC';">出版社：人民邮电出版社</span></p>
	<p><span id="publicationdate" style="font-size:16px;font-family:'PingFang SC';">出版时间：2024年2月</span></p>
	<p><span id="isbn" style="font-size:16px;font-family:'PingFang SC';">ISBN：9787115619747</span></p>
	<p><span id="word" style="font-size:16px;font-family:'PingFang SC';">字数：815千字</span></p>
	<p><span id="comment" style="font-size:16px;font-family:'PingFang SC';">本书由人民邮电出版社有限公司授权得到APP电子版制作与发行</span></p>
	<p><span id="comment2" style="font-size:16px;font-family:'PingFang SC';">版权所有·侵权必究</span></p></div>
	<p style="page-break-after: always;">
</p><div id="qz04.xhtml">
</div><div class="header0"><h1><span id="sigil_toc_id_1" style="font-size:22px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';display: block;text-align:center;"><b>内</b><b>容</b><b>提</b><b>要</b></span></h1></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">本书剖析了Windows
核心组件行为方式的内部原理，主要内容包括服务设备驱动程序和应用程序的系统机制（ALPC、对象管理器、同步、WNF、WoW64和处理器执行模型）、
底层硬件架构（陷阱处理、分段和侧信道漏洞）、Windows虚拟化技术（基于虚拟化的安全、如何防范操作系统漏洞），操作系统为进行管理、配置和诊断所
实现的底层机制细节，以及缓存管理器和文件系统驱动程序如何交互以提供对文件、目录和磁盘的可靠支持等。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">本书适合经验丰富的程序员、架构师、软件质量和性能专家、安全从业人员和支持专家及Windows高级用户阅读。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Section0001.xhtml">
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">谨以此书献给我的父母Gabriella和Danilo，以及我的兄弟Luca，感谢你们始终相信我，并鼓励我追逐自己的梦想。</span></p>
	<p><span style="font-size:16px;font-family:'FZKai-Z03';display: block;text-align:right;">——安德里亚·阿列维</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">献给我的妻子和女儿，她们从不放弃我，一直是我爱和温暖的源泉。献给我的父母，他们鼓舞并激励我追寻梦想，牺牲自我以为我提供更多机遇。</span></p>
	<p><span style="font-size:16px;font-family:'FZKai-Z03';display: block;text-align:right;">——亚历克斯·伊奥尼斯库</span></p></div>
	<p style="page-break-after: always;">
</p><div id="qz05.xhtml">
</div><div class="header0"><h1><span id="sigil_toc_id_2" style="font-size:22px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';display: block;text-align:center;"><b>作</b><b>者</b><b>简</b><b>介</b></span></h1></div>
<div class="part"><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/7e3de0b63b5a72faaffe110a127d2aa2.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安德里亚·阿列维
（Andrea 
Allievi）是一名系统级开发者和安全研究工程师，拥有超过15年的从业经验。他于2010年从米兰-比可卡大学（University of 
Milano-Bicocca）毕业，并获得计算机科学学士学位。在毕业论文中，他展示了一种能攻击所有Windows 
7内核保护机制（PatchGuard和驱动程序强制签名）的64位主引导记录（MBR）Bootkit的开发过程。安德里亚还是一名逆向工程师，专精于
从内核级代码到用户模式代码的操作系统内部原理。他是全球首款UEFI 
Bootkit（出于研究目的开发，并于2012年对外公布）的初始作者，开发过多种能绕过PatchGuard机制的技术，并撰写了大量研究论文和文
章。同时，他还开发了多款用于移除恶意软件并消除高级持续威胁的系统工具和软件。在职业生涯中，他曾就职于多家计算机安全公司，包括意大利的
TgSoft、Saferbytes（现已被MalwareBytes收购）以及思科旗下的Talos安全团队。他最初于2016年加入微软，在微软威胁
情报中心（MSTIC）担任安全研究工程师。自2018年1月起，安德里亚开始在微软内核安全核心团队担任资深操作系统内核工程师，主要负责为NT和安全
内核（Secure Kernel）维护并开发新功能（例如Retpoline以及CPU预测执行漏洞缓解措施）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安德里亚依然活跃在安全研
究社区中，并通过Microsoft Windows 
Internals博客撰写和发布了多篇有关Windows内核新功能的技术文章，同时曾在多场技术大会（如Recon以及微软BlueHat）上发言。
你可通过Twitter关注他：@aall86。</span></p><div style="display: block;text-align:center;">
	<img width="653" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ced2e652ed0a8fa6846597df76750840.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">亚历克斯·伊奥尼斯库
（Alex 
Ionescu）是CrowdStrike公司端点工程副总裁兼创始首席架构师，他是一位世界级的安全架构师，也是底层系统软件、内核开发、安全培训以及
逆向工程领域的顾问专家。二十多年来，他的安全研究为Windows内核及其相关组件中几十个关键安全漏洞以及多种错误行为的修复工作提供了巨大帮助。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">亚历克斯曾担任
ReactOS（一种从零开始编写的开源Windows克隆系统）的首席内核开发者，他为其开发了大部分基于Windows 
NT的子系统。亚历克斯曾在负责开发iPhone、iPad以及Apple 
TV的苹果公司初始核心平台团队从事iOS内核、引导加载器以及驱动程序的研发工作。亚历克斯还是Winsider Seminars &amp; 
Solutions公司的创始人，该公司专精于底层系统软件和逆向工程，并向众多机构提供安全培训。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">亚历克斯在社区非常活跃，
曾在全球二十多场活动中发表演讲。他也为全球组织和个人提供有关Windows内部原理的培训、支持和相关资源。你可以访问他的博客（www.alex-
 ionescu.com以及www.windows-internals.com/blog），或通过Twitter关注他：@aionescu。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="qz06.xhtml">
</div><div class="header2"><h3><span id="sigil_toc_id_3" style="font-size:22px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';display: block;text-align:center;"><b>序</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在使用广受好评的
Windows 3.1操作系统并深入探究其内部原理后，我立即意识到微软公司于1993年发布的Windows NT 
3.1所拥有的改变世界的潜力。作为Windows 
NT的架构师和工程主管，大卫·卡特勒打造了一个安全、可靠、可扩展的Windows版本，同时它还与其上一代，即更成熟的“前任”有着相同的用户界面和
功能来运行相同的软件。海伦·卡斯特撰写的著作<span style="font-size:16px;font-style: oblique;font-family:'PingFang SC';"><i>I</i><i>n</i><i>s</i><i>i</i><i>d</i><i>e</i><i> </i><i>W</i><i>i</i><i>n</i><i>d</i><i>o</i><i>w</i><i>s</i><i> </i><i>N</i><i>T</i></span>对Windows NT的设计和架构提供了精彩剖析，但我相信有必要出版一本深入探究其内部工作细节的图书，并且我对此很感兴趣。基于大卫·卡特勒设计的VAX/VMS所出版的<span style="font-size:16px;font-style: oblique;font-family:'PingFang SC';"><i>V</i><i>A</i><i>X</i><i>/</i><i>V</i><i>M</i><i>S</i><i> </i><i>I</i><i>n</i><i>t</i><i>e</i><i>r</i><i>n</i><i>a</i><i>l</i><i>s</i><i> </i><i>a</i><i>n</i><i>d</i><i> </i><i>D</i><i>a</i><i>t</i><i>a</i><i> </i><i>S</i><i>t</i><i>r</i><i>u</i><i>c</i><i>t</i><i>u</i><i>r</i><i>e</i><i>s</i></span>一书，尽可能从贴近源代码的角度提供了深入探讨，而我决定撰写此书的Windows NT版本。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当时的写作进展非常缓慢，
我正忙着完成博士学业，并在一家小型软件公司开始自己的职业生涯。为了了解Windows 
NT，我阅读文档，对其代码进行逆向工程，并开发Regmon和Filemon这样的系统监视工具，借此观察Windows 
NT表现出的内部行为，以便帮助自己了解其设计。随着学习的深入，我通过<span style="font-size:16px;font-style: oblique;font-family:'PingFang SC';"><i>W</i><i>i</i><i>n</i><i>d</i><i>o</i><i>w</i><i>s</i><i> </i><i>N</i><i>T</i><i> </i><i>M</i><i>a</i><i>g</i><i>a</i><i>z</i><i>i</i><i>n</i><i>e</i></span>月刊（一本面向Windows NT管理员的杂志）的NT Internals专栏分享了自己新发现的知识。这些专栏文章成为后续与IDG出版社签约并出版<span style="font-size:16px;font-style: oblique;font-family:'PingFang SC';"><i>W</i><i>i</i><i>n</i><i>d</i><i>o</i><i>w</i><i>s</i><i> </i><i>I</i><i>n</i><i>t</i><i>e</i><i>r</i><i>n</i><i>a</i><i>l</i><i>s</i></span>一书相关章节的基础。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于本职工作的影响，并且
我还要花费大量时间开发Sysinternals（当时还叫NTInternals）免费软件，并为自己新成立的Winternals 
Software公司开发商业软件，所以本书的写作进程受到拖累，交稿时间也一拖再拖。随后在1996年，大卫·所罗门出版的<span style="font-size:16px;font-style: oblique;font-family:'PingFang SC';"><i>I</i><i>n</i><i>s</i><i>i</i><i>d</i><i>e</i><i> </i><i>W</i><i>i</i><i>n</i><i>d</i><i>o</i><i>w</i><i>s</i><i> </i><i>N</i><i>T</i></span>的
第2版让我大为震惊，我发现该书既让人印象深刻，又让我感到沮丧。这本书完全重写了海伦那本书的内容，更深入、广泛地介绍了Windows 
NT的内部原理，而这些工作正是我原本打算要做的。同时这本书还通过新颖的“实验”环节，借助系统内置的，以及来自Windows 
NT资源包和设备驱动程序开发包（DDK）的工具与诊断实用工具，演示了与系统有关的重要概念和行为。大卫将标准提高了很多，让我意识到写一本从质量和深
度两方面都能与他的作品媲美的书，要比我原本的计划更艰巨。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">俗话说：如果不能打败他
们，就加入他们。早先在Windows大会演讲时我就认识大卫·所罗门了，因此在这本书出版后的几周里，我给他发了一封电子邮件，自荐要参与到这本书的下
一版的写作中，下一版将主要针对当时所谓的Windows NT 5，也就是后来的Windows 2000。我将主要基于自己之前的NT 
Internals专栏文章，撰写全新章节来涵盖大卫·所罗门尚未涉及的话题，同时围绕自己的Sysinternals工具撰写很多新的实验内容。为了让
自己的提议更有吸引力，我还建议在这本书的随附资源光盘中提供全套Sysinternals工具（借助图书和杂志分发软件是当时一种很常见的做法）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">大卫·所罗门对此很感兴
趣，但首先他需要得到微软公司的批准。我曾公开揭露Windows NT Workstation与Windows NT 
Server使用了完全相同的代码，只不过会根据注册表设置的差异而表现出不同的行为，这给微软造成了一些公关方面的麻烦。虽然他可以完整访问
Windows 
NT源代码，可我不行，但我觉得这样也挺好，以免自己在为Sysinternals或Winternals开发软件时因为涉及未公开的API而陷入知识产
权方面的麻烦。当时的时机很微妙，因为在他就此事询问微软时，我也一直在努力修复自己与Windows工程师的关系，微软最终默许了我们的合作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与大卫·所罗门合作撰写<span style="font-size:16px;font-style: oblique;font-family:'PingFang SC';"><i>I</i><i>n</i><i>s</i><i>i</i><i>d</i><i>e</i><i> </i><i>W</i><i>i</i><i>n</i><i>d</i><i>o</i><i>w</i><i>s</i><i> </i><i>2</i><i>0</i><i>0</i><i>0</i></span>的
过程极为有趣。虽然难以置信，但巧的是，他家和我家距离仅20分钟车程（我住在美国康涅狄格州的丹伯里，他住在康涅狄格州的谢尔曼）。我们会去对方家里进
行“写作马拉松”，共同研究Windows内部原理，讲些与“极客”有关的段子和双关语，并围绕技术问题进行比赛，借助他的源代码以及我的反汇编工具、调
试器和Sysinternals工具，看谁能先找到答案（如果有机会见到他，你可别戳他的痛处，因为当时总是我赢）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">就这样，我成了一本书的合
作者，而这本书描述了有史以来最成功的商业操作系统之一。在涵盖Windows XP和Windows 
Vista的本书第5版的撰写过程中，我们邀请了亚历克斯·伊奥尼斯库。亚历克斯是全球最棒的逆向工程师和操作系统专家之一，在他的帮助下，本书的广度和
深度得到进一步拓展，在可读性和细节方面达到甚至超越了我们当时的最高标准。随着本书范围继续扩大，并且Windows本身包含的新功能和子系统的数量不
断增长，第6版的篇幅已经超出了第5版所确立的单卷出版限制，因此我们将其拆分为两卷。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在第6版的撰写过程中，我
已经转岗至Azure部门，而当我们准备开始撰写第7版时，我已经完全没有时间参与本书的撰写工作了。大卫·所罗门已经退休，此外考虑到Windows已
经从每几年发布一次大版本和版本号，转变为像Windows 
10这样持续发布新功能和功能升级，本书的更新工作也变得更具挑战性。在第7版的卷1撰写过程中，帕维尔·约西沃维奇加入并帮助亚历克斯进行撰写，但现在
他也因忙于其他项目，无法继续参与卷2的撰写。亚历克斯现在也正忙于自己的初创公司CrowdStrike，我们甚至一度担心卷2能否顺利出版。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">幸运的是，我们迎来了安德
里亚。他和亚历克斯更新了卷2中的大量内容，包括启动和关机过程、注册表子系统以及UWP。他们不仅更新了原有内容，还增加了全新的三章，深入介绍了
Hyper-V、缓存和文件系统，以及诊断和跟踪。作为有史以来最重要的软件之一，Windows极为安全。而<span style="font-size:16px;font-style: oblique;font-family:'PingFang SC';"><i>W</i><i>i</i><i>n</i><i>d</i><i>o</i><i>w</i><i>s</i><i> </i><i>I</i><i>n</i><i>t</i><i>e</i><i>r</i><i>n</i><i>a</i><i>l</i><i>s</i></span>系列图书是有关Windows内部工作原理在技术上既深入又准确的著作。自己依然能够在这本书上留名，这让我倍感自豪。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在我职业生涯中有一个难忘的时刻，当时我们在邀请大卫·卡特勒为<span style="font-size:16px;font-style: oblique;font-family:'PingFang SC';"><i>I</i><i>n</i><i>s</i><i>i</i><i>d</i><i>e</i><i> </i><i>W</i><i>i</i><i>n</i><i>d</i><i>o</i><i>w</i><i>s</i><i> </i><i>2</i><i>0</i><i>0</i><i>0</i></span>作
序。为此，大卫·所罗门和我曾多次拜访微软并与Windows工程师会面，这期间几次遇到了大卫·卡特勒。然而我们完全不知道他是否会同意，因此当他同意
时，我们激动极了。现在轮到我为本书作序，这一切感觉有些难以置信，但与当年我们邀请大卫·卡特勒作序时的情况类似，能获得这个机会我倍感荣幸。希望有我
的序言作为背书能给你同样的信心，让你相信这本书是权威、清晰和全面的，正如大卫·卡特勒当年为<span style="font-size:16px;font-style: oblique;font-family:'PingFang SC';"><i>I</i><i>n</i><i>s</i><i>i</i><i>d</i><i>e</i><i> </i><i>W</i><i>i</i><i>n</i><i>d</i><i>o</i><i>w</i><i>s</i><i> </i><i>2</i><i>0</i><i>0</i><i>0</i></span>所做的那样。</span></p>
	<p><span style="font-size:16px;font-family:'FZKai-Z03';display: block;text-align:right;">马克·E. 鲁辛诺维奇</span></p>
	<p><span style="font-size:16px;font-family:'FZKai-Z03';display: block;text-align:right;">Azure首席技术官和微软技术院士</span></p></div>
	<p style="page-break-after: always;">
</p><div id="qz07.xhtml">
</div><div class="header0"><h1><span id="sigil_toc_id_4" style="font-size:22px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';display: block;text-align:center;"><b>前</b><b>言</b></span></h1></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">《深入解析Windows
操作系统》（第7版）（卷2）主要面向希望了解Microsoft Windows 10（截至并包括2021年5月更新，即21H1）与Windows
 Server（从Server 2016直至Server 2022）操作系统核心组件，包括Windows 
11X及Xbox操作系统共用的众多内部组件工作原理的高级计算机专业人员（开发者、安全研究人员和系统管理员）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">首先，借助这些知识，开发
者在针对特定Windows平台构建应用程序时可以更好地理解各种设计抉择背后的原理，并通过更好的决策打造更强大、可扩展性和安全性更高的软件。读者还
可借此增强针对系统核心组件遇到的复杂问题进行调试的技能，同时了解能在其他方面令自己获益的各类工具。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">其次，这些信息也能让系统管理员获益匪浅，因为了解操作系统的底层工作原理有助于更好地理解系统的预期性能和行为，当遇到问题后，这些知识有助于简化排错工作，并能围绕表面现象更好地解决各种关键问题。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后，安全研究人员可以更
好地发现应用程序和操作系统中的异常行为、滥用以及其他非预期行为，同时更好地理解现代化Windows操作系统针对这些情况提供的缓解措施和安全功能。
取证专家可以借此了解应该使用哪些数据结构和机制找出篡改的迹象，以及Windows本身如何检测这些行为。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通过阅读本书，读者将能更好地理解Windows的工作原理及其背后的原因。</span></p>
	<p><span style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>本</b><b>书</b><b>历</b><b>史</b><b>版</b><b>本</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">本书是第7版，第1版名为<span style="font-size:16px;font-style: oblique;font-family:'PingFang SC';"><i>I</i><i>n</i><i>s</i><i>i</i><i>d</i><i>e</i><i> </i><i>W</i><i>i</i><i>n</i><i>d</i><i>o</i><i>w</i><i>s</i><i> </i><i>N</i><i>T</i></span>（Microsoft Press，1992），由海伦·卡斯特（在Windows NT 3.1首发前）撰写。<span style="font-size:16px;font-style: oblique;font-family:'PingFang SC';"><i>I</i><i>n</i><i>s</i><i>i</i><i>d</i><i>e</i><i> </i><i>W</i><i>i</i><i>n</i><i>d</i><i>o</i><i>w</i><i>s</i><i> </i><i>N</i><i>T</i></span>是市面上有关Windows NT的第一本书，针对系统架构和设计提供了很多重要见解。<span style="font-size:16px;font-style: oblique;font-family:'PingFang SC';"><i>I</i><i>n</i><i>s</i><i>i</i><i>d</i><i>e</i><i> </i><i>W</i><i>i</i><i>n</i><i>d</i><i>o</i><i>w</i><i>s</i><i> </i><i>N</i><i>T</i></span>（第2版）（Microsoft Press，1998）由大卫·所罗门执笔，通过涵盖有关Windows NT 4.0的内容对第1版图书进行更新，同时技术深度也进一步增加。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';"><span style="font-size:16px;font-style: oblique;font-family:'PingFang SC';"><i>I</i><i>n</i><i>s</i><i>i</i><i>d</i><i>e</i><i> </i><i>W</i><i>i</i><i>n</i><i>d</i><i>o</i><i>w</i><i>s</i><i> </i><i>2</i><i>0</i><i>0</i><i>0</i></span>（第
3版）（Microsoft 
Press，2000）由大卫·所罗门和马克·鲁辛诺维奇联手撰写。其中增加了很多新话题，例如启动和关机、服务内部原理、注册表内部原理、文件系统驱动
程序以及网络，还介绍了Windows 
2000在内核方面的变化，如Windows驱动程序模型（WDM）、即插即用、电源管理、Windows管理规范（WMI）、加密、作业对象以及终端服
务。<span style="font-size:16px;font-style: oblique;font-family:'PingFang SC';"><i>W</i><i>i</i><i>n</i><i>d</i><i>o</i><i>w</i><i>s</i><i> </i><i>I</i><i>n</i><i>t</i><i>e</i><i>r</i><i>n</i><i>a</i><i>l</i><i>s</i></span>（第
4版）（Microsoft Press，2004）包含了有关Windows XP和Windows Server 
2003的更新内容，并增加了有助于IT专业人员运用已掌握的Windows内部原理知识来解决问题的内容，如Windows 
SysInternals重要工具的使用，以及崩溃转储分析。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';"><span style="font-size:16px;font-style: oblique;font-family:'PingFang SC';"><i>W</i><i>i</i><i>n</i><i>d</i><i>o</i><i>w</i><i>s</i><i> </i><i>I</i><i>n</i><i>t</i><i>e</i><i>r</i><i>n</i><i>a</i><i>l</i><i>s</i></span>（第
5版）（Microsoft Press，2009）更新了与Windows Vista和Windows Server 
2008有关的内容。当时马克·鲁辛诺维奇已成为微软全职员工（现在他是Azure的CTO），他在编写该版的过程中邀请了一位新合作者亚历克斯·伊奥尼
斯库。新增内容包括映像加载器、用户模式调试设施、高级本地过程调用（Advanced Local Procedure 
Call，ALPC）及Hyper-V。随后出版的<span style="font-size:16px;font-style: oblique;font-family:'PingFang SC';"><i>W</i><i>i</i><i>n</i><i>d</i><i>o</i><i>w</i><i>s</i><i> </i><i>I</i><i>n</i><i>t</i><i>e</i><i>r</i><i>n</i><i>a</i><i>l</i><i>s</i></span>（第6版）（Microsoft Press，2012）经历了彻底更新，包含与Windows 7和Windows Server 2008 R2内核变化有关的大量内容，同时通过新增的动手实验介绍了相关工具的变化。</span></p>
	<p><span style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>第</b><b>7</b><b>版</b><b>的</b><b>变</b><b>化</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于书稿篇幅已超出现代印刷出版的限制，本书第6版首次拆分成两卷，这使得作者能够更快速地将部分内容首先出版（卷1于2012年3月出版，卷2于2012年9月出版）。然而，当时的分卷完全基于页数，不同章节的整体安排顺序与之前的版本完全相同。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">自第6版发布后，微软开始
了操作系统的“统一”，并首先为Windows 8和Windows Phone 8使用了统一的内核，最终通过Windows 8.1、Windows
 RT和Windows Phone 8.1引入了现代化应用程序环境。这一愿望在Windows 10上终于实现了——Windows 
10已经可以运行在台式机、笔记本电脑、手机、服务器、Xbox 
One游戏机、HoloLens以及各种物联网（IoT）设备上。操作系统的“统一”得以顺利实现，是时候更新本书内容了，新版终于全面涵盖了近五年来的
所有变化。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在本书的第7版
（Microsoft 
Press，2017）中，帕维尔·约西沃维奇首次参与到本书的撰写工作中，他接替了大卫·所罗门作为“微软局内人”的角色，并负责本书的整体管理。而亚
历克斯·伊奥尼斯库也像马克那样将主要精力转向CrowdStrike（现已成为端点工程部门的副总裁）。因此帕维尔决定重构本书章节，以便让上下两卷能
够更合理地整合书稿内容，而不至于让读者必须等待卷2出版后才能理解卷1中所涉及的概念。这也使得卷1的内容完全能够独立成章，并向读者介绍了有关
Windows 10系统架构、进程管理、线程调度、内存管理、I/O处理，以及用户、数据和平台安全性等诸多关键概念。卷1涵盖了Windows 
10（截至并包含版本1703，即2017年5月的更新）以及Windows Server 2016的新内容。</span></p>
	<p><span style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>卷</b><b>2</b><b>的</b><b>变</b><b>化</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随着亚历克斯·伊奥尼斯库
和马克·鲁辛诺维奇的时间被全职工作所占据，而帕维尔也开始参与其他项目，本书第7版的卷2多年来一直在寻找新的作者。安德里亚·阿列维最终挺身而出，继
续创作并完成了该系列的后续内容，对此其他合作者表示万分感谢。与之前的合作者类似，安德里亚也能全面访问微软的源代码，同时他还是Windows操作系
统内核团队的专职开发者，这在本书历史上还是头一次。在亚历克斯的建议和指导下，安德里亚顺利完成了撰写工作，并将自己的愿景融入这一系列图书中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在意识到有关网络和崩溃转
储分析等话题的章节已不再被当今读者所关注后，安德里亚围绕Hyper-V增加了一些激动人心的新内容。无论是Azure或客户端操作系统，如今
Hyper-V已成为Windows平台战略的关键部分。该章节详细介绍了完全重写的引导过程和ReFS、DAX等全新存储技术，讨论了系统和管理机制的
扩展更新，并通过全面更新的动手实验内容帮助读者更好地运用新的调试器技术和相关工具。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">卷1和卷2较长的出版间隔
时间使得本书能够实现彻底更新，本书涵盖了Windows 
10最新的公开发布版本，即版本2104（2021年5月更新/21H1），以及Windows Server 
2019和2022。借此，读者就不会因为漫长的间隔而只能获得“落后”的信息。由于Windows 
11以完全相同的操作系统内核为基础构建，读者同样能为这个新发布的系统版本做好充分准备。</span></p>
	<p><span style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>动</b><b>手</b><b>实</b><b>验</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">即使无法访问
Windows源代码，我们依然可以通过内核调试器、Sysinternals工具以及专为本书开发的其他工具一窥Windows的内部工作原理。如果可
以通过某个工具查看或呈现Windows的某些内部行为，那么本书会在正文的“实验”环节中列出可供读者通过这些工具自行尝试的步骤。本书包含了大量此类
实验，希望读者在阅读的同时能够自行尝试。切实了解Windows的内部工作原理有助于读者深刻理解本书的内容。</span></p>
	<p><span style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>本</b><b>书</b><b>未</b><b>涵</b><b>盖</b><b>的</b><b>主</b><b>题</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows是一个庞大
的、复杂的操作系统。本书并不能涵盖与Windows内部原理有关的所有内容，而主要侧重于最基本的系统组件。例如，本书并未介绍COM+这一
Windows分布式面向对象的编程基础架构，也并未介绍Microsoft .NET 
Framework这种托管代码应用程序的基础框架。这是一本介绍“内部原理”的书，而非面向普通用户、程序员或系统管理员的书，因此，本书并不会介绍如
何使用、编程或配置Windows。</span></p>
	<p><span style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>注</b><b>意</b><b>事</b><b>项</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">本书介绍了Windows
操作系统很多未公开的内部架构和操作行为（如内核结构和函数），因此在不同的版本之间这些内容可能有所变化。此处的“可能有所变化”并不是指本书中描述的
细节肯定会在不同的版本中出现变化，而是指读者应做好可能有变化的心理准备。任何使用这些未公开接口或操作系统内部知识的软件，都可能无法在
Windows后续版本中正常运行。更糟的是，在内核模式下运行的软件（如设备驱动程序）以及使用了这些未公开接口的软件在以后的新版Windows中运
行可能会导致系统崩溃，甚至可能导致这些软件的用户数据丢失。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">简而言之，在为终端用户系统开发任何类型的软件，或出于研究和学习之外的其他目的时，绝不应该使用本书提到的任何Windows内部功能、注册表键、行为、API或其他未公开的细节。对于任何具体话题，建议始终优先以微软软件开发网络（MSDN）提供的正式文档为准。</span></p>
	<p><span style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>阅</b><b>读</b><b>本</b><b>书</b><b>的</b><b>前</b><b>提</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">本书假设读者对Windows具备高级使用经验，并对CPU寄存器、内存、进程以及线程等操作系统和硬件概念有基本了解。如果读者对函数、指针以及类似的C语言构造有所了解，那么可以更好地理解本书的某些内容。</span></p>
	<p><span style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>本</b><b>书</b><b>内</b><b>容</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">本书分为两卷（与第6版一样），读者目前阅读的是第7版的卷2。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·第8章“系统机制”，介绍了操作系统为设备驱动程序和应用程序提供关键服务所需的重要内部机制，如ALPC、对象管理器、同步例程。此外还介绍了运行Windows的硬件架构细节，包括陷阱处理、分段、侧信道漏洞以及解决这些问题的缓解措施。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·第9章“虚拟化技术”，介绍了Windows操作系统如何通过现代处理器提供的虚拟化技术让用户在同一个系统中创建并使用多个虚拟机。Windows还广泛使用虚拟化技术以提供更高的安全性，因此本章还全面讨论了安全内核与隔离用户模式。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·第10章“管理、诊断和跟踪”，详细介绍了操作系统为进行管理、配置和诊断所实现的底层机制细节，尤其是Windows注册表、Windows服务、WMI和任务计划，以及诸如Windows事件跟踪（ETW）和DTrace等诊断服务。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
第11章“缓存和文件系统”，介绍了最重要的“存储”组件（即缓存管理器和文件系统驱动程序）如何通过交互为Windows提供以高效、故障安全
（fault-safe）的方式处理文件、目录和磁盘设备的能力。本章还介绍了Windows所支持的文件系统，尤其是NTFS和ReFS。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·第12章“启动和关机”，介绍了系统启动和关机过程中的完整操作流程，以及引导过程中涉及的操作系统组件。本章还分析了由UEFI带来的新技术，如安全启动、测量启动以及安全运行。</span></p>
	<p><span style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>关</b><b>于</b><b>本</b><b>书</b><b>的</b><b>随</b><b>附</b><b>资</b><b>源</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">你可以通过以下网址下载本书的配套学习资源：MicrosoftPressStore.com/WindowsInternals7ePart2/downloads。</span></p>
	<p><span style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>致</b><b>谢</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">本书包含复杂的技术细节以
及相关推理，这些往往很难从“局外人”的角度来描述和理解。纵观其出版历史，本书的价值之一在于，始终能向局外人提供逆向工程的视角，同时能得到微软内部
承包商或员工的帮助，填补空白，并提供微软内部积累的知识和Windows操作系统背后丰富的开发与发展历史。在卷2的写作过程中，作者要感谢安德里亚·
阿列维的加入，作为主要作者，他帮助并推动了本书大部分内容的撰写和更新工作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了安德里亚，本书的成功也要感谢微软公司Windows开发团队的关键成员、微软公司的其他专家，以及同事、朋友和不同领域专家的审阅、反馈和支持，否则本书将无法实现目前这样的技术深度和准确性。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">尤其是全新撰写的第9
章“虚拟化技术”，正是在Alexander Grest和Jon 
Lange的帮助下才能如此完善且详细。他们都是相关领域内世界知名的专家，值得在此特别感谢，尤其是他们还花了多天时间帮助安德里亚理解晦涩的虚拟机监
控程序和安全内核中大部分功能的内部细节。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">亚历克斯希望特别感谢Arun Kishan、Mehmet Iyigun、David Weston以及Andy Luhrs对本书的持续宣传和推荐，同时亚历克斯以“局内人”身份获得的人脉和信息也让本书的准确性和完整性再上新高。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，我们还想感谢下列人
员为本书提供的技术审阅和反馈，以及给予我们的其他帮助和支持：Saar Amar、Craig Barkhouse、Michelle 
Bergeron、Joe Bialek、Kevin Broas、Omar Carey、Neal Christiansen、Chris 
Fernald、Stephen Finnigan、Elia Florio、James Forshaw、Andrew Harper、Ben 
Hillis、Howard Kapustein、Saruhan Karademir、Chris Kleynhans、John 
Lambert、Attilio Mainetti、Bill Messmer、Matt Miller、Jake Oshins、Simon 
Pope、Jordan Rabet、Loren Robinson、Arup Roy、Yarden Shafir、Andrey 
Shedel、Jason Shirk、Axel Souchet、Atul Talesara、Satoshi Tanda、Pedro 
Teixeira、Gabrielle Viala、Nate Warfield、Matthew Woolman和Adam Zabrocki。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">我们还想感谢Hex-
Rays（http://www.hex-rays.com）的Ilfak Guilfanov为亚历克斯·伊奥尼斯库提供了IDA Pro 
Advanced和Hex-Rays软件许可，包括最新版本的终生使用许可，这款宝贵的工具帮助我们加快了对Windows内核进行逆向工程的速度。
Hex-Rays团队针对反编译器功能的持续支持和版本更新让亚历克斯能够在没有源代码的情况下顺利完成本书的编写。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后，我们还想感谢Microsoft Press（Pearson）的员工，本书的顺利出版离不开他们的帮助。从2018年签署出版合同到两年半后最终成书，Loretta Yates、Charvi Arora以及相关支持人员的无限耐心都值得特别感谢。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter08.xhtml">
</div><div class="header0"><h1><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';display: block;text-align:center;"><b>第</b><b>8</b><b>章</b></span></h1></div>
<div class="part">
</div><div class="header0"><h1><span id="sigil_toc_id_5" style="font-size:22px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';display: block;text-align:center;"><b>系</b><b>统</b><b>机</b><b>制</b></span></h1></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows操作系统提供了多种可供执行体、内核以及设备驱动程序等内核模式组件使用的基本机制。本章将介绍下列系统机制及其用法：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·处理器执行模型，包括Ring级别、段、任务状态、陷阱调度（包括中断、延迟过程调用（DPC）、异步过程调用（APC）、计时器、系统工作线程、异常调度以及系统服务调度）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·预测执行的屏障和其他软件侧信道缓解措施。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·执行体对象管理器。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·同步，包括自旋锁、内核调度程序对象、等待调度，以及与用户模式相关的同步基元（synchronization primitive），如基于地址的等待、条件变量以及精简读取器/写入器（Slim Reader-Writer，SRW）锁。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·高级本地过程调用（Advanced Local Procedure Call，ALPC）子系统。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Windows通知设施（Windows Notification Facility，WNF）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·WoW64。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·用户模式调试框架。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，本章还将详细介绍通用Windows平台（Universal Windows Platform，UWP）以及驱动该平台的用户模式和内核模式服务，例如：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·打包的应用程序（Packaged Application）和AppX部署服务。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Centennial应用程序和Windows桌面桥（Windows Desktop Bridge）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·进程状态管理（Process State Management，PSM）和进程生命周期管理（Process Lifetime Management，PLM）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·主机活动管理器（Host Activity Manager，HAM）和后台活动审查器（Background Activity Moderator，BAM）。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter08_0001.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_6" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>1</b><b> </b><b>处</b><b>理</b><b>器</b><b>执</b><b>行</b><b>模</b><b>型</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">本节将深入介绍Intel
 
i386处理器架构，以及现代系统中更常用的AMD64架构（i386架构的扩展）的内部机制。虽然这两种架构最初由不同公司设计，但现在，这两家供应商
已经实现了对方的设计。因此，尽管我们可能依然会在Windows文件和注册表键中看到这些后缀，但目前普遍用x86（32位）和x64（64位）指代这
两种架构。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">本节将讨论段（segmentation）、任务、Ring级别等与关键机制相关的概念，以及陷阱（trap）、中断（interrupt）和系统调用（system call）等概念。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_7" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>1</b><b>.</b><b>1</b><b> </b><b>段</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">诸如C/C++和Rust等高级编程语言会被编译为机器代码，通常可称之为汇编语言或汇编代码。借助这种低级语言可直接访问处理器寄存器。通常程序可访问以下三种主要类型的寄存器（调试代码时可见）：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
程序计数器（Program Counter，PC），在x86/x64架构中可将其称为指令指针（Instruction 
Pointer，IP），由EIP（x86）和RIP（x64）寄存器所代表。该寄存器始终指向正在执行的汇编代码行（某些32位ARM架构存在例外情
况）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·栈指针（Stack Pointer，SP），由ESP（x86）和RSP（x64）寄存器所代表。该寄存器会指向保存了当前栈位置的内存位置。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·其他通用寄存器（General Purpose Register，GPR），包括但不限于EAX/RAX、ECX/RCX、EDX/RDX、ESI/RSI及R8、R14等寄存器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然这些寄存器可包含指向内存的地址值，但在访问内存位置时还需要其他寄存器的介入，这是一种称为受保护模式段（protected mode segmentation）的机制。为此需要检查各种段寄存器，此类寄存器亦可称为选择器（selector）：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·所有针对程序计数器的访问首先需要检查代码段（Code Segment，CS）寄存器。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·所有针对栈指针的访问首先需要检查栈段（Stack Segment，SS）寄存器。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·对其他寄存器的访问由段重写（Override）决定，段重写所用的编码方式可强制针对特定寄存器进行检查，如数据段（Data Segment，DS）、扩展段（Extended Segment，ES）或F段（F Segment，FS）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这些选择器位于16位段寄存器中，可在一种名为全局描述符表（Global Descriptor Table，GDT）的数据结构中进行查找。为了定位GDT，处理器还会用到另一个CPU寄存器：GDT寄存器，也就是GDTR。这些选择器的格式如图8-1所示。</span></p><div style="display: block;text-align:center;">
	<img width="582" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/29f6090f47bef4d46a523f73329cfc27.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-1 x86段选择器的格式</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">段选择器中的偏移量可以在
GDT中查看，除非TI位设置为使用另一种名为本地描述符表（Local Descriptor 
Table，LDT）的数据结构，该数据结构由LDTR所确定，但现代Windows操作系统中已不再使用该数据结构了。因为这种工作方式会造成这样一种
结果：在被发现的段项（或者无效段项）中产生一般性保护错误（#GP）或段错误（#SF）异常。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这个段项在现代操作系统中通常被称为段描述符，主要提供两种关键用途：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
对于代码段，它给出运行这个段选择器所加载的代码即将执行的Ring级别，也叫代码特权级别（Code Privilege 
Level，CPL）。Ring级别的范围介于0到3之间，会被缓存至实际选择器的最低两位，如图8-1所示。Windows操作系统会使用Ring 
0来运行内核模式组件和驱动程序，并使用Ring 
3运行应用程序和服务。此外在x64系统中，代码段还可体现出这是一个长模式还是兼容模式的段。前者允许x64代码以原生方式执行，后者可激活与x86的
遗留兼容模式。x86系统中也存在类似机制，据此可将段标记为16位段或32位段。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·对于其他段，它给出访问这些段所需的Ring级别，也叫描述符特权级别（Descriptor Privilege Level，DPL）。虽然在当今现代操作系统中已经算是一项过时的检查，但处理器（以及应用程序）依然会强制要求正确设置该段。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后，在x86系统中，段
项也可以使用32位基址，该值会被添加到已载入（使用重写引用该段的）寄存器的其他任意值中。随后会使用相应的段限制来检查底层寄存器的值是否超过某个固
定上限。因为在大部分操作系统中，该基址会被设置为0（且限制为0xFFFFFFFF），所以x64架构代码摒弃了这个概念，但FS和GS选择器除外，它
们的工作方式略有差异，如下：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
如果代码段为长模式，那么会从FS_BASE这个特殊模块寄存器（Model Specific 
Register，MSR）中的0C0000100h处获得FS段的基址。对于GS段，则查看当前的Swap状态，该状态可通过swapgs指令修改，随
后则会载入GS_BASE MSR（0C0000101h）或GS_SWAP MSR（0C0000102h）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如果FS或GS段选择器寄存器中设置了TI位，则会从LDT项相应的偏移量处获得对应的值，该值只能采用32位基址。这样做是为了保证与某些忽略32位基址限制操作系统的兼容性。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果代码段为兼容模式，那么会照常从相应的GDT项（如果TI位已设置，则会从LDT项）读取基址。该限制会强制实施，并且会通过段重写后寄存器中的偏移量进行验证。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">FS和GS段这种有趣的行为可被Windows等操作系统用于实现某种类型的线程本地寄存器效果，借此，段基址可指向某种特定的数据结构，进而以简单的方式访问其中的特定偏移量/字段。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">例如，Windows会将
线程环境块（Thread Environment 
Block，TEB）的地址存储在x86系统的FS段或x64系统的GS（已交换）段中（TEB已在卷1第3章中进行了详细介绍）。随后，当在x86系统
中执行内核模式代码时，该FS段会被手动修改为一个不同的段项，该段项包含内核处理器控制区（Kernel Processor Control 
Region，KPCR）的地址，而在x64系统中则是由GS（未交换）段存储该地址。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">因此，段可在
Windows上实现这两种效果：在处理器级别下编码并强制实施可供代码片段执行的特权级别，并分别为用户模式和内核模式代码提供对TEB和KPCR数据
结构的直接访问。请注意，由于GDT是由CPU寄存器（GDTR）指向的，因此每个CPU都可以有自己的GDT。实际上，Windows正是借此保证了每
个GDT都加载相应的每个处理器KPCR，并且在当前处理器上，当前执行线程的TEB同样会保存在自己的段中。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>在</b><b>x</b><b>6</b><b>4</b><b>系</b><b>统</b><b>中</b><b>查</b><b>看</b><b>G</b><b>D</b><b>T</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在进行远程调试或分析崩溃转储文件（都需要用到LiveKD）时，我们可以使用dg这个调试器命令查看GDT的内容，包括所有段的状态及其基址（如果相关）。该命令可接收起始段和终止段，也就是下文范例中的10和50：</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/2d3137e889ad2feb7be8f1d2902b16d5.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">此处的关键段为10h、18h、20h、28h、30h和50h（上述输出结果有省略，删除了与本话题无关的项）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
10h（KGDT64_R0_CODE）中可以看到一个处于Ring 
0的长模式代码段，该代码段在PI列下显示数字“0”，在Long列下显示字母“Lo”，其类型为Code 
RE。类似地，在20h（KGDT64_R3_CMCODE）中可以看到一个处于Ring 3的Nl段（Nl代表Not 
Long，也就是兼容模式），该段可用于在WoW64子系统中执行x86代码。而在30h（KGDT64_R3_CODE）中可以看到一个等价的长模式
段。随后请注意18h（KGDT64_R0_DATA）和28h（KGDT64_R3_DATA）段，它们对应栈、数据和扩展段。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">还有最后一个段50h（KGDT_R3_CMTEB），除非我们在转储GDT时在WoW64下运行某些x86代码，否则该段的基址通常为零。根据上文的介绍，在兼容模式下运行时，该段通常会存储TEB的基址。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">要查看64位TEB和KPCR段，我们需要转储相应的MSR。在进行本地或远程内核调试时，可通过下列命令进行转储（这些命令无法用于崩溃转储）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; rdmsr c0000101 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">msr[c0000101] = ffffb401`a3b80000 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; rdmsr c0000102 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">msr[c0000102] = 000000e5`6dbe9000 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以将这些值与@$pcr和@$teb的值进行对比，随后应该能看到相同的值，例如：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx -r0 @$pcr </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">@$pcr              : 0xffffb401a3b80000 [Type:_KPCR *] </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx -r0 @$teb </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">@$teb              : 0xe56dbe9000 [Type:_TEB *] </span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>在</b><b>x</b><b>8</b><b>6</b><b>系</b><b>统</b><b>中</b><b>查</b><b>看</b><b>G</b><b>D</b><b>T</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在x86系统中，虽然GDT包含类似的段，但分别位于不同的选择器中。此外，由于使用了双FS段来替代swapgs功能，并且缺乏长模式，因此选择器的数量也会有所差异，如下所示：</span></p><div style="display: block;text-align:center;">
	<img width="824" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/707ccf4b03eb5ee00f4e49e60dcb0a4c.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">此
处的关键段为08h、10h、18h、20h、30h和38h。在08h（KGDT_R0_CODE）中可以看到一个处于Ring 
0的代码段。类似地，在18h（KGDT_R3_CODE）中会看到一个Ring 
3的段。随后请注意10h（KGDT_R0_DATA）和20h（KGDT_R3_DATA）段，它们对应栈、数据和扩展段。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在x86系统中，可以在30h（KGDT_R0_PCR）段中看到KPCR的基址，并在38h（KGDT_R3_TEB）段中看到当前线程TEB的基址。此类系统的段不使用MSR。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>延</b><b>迟</b><b>段</b><b>加</b><b>载</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">根据上文有关段的描述和相关值的介绍，在x86或x64系统中调查DS和ES段的值可能会有“惊喜”：它们的值未必会与相应Ring级别所定义的值相匹配。例如，一个x86用户模式线程可能包含下列段：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">CS = 1Bh (18h | 3) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ES, DS = 23 (20h | 3) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">FS = 3Bh (38h | 3) </span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">然而，在Ring 0的系统调用中，可能会看到如下段：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">CS = 08h (08h | 0) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ES, DS = 23 (20h | 3) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">FS = 30h (30h | 0) </span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">类似地，内核模式执行的
x64线程也可以将自己的ES和DS段设置为2Bh（28h | 3）。造成这种差异的原因在于一项名为延迟段加载（lazy segment 
loading）的功能。此外，这种差异体现在平面内存模型下运作的系统中，如果当前代码特权级别（CPL）为0，那么数据段的描述符特权级别（DPL）
将毫无意义。由于更高位的CPL始终可以访问更低位DPL的数据（但无法反向访问），因此在进入内核时将DS和ES段设置为各自“适当”的值后，还需要在
返回用户模式时将这些值还原。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然10h处的MOV DS指令看似无关紧要，但在遇到该指令后，处理器的微码需要执行一系列选择器正确性检查，这会为系统调用和中断处理增加大量处理成本。因此，为避免增加这些成本，Windows始终会使用Ring 3数据段值。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_8" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>1</b><b>.</b><b>2</b><b> </b><b>任</b><b>务</b><b>状</b><b>态</b><b>段</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了代码和数据段寄存器，
x86和x64架构中还有另一种特殊寄存器：任务寄存器（Task 
Register，TR），这也是GDT中充当偏移量的另一个16位选择器。然而，此时的段项并不与代码或数据相关联，而是与任务相关联。这意味着，对于
处理器的内部状态而言，当前执行的代码片段会调用任务状态（task 
state），在Windows中所调用的为当前线程。现代x86操作系统会使用这些由段代表的任务状态（即任务状态段，Task State 
Segment，TSS）构建各种可关联至关键处理器陷阱（下文将详细介绍）的任务。在最基本的情况下，TSS可代表一个页目录（借助CR3寄存器），如
x64系统中的PML4（有关分页的详细信息请参阅卷1第5章），也可代表代码段、堆栈段、指令指针，甚至最多可代表四个栈指针（每个Ring级别一个指
针）。此类TSS主要用于如下场景：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·在未出现特定陷阱时，可代表当前执行状态。如果处理器当前正运行在Ring 3级别下，那么随后处理器可从该TSS加载Ring 0栈，以便正确地处理中断和异常。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·解决处理调试错误（#DB）时的架构竞争条件，这需要有包含自定义调试错误处理程序和内核栈的专用TSS。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·代表在出现双重错误（#DF）陷阱时需要加载的执行状态。借此可在安全（备份）内核栈而非当前线程的内核栈上切换至双重错误处理程序，而后者可能也是出现错误的原因。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·代表在出现不可屏蔽的中断（#NMI）时需要加载的执行状态。类似地，该TSS可用于在安全内核栈上加载NMI处理程序。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·对于会在计算机检查异常（#MCE）中使用的其他类似任务，出于相同原因，它们也可以在专用的安全内核栈中运行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在x86系统中，可以在GDT的028h选择器中找到主要的（当前）TSS，这也解释了在Windows的正常执行过程中TR会位于028h的原因。此外，#DF TSS位于58h，NMI TSS位于50h，#MCE TSS位于0A0h，#DB TSS位于0A8h。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在x64系统上，由于
TSS功能已被降级为主要执行在专用内核栈上运行的陷阱处理程序，因此删除了系统具有多个TSS的功能。目前只使用一个TSS（在Windows中位于
040h），它使用了一个由八个可能的栈指针组成的数组，该数组名为中断栈表（Interrupt Stack 
Table，IST）。先前遇到的每个陷阱都会关联至IST索引，而不再关联至自定义TSS。在下一节内容中，随着我们转储几个IDT项，你就会直观感受
到x86和x64系统以及它们处理这些陷阱的方法上的差异。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>在</b><b>x</b><b>8</b><b>6</b><b>系</b><b>统</b><b>中</b><b>查</b><b>看</b><b>T</b><b>S</b><b>S</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在x86系统中，我们可以使用上一个实验中用过的dg命令在28h处查看系统范围内的TSS：</span></p><div style="display: block;text-align:center;">
	<img width="824" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e7ede6e45b78e804eb8c670cba8a8f2f.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">上述命令将返回KTSS数据结构的虚拟地址，随后可使用dx或dt命令对其创建转储：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">kd&gt; dx (nt!_KTSS*)0x8116e400 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">(nt!_KTSS*)0x8116e400              : 0x8116e400 [Type:_KTSS *] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x000] Backlink        : 0x0 [Type: unsigned short] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002] Reserved0       : 0x0 [Type: unsigned short] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x004] Esp0            : 0x81174000 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x008] Ss0             : 0x10 [Type: unsigned short] </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请注意，上述指令只设置了Esp0和Ss0字段，因为Windows绝不会在上文介绍的陷阱之外的其他情况下使用基于硬件的任务切换。因此这个TSS的唯一用途是在硬件中断期间加载相应的内核栈。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">正
如在“陷阱调度”一节中所述，对于不会受到“Meltdown”处理器架构漏洞影响的系统，这个栈指针也是当前线程的内核栈指针（基于卷1第5章介绍过的
KTHREAD结构）；但对于受此漏洞影响的系统，这个栈指针会指向处理器描述符区域内部的过渡栈。同时，栈段将始终设置为10h，即
KGDT_R0_DATA。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如上文所述，计算机检查异常（#MC）使用了另一个TSS。我们同样可以通过dg命令查看：</span></p><div style="display: block;text-align:center;">
	<img width="822" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4e7f5d5e667f22d14f0e6b2ad4c9c9cd.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">不过这一次我们会使用.tss命令而非dx命令，该命令可格式化KTSS结构中的不同字段，并以类似于在当前执行线程中那样的方式显示任务。本例中的输入参数为栈选择器（A0h）。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">kd&gt; .tss a0 </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">eax=00000000 ebx=00000000 ecx=00000000 edx=00000000 esi=00000000 edi=00000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">eip=81e1a718 esp=820f5470 ebp=00000000 iopl=0         nv up di pl nz na po nc </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">cs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000                  efl=00000000 </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">hal!HalpMcaExceptionHandlerWrapper: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">81e1a718 fa              cli </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请
留意段寄存器的设置方式与上文“延迟段加载”中所提到的方式是一致的，并且程序计数器（EIP）指向了#MC的处理程序。此外，为了不受内存错误影响，该
栈被配置为指向内核二进制库中的一个安全栈。最后，尽管并未显示在.tss的输出结果中，但CR3实际上被配置为系统页目录。在“陷阱调度”一节，我们还
将使用!idt命令重新查看这个TSS。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>在</b><b>x</b><b>6</b><b>4</b><b>系</b><b>统</b><b>中</b><b>查</b><b>看</b><b>T</b><b>S</b><b>S</b><b>和</b><b>I</b><b>S</b><b>T</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">很不幸，x64系统中的dg命令存在Bug，无法正确显示64位基址，因此，为了获取TSS段（40h）的基址，我们需要对两个段创建转储，并将高位、中位和低位基址的数据结合在一起：</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b2cd461b4509d81db7970623c190f393.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">因此在本例中，KTSS64位于0xFFFFF8027074D000。作为获取该地址的另一种方式，请注意每个处理器的KPCR都包含一个名为TssBase的字段，其中也包含一个指向KTSS64的指针：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0: kd&gt; dx @$pcr-&gt;TssBase </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">@$pcr-&gt;TssBase              : 0xfffff8027074d000 [Type:_KTSS64 *] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x000] Reserved0      : 0x0 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x004] Rsp0           : 0xfffff80270757c90 [Type: unsigned__int64] </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请留意，此处看到的虚拟地址与GDT中看到的地址是相同的。此外我们还会发现，除RSP0之外，其他所有字段都是零，与x86架构类似，RSP0包含（在不受“Meltdown”硬件漏洞影响的计算机上）当前线程内核栈的地址，或包含处理器描述符区域过渡栈的地址。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">执行该实验所用的系统配备了一个第10代Intel处理器，因此RSP0等于当前内核栈：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0: kd&gt; dx @$thread-&gt;Tcb.InitialStack </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">@$thread-&gt;Tcb.InitialStack : 0xfffff80270757c90 [Type: void *] </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">最后，查看中断栈表会看到关联至#DF、#MC、#DB和NMI陷阱的各种栈，在“陷阱调度”一节我们还将进一步查看中断调度表（Interrupt Dispatch Table，IDT）是如何引用这些栈的：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0: kd&gt; dx @$pcr-&gt;TssBase-&gt;Ist </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">@$pcr-&gt;TssBase-&gt;Ist     [Type: unsigned__int64 [8]] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0] :            0x0 [Type: unsigned__int64] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [1] :            0xfffff80270768000 [Type: unsigned__int64] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [2] :            0xfffff8027076c000 [Type: unsigned__int64] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [3] :            0xfffff8027076a000 [Type: unsigned__int64] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [4] :            0xfffff8027076e000 [Type: unsigned__int64] </span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在讨论了GDT中Ring
级别、代码执行以及某些关键段之间的关系后，我们将通过下文的“陷阱调度”一节一起看看不同代码段（及其Ring级别）之间实际的过渡过程。但在讨论陷阱
调度前，我们先分析在易受熔断（Meltdown）硬件旁路攻击影响的系统中TSS配置是如何变化的。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter08_0002.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_9" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>2</b><b> </b><b>硬</b><b>件</b><b>侧</b><b>信</b><b>道</b><b>漏</b><b>洞</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">现代CPU可以在内部寄存
器之间以非常快的速度（皮秒级别）计算并移动数据。处理器的寄存器是一种稀缺资源，因此，操作系统和应用程序代码总是通过指令让CPU将数据从CPU寄存
器移动至主存，反之亦然。CPU可以访问不同类型的内存。位于CPU封装内部以及可由CPU执行引擎直接访问的内存称为缓存（Cache），缓存具有高速
和昂贵的特点。CPU通过外部总线访问的内存通常可称为RAM（随机访问内存，Random Access 
Memory），RAM速度更慢，价格更低，但容量更大。内存与CPU之间的位置关系定义了一种所谓的“基于内存层次结构”的内存，这些内存有着不同的速
度和容量（位置越接近CPU的内存，速度就越快，但容量就越小）。如图8-2所示，现代计算机的CPU通常包含L1、L2和L3这三级高速缓存内存，每个
物理内核均可直接访问这些高速缓存。L1和L2缓存距离CPU的内核最近，并且是每个内核专用的。L3缓存距离最远，并且始终被所有CPU内核共享（不过
嵌入式处理器一般不具备L3缓存）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">访问时间是缓存的一个重要
特征，其访问时间几乎等同于CPU的寄存器（其实缓存比寄存器略慢一些）。主存的访问时间则会慢数百倍。这意味着，如果CPU按顺序执行所有指令，由于需
要通过指令访问位于主存中的数据，整体速度会慢很多倍。为了解决这个问题，现代CPU采取了不同的策略。在历史上，这些策略曾引发了侧信道攻击（也叫预测
式攻击），事实证明，这会极大地影响终端用户系统的整体安全性。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/157ce5c4f4063667543364fbc5303b1a.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图8-2 现代CPU的缓存和存储内存及其平均容量与访问时间</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了准确描述侧信道硬件攻击以及Windows所采取的缓解措施，我们首先需要通过一些基本概念了解CPU内部的工作原理。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_10" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>2</b><b>.</b><b>1</b><b> </b><b>乱</b><b>序</b><b>执</b><b>行</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">现代微处理器通过自己的流
水线执行计算机指令。流水线包含很多阶段，如指令获取、解码、寄存器分配和更名、指令重排序、执行，以及退出。CPU应对内存访问速度不够快的一种常用策
略是：让执行引擎忽略指令顺序，优先执行所需资源已可用的指令。这意味着CPU并不会按照某种严格一致的顺序执行指令，借此能够通过让所有内核尽可能满载
的方式将所有执行单元的利用率提升至最大限度。在确定某些指令很快将会被用到并被提交（退出）之前，现代处理器能够以预测性的方式执行数百条此类指令。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上述乱序执行方法最大的问
题之一在于分支指令。一条带有附带条件的分支指令会在机器代码中定义两个可能的路径，而最终要执行的“正确”路径取决于之前执行过的指令。在计算具体情况
时，因为所依赖的“之前执行过的指令”需要访问速度缓慢的RAM，因此整体速度也会被拖慢。此时，执行引擎需要等待定义条件的指令退出（意味着需要等待内
存总线完成内存访问操作），随后才能以乱序执行的方式执行正确路径下所包含的后续指令。间接分支也会遇到类似情况。在间接分支中，CPU的执行引擎并不知
道分支（通常为Jump或Call）的具体目标，因为必须从主存中获取相关地址。在这个语境中，“推测执行”（speculative 
execution）这个术语意味着CPU的流水线需要以并行或乱序的方式解码并执行多条指令，但其结果并不会退出至永久性寄存器中，在分支指令最终执行
完毕之前，内存写入操作依然会处于挂起状态。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_11" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>2</b><b>.</b><b>2</b><b> </b><b>C</b><b>P</b><b>U</b><b>分</b><b>支</b><b>预</b><b>测</b><b>器</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在彻底评估分支条件前，
CPU如何得知哪个分支（路径）需要执行？（由于目标地址未知，间接分支同样存在类似问题。）答案位于CPU封装所包含的两个组件中：分支预测器
（branch predictor）和分支目标预测器（branch target predictor）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">分支预测器是CPU中一种
复杂的数字电路，在最终得以确认前，它会尽可能猜测每个分支最终的行进路径。借助类似方式，CPU中所包含的分支目标预测器会在最终确定前，尽可能预测间
接分支的目标。虽然实际的硬件实现主要取决于CPU制造商，但这两个组件都用到了一种名为分支目标缓冲（Branch Target 
Buffer，BTB）的内部缓存，BTB可以使用由索引函数生成的地址标签记录分支的目标地址（或有关条件分支过去曾经做过什么的相关信息），该地址标
签与缓存生成标签的方法类似，下一节会详细介绍。当分支指令首次执行时，会将目标地址存储在BTB中。通常，当执行流水线首次停机时，会迫使CPU等待从
主存中成功获取条件或目标地址。当同一个分支第二次执行时，会使用BTB中的目标地址来获取预测的目标并将其置于流水线中。图8-3展示了CPU分支目标
预测器简化后的架构范例。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b314b6901e0d18ca20c18f99823b7502.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图8-3 CPU分支目标预测器简化后的架构范例</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果预测出错，并且已经以
预测的方式执行了错误的路径，那么指令流水线会被刷新，之前预测执行的结果会被丢弃。随后会向CPU流水线中送入其他路径，并从正确的分支开始重新执行。
这个过程也叫分支预测错误。在这种情况下，浪费掉的CPU周期总数并不会多于顺序执行并等待分支条件的结果或评估间接地址所使用的CPU周期数。然而，
CPU依然会在预测执行的过程中产生各种副作用，例如CPU缓存行污染。不幸的是，一些副作用可能会被攻击者发现并利用，进而危及系统的整体安全性。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_12" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>2</b><b>.</b><b>3</b><b> </b><b>C</b><b>P</b><b>U</b><b>缓</b><b>存</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如上一节所述，CPU缓
存（Cache）是一种高速内存，可大幅缩短获取和存储数据与指令所需的时间。数据会以固定大小的块（通常为64或128字节）在内存和缓存之间传输，这
种数据块也叫缓存行或缓存块。当一个缓存行从内存复制到缓存时，会创建一个缓存项。该缓存项中包含数据副本以及用于分辨所请求内存位置的标签。与分支目标
预测器不同，缓存始终会通过物理地址创建索引（否则多个地址空间之间的映射和变更过程将变得极为复杂）。从缓存的角度来看，一个物理地址可以拆分为不同的
成分，其中较高的位通常代表标签，较低的位代表缓存行以及行本身的偏移量。标签具备唯一性，可用于区分每个缓存块所属的内存地址，如图8-4所示。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当CPU读/写内存位置
时，首先会检查缓存中是否存在对应的项（会在可能包含来自该地址数据的任何缓存行中检查。但某些缓存可能存在不同的“向”，下文很快将会提到）。如果处理
器发现来自该位置的内存数据已经位于缓存中，此时就出现了“缓存命中”的情况，处理器会立即通过该缓存行读/写数据；如果数据不在缓存中，此谓之“缓存未
命中”，此时CPU会在缓存中分配一个新项，并将数据从主存中复制进去，随后进行访问。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/fdd8fd81051aa9d3a1da0af74c878375.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-4 48位单向CPU缓存范例</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图8-4展示了一个单向
CPU缓存，该缓存最大可寻址48位虚拟地址空间。在本例中，CPU正在从虚拟地址0x19F566030中读取48字节数据。内存内容最开始已从主存读
取到缓存块0x60，该块已经被完全装满，但所请求的数据位于偏移量0x30处。范例缓存只有256块，每块256字节，因此多个物理地址可以装入编号为
0x60的块中。标签（0x19F56）能够唯一地区分数据在主存中所在的物理地址。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通过类似的方式，当CPU
接到指令向一个内存地址写入新内容时，它首先会更新该内存地址所属的一个或多个缓存行。某些时候，CPU还会将数据写回至物理RAM，这主要取决于内存页
面所应用的缓存类型（write-back、write-through、uncached等）。请注意，在多处理器系统中这具有重要的意义：必须设计某
种缓存一致协议，以避免出现主CPU更新某个缓存块后，其他CPU针对陈旧数据执行操作的情况（多CPU缓存一致算法是存在的，但超出了本书的讨论范
畴）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当出现缓存未命中情况时，
为了给新的缓存项腾出空间，CPU有时会清除某个现有的缓存块。选择要清除的缓存项（意味着选择用哪个缓存块来存储新数据）时所用的算法叫作放置策略
（placement 
policy）。如果放置策略只能替换特定虚拟地址的一个块，这种情况可以叫作直接映射（如图8-4所示缓存只有一个方向，且属于直接映射）。相反，如果
缓存可以自由选择（具备相同块编号的）任意项来保存新数据，这样的缓存也叫全相联（fully 
associative）缓存。很多缓存机制在实现方面进行了妥协，使得主存中的每个项可保存到缓存中<span style="font-size:16px;font-style: oblique;font-family:'PingFang SC';"><i>N</i></span>个
位置中的任何一个位置内，这种机制也叫N向组相联（N-ways set 
associative）。因此一个“向”可以看作缓存的一个组成部分，缓存中每个向的容量相等，并按照相同的方式进行索引。图8-5展示了一个四向组相
联缓存。图中所示的缓存可以存储分属于四个不同物理地址的数据，并通过不同的四个缓存组（使用不同标记）对相同的缓存块创建索引。</span></p><div style="display: block;text-align:center;">
	<img width="715" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/55b2de3b19cdfdc576638df2dc6669c7.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-5 一个四向组相联缓存</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_13" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>2</b><b>.</b><b>4</b><b> </b><b>侧</b><b>信</b><b>道</b><b>攻</b><b>击</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上节内容所述，现代
CPU的执行引擎只有在指令真正退出后才会写入计算结果。这意味着，就算有多条指令已经乱序执行完毕，并且对CPU寄存器和内存架构不会产生任何可见的影
响，但这样做依然会对微架构（microarchitecture）产生一定的副作用，尤其是会影响到CPU缓存。2017年年底出现了一种针对CPU乱
序引擎和分支预测器发起的新颖攻击，这种攻击所依赖的前提条件是，微架构所产生的副作用是可衡量的，尽管这些影响无法通过任何软件代码直接访问。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">围绕这种方式产生的最具破坏性且最有效的硬件侧信道攻击分别名为Meltdown和Spectre。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>M</b><b>e</b><b>l</b><b>t</b><b>d</b><b>o</b><b>w</b><b>n</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Meltdown，又被称
为恶意数据缓存负载（Rogue Data Cache 
Load，RDCL），可供恶意的用户模式进程读取所有内存，而该进程完全不需要具备相关授权。该攻击利用了处理器的乱序执行引擎，以及内存访问指令处理
过程中内存访问和特权检查两个环节之间存在的内部争用条件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在Meltdown攻击
中，恶意的用户模式进程首先会刷新整个缓存（从用户模式调用可执行该操作的指令），随后该进程会执行一个非法的内核内存访问，并执行指令以可控的方式（使
用一个probe数组）填满缓存。因为该进程无法访问内核内存，所以此时处理器会产生异常，该异常会被应用程序捕获，进而导致进程被终止。然而由于乱序执
行的缘故，CPU已经执行了（但未退出，这意味着在任何CPU寄存器或RAM中均无法检测到对架构产生的影响）非法内存访问之后发出的指令，因此已经使用
非法请求的内核内存内容填满了缓存。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后恶意应用程序会衡量访
问数组（该数组已被用于填充CPU的缓存块）中每个页面所需的时间，借此探测整个缓存。如果访问时间落后于某个阈值，则意味着数据位于缓存行中，攻击者进
而就可以通过从内核内存读取的数据推断出准确的内容。图8-6取自最早有关Meltdown的研究论文（详见https://
meltdownattack.com/），其中展示了1MB probe数组（由256个4KB的页组成）的访问时间。</span></p><div style="display: block;text-align:center;">
	<img width="704" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/9f35d74f987cba089877cf786bda61a5.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图8-6 访问一个1MB probe数组所需的CPU时间</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如图8-6所示，每个页面的访问时间都是类似的，只有一个页面的时间有较大差异。假设一次可读取1字节的机密数据，而1字节只能有256个值，那么只要准确得知数组中的哪个页面导致了缓存命中，攻击者就可以知道内核内存中到底存储了哪一字节的数据。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>S</b><b>p</b><b>e</b><b>c</b><b>t</b><b>r</b><b>e</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Spectre攻击与Meltdown攻击类似，意味着它也依赖上文介绍的乱序执行漏洞，但Spectre所利用的CPU组件主要为分支预测器和分支目标预测器。起初，Spectre攻击曾出现过两种变体，这两种变体都可以总结为如下三个阶段：</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）在设置阶段，攻击者会通过低特权（且由攻击者控制的）进程反复执行多次操作，误导CPU分支预测器，此举意在通过训练让CPU执行（合法的）条件分支或精心定义好的间接分支目标。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）在第二阶段，攻击者会迫使作为受害者的高特权应用程序（或上一阶段所使用的进程）以预测执行的方式执行错误预测分支中所包含的指令。这些指令通常会将机密信息从受害者应用程序的上下文中转移至微架构信道（通常为CPU缓存）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）在最终阶段，攻击者会通过低特权进程恢复存储在CPU缓存（微架构信道）中的敏感信息，为此攻击者会探测整个缓存（与Meltdown攻击的做法相同），借此即可获得本应在受害者高特权地址空间中受到保护的机密信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Spectre攻击的第一
个变体可通过迫使CPU分支预测器以预测执行的方式执行条件分支中错误的分支，进而获取存储在受害者进程地址空间（该地址空间可以是攻击者所控制的地址空
间，或不受攻击者控制的地址空间）中的机密信息。该分支通常是一个函数的一部分，这个函数会在访问内存缓冲区中所包含的某些非机密数据之前执行边界检查。
如果该缓冲区与某些机密数据相邻，并且攻击者控制了提供给分支条件的偏移量，攻击者即可反复训练分支预测器并提供合法的偏移量值，借此顺利通过边界检查并
让CPU执行正确的路径。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后，攻击者会准备一个精
心定义的CPU缓存（通过精心调整内存缓冲区大小，使得边界检查无法位于缓存中）并为实现边界检查分支的函数提供一个非法的偏移量。通过训练，CPU分支
预测器会始终沿用最初的合法路径，然而这一次的路径是错误的（此时本应选择其他路径）。因此访问内存缓冲区的指令会以预测执行的方式来执行，进而导致在边
界之外执行以机密数据为目标的读取操作。通过这种方式，攻击者即可探测整个缓存并读取机密数据（与Meltdown攻击的做法类似）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Spectre攻击的第二
个变体利用了CPU分支目标预测器，并会对间接分支投毒。通过这种方式，即可在攻击者控制的上下文中，借助间接分支错误预测的路径读取受害者进程（或操作
系统内核）的任意内存数据。如图8-7所示，对于变体2，攻击者会通过恶意目标对分支预测器进行误导性训练，使得CPU能在BTB中构建出足够的信息，进
而以乱序执行的方式执行位于攻击者所选择的地址中的指令。在受害者的地址空间内，该地址本应指向Gadget。Gadget是一组可以访问机密数据，并将
其存储在缓冲区（该缓冲区会以受控的方式进行缓存）中的指令（攻击者需要间接控制受害者一个或多个CPU寄存器的内容，如果API接受不可信的输入数据，
那么这种目的很好实现）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在攻击者完成对分支目标预
测器的训练后，即可刷新CPU缓存并调用由目标高特权实体（进程或操作系统内核）提供的服务。实现该服务的代码必须同时实现与攻击者控制的进程类似的间接
分支。随后，CPU分支目标预测器会以预测执行的方式执行位于错误目标地址中的Gadget。这与变体1和Meltdown攻击一样，会在CPU缓存中产
生微架构副作用，进而使其可以从低特权上下文中读取。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/2674ec4bf2d23e5d44ecfa055a06706c.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-7 Spectre攻击变体2的结构</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>其</b><b>他</b><b>侧</b><b>信</b><b>道</b><b>攻</b><b>击</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Spectre和Meltdown攻击一经曝光，就催生了多种类似的侧信道硬件攻击。与Meltdown和Spectre相比，虽然其他攻击方式的破坏性和影响范围并没有那么大，但我们依然有必要了解这类全新侧信道攻击所采用的整体方法。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">CPU性能优化措施所催生
的预测式存储旁路（Speculative Store 
Bypass，SSB），可以让CPU评估过的加载指令不再依赖之前所用的存储，而是能够在存储的结果退出前以预测执行的方式执行。如果预测错误，则可能
导致加载操作读取陈旧数据，其中很可能包含机密信息。读取到的数据可以转发给预测过程中执行的其他操作。这些操作可以访问内存并生成微架构副作用（通常位
于CPU缓存中）。借此攻击者即可衡量副作用并从中恢复机密信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Foreshadow（又名L1TF）是一种更严重的攻击，在设计上，这种攻击最初是为了从硬件隔区（SGX）中窃取机密数据，随后广泛应用于在非特权上下文中执行的普通用户模式软件。Foreshadow利用了现代CPU预测执行引擎中的两个硬件漏洞，分别如下：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
在不可访问的虚拟内存中进行预测。在本场景中，当CPU访问由页表项（Page Table 
Entry，PTE）所描述的虚拟地址中存储的某些数据时，如果未包含“存在”位（意味着该地址非有效地址），则将以正确的方式生成一个异常。然而，如果
该项包含有效地址转换，CPU就可以根据读取的数据预测执行指令。与其他所有侧信道攻击方式类似，处理器并不会重试这些指令，但会产生可衡量的副作用。在
这种情况下，用户模式应用程序即可读取内核内存中保存的机密数据。更严重的是，该应用程序在某些情况下还能读取其他虚拟机中的数据：当CPU转换客户物理
地址（Guest Physical Address，GPA）时，如果在二级地址转换（Second Level Address 
Translation，SLAT）表中遇到了不存在的项，就会产生相同的副作用（有关SLAT、GPA以及转换机制的详细信息，请参阅本书卷1第5章，
以及卷2第9章）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
在CPU内核的逻辑（超线程）处理器上进行预测。现代CPU的每个物理核心可以具备多条执行流水线，借此即可通过共享的执行引擎以乱序的方式同时执行多个
指令（这是一种对称多线程（Symmetric 
Multi-Threading，SMT）架构，详见第9章）。在这种处理器中，两个逻辑处理器（Logical 
Processor，LP）共享同一个缓存。因此，当一个LP在高特权上下文中执行某些代码时，对端的另一个LP即可读取这个LP的高特权代码执行过程中
产生的副作用。这会对系统的整体安全性造成极为严重的影响。与Foreshadow的第一个变体类似，在低特权上下文中执行攻击者代码的LP，甚至只需要
等待虚拟机代码通过调度由对端LP执行，即可窃取其他高安全性虚拟机中存储的机密信息。Foreshadow的这个变体属于一种Group 4漏洞。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">微架构副作用并非总是以
CPU缓存为目标。为了更好地访问已缓存和未缓存的内存并对微指令重新排序，Intel的CPU使用了其他中等级别的高速缓冲区（不同缓冲区的介绍已超出
本书范畴）。微架构数据采样（Microarchitectural Data Sampling，MDS）攻击可暴露下列微架构结构所包含的机密数据：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>存</b><b>储</b><b>缓</b><b>冲</b><b>区</b><b>（</b><b>s</b><b>t</b><b>o</b><b>r</b><b>e</b><b> </b><b>b</b><b>u</b><b>f</b><b>f</b><b>e</b><b>r</b><b>）</b></span>。在执行存储操作时，处理器会将数据写入一个名为存储缓冲区的内部临时微架构结构中，这样CPU就能在数据被真正写入缓存或主存（对于未缓存的内存访问）之前继续执行指令。当加载操作从与之前的存储相同的内存地址读取数据时，处理器可以从该存储缓冲区直接转发数据。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>填</b><b>充</b><b>缓</b><b>冲</b><b>区</b><b>（</b><b>f</b><b>i</b><b>l</b><b>l</b><b> </b><b>b</b><b>u</b><b>f</b><b>f</b><b>e</b><b>r</b><b>）</b></span>。
填充缓冲区是一种内部处理器结构，主要用于在一级数据缓存未命中（并且执行了I/O或特殊寄存器操作）时收集（或写入）数据。填充缓冲区在CPU缓存和
CPU乱序执行引擎之间充当了中介的作用，其中可能保留了上一个内存请求所涉及的数据，这些数据可能会以推测的方式转发给加载操作。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>加</b><b>载</b><b>端</b><b>口</b><b>（</b><b>l</b><b>o</b><b>a</b><b>d</b><b> </b><b>p</b><b>o</b><b>r</b><b>t</b><b>）</b></span>。加载端口是一种临时的内部CPU结构，主要用于从内存或I/O端口执行加载操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">微架构缓冲区通常属于单一CPU内核，但会被SMT线程共享。这意味着，即使难以通过可靠的方式对这些结构发起攻击，在特定情况下依然有可能跨越SMT线程，通过推测的方式从中提取机密数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">一般来说，所有硬件侧信道漏洞的后果都是相同的：可以从受害者地址空间中窃取机密数据。为了防范Spectre、Meltdown以及上文提到的其他各种侧信道攻击，Windows实现了多种缓解措施。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter08_0003.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_14" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>3</b><b> </b><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>中</b><b>的</b><b>侧</b><b>信</b><b>道</b><b>缓</b><b>解</b><b>措</b><b>施</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">本节简要介绍Windows如何通过各种缓解措施防范侧信道攻击。总的来说，某些侧信道缓解措施是由CPU制造商通过微码（microcode）更新实现的。然而，并非所有这类措施都始终可用，有些缓解措施需要由软件（Windows内核）启用。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_15" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>3</b><b>.</b><b>1</b><b> </b><b>K</b><b>V</b><b>A</b><b>影</b><b>子</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">内核虚拟地址影子
（kernel virtual address 
shadowing）也称KVA影子（在Linux的世界中称为KPTI，代表内核页表隔离，kernel page table 
isolation），可在内核与用户页表之间创建清晰的隔离，借此缓解Meltdown攻击。当处理器未以正确的特权级别访问时，预测执行使得CPU能
够获取到内核数据，但这要求在转换目标内核页的页表中存在一个有效的页帧编号。Meltdown攻击针对的内核内存通常会使用系统页表中有效的叶项
（leaf 
entry）进行转换，这意味着需要具备监管特权级别（有关页表和虚拟地址转换的介绍请参阅本书卷1第5章）。在启用KVA影子后，系统会为每个进程分配
并使用两个顶级页表：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·内核页表，用于映射整个进程地址空间（包括内核和用户页）。在Windows中，用户页会以不可执行的方式进行映射，这是为了防止内核代码执行以用户模式分配的内存（这类似于硬件SMEP提供的功能）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·用户页表（又名影子页表），只负责映射用户页以及最少量不包含任何机密信息的内核页，可用于为页表切换、内核栈提供最基本的功能，以及中断、系统调用和其他转换、陷阱的处理。这组内核页也叫过渡（transition）地址空间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在这个过渡地址空间中，
NT内核通常会映射一种名为KPROCESSOR_DESCRIPTOR_AREA的数据结构，该数据结构被包含在处理器的PRCB中，其中包含需要在用
户（或影子）和内核页表之间共享的数据，如处理器的TSS、GDT以及内核模式GS基址的副本。此外，该过渡地址空间还包括NT内核映
像“.KVASCODE”节下的所有影子陷阱处理程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当启用KVA影子的系统运
行非特权用户模式线程（如以非管理员特权级别运行）时，处理器并不会映射任何可能包含机密数据的内核页。因此Meltdown攻击将彻底失效，因为内核页
不再有效映射至进程的页表，并且任何以这些页为目标的CPU预测操作都无法继续进行。当用户进程使用系统调用，或当CPU在用户模式进程中执行代码的同时
遇到中断时，CPU会在过渡栈上构建一个陷阱帧，并按照上文所述的方式将其同时映射至用户和内核页表。随后CPU会执行影子陷阱处理程序的代码，借此处理
中断或系统调用。在处理系统调用时通常还需要切换至内核页表，复制内核栈中的陷阱帧，然后跳转至最初的陷阱处理程序（这意味着需要实现一种妥善的算法，以
便刷新TLB中陈旧的项。下文将详细介绍TLB刷新算法）。这样即可在映射了整个地址空间的情况下，执行最初的陷阱处理程序。</span></p>
</div><div class="header2"><h3><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>初</b><b>始</b><b>化</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在内核初始化第1阶段的早
期，当处理器功能位（feature 
bit）计算完毕后，NT内核会借助内部例程KiDetectKvaLeakage判断CPU是否会受到Meltdown攻击。该例程会获取处理器信息，
并将除Atom（一种有序处理器）外其他所有Intel处理器的内部变量KiKvaLeakage都设置为“1”。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内部变量
KiKvaLeakage设置完毕后，系统会通过KiEnableKvaShadowing例程启用KVA影子，并开始准备处理器的TSS和过渡栈。处理
器TSS的RSP0（内核）和IST栈会设置为指向相应的过渡栈。随后在基栈中写入一种名为KIST_BASE_FRAME的数据结构，借此让过渡栈（其
大小为512字节）做好准备。该数据结构使得过渡栈能够链接至自己的非过渡内核栈（只有在页表切换之后才能访问），如图8-8所示。请注意，常规的非
IST内核栈并不需要该数据结构。操作系统可以从CPU的PRCB中获取用户与内核模式切换所需的全部数据。每个线程都有对应的内核栈。当新线程被选中执
行后，调度器会将其内核栈链接至处理器的PRCB，以此激活该内核栈。这是内核栈与IST栈的一个重要差异，并且每个处理器中只存在一个IST栈。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/1024baab9cc06c2ca846f37021f5f5a8.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图8-8 KVA影子被激活后，CPU任务状态段（TSS）的配置情况</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">KiEnableKvaShadowing
例程还承担一个重要职责：确定适合的TLB刷新算法（下面将详细介绍）。而确定后的结果（全局项或PCID）会存储在全局变量
KiKvaShadowMode中。最后，对于非引导处理器，该例程会调用KiShadowProcessorAllocation在影子页表中映射每个
处理器的共享数据结构。对于BSP处理器，则会在初始化阶段1的后期，当SYSTEM进程及其影子页表均已成功创建（且IRQL已被降至被动级别）之后再
进行映射。只有在这种情况下，影子陷阱处理程序（全局的，且并非每个处理器专用的）才会映射至用户页表。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>影</b><b>子</b><b>页</b><b>表</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当进程的地址空间创建完成后，内存管理器将使用内部例程MiAllocateProcessShadow分配影子（或用户）页表。新进程的影子页表在创建好后内容为空。随后，内存管理器会将SYSTEM进程的所有内核影子顶级页表项复制到新进程的影子页表中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">借此，操作系统可快速将整
个过渡地址空间（位于内核中，被所有用户模式进程共享）映射给新进程。对于SYSTEM进程，影子页表依然为空，正如上一节所述，该页表将由
KiShadowProcessorAllocation例程填充，这个例程会使用内存管理器服务将特定的内存块映射至影子页表，并重建整个页面层次结
构。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内存管理器只会在特定情况
下更新影子页表，并且仅有内核可以写入映射或解除映射。当一个请求需要分配或映射新内存到用户进程地址空间时，可能会遇到特定地址的顶级页表项丢失的情
况。在这种情况下，内存管理器会分配整个页表层次结构的所有页面，并将新的顶级PTE存储在内核页表中。然而在启用KVA后，仅这样做还不够，内存管理器
还必须在影子页表中写入顶级PTE。否则在陷阱处理程序正确切换页表后，返回用户模式之前，该地址将无法出现在用户映射中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">相比内核页表，内核地址会
使用不同的方式映射至过渡地址空间。为防止错误地将与映射至过渡地址空间中的内存块距离太过接近的地址共享出来，内存管理器会始终为被共享的一个或多个
PTE重建页表层次结构映射。这也意味着当内核需要在进程的过渡地址空间中映射某些新页面时，都必须在所有进程的影子页表中重复进行该映射（该操作完全由
内部例程MiCopyTopLevelMappings负责）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>T</b><b>L</b><b>B</b><b>刷</b><b>新</b><b>算</b><b>法</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在x86架构中，切换页表
通常会导致刷新当前处理器的TLB（Translation Look-aside 
Buffer，转译后备缓冲区）。TLB是一种缓存，处理器会用它来快速转译在执行代码或访问数据时所用的虚拟地址。TLB中的有效项可以让处理器无须查
询页表链，因此可加快执行速度。在未启用KVA影子的系统中，TLB中用于转译内核地址的项无须显式刷新。在Windows中，内核地址空间在大部分情况
下是唯一的，并会被所有进程共享。Intel和AMD采用不同的技术来避免每次切换页表时刷新内核项，例如全局/非全局位和进程上下文标识符
（Process-Context 
Identifier，PCID）。Intel与AMD的架构手册中详细描述了TLB及其刷新方法，本书不再深入讨论。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通过使用CPU的新功能，
操作系统可以只刷新用户项，以此确保性能不受影响。但在启用KVA影子的情况下无疑是无法接受这种做法的，因为线程有义务切换页表，即使是在进入或退出内
核时。在启用KVA的系统中，Windows会借助一种算法确保只在必要时才明确刷新内核和用户TLB项，进而实现下列两个目标：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·在执行线程用户代码时，TLB中不维持任何有效的内核项。否则这些内核项可能被攻击者使用与Meltdown类似的推测技术所利用，进而读取机密的内核数据。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·在切换页表时，只刷新最少量的TLB项。这样可确保因启用KVA影子而导致的性能损失处于可接受范围内。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">TLB刷新算法主要应用于
这三个场景：上下文切换、进入陷阱以及退出陷阱。无论是只支持全局/非全局位，还是在此基础上还能支持PCID的系统，都可以运行该算法。对于只支持全
局/非全局位的系统，非KVA影子的配置将有所差异，其中所有内核页面都会标记为“非全局”，而过渡页和用户页会标记为“全局”。进行页表切换时，全局页
不会被刷新（系统会更改CR3寄存器的值）。对于支持PCID的系统，则会将内核页标记为PCID 2，并将用户页标记为PCID 
1。此时会忽略全局位和非全局位。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在当前执行的线程结束其量
程（quantum）时，将会初始化上下文切换。当内核被调度去执行隶属于其他进程地址空间的线程时，TLB算法会保证TLB中的所有用户页均已移出（这
意味着对于使用全局/非全局位的系统，需要进行一次彻底的TLB刷新，并且用户页会被标记为全局）。在内核退出陷阱（内核执行完代码返回用户模式）时，算
法会保证TLB中的所有内核项已被移出（或作废）。这一点很容易实现，在支持全局/非全局位的处理器上，只需重新加载页表即可迫使处理器将所有非全局页作
废；在支持PCID的系统中，用户页表会使用User PCID重新加载，进而让所有陈旧的内核TLB项自动作废。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">该策略允许内核进入陷阱，即系统正在执行用户代码时产生了中断，或线程使用了系统调用，此时TLB中的一切都不会作废。上述TLB刷新算法的方案如表8-1所示。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-1 KVA影子TLB刷新策略</span></p><div style="display: block;text-align:center;">
	<img width="793" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/411100907039b4a56f3c9008750287fd.jpg" alt="" title=""></div>
</div><div class="header2"><h3><span id="sigil_toc_id_16" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>3</b><b>.</b><b>2</b><b> </b><b>硬</b><b>件</b><b>间</b><b>接</b><b>分</b><b>支</b><b>控</b><b>制</b><b>（</b><b>I</b><b>B</b><b>R</b><b>S</b><b>、</b><b>I</b><b>B</b><b>P</b><b>B</b><b>、</b><b>S</b><b>T</b><b>I</b><b>B</b><b>P</b><b>、</b><b>S</b><b>S</b><b>B</b><b>D</b><b>）</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">处理器制造商也为不同的侧信道攻击设计了硬件层面的缓解措施。这些缓解措施在设计上能够与软件措施配合生效。有关侧信道攻击的硬件缓解措施主要通过下列间接分支控制机制来实现，具体采用何种机制通常是由CPU特殊模块寄存器（MSR）中的一位决定的。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>间</b><b>接</b><b>分</b><b>支</b><b>限</b><b>制</b><b>推</b><b>测</b><b>（</b><b>I</b><b>n</b><b>d</b><b>i</b><b>r</b><b>e</b><b>c</b><b>t</b><b> </b><b>B</b><b>r</b><b>a</b><b>n</b><b>c</b><b>h</b><b> </b><b>R</b><b>e</b><b>s</b><b>t</b><b>r</b><b>i</b><b>c</b><b>t</b><b>e</b><b>d</b><b> </b><b>S</b><b>p</b><b>e</b><b>c</b><b>u</b><b>l</b><b>a</b><b>t</b><b>i</b><b>o</b><b>n</b><b>，</b><b>I</b><b>B</b><b>R</b><b>S</b><b>）</b><b>：</b></span>可
在切换至不同安全上下文（用户/内核模式，或VM根/非根）时彻底禁用分支预测器（并刷新分支预测器缓冲区）。如果操作系统在过渡到更高特权的模式后设置
了IBRS，那么间接分支预测目标将无法继续被低特权模式下执行的软件所控制。此外，在启用IBRS后，间接分支预测目标将无法被其他逻辑处理器所控制。
操作系统通常会将IBRS设置为1，并在返回至较低特权安全上下文之前始终保持该设置。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">IBRS
的实现取决于CPU制造商：一些CPU会在启用IBRS后彻底禁用分支预测器缓冲区（这是一种禁止行为），而其他CPU可能只会刷新预测器的缓冲区（这是
一种刷新行为）。在这些CPU中，IBRS缓解措施的工作方式与IBPB的较为类似，因此这些CPU通常只会实现IBRS。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>间</b><b>接</b><b>分</b><b>支</b><b>预</b><b>测</b><b>器</b><b>屏</b><b>障</b><b>（</b><b>I</b><b>n</b><b>d</b><b>i</b><b>r</b><b>e</b><b>c</b><b>t</b><b> </b><b>B</b><b>r</b><b>a</b><b>n</b><b>c</b><b>h</b><b> </b><b>P</b><b>r</b><b>e</b><b>d</b><b>i</b><b>c</b><b>t</b><b>o</b><b>r</b><b> </b><b>B</b><b>a</b><b>r</b><b>r</b><b>i</b><b>e</b><b>r</b><b>，</b><b>I</b><b>B</b><b>P</b><b>B</b><b>）</b></span>：在设置为“1”后，会刷新分支预测器的内容，以此防止之前执行过的软件控制同一个逻辑处理器上的间接分支预测目标。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>单</b><b>线</b><b>程</b><b>间</b><b>接</b><b>分</b><b>支</b><b>预</b><b>测</b><b>器</b><b>（</b><b>S</b><b>i</b><b>n</b><b>g</b><b>l</b><b>e</b><b> </b><b>T</b><b>h</b><b>r</b><b>e</b><b>a</b><b>d</b><b> </b><b>I</b><b>n</b><b>d</b><b>i</b><b>r</b><b>e</b><b>c</b><b>t</b><b> </b><b>B</b><b>r</b><b>a</b><b>n</b><b>c</b><b>h</b><b> </b><b>P</b><b>r</b><b>e</b><b>d</b><b>i</b><b>c</b><b>t</b><b>o</b><b>r</b><b>，</b><b>S</b><b>T</b><b>I</b><b>B</b><b>P</b><b>）</b></span>：可对同一个物理CPU内核上不同逻辑处理器之间共享的分支预测进行限制。将逻辑处理器的STIBP设置为“1”后，可防止当前正在执行的逻辑处理器的间接分支预测目标被同一个内核中其他逻辑处理器上执行（或曾经执行过）的软件所控制。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>预</b><b>测</b><b>存</b><b>储</b><b>旁</b><b>路</b><b>禁</b><b>止</b><b>（</b><b>S</b><b>p</b><b>e</b><b>c</b><b>u</b><b>l</b><b>a</b><b>t</b><b>i</b><b>v</b><b>e</b><b> </b><b>S</b><b>t</b><b>o</b><b>r</b><b>e</b><b> </b><b>B</b><b>y</b><b>p</b><b>a</b><b>s</b><b>s</b><b> </b><b>D</b><b>i</b><b>s</b><b>a</b><b>b</b><b>l</b><b>e</b><b>，</b><b>S</b><b>S</b><b>B</b><b>D</b><b>）</b></span>：可以让处理器不以预测执行的方式加载，除非所有较旧的存储均处于已知状态。这样即可确保加载操作不会因为同一个逻辑处理器上较旧存储所产生的旁路，而以预测的方式使用陈旧的数据值，从而可防范预测性存储旁路攻击（详见上文“其他侧信道攻击”一节）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NT内核会使用一种复杂的
算法来确定上述间接分支限制机制的值，而这些值也会在上文有关KVA影子介绍中所提到的三个场景中产生相应的变化，这三个场景分别为上下文切换、进入陷阱
以及退出陷阱。在兼容的系统中，系统会在始终启用IBRS的情况下运行内核代码（除非启用了Retpoline）。如果没有可用的IBRS（但IBPB和
STIBP均可支持），内核将在启用STIBP的情况下运行，并在每次进入陷阱时（使用IBPB）刷新分支预测器缓冲区（这样，分支预测器就不会被用户模
式运行的代码或在其他安全上下文中运行的“同胞”线程所影响）。如果CPU支持SSBD，则SSBD会始终在内核模式中启用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">出于性能方面的考虑，用户
模式线程在执行时通常并不会启用硬件预测缓解措施，或只启用STIBP（取决于STIBP配对是否启用，详见下一节）。如果需要，则必须通过全局或每个进
程的预测执行功能手动启用针对预测性存储旁路攻击的防护。实际上，所有预测缓解措施均可通过全局注册表值
HKLM\System\CurrentControlSet\Control\Session Manager\Memory 
Management\FeatureSettings加以调整。这是一个32位掩码值，其中的每一位对应一个具体的设置。表8-2总结了不同的功能设置
及其含义。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-2 功能设置及其对应的值</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/8ed6d17baa18a7fdbaae2a508885282c.jpg" alt="" title=""></div>
</div><div class="header2"><h3><span id="sigil_toc_id_17" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>3</b><b>.</b><b>3</b><b> </b><b>R</b><b>e</b><b>t</b><b>p</b><b>o</b><b>l</b><b>i</b><b>n</b><b>e</b><b>和</b><b>导</b><b>入</b><b>优</b><b>化</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">硬件缓解措施会对系统性能
产生极大影响，因为在启用这些缓解措施后，CPU的分支预测器会受到限制甚至被彻底禁用。对游戏和关键业务应用程序来说，大幅度的性能下降往往是无法接受
的。用于防范Spectre的IBRS（或IBPB）可能是对性能产生最大影响的缓解措施。在内存屏障（memory 
fence）指令的帮助下，可以在不使用任何硬件缓解措施的情况下防范Spectre的第一个变体，例如x86架构中所用的LFENCE。这些指令会迫使
处理器在屏障本身建立完成之前不以预测执行的方式执行任何新操作，仅在屏障建立完成（并且在此之前的所有指令均已退出）后，处理器的流水线才会重新开始执
行（并预测）新的操作码（Opcode）。不过Spectre的第二个变体依然需要通过硬件缓解措施来预防，进而会因为IBRS和IBPB导致性能退化。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了解决这个问题，
Google的工程师设计了一种新颖的二进制修改技术，名为Retpoline。Retpoline代码序列如图8-9所示，可将间接分支从预测执行中隔
离出来。这样无须执行存在漏洞的间接调用，处理器可以跳转至一个安全控制序列，该序列可动态地修改栈，记录最终的预测，并通过“Return”操作抵达新
的目标。</span></p><div style="display: block;text-align:center;">
	<img width="892" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/49e0ff4b98dce128b19197aeb609ccca.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图8-9 x86 CPU的Retpoline代码序列</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在Windows中，
Retpoline是在NT内核里实现的，这样可通过动态值重定位表（Dynamic Value Relocation 
Table，DVRT），动态地为内核与外部驱动程序映像应用Retpoline代码序列。当内核映像使用Retpoline编译（通过兼容的编译器）
时，编译器会在映像的DVRT里为代码中存在的每个间接分支插入一个项，以此描述其地址和类型。执行该间接分支的操作码会照原样保存在最终的代码中，但会
被增加一个大小可变的填充（padding）。DVRT中的项包含NT内核动态修改间接分支的操作码所需的全部信息。这种架构确保了使用
Retpoline选项编译的外部驱动程序也可以在老版本操作系统中运行，为此只需跳过DVRT表中这些项的解析操作即可。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> DVRT的开发最初是为了支持内核ASLR（Address Space Layout Randomization，地址空间布局随机化，详见卷1第5章）。随后DVRT表通过扩展包含了Retpoline描述符。系统可以识别映像中所包含的DVRT表的版本。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在初始化的阶段1，内核将
检测处理器是否会受到Spectre攻击，如果系统可兼容并具备足够可用的硬件缓解措施，就会启用Retpoline并将其应用到NT内核映像和HAL。
RtlPerformRetpolineRelocationsOnImage例程会扫描DVRT，将表中每项所描述的间接分支替换为不容易受到预测攻
击，且以Retpoline代码序列为目标的直接分支。间接分支最初的目标地址会保存在一个CPU寄存器（AMD和Intel处理器的R10寄存器）中，
并通过一条指令覆盖写入由编译器生成的填充。Retpoline代码序列会存储在NT内核映像的RETPOL节中，为该节提供支撑的页面会映射至每个驱动
程序映像的结尾处。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">启动前，内部例程
MiReloadBootLoadedDrivers会将引导驱动程序物理迁移至其他位置，并为每个驱动程序的映像进行必要的修复（包括
Retpoline）。所有引导驱动程序、NT内核以及HAL映像都会被Windows加载器（Windows 
Loader）分配一块连续的虚拟地址空间，该空间不包含相关的控制区域，因此这些空间将不可分页。这意味着为这些映像提供支撑的内存将始终驻留，并且
NT内核可以使用同一个RtlPerformRetpolineRelocationsOnImage函数直接在代码中修改每个间接分支。如果启用了
HVCI，那么系统必须调用安全内核（Secure 
Kernel）以应用Retpoline（借助安全调用PERFORM_RETPOLINE_RELOCATIONS）。实际上，在这个场景中，驱动程序
的可执行内存会按照第9章介绍的安全内核写入执行限制措施加以保护，不允许任何形式的修改，仅安全内核可以进行修改。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 Retpoline和导入优化修复措施是由内核在PatchGuard（也叫内核补丁保护，Kernel Patch 
Protection，详见本书卷1第7章）初始化并提供一定程度的保护之前对引导驱动程序应用的。对于驱动程序和NT内核本身，修改受保护驱动程序的代
码节是一种非法操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">运行时驱动程序（详见本书
卷1第5章）由NT内存管理器负责加载，可创建出由驱动程序的映像文件支撑的节对象（section 
object）。这意味着为了跟踪内存节中的页面，需要创建一个控制区（包括原型PTE数组）。对于驱动程序节，一些物理页面最初被放入内存中只是为了验
证代码的完整性，随后就会被转移至备用表（standby 
list）中。当这样的节随后被映射并且驱动程序的页面被首次访问时，来自备用表（或来自备份文件）的物理页面会被页面错误处理程序按需进行具体化。
Windows会对原型PTE所指向的共享页面应用Retpoline。如果同一节同时也被用户模式的应用程序所映射，内存管理器就会新建一个私有页，并
将共享页面中的内容复制到私有页，借此重新恢复Retpoline（以及导入优化）的修复措施。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 一些较新的Intel处理器还会对“Return”指令进行预测。此类CPU将无法启用Retpoline，因为无法借此防范Spectre v2。在这种情况下，只能使用硬件缓解措施。增强型IBRS（一种新的硬件缓解措施）解决了IBRS的性能退化问题。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>R</b><b>e</b><b>t</b><b>p</b><b>o</b><b>l</b><b>i</b><b>n</b><b>e</b><b>位</b><b>图</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在Windows中实现
Retpoline的最初设计目标（局限）之一在于需要为混合环境（同时包含兼容和不兼容Retpoline的驱动程序）提供支持，并针对Spectre
 
v2提供整体性系统保护。这意味着不支持Retpoline的驱动程序应在启用IBRS（或在启用STIBP的情况下同时为内核项启用IBPB，详见“硬
件间接分支控制”一节）的情况下运行，其他驱动程序则可在不启用任何硬件预测缓解措施的情况下运行（此时可由Retpoline代码序列和内存屏障提供保
护）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了动态实现与老旧驱动程
序的兼容性，在初始化的阶段0过程中，NT内核会分配并初始化一个动态位图，以此跟踪组成整个内核地址空间的每个64KB内存块。在这种模型中，设置
为“1”的位代表64KB的地址空间块包含可兼容Retpoline的代码，反之则会设置为“0”。随后，NT内核会将代表HAL和NT映像（始终兼容
Retpoline）的地址空间对应的位设置为“1”。每次加载新的内核映像后，系统都会尝试为其应用Retpoline。如果能成功应用，那么
Retpoline位图中对应的位也会被设置为“1”。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Retpoline代码序
列还可进一步加入位图检查功能：每次执行间接分支时，系统会检查最初的调用目标是否位于可兼容Retpoline的模块中。如果检查通过（且相关位被设置
为“1”），则系统会执行Retpoline代码序列（见图8-9）并以安全的方式进入目标地址。否则（当Retpoline位图中的位被设置
为“0”时）将会初始化Retpoline退出序列。随后，当前CPU的PRCB会设置RUNNING_NON_RETPOLINE_CODE标记（用于
上下文切换），IBRS会被启用（或启用STIBP，取决于硬件配置），需要时会发出IBPB和LFENCE，并生成内核事件SPEC_CONTROL。
最后，处理器依然能以安全的方式进入目标地址（由硬件缓解措施提供所需的保护能力）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当线程量程终止且调度器选
择新线程后，调度器会将当前处理器的Retpoline状态（由是否出现RUNNING_NON_RETPOLINE_CODE标记来表示）保存在旧线程
的KTHREAD数据结构中。通过这种方式，当旧线程被选中再次执行（或发生了进入内核陷阱事件）时，系统就会知道自己需要重新启用所需的硬件预测缓解措
施，进而确保系统能够始终获得保护。</span></p>
</div><div class="header2"><h3><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>导</b><b>入</b><b>优</b><b>化</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">DVRT中的
Retpoline项还描述了以导入函数为目标的间接分支。DVRT会借助导入的控制传输项，使用指向IAT中正确项的索引来描述此类分支（IAT是指
Image Import Address 
Table，即映像导入地址表，这是一种由加载器编译的导入函数指针数组）。当Windows加载器编译了IAT后，其内容通常就不太可能发生变化了（但
存在一些罕见的例外情况）。如图8-10所示，其实并不需要将指向导入函数的间接分支转换为Retpoline分支，因为NT内核可以保证两个映像（调用
方和被调用方）的虚拟地址足够接近，可直接调用（不超过2GB的）目标。</span></p><div style="display: block;text-align:center;">
	<img width="830" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/bdc23187fb5e8aaa73d7c748f7cfe196.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图8-10 ExAllocatePool函数不同的间接分支</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">导入优化（import 
optimization，在内部通常称为“导入链接”）这项功能可使用Retpoline动态重定向，将指向导入函数的间接调用转换为直接分支。如果使
用直接分支将代码执行过程转向至导入函数，则无须应用Retpoline，因为直接分支不会受到预测攻击。NT内核会在应用Retpoline的同时应用
导入优化，虽然这两个功能可以单独配置，但为了正常生效，它们都用到了相同的DVRT项。借助导入优化，甚至在不会受到Spectre 
v2攻击的系统中，Windows也可以进一步获得性能提升（直接分支不需要任何额外的内存访问）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_18" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>3</b><b>.</b><b>4</b><b> </b><b>S</b><b>T</b><b>I</b><b>B</b><b>P</b><b>配</b><b>对</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在超线程（hyper-
thread）系统中，为保护用户模式代码免受Spectre 
v2攻击，系统至少会在启用了STIBP的情况下运行用户线程。在非超线程系统中则无须这样做：因为先前执行内核模式代码时已经启用了IBRS，此时已经
可以防止先前执行的用户模式线程进行预测。如果启用了Retpoline，当跨进程切换线程并且首次从内核陷阱返回时，就已经发出了所需的IBPB。这确
保了在执行用户线程代码前，CPU分支预测器缓冲区一定为空。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在超线程系统中启用
STIBP会导致性能退化，因此，默认情况下，用户模式线程的STIBP会被禁用，这会导致线程可能受到来自同胞SMT线程的预测攻击。终端用户可以通过
USER_STIBP_ALWAYS功能设置，或使用RESTRICT_INDIRECT_BRANCH_PREDICTION这个进程缓解选项为用户线
程手动启用STIBP（详见“硬件间接分支控制”一节）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上述场景并非最理想的。更
好的解决方案是通过STIBP配对机制来实现。STIBP配对是由I/O管理器在NT内核初始化的阶段1启用的（使用
KeOptimizeSpecCtrlSettings函数），但这需要满足一些条件。系统必须启用超线程，CPU需要支持IBRS和STIBP。此外，
只有非嵌套虚拟化环境或禁用Hyper-V的情况下才能支持STIBP配对（详见第9章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在STIBP配对场景中，
系统会为每个进程分配一个安全域标识符（存储在EPROCESS数据结构中），该标识符由一个64位数字表示。System安全域标识符（等于“0”）只
会分配给使用System或完整管理令牌运行的进程。Nonsystem安全域则会在进程创建时（由内部函数
PspInitializeProcessSecurit）按照如下规则分配：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果新建的进程未明确分配新的主令牌，那么它会从创建它的父级进程获得相同的安全域。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
如果新进程明确指定了新的主令牌（例如使用CreateProcessAsUser或CreateProcessWithLogon 
API），则会从内部符号PsNextSecurityDomain开始为新进程生成新的用户安全域ID。随后每生成一个新的域ID，其值都会增加（保证
了在系统运行全过程中不会产生冲突的安全域）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
请注意，进程最初创建完毕后，还可以使用NtSetInformationProcess 
API（以及ProcessAccessToken信息类）分配新的主令牌。为了让该API的操作成功实现，进程需要创建为挂起状态（其中未运行任何线
程）。至此，该进程依然具备最初的令牌并处于非冻结状态。新安全域则会按照上文介绍的规则进行分配。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全域还可以以手动方式分
配给属于同一组的不同进程。应用程序可以使用NtSetInformationProcess 
API以及ProcessCombineSecurityDomainsInformation类，将进程的安全域替换为同一组中其他进程的安全域。该
API可接收两个进程句柄，并在两个令牌都被冻结的情况下替换第一个进程的安全域，而这两个进程可以通过PROCESS_VM_WRITE和
PROCESS_VM_OPERATION访问权打开对方。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">STIBP配对机制的正常
生效离不开安全域。STIBP配对可将逻辑处理器（LP）与其“同胞”链接在一起（两者共享一个物理内核。本节内容中出现的LP和CPU这两个术语可互
换）。只有在本地CPU和远程CPU的安全域相同，或者两个LP中有一个闲置时，两个LP才会由STIBP配对算法（实现于内部函数
KiUpdateStibpPairing中）进行配对。这些情况下，两个LP都可以在不设置STIBP的情况下运行，并暗地受到预测执行保护（对相同安
全上下文中运行的同胞CPU进行此类攻击无法获得任何好处）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">STIBP配对算法实现于
KiUpdateStibpPairing函数中，其中包含一个完整的状态机。只有当CPU的PRCB中所存储的配对状态信息变得陈旧时，陷阱退出处理程
序才会调用该例程（会在系统退出内核模式开始执行用户模式线程时调用）。LP的配对状态主要会因为如下两个原因变得陈旧：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·NT调度器选择了在当前CPU上执行的新线程。如果新线程的安全域不同于旧线程，CPU的PRCB配对状态就会被标记为陈旧。随后STIBP配对算法会重新评估两者的配对状态。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·当同胞CPU脱离闲置状态时，它会请求远程CPU重新评估自己的STIBP配对状态。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">请注意，当LP在启用
STIBP的情况下运行代码时，可防范来自同胞CPU的预测。STIBP配对是基于相反概念开发的：启用STIBP的情况下执行LP时，可保证同胞CPU
能够防范来自自己的预测。这意味着当通过上下文切换进入不同的安全域时，完全不需要中断同胞CPU的执行，哪怕对方正在禁用STIBP的情况下运行用户模
式代码。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上述场景唯独不适用于这种
情况：调度器选择的VP调度线程（在启用根调度器的情况下为虚拟处理器提供支撑，详见第9章）隶属于VMMEM进程。这种情况下，系统会立刻向同胞线程发
送IPI以便更新其STIBP配对状态。实际上，运行客户端虚拟机代码的VP调度线程始终可以决定禁用STIBP，导致同胞线程（同样运行于STIBP禁
用的情况下）处于不受保护的状态。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>询</b><b>系</b><b>统</b><b>的</b><b>侧</b><b>信</b><b>道</b><b>缓</b><b>解</b><b>状</b><b>态</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">Windows
会使用原生API NtQuerySystemInformation，通过SystemSpeculationControl- 
Information和SystemSecureSpeculationControlInformation这两个信息类暴露侧信道缓解信息。很多工
具可利用该API向终端用户显示系统的侧信道缓解状态：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
由Matt 
Miller开发并由微软官方提供支持的PowerShell脚本SpeculationControl，这是一个开源工具，已发布至如下GitHub代
码库：https://github.com/microsoft/SpeculationControl。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·由亚历克斯·伊奥尼斯库（本书作者之一）开发的SpecuCheck工具，同样已开源并发布至如下GitHub代码库：https://github.com/ionescu007/SpecuCheck。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·由安德里亚·阿列维（本书作者之一）开发的SkTool，（在撰写本书时）已被纳入较新的Windows Insider版本中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">上
述三个工具都能提供大致相同的结果。但只有SkTool能够显示安全内核中实现的侧信道缓解措施（虚拟机监控程序和安全内核详见第9章）。在这个实验中，
我们将了解自己系统中启用了哪些缓解措施。请下载SpecuCheck并打开命令提示符窗口（在搜索框中输入cmd）执行该工具，随后应该能看到类似如下
的输出结果：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">SpecuCheck v1.1.1    --   Copyright(c) 2018 Alex Ionescu </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">https://ionescu007.github.io/SpecuCheck/ --   @aionescu </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">--------------------------------------------------------</span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Mitigations for CVE-2017-5754 [rogue data cache load] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">--------------------------------------------------------</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">[-] Kernel VA Shadowing Enabled:                       yes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     &gt; Unnecessary due lack of CPU vulnerability:    no </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     &gt; With User Pages Marked Global:                no </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     &gt; With PCID Support:                           yes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     &gt; With PCID Flushing Optimization (INVPCID):   yes </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Mitigations for CVE-2018-3620 [L1 terminal fault] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">[-] L1TF Mitigation Enabled:                           yes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     &gt; Unnecessary due lack of CPU vulnerability:    no </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     &gt; CPU Microcode Supports Data Cache Flush:     yes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     &gt; With KVA Shadow and Invalid PTE Bit:         yes </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">（为节省版面，上述输出结果已节略。）</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">此
外，也可下载最新的Windows 
Insider版本并尝试使用SkTool工具。在不添加任何命令行参数的情况下启动该工具后，默认即可显示虚拟机监控程序和安全内核的状态。要查看所有
侧信道缓解措施的状态，需要使用/mitigations这个命令行参数来调用该工具：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Hypervisor /Secure Kernel /Secure Mitigations Parser Tool 1.0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Querying Speculation Features... Success! </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   This system supports Secure Speculation Controls. </span></p>
</div><div class="header0"><h1><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h1></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">System Speculation Features. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Enabled: 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Hardware support: 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   IBRS Present: 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   STIBP Present: 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   SMEP Enabled: 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Speculative Store Bypass Disable (SSBD) Available: 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Speculative Store Bypass Disable (SSBD) Supported by OS: 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Branch Predictor Buffer (BPB) flushed on Kernel/User transition: 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Retpoline Enabled: 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Import Optimization Enabled: 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   SystemGuard (Secure Launch) Enabled: 0 (Capable: 0) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   SystemGuard SMM Protection (Intel PPAM /AMD SMI monitor) Enabled: 0 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Secure system Speculation Features. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   KVA Shadow supported: 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   KVA Shadow enabled: 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   KVA Shadow TLB flushing strategy: PCIDs </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Minimum IBPB Hardware support: 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   IBRS Present: 0 (Enhanced IBRS: 0) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   STIBP Present: 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   SSBD Available: 0 (Required: 0) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Branch Predictor Buffer (BPB) flushed on Kernel/User transition: 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Branch Predictor Buffer (BPB) flushed on User/Kernel and VTL 1 transition: 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   L1TF mitigation: 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Microarchitectural Buffers clearing: 1</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter08_0004.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_19" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>4</b><b> </b><b>陷</b><b>阱</b><b>调</b><b>度</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">中断和异常是一类会导致处
理器在常规控制流范围外执行代码的操作系统状况。硬件和软件都可能导致此类状况。陷阱（trap）是指在发生异常或中断时，处理器捕获执行中的线程并将控
制权转交到操作系统中固定位置的机制。在Windows中，处理器会将控制权转交给陷阱处理程序（trap 
handler），这是一种针对特定中断或异常的函数。图8-11展示了一些可能会激活陷阱处理程序的状况。</span></p><div style="display: block;text-align:center;">
	<img width="662" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/f0907cc5943d17dfdace4e67bb3e8fa5.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-11 陷阱调度</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内核会通过如下方式区分中
断和异常。中断（interrupt）是一种异步事件（可能会在任何时间发生），但通常与处理器正在执行的工作无关。中断主要由I/O设备、处理器时钟或
计时器生成的，可以启用（开启）或禁用（关闭）。作为对比，异常（exception）是一种同步状况，通常是在执行特定指令时产生的（对计算机检查的中
止是一种处理器异常，但这通常与指令的执行无关）。异常和中止有时也被称为错误（fault），如页面错误（page 
fault）或双重错误（double 
fault）。在相同条件下用相同数据再次运行程序可以重现异常。异常的常见范例包括内存访问冲突、某些调试器指令及“除以零”错误等。内核也会将系统服
务调用视为异常（不过从技术的角度来看，它们其实是系统陷阱）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">无论硬件或软件都可能产生异常和中断。例如，硬件问题可能造成总线错误异常，软件Bug可能导致“除以零”异常。同样，I/O设备也可产生中断，而内核本身也可能产生软件中断（如APC或DPC，下面将介绍它们）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">产生硬件异常或中断后，
x86和x64处理器首先会检查当前代码段（Code Segment，CS）是否位于CPL 
0或更低级别（即当前线程是在内核模式还是用户模式下运行）。如果线程已经运行在Ring 
0级别，则处理器会为当前栈存储（或推送）下列信息，这相当于进行了从内核到内核的过渡。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·当前处理器的标记（EFLAGS/RFLAGS）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·当前的代码段（CS）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·当前的程序计数器（EIP/RIP）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·可选：某些类型异常的错误代码。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当处理器实际在Ring 
3级别下运行用户模式代码时，首先会根据任务寄存器（Task 
Register，TR）查找当前的TSS，随后在x86系统中切换至SS0/ESP0，或在x64系统中直接切换至RSP0，这一过程已在“任务状态
段”中进行了介绍。随着处理器开始在内核栈上执行，它会首先存储之前的SS（用户模式值）和ESP（用户模式栈），随后存储从内核到内核过渡期间的其他相
同数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">存储这些数据可以获得双重
收益。首先，可以在内核栈中记录足够的计算机状态信息，以便在当前线程的控制流中返回最初的点位并继续执行，就好像什么事情都没有发生过。其次，由此操作
系统可以（根据保存的CS值）得知陷阱的来源，例如可以得知某个异常是来自用户模式代码还是内核系统调用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于处理器仅存储还原控制
流所必需的信息，计算机的其他状态（包括EAX、EBX、ECX、EDI等寄存器）均保存在陷阱帧中，这是Windows在线程的内核栈中分配的一种数据
结构。陷阱帧存储了线程的执行状态，属于线程完整上下文的超集，并包含额外的状态信息。若要查看其定义，可在内核调试器中使用dt 
nt!_KTRAP_FRAME命令，或下载Windows驱动程序开发包（WDK）并查看NTDDK.H头文件，其中包含相关定义及备注信息（有关线程
上下文的详细介绍请参阅本书卷1第5章）。内核会将软件中断作为硬件中断的一部分加以处理，或当线程调用与软件中断有关的内核函数时以同步的方式来处理。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">大部分情况下，在将控制权
转交给产生陷阱的其他函数之前或之后，内核会安装前端陷阱处理函数，并以此执行与陷阱有关的常规处理任务。举例来说，如果遇到设备中断，内核硬件中断陷阱
处理程序会将控制权转交给设备驱动程序为中断设备提供的中断服务例程（Interrupt Service 
Routine，ISR）。如果相关状况是由系统服务的调用所致，那么常规系统服务陷阱处理程序会将控制权转交给执行体中的特定系统服务函数。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在一些不常见的情形下，内
核还会收到本不应看到或处理的陷阱或中断。有时这些情况也叫虚假陷阱或非预期陷阱。陷阱处理程序通常会执行系统函数KeBugCheckEx，当内核检测
到有问题或错误的行为时，它会将计算机挂起，如果不检查这样的情况，则可能会导致数据出错。下一节将进一步详细介绍中断、异常以及系统服务调度。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_20" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>4</b><b>.</b><b>1</b><b> </b><b>中</b><b>断</b><b>调</b><b>度</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">硬件生成的中断通常源自那
些需要通知处理器自己何时需要服务的I/O设备。中断驱动的设备可以用重叠的方式集中处理I/O操作，以此让操作系统最大限度地充分利用处理器。当线程
向/从一个设备启动I/O传输后，即可在设备完成传输操作的过程中执行其他工作。当设备传输操作完成后，会向处理器发出中断，以便要求获得服务。指点设
备、打印机、键盘、磁盘驱动器以及网卡通常都属于中断驱动的设备。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统软件也可以产生中断。举例来说，内核产生软件中断以初始化线程调度，并以异步的方式打断线程的执行。内核还可以禁用中断，这样处理器就不会再遇到中断，但这种情况并不常见，通常只发生在一些关键时刻，如对中断控制器进行编程或调度异常时。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为响应设备中断，内核会安装中断陷阱处理程序。中断陷阱处理程序可以将控制权转交给处理该中断的外部例程（ISR），或者转交给响应该中断的内部内核例程。设备驱动程序会为设备中断的相关服务提供ISR，其他类型的中断则由内核提供中断处理例程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在下面几节我们将介绍硬件向处理器发出设备中断通知的方式、内核可支持的中断类型、设备驱动程序与内核交互的方式（这是中断处理工作的一部分）、内核可识别的软件中断（以及用于实现中断的内核对象）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>硬</b><b>件</b><b>中</b><b>断</b><b>处</b><b>理</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在Windows可支持的
硬件平台上，外部I/O中断将成为中断控制器（例如I/O高级可编程中断控制器，I/O Advanced Programmable 
Interrupt Controller，IOAPIC）的一种输入。随后控制器将打断一个或多个处理器的本地高级可编程中断控制器（Local 
Advanced Programmable Interrupt Controller，LAPIC），最终在输入线上中断处理器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">被中断的处理器会向控制器
查询全局系统中断向量（Global System Interrupt 
Vector，GSIV），GSIV有时会表现为一个中断请求（Interrupt 
Request，IRQ）编号。中断控制器可将GSIV转换为处理器中断向量，随后将该向量作为中断调度表（Interrupt Dispatch 
Table，IDT）这种数据结构的索引，IDT存储在CPU的IDT寄存器（即IDTR）中，可以为中断向量返回匹配的IDT项。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">根据IDT项所包含的信
息，处理器可以将控制转交给Ring 
0级别下运行的相应中断调度例程（这一进程的具体描述可参阅本节开头处），或者也可以使用一种名为中断门（interrupt 
gate）的进程，加载新的TSS并更新任务寄存器（TR）。对于Windows，在系统引导过程中，内核会向IDT中填充指针，这些指针指向部分专用内
核与HAL例程，它们与每个异常以及内部处理过的中断相对应。此外，还有一些指针会指向一种名为KiIsrThunk的形式转换（Thunk）内核例程，
借此处理第三方设备驱动程序可注册的外部中断。在x86和x64架构的处理器中，与中断向量0～31所关联的前32个IDT项是为处理器陷阱保留的，详见
表8-3的介绍。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-3 处理器陷阱</span></p><div style="display: block;text-align:center;">
	<img width="418" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/edd397f57d413c78c17056cc6abb9e76.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="413" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/27e5a8aa498ca0e014ecdf29702dd40c.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="415" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/9102dc905310f03d42d3675b6f787bc1.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">其余IDT项包含硬编码的
值（例如向量30～34始终用于与Hyper-V有关的VMBus中断）以及设备驱动程序、硬件、中断控制器与平台软件（如ACPI）协商获得的值。例
如，键盘控制器可能会在一个Windows系统中发出中断向量82，而在另一个系统中可能会发出中断向量67。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>6</b><b>4</b><b>位</b><b>I</b><b>D</b><b>T</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们可以使用调试器命令!idt查看IDT的内容，包括与Windows为中断（包括异常和IRQ）分配的陷阱处理程序相关的信息。在不包含任何标记的情况
下运行!idt命令，可以显示简化后的输出结果，其中仅包含已注册的硬件中断（在64位计算机上还会包含处理器陷阱处理程序）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">下列范例展示了在x64系统上运行!idt命令后看到的结果：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0: kd&gt; !idt </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Dumping IDT: fffff8027074c000 </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">00:     fffff8026e1bc700 nt!KiDivideErrorFault </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">01:     fffff8026e1bca00 nt!KiDebugTrapOrFault  Stack = 0xFFFFF8027076E000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">02:     fffff8026e1bcec0 nt!KiNmiInterrupt  Stack = 0xFFFFF8027076A000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">03:     fffff8026e1bd380 nt!KiBreakpointTrap </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">04:     fffff8026e1bd680 nt!KiOverflowTrap </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">05:     fffff8026e1bd980 nt!KiBoundFault </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">06:     fffff8026e1bde80 nt!KiInvalidOpcodeFault </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">07:     fffff8026e1be340 nt!KiNpxNotAvailableFault </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">08:     fffff8026e1be600 nt!KiDoubleFaultAbort  Stack = 0xFFFFF80270768000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">09:     fffff8026e1be8c0 nt!KiNpxSegmentOverrunAbort </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0a:     fffff8026e1beb80 nt!KiInvalidTssFault </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0b:     fffff8026e1bee40 nt!KiSegmentNotPresentFault </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0c:     fffff8026e1bf1c0 nt!KiStackFault </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0d:     fffff8026e1bf500 nt!KiGeneralProtectionFault </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0e:     fffff8026e1bf840 nt!KiPageFault </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">10:     fffff8026e1bfe80 nt!KiFloatingErrorFault </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">11:     fffff8026e1c0200 nt!KiAlignmentFault </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">12:     fffff8026e1c0500 nt!KiMcheckAbort  Stack = 0xFFFFF8027076C000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">13:     fffff8026e1c0fc0 nt!KiXmmException </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">14:     fffff8026e1c1380 nt!KiVirtualizationException </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">15:     fffff8026e1c1840 nt!KiControlProtectionFault </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">1f:     fffff8026e1b5f50 nt!KiApcInterrupt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">20:     fffff8026e1b7b00 nt!KiSwInterrupt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">29:     fffff8026e1c1d00 nt!KiRaiseSecurityCheckFailure </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">2c:     fffff8026e1c2040 nt!KiRaiseAssertion </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">2d:     fffff8026e1c2380 nt!KiDebugServiceTrap </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">2f:     fffff8026e1b80a0 nt!KiDpcInterrupt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">30:     fffff8026e1b64d0 nt!KiHvInterrupt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">31:     fffff8026e1b67b0 nt!KiVmbusInterrupt0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">32:     fffff8026e1b6a90 nt!KiVmbusInterrupt1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">33:     fffff8026e1b6d70 nt!KiVmbusInterrupt2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">34:     fffff8026e1b7050 nt!KiVmbusInterrupt3 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">35:     fffff8026e1b48b8 hal!HalpInterruptCmciService (KINTERRUPT fffff8026ea59fe0)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">b0:     fffff8026e1b4c90 ACPI!ACPIInterruptServiceRoutine (KINTERRUPT ffffb88062898dc0)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ce:     fffff8026e1b4d80 hal!HalpIommuInterruptRoutine (KINTERRUPT fffff8026ea5a9e0)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">d1:     fffff8026e1b4d98 hal!HalpTimerClockInterrupt (KINTERRUPT fffff8026ea5a7e0)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">d2:     fffff8026e1b4da0 hal!HalpTimerClockIpiRoutine (KINTERRUPT fffff8026ea5a6e0)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">d7:     fffff8026e1b4dc8 hal!HalpInterruptRebootService (KINTERRUPT fffff8026ea5a4e0)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">d8:     fffff8026e1b4dd0 hal!HalpInterruptStubService (KINTERRUPT fffff8026ea5a2e0)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">df:     fffff8026e1b4e08 hal!HalpInterruptSpuriousService (KINTERRUPT fffff8026ea5a1e0)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">e1:     fffff8026e1b8570 nt!KiIpiInterrupt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">e2:     fffff8026e1b4e20 hal!HalpInterruptLocalErrorService (KINTERRUPT fffff8026ea5a3e0)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">e3:     fffff8026e1b4e28 hal!HalpInterruptDeferredRecoveryService </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                         (KINTERRUPT fffff8026ea5a0e0) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fd:     fffff8026e1b4ef8 hal!HalpTimerProfileInterrupt (KINTERRUPT fffff8026ea5a8e0)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fe:     fffff8026e1b4f00 hal!HalpPerfInterrupt (KINTERRUPT fffff8026ea5a5e0) </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在执行上述实验的系统中，ACPI SCI ISR位于中断编号B0h。此外，我们还可以看到，中断14 (0Eh)对应了KiPageFault，由上文的介绍可知，这是一种预定义的CPU陷阱。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">另
外我们还会注意到，有些中断（尤其是1、2、8、12）的旁边有一个栈指针。这些栈指针对应了上文“任务状态段”中所介绍的陷阱，需要由专用的安全内核栈
来处理。通过转储IDT项，调试器可以得知这些栈指针的存在，而我们也可以使用dx命令并取消对IDT中某个中断向量的引用来达到相同的目的。虽然我们可
以从处理器的IDTR获得IDT，但其实也可以从内核的KPCR结构中获得，该结构在一个名为IdtBase的字段中有一个指向IDT的指针。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0: kd&gt; dx @$pcr-&gt;IdtBase[2].IstIndex </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">@$pcr-&gt;IdtBase[2].IstIndex : 0x3 [Type: unsigned short] </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0: kd&gt; dx @$pcr-&gt;IdtBase[0x12].IstIndex </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">@$pcr-&gt;IdtBase[0x12].IstIndex : 0x2 [Type: unsigned short] </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">将上述IDT值与上一个实验中转储的x64 TSS值进行比较，就会看到与该实验有关的可匹配的内核栈指针。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每个处理器都有自己的
IDT（由自己的IDTR所指向），因此必要时，不同的处理器可以运行不同的ISR。例如在多处理器系统中，每个处理器都能收到时钟中断，但只有一个处理
器可以更新系统时钟以响应此中断。不过所有的处理器都可以使用该中断来衡量线程量程，并在线程量程结束后发起重调度。类似地，有些系统配置可能需要由特定
的处理器来处理某些设备中断。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>可</b><b>编</b><b>程</b><b>中</b><b>断</b><b>控</b><b>制</b><b>器</b><b>架</b><b>构</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">传统x86系统依赖
i8259A可编程中断控制器（Programmable Interrupt Controller，PIC），这是一项源自早期IBM 
PC的标准。i8259A PIC仅适用于单处理器系统，且只包含8条中断线（interrupt line）。然而IBM 
PC体系结构还额外定义了一种名为Secondary的第二个PIC，其中断可通过多路传输（multiplexed）进入主PIC的一条中断线中。这样
总共就可以提供15个中断（7个位于主PIC，8个位于辅PIC，通过主PIC的第八条中断线进行多路传输）。由于PIC会通过如此奇特的方式处理8个以
上的设备，并且15个中断依然不太够用，以及受各种电气问题（很容易造成虚假的中断）以及单处理器支持本身存在局限的影响，所以现代系统逐渐淘汰了这种类
型的中断控制器，转而使用一种名为i82489高级可编程中断控制器（Advanced Programmable Interrupt 
Controller，APIC）的变体。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于APIC可适用于多处
理器系统，所以Intel与其他公司还定义了多处理器规范（Multiprocessor 
Specification，MPS），这适用于x86多处理器系统的设计标准且以APIC的使用为中心，并将连接外部硬件设备的I/O 
APIC（IOAPIC）与连接处理器内核的本地APIC（LAPIC）进行了集成。随着时间的推移，MPS标准被融入高级配置和电源接口
（Advanced Configuration and Power 
Interface，ACPI）中，这两个标准的首字母缩写如此相似纯属巧合。为了兼容单处理器操作系统以及在单处理器模式下启动多处理器系统的引导代
码，APIC支持一种PIC兼容模式，该模式可提供15个中断，并且中断只会被传递给主处理器。APIC架构如图8-12所示。</span></p><div style="display: block;text-align:center;">
	<img width="575" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/9e28ba59bb34f5dcfa6866a54cae9e19.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-12 APIC架构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，APIC包含
多个组件：一个负责从设备接收中断的I/O APIC，多个在总线上接收来自I/O 
APIC的中断并打断所关联处理器的本地APIC，以及一个将APIC信号转换为等价PIC信号且可兼容i8259A的中断控制器。由于系统中可能存在多
个I/O 
APIC，所以主板上通常会在它们以及处理器之间放置一定的核心逻辑。该逻辑负责实现中断路由算法，借此跨越多个处理器对设备中断的负载进行均衡，并充分
利用位置的毗邻性，将设备中断发送给刚刚处理过相同类型中断的同一个处理器。软件程序可以通过一种固定的路由算法对I/O 
APIC重编程，进而绕过这种芯片组逻辑。大部分情况下，Windows会用自己的路由逻辑对I/O 
APIC重编程以便支持各种功能（如中断路由控制），但设备驱动程序和固件也可以这样做。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">因为x64架构可兼容
x86操作系统，所以x64系统必须提供与x86相同的中断控制器。不过此时的一个重大差异在于，x64版本的Windows会拒绝在不包含APIC的系
统中运行，因为x64版Windows需要使用APIC实现中断控制，而x86版的Windows可同时支持PIC和APIC硬件。这种情况在
Windows 
8和Windows后续版本中有所变化，无论CPU架构如何，这些系统都只能在APIC硬件上运行。x64系统的另一个差异在于，APIC的任务优先级寄
存器（Task Priority Register，TPR）已经直接绑定至处理器的控制寄存器8（Control Register 
8，CR8）。包括Windows在内的现代操作系统会使用该寄存器存储当前软件中断优先级（在Windows中这叫IRQL），并在做出路由决策时告知
IOAPIC。下文很快将介绍有关IRQL处理的更多信息。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>P</b><b>I</b><b>C</b><b>和</b><b>A</b><b>P</b><b>I</b><b>C</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们可以分别使用内核调试器命令!pic和!apic查看单处理器系统的PIC配置以及多处理器系统的当前本地APIC。单处理器系统中的!pic命令输出
结果如下。请注意，即使在具备APIC的系统中，该命令依然可以生效，因为为了模拟老旧硬件，APIC系统始终包含相关联的等价PIC。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/7c80d806935cc67869db97d567c9e4e6.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
启用Hyper-V的系统中运行!apic命令的输出结果如下，从中可见，由于SINTI项的存在，此处引用了Hyper-V的综合中断控制器
（Synthetic Interrupt 
Controller，SynIC，详见第9章的介绍）。另外还请注意，在本地内核调试过程中，该命令可显示与当前处理器相关联的APIC，换句话说，也
就是在运行该命令时恰好用于运行调试器线程的任何一个处理器。如果要查看崩溃转储或远程系统，可以使用~命令，后跟想要查看的本地APIC所对应的处理器
编号。无论哪种情况，ID:标记旁边的编号都对应了我们想要查看的处理器。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; !apic </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Apic (x2Apic mode)  ID:1 (50014)  LogDesc:00000002  TPR 00 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">TimeCnt: 00000000clk  SpurVec:df  FaultVec:e2  error:0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Ipi Cmd: 00000000`0004001f  Vec:1F  FixedDel    Dest=Self    edg high </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Timer..: 00000000`000300d8  Vec:D8  FixedDel    Dest=Self    edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Linti0.: 00000000`000100d8  Vec:D8  FixedDel    Dest=Self    edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Linti1.: 00000000`00000400  Vec:00  NMI         Dest=Self    edg high </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sinti0.: 00000000`00020030  Vec:30  FixedDel    Dest=Self    edg high </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sinti1.: 00000000`00010000  Vec:00  FixedDel    Dest=Self    edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sinti2.: 00000000`00010000  Vec:00  FixedDel    Dest=Self    edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sinti3.: 00000000`000000d1  Vec:D1  FixedDel    Dest=Self    edg high </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sinti4.: 00000000`00020030  Vec:30  FixedDel    Dest=Self    edg high </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sinti5.: 00000000`00020031  Vec:31  FixedDel    Dest=Self    edg high </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sinti6.: 00000000`00020032  Vec:32  FixedDel    Dest=Self    edg high </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sinti7.: 00000000`00010000  Vec:00  FixedDel    Dest=Self    edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sinti8.: 00000000`00010000  Vec:00  FixedDel    Dest=Self    edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sinti9.: 00000000`00010000  Vec:00  FixedDel    Dest=Self    edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sintia.: 00000000`00010000  Vec:00  FixedDel    Dest=Self    edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sintib.: 00000000`00010000  Vec:00  FixedDel    Dest=Self    edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sintic.: 00000000`00010000  Vec:00  FixedDel    Dest=Self    edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sintid.: 00000000`00010000  Vec:00  FixedDel    Dest=Self    edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sintie.: 00000000`00010000  Vec:00  FixedDel    Dest=Self    edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sintif.: 00000000`00010000  Vec:00  FixedDel    Dest=Self    edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">TMR: 95, A5, B0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">IRR: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ISR: </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">Vec
后跟的各种编号代表了特定命令的IDT中所关联的向量。例如，在上述输出结果中，中断编号0x1F关联了中断处理器中断（Interrupt 
Processor 
Interrupt，IPI）向量，而中断编号0xE2负责处理APIC错误。再次查看上一个实验中!idt命令的输出结果将会发现，0x1F是内核的
APC中断（意味着刚刚使用了IPI从一个处理器向另一个处理器发送了APC），而0xE2当然就是HAL的本地APIC错误处理程序。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">下
列输出是!ioapic命令的运行结果，其中显示了I/O APIC的配置，以及连接到设备的中断控制器组件。例如，请留意GSIV/IRQ 
9（系统控制中断，System Control 
Interrupt，SCI）是如何关联到向量B0h的，而在上一个实验的!idt命令输出结果中，当时关联的是ACPI.SYS。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0: kd&gt; !ioapic </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Controller at 0xfffff7a8c0000898 I/O APIC at VA 0xfffff7a8c0012000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">IoApic @ FEC00000  ID:8 (11)  Arb:0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Inti00.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000      edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Inti01.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000      edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Inti02.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000      edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Inti03.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000      edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Inti04.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000      edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Inti05.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000      edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Inti06.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000      edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Inti07.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000      edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Inti08.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000      edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Inti09.: ff000000`000089b0  Vec:B0  LowestDl  Lg:ff000000      lvl high </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Inti0A.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000      edg high    m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Inti0B.: 00000000`000100ff  Vec:FF  FixedDel  Ph:00000000      edg high    m</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>软</b><b>件</b><b>中</b><b>断</b><b>请</b><b>求</b><b>级</b><b>别</b><b>（</b><b>I</b><b>R</b><b>Q</b><b>L</b><b>）</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然中断控制器会按照一定
的优先级顺序来执行中断，但Windows会强制实行自己的中断优先级方案，名为中断请求级别（Interrupt Request 
Level，IRQL）。在内部，内核会使用数字0～31（x86）或0～15（x64以及ARM/ARM64）代表IRQL，数字越大，中断优先级越
高。虽然内核为软件中断定义了一套标准的IRQL，但HAL会将硬件中断编号映射至这些IRQL。图8-13展示了为x86架构和x64（以及ARM/
ARM64）架构定义的IRQL。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e2c8ff1bf9aff5104762744793928408.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图8-13 x86和x64的中断请求级别（IRQL）</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">中断会按照优先级顺序获得
服务，较高优先级的中断可以抢占低优先级中断获得服务的机会。当发生高优先级中断后，处理器会保存被中断线程的状态，并调用与该中断关联的陷阱调度程序。
陷阱调度程序会提升IRQL并调用中断的服务例程。该服务例程执行完毕后，中断调度程序会将处理器的IRQL降低为该中断发生之前的级别，随后加载保存的
计算机状态。被中断的线程可以从之前断掉的地方恢复执行。当内核降低IRQL时，之前被遮蔽的低优先级中断可能会被具体化（materialize）。如
果发生这种情况，内核会重复执行该过程来处理新中断。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">IRQL优先级与线程调度
优先级（详见本书卷1第5章）有着截然不同的含义。调度优先级是线程本身的一种属性，而IRQL是中断来源（如键盘或鼠标）的一种属性。此外，每个处理器
都有一个会随操作系统代码执行而改变的IRQL设置。正如上文所述，在x64系统中，IRQL会存储在CR8寄存器中，后者会映射回APIC的TPR上。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每个处理器的IRQL设置
决定了处理器可以接收哪些中断。IRQL还可用于对内核模式数据结构进行同步访问（下面将详细介绍同步）。当内核模式线程运行时，会调用
KeRaiseIrql和KeLowerIrql直接提升或降低处理器的IRQL，或者更常见的做法是通过调用获取内核同步对象的函数来间接更改
IRQL。如图8-14所示，如果中断来源的IRQL高于当前级别，则这种中断会打断处理器的执行；而如果中断来源的IRQL等于或低于当前级别，那么在
有执行线程低于该IRQL之前，此类中断会被遮蔽。</span></p><div style="display: block;text-align:center;">
	<img width="848" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/2b2a3f4988325da665672a546fc0a22f.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-14 中断的遮蔽</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">根据所要执行的操作，内核
模式线程可以提高或降低自己运行所在处理器的IRQL。例如，当发生中断后，陷阱处理程序（或者也可能是处理器本身，这取决于具体架构）会将处理器的
IRQL提升至中断来源所分配的IRQL。这种提升会使得（仅这一个处理器上）所有等于或低于该IRQL的中断被遮蔽，这样即可确保处理器对高IRQL中
断提供的服务不会被同级或更低级别的中断拦截。被遮蔽的中断可以被其他处理器处理，或一直等待，直到IRQL降低。因此系统中的所有组件（包括内核和设备
驱动程序）都会尽可能地保持IRQL为被动级别（有时也叫低级别）。这样做是因为，即使IRQL在很长时间里没能保持非必要的提升状态，设备驱动程序也可
以及时响应硬件中断。因此，当系统没有执行任何中断工作（或需要与中断同步）或处理诸如DPC或APC等软件中断时，IRQL可以始终为“0”。很明显，
这也适用于所有用户模式的处理，因为允许用户模式代码碰触IRQL可能会对系统运行产生极大影响。实际上，以大于0的IRQL返回到用户模式线程会导致系
统立即崩溃（BugCheck），对驱动程序来说这是一种非常严重的Bug。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后请注意，调度程序自身
是以IRQL 2级别运行的（例如，因为抢占而从一个线程上下文切换至另一个线程），因此才有了“调度级别”（dispatch 
level）的概念，意味着处理器在这个级别以及更高级别上将表现为类似单线程合作运行的工作方式。然而此时的一些做法是非法的，例如，等待处于这种
IRQL的调度程序对象（有关该话题的详情请参阅下文“同步”一节），因为通过上下文切换进入另一个线程（或Idle线程）的情况永远不会发生。另一个限
制在于，仅未分页的内存可以在DPC/Dispatch级别或更高IRQL级别上访问。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这一规则实际上属于第一个
限制所产生的副作用，因为试图访问非常驻内存的操作会导致页面错误。当发生页面错误时，内存管理器会发起磁盘I/O操作，随后需要等待文件系统驱动程序从
磁盘中读取页面内容。进而，这个等待过程需要调度器执行上下文切换（如果没有别的用户线程等待运行，也许会切换至Idle线程），而这就违反了“调度器无
法被调用”这一规则（因为在读取磁盘时，IRQL依然处于DPC/Dispatch级别或更高级别）。进一步还会导致另一个问题：I/O完成操作通常发生
在APC_LEVEL，即使有时并不需要等待，I/O也永远无法完成，因为真正需要“完成”的APC根本没有机会运行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果违反上述两个限制中的
任何一个，系统会崩溃并显示IRQL_NOT_LESS_OR_EQUAL或DRIVER_IRQL_NOT_LESS_OR_EQUAL崩溃代码（有关
系统崩溃的详细讨论请参阅第10章）。违反这些限制是设备驱动程序最常见的Bug之一。Windows驱动程序验证器（Windows driver 
verifier）提供了一个选项，可以帮助我们查找这种类型的Bug。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">反之，这也意味着当运行在
IRQL 1（也叫APC级别）时，依然可以进行抢占或上下文切换。这使得IRQL 
1的行为结果在本质上更像是一种线程本地IRQL而非处理器本地IRQL，因为在IRQL 
1上执行的等待或抢占操作会导致调度器将当前IRQL保存到线程的控制块（位于KTHREAD结构中，详见本书卷1第5章）中，并将处理器的IRQL还原
为新执行线程的IRQL。这意味着处于被动级别（IRQL 0）的线程依然可以抢占运行在APC级别（IRQL 1）的线程，因为在IRQL 
2以下的级别中，是由调度器来决定由哪个线程控制处理器的。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>I</b><b>R</b><b>Q</b><b>L</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以使用调试器命令!irql查看处理器已保存的IRQL。已保存的IRQL代表调试器进入之前那一刻的IRQL，在这之后，IRQL将提升至一个静态且无实际意义的值：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">kd&gt; !irql </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Debugger saved IRQL for processor 0x0 -- 0 (LOW_LEVEL) </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请
注意，IRQL值会保存在两个位置。第一个位置是处理器控制区（Processor Control 
Region，PCR），其中所存储的值代表当前的IRQL；第二个位置是PCR的扩展，即处理器区控制块（Processor Region 
Control 
Block，PRCB），其中包含了DebuggerSavedIRQL字段中已保存的IRQL。使用这种保存方式的原因在于，远程内核调试器的使用会将
IRQL升高至HIGH_LEVEL，以便在用户调试计算机时阻止所有异步的处理器操作，因为这种操作会导致!irql命令的输出结果变得毫无意义。因此
会使用这种“保存”的值代表调试器连接之前那一刻的IRQL。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">每
个中断级别都有具体的用途。例如，内核会发出处理器间中断（Inter-processor 
Interrupt，IPI）来请求另一个处理器执行某操作，如调度要执行的特定线程，或者更新自己的转译后备缓冲区（TLB）缓存。系统时钟会以固定间
隔生成中断，内核通过更新时钟并衡量线程执行时间作为对此的响应。HAL为中断驱动的设备提供了中断级别，而具体数字取决于处理器和系统配置。内核会使用
软件中断（详见本章下文）来发起线程调度，并以异步方式打断线程的执行。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>将</b><b>中</b><b>断</b><b>向</b><b>量</b><b>映</b><b>射</b><b>至</b><b>I</b><b>R</b><b>Q</b><b>L</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在非APIC架构的系统
中，GSIV/IRQ与IRQL之间的映射必须非常严格。为避免一些情况下中断控制器可能认为某个中断线的优先级比其他中断线更高，在Windows的世
界里，IRQL其实会反映一种相反的情况。好在凭借APIC，Windows可以轻松地通过APIC的TPR暴露这些IRQL，这些IRQL随后可被
APIC用于做出更完善的交付决策。此外，在APIC系统中，每个硬件中断的优先级并不会绑定至自己的GSIV/IRQ，而是会绑定至中断向量，具体来
说，会将向量中较高的4位重新映射为优先级。由于IDT中最多可包含256个项，因此就可以产生16个可能的优先级（例如向量0x40可以代表优先级
4），这与TPR可以保存的16个数字相同，这些数字也可以重新映射至Windows所实现的相同的16个IRQL！</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">因此，Windows为了
判断要为某个中断分配哪个IRQL，首先必须判断该中断对应的中断向量，并对IOAPIC进行编程，以便相关的硬件GSIV使用该向量。或者反过来看，如
果硬件设备需要某个特定的IRQL，Windows必须选择一个能重新映射至该优先级的中断向量。这些决策是由即插即用管理器与一种名为“总线驱动程
序”的设备驱动程序配合做出的，借此可确定总线上所连接的设备（PCI、USB设备等）以及要为每个设备分配的中断。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">总线驱动程序会将这些信息
上报至即插即用管理器，后者在权衡过所有其他设备可接受的中断分配情况后，决定具体为每个设备分配哪个中断。随后，即插即用管理器会调用一个即插即用中断
仲裁程序（Arbiter），借此将中断映射至IRQL。该仲裁程序由HAL（Hardware Abstraction 
Layer，硬件抽象层）暴露，同时也需要与ACPI总线驱动程序及PCI总线驱动程序配合，共同决定相应的映射关系。大多数情况下，会通过轮询的方式选
择最终的向量编号，因此无法通过计算的方式预先得知该编号。本节稍后的一个实验将展示调试器如何通过中断仲裁程序查询这些信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了与硬件中断相关的仲裁中断向量，Windows还有一系列预定义的中断向量（见表8-4），这些向量在IDT中始终具备相同的索引。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-4 预定义的中断向量</span></p><div style="display: block;text-align:center;">
	<img width="335" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/278696fa7b2cf2c0e08aff2350b404cf.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="335" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3bbc87d9362172df2b6b18de1d3b9e31.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="334" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/f7fed78a2df7795e87384dd9a5875ff1.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通过表8-4可知，这些向
量编号的优先级（上文曾经提到，优先级信息存储在较高的4位或半字节（Nibble）中）通常会与图8-14中所示的IRQL保持匹配，例如APC中断为
1，DPC中断为2，IPI中断为14，Profile中断为15。关于这个话题，下面一起看看在现代Windows系统中这些预定义的IRQL分别是什
么。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>预</b><b>定</b><b>义</b><b>的</b><b>I</b><b>R</b><b>Q</b><b>L</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">接下来一起详细看看这些预定义的IRQL的使用，首先从图8-13中所示的最高级别开始：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
通常只有在内核将系统停止于KeBugCheckEx状态并对所有中断进行屏蔽（masking 
out）或连接了远程内核调试器的情况下，才会使用高级别。在非x86系统中，Profile级别共享了相同的值，在启用该功能的情况下，Profile
计时器也是在该级别下运行的。Performance中断（与如Intel Processor Trace，即Intel 
PT及其他硬件性能监视单元，即PMU功能有关）也运行在该级别下。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Interprocessor
 interrupt级别可用于请求另一个处理器执行某个操作，如更新处理器的TLB缓存或修改所有处理器的控制寄存器。Deferred 
Recovery Service（DRS）级别也共享了相同的值，在x64系统中，Windows Hardware Error 
Architecture（WHEA，Windows硬件错误架构）会使用该级别从某些机器检查错误（Machine Check 
Errors，MCE）中恢复。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Clock级别被系统时钟所使用，内核可借此跟踪时间，并为线程衡量和分配CPU时间。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Synchronization IRQL供调度程序和调度器代码内部使用，借此保护全局线程调度和等待/同步代码的访问过程。通常，该级别会被定义为Device IRQL之下最高的级别。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Device IRQL可用于对设备中断划分优先级（有关硬件中断级别映射至IRQL的具体方法请参阅上一节）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·当CPU或固件通过机器检查错误（MCE）接口上报了严重但已纠正的硬件状况后，可通过Corrected machine check interrupt级别向操作系统发出信号。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·DPC/Dispatch级别和APC级别的中断是内核与设备驱动程序生成的软件中断（下文将详细介绍DPC和APC）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Passive级别是最低的IRQL，严格来说，该级别并非真正的中断级别，而是一种设置，常规线程可在该设置下执行并产生所有其他中断。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>中</b><b>断</b><b>对</b><b>象</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内核提供了一种可移植机制
（一种名为中断对象的内核控制对象，即KINTERRUPT），设备驱动程序可借此为自己的设备注册ISR。中断对象包含了内核将设备ISR关联至特定硬
件中断所需的全部信息，如ISR的地址、中断的极性（polarity）和触发器模式、设备中断所处的IRQL、共享状态、GSIV和其他中断控制器数
据，以及性能统计信息的主机。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这些中断对象是从一个通用
内存池分配的，当设备驱动程序（通过IoConnectInterrupt或IoConnectInterruptEx）注册中断时，其中一个中断对象会
被初始化所有的必要信息。基于有资格接收该中断（由设备驱动程序指定的中断相关性决定该资格）的处理器编号，每个有资格的处理器将会分配到一个
KINTERRUPT对象，通常来说，这包括计算机上的每个处理器。随后，当选择了中断向量后，每个有资格的处理器的KPRCB中会有一个数组（名为
InterruptObject）被更新，借此即可指向专为该处理器分配的KINTERRUPT对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">KINTERRUPT分配
完成后，系统会检查和验证所选中断向量是否为可共享的向量；如果可共享，还会检查是否有现有的KINTERRUPT已经声明了该向量。如果已声明，内核会
更新（KINTERRUPT数据结构的）DispatchAddress字段，使其指向KiChainedDispatch函数，并将这个
KINTERRUPT添加到第一个已与该向量关联的现有KINTERRUPT所包含的链表（InterruptListEntry）中。但如果是专用向
量，则会使用KiInterruptDispatch函数。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">中断对象还存储了与中断有
关的IRQL，这样KiInterruptDispatch或KiChainedDispatch就可以在调用ISR之前将IRQL提升至正确的级别，并
在ISR返回后降低IRQL。这个包含两个步骤的过程是必需的，因为初始调度是通过硬件执行的，因此无法在初始调度上传递指向中断对象或其他参数的指针。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当中断发生时，IDT会指
向KiIsrThunk函数的256个副本之一，每个副本都有一个不同的汇编代码行负责推送内核栈上的中断向量（因为该向量并非由处理器提供的），随后调
用一个共享的KiIsrLinkage函数执行后续处理工作。此外，按照上文介绍，该函数还会构建相应的陷阱帧，并最终调用存储在KINTERRUPT中
的调度地址（上述两个函数之一）。这个函数会读取当前KPRCB的InterruptObject数组以查找KINTERRUPT，并将栈上的中断向量用
作索引进而取消对匹配指针的引用。如果KINTERRUPT不存在，那么该中断会被视为非预期中断。根据注册表
HKLM\SYSTEM\CurrentControlSet\Control\Session 
Manager\Kernel键下BugCheckUnexpectedInterrupts的值，系统可能会因KeBugCheckEx而崩溃，或者中
断会被悄然忽略，执行过程会恢复至原始控制点。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在x64 
Windows系统中，内核会使用特定例程来优化中断调度，这些例程通过忽略不需要的功能进而节省处理器运行周期。例如为没有关联内核管理自旋锁的中断
（此类中断通常被希望与ISR保持同步的驱动程序所用）使用KiInterruptDispatchNoLock例程，为不希望使用ETW性能跟踪的中断
使用KiInterruptDispatchNoLockNoEtw例程，为激活之后无须发送“中断终止”信号的虚假中断使用
KiSpuriousDispatchNoEOI例程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后，还可以为将APIC
设置为Auto-End-of-Interrupt（Auto-EOI）模式的中断使用KiInterruptDispatchNoEOI例程，因为中断
控制器会自动发送EOI信号，内核无须额外的代码来亲自执行EOI。例如，很多HAL中断例程会利用“无锁”调度代码，因为HAL无须内核与自己的ISR
保持同步。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">另一个内核中断处理程序是
KiFloatingDispatch，它可用于需要保存浮点状态的中断。内核模式代码通常不允许使用浮点（MMX、SSE、3DNow!）操作，因为这
些寄存器无法跨越上下文切换过程保存，ISR可能需要使用这些寄存器（例如显卡ISR执行快速绘图操作）。连接中断时，驱动程序可将
FloatingSave参数设置为TRUE，进而请求内核使用浮点调度例程来保存浮点寄存器（但这会大幅增加中断延迟）。请注意，仅32位系统支持此做
法。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">无论使用哪个调度例程，最
终都需要调用KINTERRUPT中的ServiceRoutine字段，这里存储了驱动程序的ISR。或者对于下文即将介绍的消息信号中断
（Message Signaled 
Interrupt，MSI），作为指向KiInterruptMessageDispatch的指针，随后可由该中断调用KINTERRUPT中的
MessageServiceRoutine指针。请注意，在某些情况下，例如处理内核模式驱动程序框架（Kernel Mode Driver 
Framework，KMDF）驱动程序或处理基于NDIS或StorPort等某些微型端口（Miniport）驱动程序时（有关驱动程序框架的详情请
参阅本书卷1第6章），可能需要用到这些框架或端口驱动程序特定的例程，由这些例程在最终调用底层驱动程序之前执行进一步的处理工作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图8-15展示了与中断对象有关的中断所包含的典型中断控制流。</span></p><div style="display: block;text-align:center;">
	<img width="865" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b7e6b97fa50209c92be205b25a78b93a.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-15 典型的中断控制流</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">将ISR与特定中断级别进
行关联的过程也称“连接中断对象”，而将ISR与IDT分离的过程称为“断开中断对象”。这些操作需要通过调用内核函数
IoConnectInterruptEx和IoDisconnectInterruptEx来完成，可供设备驱动程序在载入系统时“开启”ISR，并在
卸载驱动程序时“关闭”ISR。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，使用中断对象
注册ISR可防止设备驱动程序无谓地直接与中断硬件交互（具体方式因不同处理器架构而异），并且无须了解有关IDT的任何细节。内核的这一功能有助于开发
可移植的设备驱动程序，因为该功能使得我们无须使用汇编语言开发驱动程序代码，也无须在设备驱动程序代码中考虑不同处理器的差异。中断对象还提供了其他好
处。通过使用中断对象，内核可将ISR的执行过程与设备驱动程序中可能需要与ISR共享数据的其他部分保持同步（有关设备驱动程序如何响应中断的详细信息
请参阅本书卷1第6章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上文还提到了链式调度
（chained 
dispatch）的概念，该功能使得内核能够非常轻松地为任何中断级别调用多个ISR。如果多个设备驱动程序创建了中断对象并将其连接到同一个IDT
项，在特定中断线发生中断后，KiChainedDispatch例程可调用每一个ISR。借此内核即可轻松地支持菊花链式（daisy-chain）配
置，让多个设备共享同一个中断线。当任何一个ISR向中断调度程序返回一种状态，借此声明中断的所有权后，这种链便会断开。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果共享同一个中断的多个
设备同时需要服务，那么无法通过ISR确认的设备会在中断调度程序降低IRQL后再次中断系统。只有在所有希望使用同一个中断的设备驱动程序告知内核自己
可以共享中断（这种情况可由KINTERRUPT对象中的ShareVector字段来代表）的情况下，才允许创建链式配置；如果无法共享中断，即插即用
管理器会重新调整它们的中断分配情况，以保证中断的分配符合每个驱动程序有关共享的要求。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>中</b><b>断</b><b>的</b><b>内</b><b>部</b><b>机</b><b>理</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们可以通过内核调试器查看中断对象的内部细节，包括其IRQL、ISR地址以及自定义中断分发代码。首先请执行调试器命令!idt以检查能否找到一个引用
了I8042KeyboardInterruptService的项，这是适用于PS2键盘设备的ISR例程。此外，也可以查看指向
Stornvme.sys或Scsiport.sys，或者指向我们可识别的其他任何第三方驱动程序的项。在Hyper-V虚拟机中则可以直接使用
Acpi.sys项。具备PS2键盘设备项的系统会显示如下结果：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">70:    fffff8045675a600 i8042prt!I8042KeyboardInterruptService (KINTERRUPT </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffff8e01cbe3b280)</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">运行dt命令后，可以直接点击调试器提供的链接查看该中断所关联的中断对象的内容，或者也可以手动使用<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>d</b><b>x</b></span>命令查看。本次实验中所用计算机上的KINTERRUPT内容如下所示：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">6: kd&gt; dt nt!_KINTERRUPT ffff8e01cbe3b280 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x000 Type             : 0n22 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x002 Size             : 0n256 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x008 InterruptListEntry :_LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x018 ServiceRoutine   : 0xfffff804`65e56820 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                             unsigned char i8042prt!I8042KeyboardInterruptService</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x020 MessageServiceRoutine : (null) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x028 MessageIndex     : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x030 ServiceContext   : 0xffffe50f`9dfe9040 Void </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x038 SpinLock         : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x040 TickCount        : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x048 ActualLock       : 0xffffe50f`9dfe91a0 -&gt; 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x050 DispatchAddress  : 0xfffff804`565ca320 void nt!KiInterruptDispatch+0</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x058 Vector           : 0x70 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x05c Irql             : 0x7 '' </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x05d SynchronizeIrql  : 0x7 '' </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x05e FloatingSave     : 0 '' </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x05f Connected        : 0x1 '' </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x060 Number           : 6 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x064 ShareVector      : 0 '' </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x065 EmulateActiveBoth : 0 '' </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x066 ActiveCount      : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x068 InternalState    : 0n4 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x06c Mode             : 1 ( Latched ) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x070 Polarity         : 0 ( InterruptPolarityUnknown ) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x074 ServiceCount     : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x078 DispatchCount    : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x080 PassiveEvent     : (null) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x088 TrapFrame        : (null) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x090 DisconnectData   : (null) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x098 ServiceThread    : (null) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x0a0 ConnectionData   : 0xffffe50f`9db3bd90_INTERRUPT_CONNECTION_DATA </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x0a8 IntTrackEntry    : 0xffffe50f`9d091d90 Void </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x0b0 IsrDpcStats      :_ISRDPCSTATS </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x0f0 RedirectObject   : (null) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x0f8 Padding          : [8] "" </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">本例中，Windows为该中断分配的IRQL为7，这与中断向量0x70是一致的（该向量的高4位为7）。此外，我们可从DispatchAddress字段中看到这是一个常规的KiInterruptDispatch样式中断，不包含额外优化或共享。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如
果想查看该中断关联了哪个GSIV（IRQ），此时可通过两种方式实现。首先，新版Windows会将该数据以
INTERRUPT_CONNECTION_DATA结构嵌入KINTERRUPT的ConnectionData字段，具体情况可参阅上一个命令的输出
结果。此外，我们也可以使用<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>d</b><b>t</b></span>命令从自己的系统中转储指针，方法如下：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">6: kd&gt; dt 0xffffe50f`9db3bd90_INTERRUPT_CONNECTION_DATA Vectors[0].. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">nt!_INTERRUPT_CONNECTION_DATA </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x008 Vectors      : [0] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      +0x000 Type         : 0 ( InterruptTypeControllerInput ) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      +0x004 Vector       : 0x70 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      +0x008 Irql         : 0x7 '' </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      +0x00c Polarity     : 1 ( InterruptActiveHigh ) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      +0x010 Mode         : 1 ( Latched ) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      +0x018 TargetProcessors : </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      +0x000 Mask         : 0xff </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      +0x008 Group        : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      +0x00a Reserved     : [3] 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x028 IntRemapInfo : </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      +0x000 IrtIndex     : 0y000000000000000000000000000000 (0) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      +0x000 FlagHalInternal : 0y0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      +0x000 FlagTranslated : 0y0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      +0x004 u            : &lt;anonymous-tag&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x038 ControllerInput : </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      +0x000 Gsiv         : 1 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">上
述输出结果中的Type表明，这是一个传统的、基于线/控制器的输入，而Vector和Irql字段确认了前一个实验中我们已经在KINTERRUPT中
看到的数据。随后通过查看ControllerInput结构，我们可以看到GSIV为1（即IRQ 
1）。如果查看的是不同类型的中断（如消息信号中断，详见下文），则应取消对MessageRequest字段的引用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们还可以通过另一种方法将GSIV映射至中断向量：当通过所谓的仲裁程序管理设备资源时，Windows会持续跟踪整个过程。对于每一类资源，可通过仲裁
程序维持虚拟资源的使用情况（如中断向量）和物理资源（如中断线）之间的关系。因此我们可以查询ACPI IRQ仲裁程序并获得相关映射关系。为此可使用<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>!</b><b>a</b><b>p</b><b>c</b><b>i</b><b>i</b><b>r</b><b>q</b><b>a</b><b>r</b><b>b</b></span>命令获取有关ACPI IRQ仲裁程序的信息：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">6: kd&gt; !acpiirqarb </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Processor 0 (0, 0): </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Device Object: 0000000000000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Current IDT Allocation: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  000000070 - 00000070 D ffffe50f9959baf0 (i8042prt) A:ffffce0717950280 IRQ(GSIV):1</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">... </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请注意，键盘的GSIV为IRQ 1，这是一个古老的遗留数值，甚至可以从今天一直追溯至IBM PC/AT时代。我们也可以使用<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>!</b><b>a</b><b>r</b><b>b</b><b>i</b><b>t</b><b>e</b><b>r</b><b> </b><b>4</b></span>（“4”可以让调试器只显示IRQ仲裁程序）查看ACPI IRQ仲裁程序内部包含的项：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">6: kd&gt; !arbiter 4 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">DEVNODE ffffe50f97445c70 (ACPI_HAL\PNP0C08\0) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  Interrupt Arbiter "ACPI_IRQ" at fffff804575415a0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Allocated ranges: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      0000000000000001 - 0000000000000001 ffffe50f9959baf0 (i8042prt) </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">本例中要注意，上述范围代表了GSIV（IRQ）而非中断向量。此外要注意，上述这些输出结果中我们都可以看到向量的所有信息，这是以设备对象的类型来表示的（本例中为0xFFFFE50F9959BAF0）。随后即可使用<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>!</b><b>d</b><b>e</b><b>v</b><b>o</b><b>b</b><b>j</b></span>命令查看本例中i8042prt设备（对应着PS/2驱动程序）的相关信息：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">6: kd&gt; !devobj 0xFFFFE50F9959BAF0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Device object (ffffe50f9959baf0) is for: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> 00000049 \Driver\ACPI DriverObject ffffe50f974356f0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Current Irp 00000000 RefCount 1 Type 00000032 flags 00001040 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">SecurityDescriptor ffffce0711ebf3e0 DevExt ffffe50f995573f0 DevObjExt ffffe50f9959bc40</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">DevNode ffffe50f9959e670 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Extensionflags (0x00000800) DOE_DEFAULT_SD_PRESENT </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Characteristics (0x00000080) FILE_AUTOGENERATED_DEVICE_NAME </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">AttachedDevice (Upper) ffffe50f9dfe9040 \Driver\i8042prt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Device queue is not busy. </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">该设备对象关联了一个设备节点，其中存储了该设备的所有物理资源。至此我们已经可以使用<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>!</b><b>d</b><b>e</b><b>v</b><b>n</b><b>o</b><b>d</b><b>e</b></span>命令转储这些资源，并使用0xF标记同时查看原始数据和转换后的资源信息：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">6: kd&gt; !devnode ffffe50f9959e670 f </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">DevNode 0xffffe50f9959e670 for PDO 0xffffe50f9959baf0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  InstancePath is "ACPI\LEN0071\4&amp;36899b7b&amp;0" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  ServiceName is "i8042prt" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  TargetDeviceNotify List - f 0xffffce0717307b20 b 0xffffce0717307b20 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  State = DeviceNodeStarted (0x308) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  Previous State = DeviceNodeEnumerateCompletion (0x30d) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  CmResourceList at 0xffffce0713518330 Version 1.1 Interface 0xf Bus #0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Entry 0 - Port (0x1) Device Exclusive (0x1) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      Flags (PORT_MEMORY PORT_IO 16_BIT_DECODE </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      Range starts at 0x60 for 0x1 bytes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Entry 1 - Port (0x1) Device Exclusive (0x1) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      Flags (PORT_MEMORY PORT_IO 16_BIT_DECODE </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      Range starts at 0x64 for 0x1 bytes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Entry 2 - Interrupt (0x2) Device Exclusive (0x1) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      Flags (LATCHED </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      Level 0x1, Vector 0x1, Group 0, Affinity 0xffffffff </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  TranslatedResourceList at 0xffffce0713517bb0 Version 1.1 Interface 0xf Bus #0</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Entry 0 - Port (0x1) Device Exclusive (0x1) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      Flags (PORT_MEMORY PORT_IO 16_BIT_DECODE </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      Range starts at 0x60 for 0x1 bytes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Entry 1 - Port (0x1) Device Exclusive (0x1) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      Flags (PORT_MEMORY PORT_IO 16_BIT_DECODE </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      Range starts at 0x64 for 0x1 bytes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Entry 2 - Interrupt (0x2) Device Exclusive (0x1) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      Flags (LATCHED </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      Level 0x7, Vector 0x70, Group 0, Affinity 0xff </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">通过设备节点可知，该设备有一个包含三项内容的资源列表，其中一项为对应于IRQ 1的中断项（级别和向量编号代表了GSIV而非中断向量）。从后续显示的转换后的资源列表可知IRQL为7（这是级别编号），而中断向量为0x70。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在ACPI系统中，我们可以通过一种更简单的方式获取此类信息，为此可查看上述<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>!</b><b>a</b><b>c</b><b>p</b><b>i</b><b>i</b><b>r</b><b>q</b><b>a</b><b>r</b><b>b</b></span>命令的扩展输出结果。该输出结果还会显示IRQ与IDT之间的映射表：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Interrupt Controller (Inputs: 0x0-0x77): </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    (01)Cur:IDT-70 Ref-1 Boot-0 edg hi    Pos:IDT-00 Ref-0 Boot-0 lev unk </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    (02)Cur:IDT-80 Ref-1 Boot-1 edg hi    Pos:IDT-00 Ref-0 Boot-1 lev unk </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    (08)Cur:IDT-90 Ref-1 Boot-0 edg hi    Pos:IDT-00 Ref-0 Boot-0 lev unk </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    (09)Cur:IDT-b0 Ref-1 Boot-0 lev hi    Pos:IDT-00 Ref-0 Boot-0 lev unk</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    (0e)Cur:IDT-a0 Ref-1 Boot-0 lev low   Pos:IDT-00 Ref-0 Boot-0 lev unk</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    (10)Cur:IDT-b5 Ref-2 Boot-0 lev low   Pos:IDT-00 Ref-0 Boot-0 lev unk</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    (11)Cur:IDT-a5 Ref-1 Boot-0 lev low   Pos:IDT-00 Ref-0 Boot-0 lev unk</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    (12)Cur:IDT-95 Ref-1 Boot-0 lev low   Pos:IDT-00 Ref-0 Boot-0 lev unk</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    (14)Cur:IDT-64 Ref-2 Boot-0 lev low   Pos:IDT-00 Ref-0 Boot-0 lev unk</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    (17)Cur:IDT-54 Ref-1 Boot-0 lev low   Pos:IDT-00 Ref-0 Boot-0 lev unk</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    (1f)Cur:IDT-a6 Ref-1 Boot-0 lev low   Pos:IDT-00 Ref-0 Boot-0 lev unk</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    (41)Cur:IDT-96 Ref-1 Boot-0 edg hi    Pos:IDT-00 Ref-0 Boot-0 lev unk</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">不出所料，IRQ 1关联给了IDT项0x70。有关设备对象、资源以及相关概念的详细信息，请参阅卷1第6章。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_21" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>4</b><b>.</b><b>2</b><b> </b><b>基</b><b>于</b><b>线</b><b>的</b><b>中</b><b>断</b><b>和</b><b>基</b><b>于</b><b>消</b><b>息</b><b>信</b><b>号</b><b>的</b><b>中</b><b>断</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">共享的中断经常会导致较高
的中断延迟，甚至可能导致稳定性问题。对于物理中断线路（interrupt 
line）有限的计算机，这是一种需要尽力避免的副作用。例如，对于能同时支持USB、Compact Flash存储卡、Sony Memory 
Stick记忆棒、Secure 
Digital存储卡以及其他介质的多合一读卡器，同一个物理设备中包含的所有控制器通常都会连接到同一个中断线，随后被不同设备驱动程序配置为共享的中
断向量。这会导致延迟增加，因为需要按顺序轮流调用每个驱动程序才能确定为该媒体设备发出中断的实际控制器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">更好的解决方案是让每个设
备控制器使用自己的中断，并通过同一个驱动程序管理不同的中断，以此得知这些中断来自哪个设备。然而，为一个设备使用四个传统的IRQ线会很快导致IRQ
线耗尽。此外无论如何，每个PCI设备都只能连接到一个IRQ线，因此，对于上述那样的多媒体读卡器，即使需要，也无法使用超过一个的IRQ。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通过IRQ线生成中断的另
一个问题在于，如果无法正确管理IRQ信号，可能会导致计算机遇到中断风暴或其他类型的死锁，因为在ISR确认信号之前，信号需要处于“高”或“低”的状
态（此外，中断控制器通常必须收到EOI信号）。如果由于存在Bug而无法实现上述操作，系统将永久陷入中断状态，后续中断将无法被屏蔽，甚至同时出现这
两种情况。最后，基于线的中断在多处理器环境中的可扩展性有限。很多情况下，当即插即用管理器为一个中断选择了一组处理器后，最终将由硬件决定要中断哪个
处理器，设备驱动程序在其中起到的作用极为有限。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为解决上述所有问题，
PCI 2.2标准中首次引入了一种名为消息信号中断（Message- Signaled 
Interrupt，MSI）的机制。虽然这是该标准的一种可选组件，并且很少出现在客户端计算机（主要被服务器用于改善网卡和存储控制器性能）中，但随
着PCI Express 
3.0和后续标准的普及，大部分现代操作系统已经可以全面支持这种模型。在MSI的世界里，设备可以通过PCI总线对一个特定内存地址执行写入操作，以此
向自己的驱动程序传递消息。从硬件的角度来看，实际上这可以视为一种直接内存访问（Direct Memory 
Access，DMA）操作。该操作会产生一个中断，随后Windows即可使用消息内容（值）和消息传递到的地址来调用ISR。设备还可以向内存地址传
递多个消息（最多32个），以此根据不同事件传递不同的消息载荷。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于某些要求更高性能和更
低延迟的系统，PCI 
3.0标准引入了MSI-X技术，这是对原有MSI模型的扩展，该技术可支持32位（而不再是16位）的消息，最多可支持2048个（不再是仅仅32个）
不同的消息，更重要的是，该技术可以为每个MSI载荷使用不同的地址（地址可动态确定）。不同地址的使用使得MSI载荷可以被写入属于不同处理器的不同物
理地址范围，或写入不同的目标处理器集，这种方式高效地实现了通过非一致内存访问（Nonuniform Memory 
Access，NUMA）来感知中断交付，进而可将中断发送给最初发起相关硬件请求的处理器。通过在中断完成过程中监视负载和距离最近的NUMA节点，该
技术可以大幅改善延迟与可扩展性。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在上述这些模型中，因为要
基于内存值进行通信，并且因为内容是与中断一起交付的，因此可以不再需要IRQ线（进而使得系统对于MSI整体限于中断向量的数量，而非IRQ线的数
量），而是需要通过驱动程序ISR向设备查询与中断有关的数据，进而降低了延迟。由于该模型可提供大量设备中断，也使得共享中断的必要性显著降低，进而通
过将中断数据直接交付给相关ISR而进一步降低了延迟。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">也正因如此，我们可以看到
大部分调试器命令会使用GSIV这个术语来替代IRQ，因为GSIV可以概括地描述MSI向量（由不同的“负数”进行区分）、传统的基于IRQ的线，甚至
嵌入式设备中的通用输入/输出（General Purpose Input 
Output，GPIO）引脚。此外，ARM和ARM64系统并未使用上述任何一种模型，而是使用了通用中断控制器（Generic Interrupt
 
Controller，GIC）架构。从图8-16中可以看到两个计算机系统中的设备管理器，其中分别显示了传统的基于IRQ的GSIV，以及以负数形式
显示的MSI值的分配情况。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/724e657b494f3848f1548d31142f0a0c.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图8-16 基于IRQ和MSI的GSIV分配情况</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>中</b><b>断</b><b>路</b><b>由</b><b>控</b><b>制</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在非虚拟化环境中运行且一
个处理器组包含2～16个处理器的客户端（即非服务器SKU）系统中，Windows会通过一种名为中断路由控制（Interrupt 
Steering）的功能满足消费级现代操作系统对能耗和延迟的需求。在该功能的帮助下，可以按需将中断的负载分摊到多个处理器，以避免单一CPU可能造
成的瓶颈，而内核休止引擎（Core Parking 
Engine，详见本书卷1第6章）亦可将中断路由至未休止的内核，以避免大量中断的分配导致太多处理器在同一时间处于被唤醒的状态。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">中断路由控制的具体功能取
决于中断控制器。例如，在支持GIC的ARM系统中，所有等级敏感的以及边缘（锁存）触发的中断均可进行路由控制；而在APIC系统（除非在Hyper-
V中运行）中，仅等级敏感的中断可进行路由控制。然而，由于MSI始终是等级边缘触发（level 
edge-triggered）的，所以会导致该技术提供的收益大幅降低，为应对这种情况，Windows还实现了另一种中断重定向模型。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在启用路由控制后，中断控
制器通过重编程将GSIV交付给不同处理器的LAPIC（在ARM 
GIC环境中也会实现类似的交付机制）。在必须进行重定向的情况下，所有处理器都会成为GSIV的交付目标，随后实际收到该中断的处理器需要手动向该中断
原本应该路由到的目标处理器发送一个IPI。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了内核休止引擎所使用的
中断路由控制，Windows还会通过系统信息类暴露这些功能，该信息类会由KeIntSteerAssignCpuSetForGsiv通过
Windows 10的实时音频功能和CPU集（CPU 
Set）功能进行处理，详见本书卷1第4章。由此特定GSIV即可路由至能够被用户模式应用程序选择的特定处理器组，但前提是应用程序需具备
Increase Base Priority权限，通常只有管理员或本地服务账户具备该权限。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>中</b><b>断</b><b>的</b><b>相</b><b>关</b><b>性</b><b>和</b><b>优</b><b>先</b><b>级</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows允许驱动程
序开发者和管理员在一定程度上控制处理器相关性（选择接收中断的处理器或处理器组）和相关性策略（决定处理器的选择方式以及要选择处理器组中的哪个处理
器）。此外，Windows还能根据IRQL的选择情况实现一种用于为中断划分优先级的基元机制。相关性策略的定义如表8-5所示，这些策略可通过设备实
例的注册表键中Interrupt Management\Affinity 
Policy子键下一个名为InterruptPolicyValue的注册表值加以控制。因此管理员无须配置任何代码，即可将该值添加到特定驱动程序的
注册表键中，进而改变其行为。有关中断相关性的详细介绍可参阅微软文档：https://docs.microsoft.com/windows-
hardware/drivers/kernel/interrupt-affinity-and-priority。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-5 IRQ相关性策略</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e2fafa12359c5303e96eff42e73a09f7.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了设置上述相关性策略，我们还可以根据表8-6列出的注册表值设置中断的优先级。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-6 IRQ优先级</span></p><div style="display: block;text-align:center;">
	<img width="884" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b50af44b428743b18cf007ef98291a94.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">我们需要意识到
Windows并非实时操作系统，因此这些IRQ优先级仅仅是提供给系统的一种“暗示”，只能用于控制与中断有关的IRQL，无法提供Windows 
IRQL优先级方案机制之外的其他优先级。由于IRQ优先级也存储在注册表中，因此管理员可以自由地为未利用此功能的驱动程序更改相关注册表值，以便有更
低的延迟。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>软</b><b>件</b><b>中</b><b>断</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然大部分中断是硬件生成的，但Windows内核也能为很多任务生成软件中断，这些任务包括：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·初始化线程调度。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·处理非时间关键型中断。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·处理计时器过期。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·在特定线程的上下文中以异步方式执行过程。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·为异步I/O操作提供支持。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">下面将详细介绍这些任务。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>调</b><b>度</b><b>或</b><b>延</b><b>迟</b><b>过</b><b>程</b><b>调</b><b>用</b><b>（</b><b>D</b><b>P</b><b>C</b><b>）</b><b>中</b><b>断</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">DPC通常是一种与中断有
关的功能，会在所有设备中断处理完毕后执行某种处理任务。该功能名称中的“延迟”是指相关任务也许不会立即执行。内核会使用DPC处理计时器过期（并释放
等待该计时器的线程）并在线程的量程过期后重新调度处理器（这一过程发生在DPC 
IRQL下，但其实并非通过常规内核DPC进行的）。设备驱动程序可使用DPC处理中断并执行更高IRQL下不可用的操作。为了向硬件中断提供及时的服
务，Windows会在设备驱动程序的配合下尝试保持该IRQL低于设备的IRQL级别。实现这一目标的方法之一是让设备驱动程序ISR仅执行确认设备所
需的最少量必要工作，保存可变的中断状态，并将数据传输工作或对时间要求不敏感的中断处理工作延迟到在DPC/Dispatch 
IRQL下通过DPC来执行（有关I/O系统的详细信息请参阅本书卷1第6章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果IRQL为被动模式或
处于APC级别，DPC将立即执行并阻止所有其他非硬件相关的处理任务，因此该机制通常也用于强制立即执行高优先级的系统代码。借此，DPC为操作系统提
供了生成中断并在内核模式下执行系统函数的能力。例如，当一个线程无法继续执行时（也许因为该线程已终止或自愿进入等待状态），内核会直接调用调度程序来
立即执行上下文切换。然而，有时候内核会检测到自己深陷于多层代码中，进而需要重新调度。此时内核会请求进行调度，但会延迟调度操作的发生，直到自己完成
当前操作。DPC软件中断是实现这种延迟处理目标的一种便利方法。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当内核需要同步访问与调度
有关的内核结构时，会始终将处理器的IRQL提升至DPC/Dispatch级别或更高级别。这会同时禁用其他的软件中断和线程调度。当内核检测到需要进
行调度时，会请求一个DPC/Dispatch级别的中断，但由于IRQL已处于或高于该级别，处理器会将该中断置于检查状态。内核完成当前活动后，发现
自己需要将IRQL降低至DPC/Dispatch级别以下，并需要检查是否有挂起的调度中断。如果有，则IRQL会降低至DPC/Dispatch级别
并开始处理调度中断。使用软件中断激活线程调度程序，是一种在所需条件满足之前进行延迟调度的方法。DPC由DPC对象表示，这是一种对用户模式程序不可
见，但对设备驱动程序和其他系统代码可见的内核控制对象。内核在处理DPC中断时所调用系统函数的地址是DPC对象中包含的最重要信息。等待执行的DPC
例程会保存在内核管理的队列中，该队列名为DPC队列，每个处理器都有一个这样的队列。若要请求DPC，系统代码会调用内核初始化一个DPC对象，并将其
保存在DPC队列中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">默认情况下，内核会将
DPC对象放置在请求了该DPC的处理器（通常也是负责执行ISR的处理器）所属的两个DPC队列之一的末尾处。不过设备驱动程序可以重写此行为，为此只
需要指定一个DPC优先级（低、中、中高、高，其中“中”为默认优先级）并为该DPC选择一个特定处理器作为目标。针对特定CPU的DPC也称定向DPC
（Targeted DPC）。如果DPC优先级为“高”，则内核会将该DPC对象插入队列前方；如果为其他任何优先级，则会置于队列末尾。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当处理器的IRQL即将从
DPC/Dispatch级别或更高级别降至更低级别（APC或被动级别）时，内核将开始处理DPC。Windows会保证IRQL依然处于DPC/
Dispatch级别，并从当前处理器的队列中持续“取出”DPC对象，直到队列为空（也就是说，内核开始“排空”队列），并会按顺序调用每个DPC函
数。只有在队列为空后，内核才会让IRQL降至低于DPC/Dispatch的级别，并让常规线程继续执行。图8-17展示了DPC的处理过程。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/704549c5babbbdd30658b2c3bd978437.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-17 DPC的处理过程</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">DPC优先级还会以其他方
式对系统行为产生影响。内核通常会使用DPC/Dispatch级别的中断发起DPC队列排空操作。但只有在DPC被当前处理器（执行ISR的处理器）控
制且DPC的优先级高于“低”优先级时，内核才会生成此类中断。如果DPC的优先级为“低”，那么只有在该处理器尚未解决的DPC请求数量（存储在
KPRCB的DpcQueueDepth字段中）超过某一阈值（在KPRCB中该阈值被称为MaximumDpcQueueDepth）之后，或特定时间
窗口内处理器所请求的DPC数量极低的情况下，内核才会请求这样的中断。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果某个DPC的目标
CPU不同于运行ISR的CPU，且该DPC的优先级为“高”或“中高”时，内核就会立即向目标CPU发送信号（发送“调度IPI”）以排空其DPC队
列，但前提是目标处理器必须为空闲状态。如果优先级为“中”或“低”，那么目标处理器DPC队列中的请求数量（依然是DpcQueueDepth）必须超
过内核触发DPC/Dispatch中断的阈值（MaximumDpcQueueDepth）。系统闲置线程也可以排空它所运行的处理器的DPC队列。虽
然DPC目标和优先级机制非常灵活，但设备驱动程序很少需要更改自己DPC对象的默认行为。表8-7总结了可以发起DPC队列排空的各种情况。从生成规则
的角度来看，“中高”和“高”优先级其实是等同的，它们之间的差异在于插入队列的位置，“高”优先级中断会被插入头部，“中高”优先级中断会被插入尾部。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-7 DPC中断生成规则</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/1d15f0be12a2fbe560a0537701436481.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">另外，表8-8描述了各种DPC中断生成变量及其默认值，以及该如何通过注册表修改这些值。除了注册表，我们也可以通过SystemDpcBehaviorInformation这个系统信息类来设置这些值。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-8 DPC中断生成变量及其默认值</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/2fbf5916fb82b3755922484b96e2d29e.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于用户模式线程以低
IRQL执行，DPC在很多时候会中断常规用户线程的执行。DPC例程的执行并不考虑哪些线程正在运行，这意味着当DPC例程运行时，并不能假定当前已经
映射了哪些进程地址空间。DPC例程可以调用内核函数，但无法调用系统服务，无法生成页面错误，也无法创建或等待调度程序对象（下文将详细介绍）。不过
DPC例程可以访问未分页系统内存地址，因为无论当前进程是哪个，系统地址空间始终会被映射。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于所有用户模式内存都可
分页且DPC会在任意进程上下文中执行，DPC代码永远不能以任何方式访问用户模式内存。在支持管理模式访问保护（Supervisor Mode 
Access Protection，SMAP）或永无特权访问（Privileged Access 
Never，PAN）的系统中，Windows会在处理DPC队列（及执行例程）的过程中激活这些功能，保证访问用户模式内存的任何操作均会立即导致
Bugcheck错误。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">DPC中断线程执行带来的
另一个副作用是最终会导致线程的运行时间被“窃取”。因为当调度器认为当前线程正在执行时，实际上执行的可能是DPC。卷1第4章中讨论过调度器会通过一
些机制跟踪线程运行所消耗的CPU时钟周期准确数量，并在必要时扣除DPC和ISR时间，以此为线程失去的运行时间做出补偿。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然这保证了线程不会牺牲
自己的量程作为代价，但仍意味着，从用户的角度来看，钟表时间（也就是现实世界中流逝的时间）依然用于处理其他事情了。假设用户正在通过在线音乐服务听自
己喜欢的歌曲，如果DPC运行耗时2秒，在这2秒时间里，音乐可能会卡顿或重复播放一小段相同内容。在线视频流媒体甚至键盘鼠标的输入也可能会受到类似影
响。因此，对于客户端系统或工作站工作负载来说，DPC已成为导致很多可察觉系统卡顿问题的主要原因，即使是最高优先级的线程，也可能被DPC的运行所打
断。为了让某些包含需长时间运行DPC的驱动程序能够正确实现，Windows开始支持线程式DPC（Threaded 
DPC）。顾名思义，线程式DPC可以在实时优先级（优先级31）的线程上以被动模式执行DPC例程，这样DPC就可以抢占大部分用户模式线程（因为大部
分应用程序线程并不在实时优先级的范围内运行），但同时又允许其他中断、非线程式DPC、APC以及其他优先级为31的线程能够抢占这种DPC例程的执
行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">线程式DPC默认已经启
用，我们可在注册表的HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session 
Manager\Kernel键下添加一个名为ThreadDpcEnable的DWORD值，并将其数值设置为“0”，这样即可禁用线程式DPC。线程
式DPC必须由开发者通过KeInitializeThreadedDpc 
API进行初始化，由此可将DPC的内部类型设置为ThreadedDpcObject。由于线程式DPC可以被禁用，所以使用该机制的驱动程序开发者必
须按照与非线程式DPC例程相同的规则编写自己的例程，不能访问已分页内存、执行调度程序等待，或者假设执行所用的IRQL级别。此外，此类驱动程序的开
发者也不应使用KeAcquire/ReleaseSpinLockAtDpcLevel 
API，因为相关函数会假设CPU处于调度级别。实际上，线程式DPC必须使用KeAcquire/ReleaseSpinLockForDpc，借此在
检查当前IRQL后执行相应操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然线程式DPC是一项出
色的功能，可帮助驱动程序开发者尽可能地保护系统资源，但无论是从开发者还是系统管理员的角度，这都是一项选择性使用的功能。因此大部分DPC依然以非线
程式的模式执行，并可能导致上述系统卡顿问题。Windows会使用大量性能跟踪机制诊断并协助解决与DPC有关的问题。第一个问题当然是通过性能计数器
和更精确的ETW跟踪机制来跟踪DPC和ISR所消耗的时间。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>监</b><b>视</b><b>D</b><b>P</b><b>C</b><b>活</b><b>动</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">可以使用Process Explorer监视DPC活动，为此请打开“System Information”对话框并切换至CPU选项卡，这里列出了每一次Process Explorer刷新显示结果（默认为1秒）过程中所执行的中断和DPC数量。</span></p><div style="display: block;text-align:center;">
	<img width="832" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/132e2a4e93d076f7fb727d012ff13405.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/270d0decb1f4bdb23d5b8005b2b8a9f7.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">也
可以使用内核调试器查看KPRCB中名称以“Dpc”开头的各种字段，例如，DpcRequestRate、DpcLastCount、DpcTime以
及DpcData（其中包含DpcQueueDepth和DpcCount，分别对应非线程式和线程式DPC）。此外，较新版本的Windows还包含
IsrDpcStats字段，该字段是一个指向_ISRDPCSTATS结构的指针，这个结构已包含在公开发布的符号文件中。例如，下列命令可显示当前
KPRCB中已加入队列的（线程式和非线程式）DPC总数，以及已执行过的DPC数量：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt;
 dx new { QueuedDpcCount = @$prcb-&gt;DpcData[0].DpcCount + 
@$prcb-&gt;DpcData[1].DpcCount, ExecutedDpcCount = 
((nt!_ISRDPCSTATS*)@$prcb-&gt;IsrDpcStats)-&gt;DpcCount },d</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    QueuedDpcCount   : 3370380 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ExecutedDpcCount : 1766914 [Type: unsigned__int64] </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">上
述范例输出结果中的差异是正常的，驱动程序可能会将已位于队列中的DPC再次加入队列，而Windows可以安全地处理这种情况。此外，最开始DPC可能
会被加入特定处理器的队列（但并不以任何具体处理器作为目标），在某些情况下，它可能在另一个处理器上执行，例如，当驱动程序使用
KeSetTargetProcessorDpc（该API可以让驱动程序将特定处理器作为DPC目标）时。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows不仅可以帮
助用户手动调查由DPC导致的延迟问题，还能通过一套内置的机制解决少数导致严重问题的常见场景。首先是DPC Watchdog和DPC 
Timeout机制，这些机制可通过注册表
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session 
Manager\Kernel键下的DPCTimeout、DpcWatchdogPeriod以及DpcWatchdogProfileOffset等
值进行配置。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果IRQL降低事件在很
长时间里都未注册，DPC Watchdog将负责监视在DISPATCH_LEVEL或更高级别执行的所有代码。另外，DPC 
Timeout负责监视特定DPC的执行时间。默认情况下，特定DPC会在大约20秒后超时，而所有DISPATCH_LEVEL（以及更高级别）的执行
会在2分钟后超时。这两项限制都可以通过上文提到的注册表值进行配置（DPCTimeout控制了特定DPC的时间限制，而
DpcWatchdogPeriod控制了在高IRQL下运行的所有代码的整体执行情况）。当达到这些阈值后，系统可能会发出
DPC_WATCHDOG_VIOLATION的Bugcheck错误（由此可判断到底是哪种情况），如果附加了内核调试器，则会发出一个可以继续运行的
断言。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">驱动程序开发者如果希望通
过自己的工作避免出现这些情况，可以使用KeQueryDpcWatchdogInformation 
API查看这些注册表当前配置的值以及剩余时间。此外，KeShouldYieldProcessor 
API也可以将这些值（以及其他与系统状态有关的值）纳入考虑范围，进而为驱动程序返回相关提示信息，供驱动程序决定接下来是否继续处理自己的DPC工
作，或是否在可行的情况下将IRQL重新降低至PASSIVE_LEVEL（主要适用于DPC并未执行但驱动程序持有了锁或是通过某种方式与DPC进行同
步的情况）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在最新版本的
Windows 
10中，每个PRCB还包含一个DPC运行时历史记录表（DpcRuntimeHistoryHashTable），其中保存了一个哈希（或散列）表桶，
它由最近执行的特定DPC回调函数及其运行所消耗的CPU周期数量等痕迹信息所组成。在分析内存转储或远程系统时，可在无须借助UI工具的情况下通过这些
信息研究延迟问题，但更重要的是，内核也可以使用这些信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">驱动程序开发者通过
KeInsertQueueDpc将DPC插入队列时，该API将枚举处理器的表并检查该DPC之前是否曾执行并耗费了相当长时间（默认为100毫秒，可
通过注册表HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session 
Manager\Kernel下的LongDpcRuntimeThreshold值进行配置）。如果是这种情况，上文提到的DpcData结构中将被设
置LongDpcPresent字段。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于每个闲置线程（有关线
程调度和闲置线程的详细信息请参阅本卷1第4章），现在的内核也可以创建DPC委派线程（DPC Delegate 
Thread）。这是一种具备高度唯一性的线程，隶属于System Idle Process（这一点与闲置线程，即Idle 
Thread一样）。这种线程永远不会被包含在调度器的默认线程选择算法中，而是在内核中专供内核自己使用。图8-18展示了一个具备16个逻辑处理器、
16个闲置线程和16个DPC委派线程的系统。请注意，在这种情况下，这些线程有着真实的线程ID（TID），图中Processor列显示的信息即可视
为其TID。</span></p><div style="display: block;text-align:center;">
	<img width="619" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/511a157af5f53c2cc555a2f4719d4396.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图8-18 具备16个CPU的系统中的DPC委派线程</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内核调度DPC时，会检查
DPC队列深度是否已超过这种长时间运行DPC的阈值（默认深度为2，可通过上文多次提到的注册表键进行配置）。如果已超出，则需要决定是否通过查看当前
执行中线程的属性来缓解这种情况，而具体要研究的属性包括：该线程是否闲置、是否为实时线程，其相关性掩码是否决定了该线程通常需要在不同的处理器上运
行。基于结果，内核可能决定调度DPC委派线程作为代替，从本质来看，这等于是将该DPC从运行时间所剩无几的线程切换至一个优先级尽可能高的专用线程中
（但依然在DISPATCH_LEVEL级别下执行）。这样原本被抢占的线程（或位于待命列表中的任何其他线程）就有机会重新调度至其他CPU。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">该机制与上文提到的线程式
DPC类似，但也有些差异。委派线程依然运行在DISPATCH_LEVEL级别下。实际上，当委派线程在NT内核初始化（详见第12章）的阶段1创建并
启动时，就会将自己的IRQL提升至DISPATCH级别，保存到自己内核线程数据结构的WaitIrql字段中，并自发地请求调度器对另一个待机或就绪
线程进行上下文切换（通过KiSwapThread例程实现）。因此，委派DPC为系统提供了一种自动化均衡操作，并不需要由驱动程序开发者选择性地采用
并慎重地应用在自己的代码中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果是具备该功能的新版本Windows 10系统，可在内核调试器中运行下列命令来查看对委派线程的需求到底有多频繁，这可以从系统引导后执行的上下文切换次数推断出来：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx @$cursession.Processes[0].Threads.Where(t =&gt; t.KernelObject.ThreadName-&gt;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ToDisplayString().Contains("DPC Delegate Thread")).Select(t =&gt; t.KernelObject.Tcb.</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ContextSwitches),d </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [44]             : 2138 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [52]             : 4 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [60]             : 11 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [68]             : 6 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [76]             : 13 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [84]             : 3 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [92]             : 16 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [100]            : 19 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [108]            : 2 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [116]            : 1 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [124]            : 2 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [132]            : 2 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [140]            : 3 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [148]            : 2 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [156]            : 1 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [164]            : 1 [Type: unsigned long] </span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>异</b><b>步</b><b>过</b><b>程</b><b>调</b><b>用</b><b>中</b><b>断</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">异步过程调用
（Asynchronous Procedure 
Call，APC）为用户程序和系统代码提供了一种在特定用户线程的上下文（进而在特定进程地址空间）中执行的方法。由于APC需要在特定用户线程的上下
文中排队执行，因此也会受制于线程调度规则，无法在与DPC相同的环境中运行。也就是说，APC无法在DISPATCH_LEVEL下运行，可能会被更高
优先级的线程抢占，可以执行阻塞等待，可以访问可分页的内存。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">话虽如此，但由于APC依
然是一种软件中断，因此必须以某种方式从线程的主执行路径“夺取”控制权，本节将会介绍这是通过在名为APC_LEVEL的IRQL上操作实现的。这意味
着尽管APC的运行不像DPC那样会遇到相同限制，但开发者依然需要遵守某些规则，下文还将详细介绍这一点。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">APC是由一个名为APC
对象的内核控制对象描述的。待执行的APC在内核管理的两个APC队列中等待。这与DPC队列不同，DPC队列是每个处理器专用的（并会分为线程的和非线
程的），而APC队列是每个线程的，每个线程有两个APC队列：一个适用于内核APC，另一个适用于用户APC。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在需要将APC加入队列时，内核会查看APC的模式（用户或线程），随后将APC加入执行该APC例程的线程所属的相应队列。在介绍该APC如何以及何时执行之前，我们先来看看两种模式之间的差异。当APC被加入线程队列时，该线程可能处于下列三种情况之一：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·线程当前正在运行（甚至可能就是当前线程）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·线程当前正在等待。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·线程正在执行其他操作（就绪、准备等）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">首先请回忆卷1第4章的内
容，执行等待的线程具备一个可告警的状态。除非针对某个线程彻底禁用了APC，否则对于内核APC，该状态会被忽略，也就是说，APC总是会终止等待，而
这一行为的结果会在下文进一步讨论。不过对于用户APC，只有在等待操作是可告警的并且代表某个用户模式组件进行了实例化，或者其他正在挂起的用户APC
已经开始终止该等待（如果有大量处理器试图将APC加入同一个线程的队列，就会发生这种情况）的情况下，该线程才是可以中断的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">用户APC也永远不会中断
正在用户模式下运行的线程，此时该线程需要执行可告警的等待，或者通过Ring级别转换或上下文切换重新访问用户APC队列。然而对于内核APC，在目标
线程所在处理器上请求中断会将IRQL提升至APC_LEVEL级别，通知处理器必须查看当前运行中线程的内核APC队列。并且在这两种场景下，如果线程
正在“做其他事情”，则需要通过某种转换让该线程进入运行中或等待中的状态。而这种操作实际上会导致线程被挂起，例如不再执行被加入自己队列中的APC。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了上文介绍的有关可告警
场景，我们曾提到线程的APC是可被禁用的。内核与驱动程序开发者可通过两种机制做到这一点，一种是在执行某些代码时直接将其IRQL提升至
APC_LEVEL或更高级别。由于线程已经处于运行中的状态，因此通常会产生一个中断，但根据之前介绍过的IRQL规则，如果处理器已经处于
APC_LEVEL（或更高）级别，中断将会被遮掩。因此，只有当IRQL被降低至PASSIVE_LEVEL，挂起的中断才会被交付，APC才能正常执
行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果希望将APC重新交付
给线程，强烈建议使用第二种机制，即使用内核API 
KeEnterGuardedRegion并配合使用KeLeaveGuardedRegion，这种方式可避免更改中断控制器状态。这些API是递归
的，可通过嵌套的方式多次调用。只要依然在这样的区域中，就可以安全地通过上下文切换至其他线程，因为状态更新操作会应用于线程对象（KTHREAD）结
构中的SpecialApcDisable字段，而不是每个处理器的状态。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">类似地，上下文切换也可以
发生在APC_LEVEL级别上，即使这是每个处理器的状态。调度程序会将IRQL保存在KTHREAD的WaitIrql字段中，随后将处理器IRQL
设置为新传入线程的WaitIrql（该IRQL可能是PASSIVE_LEVEL）。这会导致一种非常有趣的情况：从技术上来说，
PASSIVE_LEVEL级别的线程可抢占APC_LEVEL级别的线程。这种可能性很常见并且完全正常，并且这也证明了在线程执行方面，调度器本身的
重要性远远超过任何IRQL。只有提升至DISPATCH_LEVEL级别，禁用线程抢占，才能让IRQL取代调度器。由于最终只有APC_LEVEL的
IRQL存在这样的行为，因此这通常也被称为线程本地IRQL（Thread-local 
IRQL），虽然并不完全准确，但该机制已经足以描述此处提到的这种行为。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">无论内核开发者如何禁用
APC，有一条规则是始终适用的：代码不能以PASSIVE_LEVEL之上的任何APC级别返回至用户模式，SpecialApcDisable也不能
设置为“0”之外的其他任何值。实际出现这种情况会立即触发Bugcheck，通常这意味着某些驱动程序忘了释放锁，或者离开了自己的保护区域。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于两种APC模式，每种模式也有两个类型的APC：常规APC与特殊APC，这取决于不同的模式，这两种APC的行为也存在差异。下面将分别讨论每种组合。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>特</b><b>殊</b><b>内</b><b>核</b><b>A</b><b>P</b><b>C</b></span>。这种组合产生的APC会始终被插入APC队列中其他所有现有特殊内核APC的尾部，但在任何常规内核APC之前的位置。内核例程会收到指向APC参数和常规例程的指针，并在APC_LEVEL级别上运行，这样就可以选择将新的常规APC加入队列。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>常</b><b>规</b><b>内</b><b>核</b><b>A</b><b>P</b><b>C</b></span>。
此类APC始终会被插入APC队列的末尾，由此，特殊内核APC就可以将新的常规内核APC加入队列并稍后执行，上文的例子中描述了这样的情况。此类
APC不仅可以通过上文提到的两种机制禁用，也可以通过一种名为KeEnterCriticalRegion的API（配合
KeLeaveCriticalRegion）禁用，这会更新KTHREAD中的KernelApcDisable计数器，但不会更新
SpecialApcDisable计数器。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
这些APC首先会在APC_LEVEL级别下执行自己的内核例程，并向其发送参数和常规例程指针。如果常规例程尚未清除，则会将IRQL降低至
PASSIVE_LEVEL并照常执行常规例程，只不过此时会通过值的形式来传递输入参数。一旦常规例程返回，IRQL将再次重新提升至
APC_LEVEL。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>常</b><b>规</b><b>用</b><b>户</b><b>A</b><b>P</b><b>C</b></span>。
这种组合会导致APC被插入APC队列的末尾，进而供内核例程按照上一段所描述的方法在APC_LEVEL级别下首次执行。随后如果常规例程依然存在，该
APC将准备进行用户模式的交付（很明显，是在PASSIVE_LEVEL级别进行的），为此会创建一个陷阱帧和执行帧，并最终导致在返回用户模式后，将
由Ntdll.dll中的用户模式APC调度程序接管控制权，还将调用所提供的用户指针。一旦用户模式APC返回，调度程序将使用NtContinue或
NtContinueEx系统调用返回到原来的陷阱帧。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
这里需要注意，如果内核例程最后清理了常规例程，那么已收到告警的线程将失去该状态；相反，如果没有收到告警，则会变为已告警状态并且用户APC挂起标记
会被设置，这可能导致其他用户模式APC被尽快交付。这是由KeTestAlertThread 
API负责执行的，本质上，其行为依然类似于常规APC在用户模式下执行，尽管内核例程已经取消了该调度。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>特</b><b>殊</b><b>用</b><b>户</b><b>A</b><b>P</b><b>C</b></span>。
这种组合产生的APC是较新版本的Windows 
10中新增的，概括体现了一种为线程终止APC而做的特殊调度情况，其他开发者也可以使用这种组合。下文很快将会提到，终止远程（非当前）线程的操作需要
使用APC，但该操作只有在所有内核模式代码均已执行完毕后才能进行。以用户APC的形式交付终止代码很适合这种情况，但这也意味着用户模式的开发者应避
免通过执行不可告警的等待或使用其他用户APC填充队列的方式进行终止。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了解决这种问题，长久以
来，内核都会通过一种硬编码的检查来验证用户APC的内核例程是否使用了KiSchedulerApcTerminate。如果是，则用户APC会被视
为“特殊”的，放置在队列的开头处。此外，线程的状态也会被忽略，并且始终设置为“用户APC正在挂起”的状态，这会迫使系统在下一次用户模式Ring级
别转换或上下文切换到该线程时执行该APC。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">该功能是专为终止代码路径
保留的，这意味着开发者如果希望为用户APC的执行提供类似保证，无论可告警状态如何，都必须进一步使用更复杂的机制，如使用
SetThreadContext手动更改线程上下文，但这种做法易出错。为了解决此问题，QueueUserAPC2 
API应运而生，该API可通过QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC标记传递，也能以官方可支持的方式为开发者
提供类似功能。此类APC在加入队列后始终位于其他任何用户模式APC之前（极为特殊的终止APC除外），并且对于等待中的线程，还会忽略可告警标记。此
外，该APC首先会以一种非常特殊的内核APC形式插入，其内核例程几乎可以立即执行，并将APC重新注册为一个特殊用户APC。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">表8-9总结了每一类APC的插入与交付行为。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-9 APC的插入与交付行为</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/adcbcac4af5bddec9016c9012e155403.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">执行体会使用内核模式
APC来执行必须在特定线程地址空间（以及上下文）中执行的操作系统工作。例如，它可以使用特殊内核模式APC指示线程停止执行可中断的系统服务，或借此
记录某个线程地址空间内的一次异步I/O操作结果。环境子系统会使用特殊内核模式APC让线程变得可挂起或终止自身运行，或借此让线程获取或设置自己的用
户模式执行上下文。Windows Subsystem for 
Linux（WSL）会使用内核模式APC来模拟向UNIX应用程序进程子系统传递的UNIX信号。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内核模式APC的另一个重
要用途与线程的挂起和终止有关。由于这些操作可从任意线程发起并以其他任意线程为目标，内核会使用APC来查询线程上下文以及终止线程。设备驱动程序通常
会阻止APC，或通过进入关键/保护区域防止在自己持有了锁的情况下执行此类操作，否则锁可能将永远无法释放，进而导致系统宕机。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">设备驱动程序也可以使用内
核模式APC。举例来说，如果发起一个I/O操作并且有线程进入等待状态，此时可调度执行另一个进程中的其他线程。当设备数据传输操作完成后，I/O系统
必须通过某种方式重新进入发起该I/O操作的线程的上下文，以便将I/O操作结果复制到包含该线程的进程的地址空间缓冲区中。I/O系统使用一种特殊的内
核模式APC来执行该操作，除非应用程序使用了SetFileIoOverlappedRange 
API或I/O完成端口，在这种情况下，缓冲区可能是内存中的全局缓冲区，否则，只有在线程从端口拉取到完成结果之后才能进行复制（I/O系统对APC的
使用已在卷1第6章进行过详细介绍）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">很多Windows 
API（如ReadFileEx、WriteFileEx以及QueueUserAPC）也会使用用户模式APC。例如ReadFileEx和
WriteFileEx函数可允许调用方指定I/O操作结束后要调用的完成例程。I/O完成是通过查询发起I/O操作的线程所对应的APC实现的，然而对
完成例程的回调并不一定发生在将APC加入队列的时候，因为用户模式APC只能交付给处于可告警等待状态的线程。为了进入等待状态，线程可以等待对象句柄
并指定自己的等待是可告警的（使用Windows的WaitForMultipleObjectsEx函数），或者可以直接测试自己是否有正在挂起的
APC（使用SleepEx）。在这两种情况下，如果有用户模式APC正处于挂起状态，内核会中断（告警）这个线程，将控制转交给APC例程，并在APC
例程完成后恢复线程的执行。与在APC_LEVEL级别下执行的内核模式APC不同，用户模式APC会在PASSIVE_LEVEL级别下执行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">APC的交付会导致等待队
列重新排序，此处的“等待队列”可以理解为一个列表，其中列出了哪个线程正在等待什么，以及它们等待的具体顺序（有关如何解决这些等待的详细信息，请参
阅“低IRQL同步”一节）。如果在交付APC时线程处于等待状态，在APC例程完成后，将重新发起或重新执行该等待。如果等待依然未能解决，线程将返回
至等待状态，但这一次它会处于对象等待列表的末尾。例如，由于APC可用于挂起线程的执行过程，如果线程正在等待任何对象，那么其等待状态将被移除，直到
线程恢复执行，随后该线程将被放置在线程列表的末尾，继续等待访问自己所等待的对象。正在执行可告警的内核模式等待的线程还可在线程终止时被唤醒，借此该
线程就可以检查自己的唤醒到底是因为终止还是其他什么原因造成的。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_22" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>4</b><b>.</b><b>3</b><b> </b><b>计</b><b>时</b><b>器</b><b>处</b><b>理</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统的时钟间隔计时器可能
是Windows计算机上最重要的设备，因为它有着高IRQL值（CLOCK_LEVEL）并且起着至关重要的作用。如果不使用该中断，Windows将
无法跟踪时间，导致无法准确计算正常的运行时间和时钟时间，更严重的是，还会导致计时器无法过期，线程将永远无法使用自己的量程。如果不使用该中断，
Windows还将无法成为一种可抢占的操作系统（preemptive operating 
system），此时，除非当前运行中的线程释放了CPU，否则任何处理器上将永远无法运行关键的后台任务和调度。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>计</b><b>时</b><b>器</b><b>的</b><b>类</b><b>型</b><b>和</b><b>间</b><b>隔</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">传统上，Windows控
制计算机的系统时钟在某个适当的间隔内激发，后来还允许驱动程序、应用程序以及管理员根据需要修改时钟间隔。因此，系统时钟可以按照固定的周期性间隔进行
激发，而时钟本身则是由自PC/AT时代起每台计算机都配备的可编程中断计时器（Programmable Interrupt 
Timer，PIT）芯片或实时时钟（Real Time 
Clock，RTC）维护的。PIT运行所用的晶振被调谐为以NTSC彩色载波频率的1/3来运行（这是因为该晶振最初被首款CGA图形卡用于视频输出功
能），HAL可在此基础上通过多种可行的复合机制实现毫秒级别的间隔，这些间隔始于1ms，最长可达15ms。而RTC运行在32.768kHz频率下，
由于该频率本身是2的幂次，因此很容易配置为以2的幂次为间隔的各种频率运行。在基于RTC的系统中，可由APIC多处理器HAL将RTC配置为每
15.6ms激发一次，这大约等于每秒激发64次。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">PIT和RTC存在很多问
题：它们速度很慢，是一种连接到遗留总线上的外部设备，能实现的时钟粒度太粗，迫使所有处理器必须以同步方式访问自己的硬件寄存器，难以模拟，在新的嵌入
式硬件设备（如物联网和移动设备）上已经越来越罕见。因此，硬件供应商开发了各种新型计时器，例如ACPI计时器（有时也叫电源管理（Power 
Management，PM）计时器）和APIC计时器（直接集成在处理器内部）。ACPI计时器针对不同的硬件架构实现了一流的灵活性和可移植性，但延
迟较大，且在实现方面会导致各类问题的很多瑕疵。APIC计时器虽然高效，但通常已被用于实现其他的平台需求，如性能分析，即Profiling（不过较
新的处理器已开始提供专用Profiling计时器）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了解决该问题，微软与业
内厂商联手创建了一种名为高性能事件计时器（High Performance Event 
Timer，HPET）的规范，借此对RTC进行了大量改进。在具备HPET的系统中，将使用HPET代替RTC或PIC，此外，ARM64系统也有自己
的计时器架构，名为通用中断计时器（Generic Interrupt 
Timer，GIT）。针对所有这些不同的机制，HAL会维持一种复杂的层次结构，借此针对特定系统确定可以使用的最佳计时器。这一过程的具体顺序如下：</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）如果是在虚拟机内部运行，为避免进行任何类型的模拟，首先会尝试找到一种合成的虚拟机监控程序（Hypervisor）计时器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）在物理硬件上，会试图找到GIT，但该机制仅适用于ARM64系统。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）如果可能，会试图找到一种每处理器的计时器，例如本地APIC计时器（如果尚未被使用）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）否则会寻找HPET，具体查找顺序为：兼容MSI的HPET，遗留的周期性HPET，任何其他类型的HPET。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">5）如果未找到HPET，则会使用RTC。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">6）如果未找到RTC，则会试图寻找某些其他类型的计时器，如PIT或SFI计时器，并在可能的情况下，会优先尝试寻找支持MSI中断的此类计时器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">7）如果依然未找到任何计时器，意味着系统实际并不包含兼容Windows的计时器，这种情况应该是不会出现的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">HPET和LAPIC计时
器还提供了另一个优势：除了只支持上文提到的典型的周期性模式外，这些计时器还可配置为一种“一次激发”（one 
shot）模式。该功能使得较新版本的Windows可以使用一种动态时钟周期模型（dynamic tick 
model），下文还将详细介绍这种模型。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>计</b><b>时</b><b>器</b><b>粒</b><b>度</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">某些类型的Windows
应用程序需要非常快的响应速度，例如多媒体应用程序。实际上，某些多媒体任务甚至需要低至1ms的响应速度。因此，Windows从早期开始就实现了一系
列API与机制，以此降低系统时钟中断的间隔，进而可以更频繁地产生时钟中断。这些API并不会调整特定计时器所指定的速率（后续版本Windows通过
增加增强的计时器提供了这样的功能，具体介绍请参见下一节），而是会提高系统中所有计时器的精度，但这也有可能导致其他计时器更频繁地过期。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">也就是说，Windows
依然会尽可能将时钟计时器还原为初始值。当进程每次请求更改时钟间隔时，Windows会增加一个内部引用计数器，并将其关联给该进程。驱动程序（也能更
改时钟速率）也可以通过类似的方式加入这个全局引用计数器中。在所有驱动程序还原了时钟，且所有修改过时钟的进程已退出或还原改动后，Windows会将
时钟还原至其默认值（否则将时钟调整为被进程或驱动程序使用过的第二高的值）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>识</b><b>别</b><b>高</b><b>频</b><b>计</b><b>时</b><b>器</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">由
于高频计时器可能会导致一些问题，Windows会使用Windows事件跟踪（Event Tracing for 
Windows，ETW）机制跟踪所有请求更改系统时钟间隔的进程和驱动程序，并显示这种请求的产生时间和所请求的间隔。目前的间隔如下图所示，开发者和
系统管理员可以通过这些数据判断那些在其他方面完全正常，但电池性能较低的系统的问题所在，并能借此降低大型系统的整体能耗。要获取这些数据，只需运行
powercfg/energy指令，随后就可以得到一个名为energy-report.html的HTML文件，其内容类似下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/752b18588710fa1b69ba13a61f443382.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">向
下拖动页面打开Platform Timer 
Resolution（平台计时器精度）小节，在这里可以看到所有曾经更改过计时器精度并且依然活跃的应用程序，以及导致相关调用的调用栈。计时器精度对
应的数值以“百纳秒”为单位，因此数值为20000的时段对应了2ms。在如上例子中，有两个应用程序（Microsoft 
Edge以及远程桌面服务器TightVNC）分别请求过更高的精度。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们也可以通过调试器获取此类信息。对于每个进程，EPROCESS结构中都包含了下列字段，这有助于我们发现计时器精度的变化：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">+0x4a8 TimerResolutionLink :_LIST_ENTRY [ 0xfffffa80'05218fd8 - 0xfffffa80'059cd508 ]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">+0x4b8 RequestedTimerResolution : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">+0x4bc ActiveThreadsHighWatermark : 0x1d </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">+0x4c0 SmallestTimerResolution : 0x2710 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">+0x4c8 TimerResolutionStackRecord : 0xfffff8a0'0476ecd0_PO_DIAG_STACK_RECORD </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请
注意，调试器还会额外显示另一类信息：特定进程曾经请求过的最小计时器精度。本例中所示的进程属于PowerPoint 
2010，在放映幻灯片过程中，该应用通常会请求较低的计时器精度；但在编辑幻灯片过程中通常不会这样做。上文所示代码中PowerPoint的
EPROCESS字段内容也证明了这一点，而相应的栈可通过转储PO_DIAG_STACK_RECORD结构来进行解析。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">最
后，TimerResolutionLink字段通过双向链表ExpTimerResolutionListHead连接了所有曾经更改过计时器精度的进
程。如果powercfg命令不可用或需要查阅历史进程的信息，则可使用调试器数据模型解析该列表，由此得知系统中所有已经或曾经更改过计时器精度的进
程。例如，由下列输出结果可知，Edge曾在不同的时间请求过1ms的精度，此外，远程桌面客户端和Cortana也有过类似的操作。不过WinDbg 
Preview不仅曾请求过更改精度，并且它在运行该命令时依然在请求更改精度。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3fbe05050059c381580af79fe6ef809b.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>计</b><b>时</b><b>器</b><b>过</b><b>期</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上文曾经提到与时钟源生成
的中断相关联的ISR，其主要任务之一是跟踪系统时间，这主要是通过KeUpdateSystemTime例程实现的。该ISR的另一个作用是跟踪逻辑运
行时间，例如进程/线程执行时间以及系统时钟周期时间，诸如GetTickCount等API会使用这些底层数据，以供开发者在自己的应用程序中执行计时
操作。这部分工作是由KeUpdateRunTime进行的。不过在执行任何此类工作前，KeUpdateRunTime会检查是否有计时器已过期。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows计时器可以
是绝对计时器，这种计时器暗含了明确的未来过期时间；也可以是相对计时器，其中包含一个为负数的过期值，在插入计时器后，可通过该值从当前时间中进行扣
减。从内部运作来看，所有计时器都会转换为绝对过期时间，不过系统会持续跟踪每个时间到底是“真正的”绝对时间还是转换后的相对时间。这个差异在某些情况
下非常重要，例如在夏令时（甚至手动调整时钟）的情况下，如果用户将时钟从1:00 p.m.改为7:00 p.m.，此时绝对计时器依然可以在8:00
 
p.m.激发。但相对计时器（例如一个被设置为“两小时后过期”的计时器）将无法感知时钟的变化，因为两小时实际上还没有到。在遇到类似这种系统时间产生
变化的情况下，内核会重编程与相对计时器有关联的绝对时间，以便匹配新的设置。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当时钟仅以周期模式激发的
时候，由于时钟会以已知间隔的倍数过期，因此计时器可关联的系统时间的每个倍数，也可以叫作时钟指针（Hand），这是一种索引，存储在计时器对象的调度
程序头部。Windows会通过这种方式，根据数组将所有驱动程序和应用程序的计时器整理为链表，表中的每一项对应了系统时间一种可能的倍数。由于现代版
本Windows 
10的运行不再必须依赖周期性的时钟周期（这归功于动态时钟周期功能），因此时钟指针也被重新定义为到期时间的上46位（以100ns为单位）。这样每个
时钟指针可以获得大约28ms的“时间”。此外，因为在一个特定的时钟周期过程中（尤其是没有以固定的周期间隔激发时），可能会有多个时钟指针具备即将过
期的计时器，Windows不能只检查当前时钟指针，而是需要使用一个位图来跟踪每个处理器的计时器表中的每个时钟指针。这些挂起的时钟指针都可通过该位
图找到，并在每个时钟中断期间进行检查。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">无论使用何种方法，这256个链表都会保存到一个名为计时器表（位于PRCB中）的表中，这样每个处理器就可以单独让自己的计时器过期，而不需要获取全局锁。该过程如图8-19所示。新版的Windows 10最多可使用两个计时器表，因此总共可产生512个链表。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">稍后我们还将讨论如何决定
计时器会被插入哪个逻辑处理器的计时器表。因为每个处理器都有自己的计时器表，每个处理器也都需要处理自己的计时器过期工作。当处理器被初始化时，该表中
会被填入绝对计时器，为避免产生不连贯的状态，这些计时器的过期时间是无限的。因此，为确定某个时钟是否已过期，就只需要检查与当前时钟指针相关的对应链
表中是否存在任何计时器即可。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4af34c7f452d088aeb8b0859a5351ad0.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-19 每处理器计时器列表范例</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然更新计数器和检查链表
操作的执行速度都很快，但对每个计时器执行该操作并使其过期，则可能会造成巨大的运行开销，毕竟目前所有这些工作都是在CLOCK_LEVEL级别（一种
特别提升后的IRQL）上进行的。类似于驱动程序ISR通过将DPC加入队列来延迟自己工作的做法，时钟ISR也会请求DPC软件中断并在PRCB中设置
标记，这样DPC排空机制就会知道哪些计时器需要过期。同理，在更新进程/线程运行时的时候，如果时钟ISR确定某个线程的量程已经过期，此时也会请求
DPC软件中断并设置一个不同的标记。这些标记是针对每个PRCB专用的，因为每个处理器通常都会自行处理自己的运行时更新，而这是由于每个处理器都在运
行不同的线程，并关联了不同的任务。表8-10列出了在计时器过期和处理过程中所涉及的各种字段。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">表8-10 计时器处理所涉及的KPRCB字段</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a5245371ca2297b97b8cfe823c30713a.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">DPC主要供设备驱动程序
使用，但内核也可以使用。内核主要会使用DPC处理量程的过期。在系统时钟的每次时钟周期过程中，会在时钟的IRQL级别上发出一个中断。时钟中断处理程
序（运行于Clock 
IRQL级别下）会更新系统时间并减小一个计数器的值，该计数器用于跟踪当前线程的运行时长。当该计数器归零后，意味着线程的时间量程已过期，此时内核可
能需要重新调度处理器，并在DPC/Dispatch 
IRQL级别上完成一个低优先级的任务。时钟中断处理程序会将DPC加入队列以发起线程分发操作，随后完成自己的工作并降低处理器的IRQL。由于DPC
中断的优先级低于设备中断，因此，在时钟中断完成之前所产生的任何挂起的设备中断都会先于DPC中断进行处理。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当IRQL最终降低至DISPATCH_LEVEL之后，作为DPC处理工作的一部分，还会选中这两个标记。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">卷1第4章曾介绍过与线程
调度和量程过期有关的操作。这里我们简要介绍计时器过期的工作方式。由于计时器会通过时钟指针相互链接，过期代码（由PRCB在
TimerExpirationDpc字段中关联的DPC执行，通常为KiTimerExpirationDpc）会从头到尾解析该列表（在插入时，将优
先插入距离时钟间隔倍数最接近的计时器，其次会选择最接近下一个间隔但依然位于当前时钟指针范围的计时器）。要让计时器过期，主要涉及两个任务：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
计时器会被视为一种调度程序同步对象（在超时或直接等待的过程中，线程会在计时器上等待）。计时器上还会运行Wait-testing（等待测试）和
Wait-satisfaction（等待满足）算法，下文介绍同步的章节中还将详细介绍具体的工作方式。用户模式应用程序以及一些驱动程序就是通过这种
方法使用计时器的。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
计时器会被视为一种与DPC回调例程相关联的控制对象，计时器过期时将会执行该例程。该方法仅供驱动程序使用，可以针对计时器过期实现非常低延迟的响应
（等待/调度程序方法则需要通过各种额外的逻辑来实现等待信号）。此外，因为计时器过期本身是在DISPATCH_LEVEL级别执行的，DPC也运行在
该级别下，因此很适合充当计时器回调。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随着每个处理器被唤醒来处
理时钟间隔计时器，借此执行系统时间和运行时间的处理工作，当一个轻微的延迟/拖延后导致IRQL从CLOCK_LEVEL降低至
DISPATCH_LEVEL级别时，该过程中还会处理计时器的过期。图8-20展示了双处理器系统中的这一行为：其中实线箭头代表时钟中断的激发，而虚
线箭头代表在处理器具备相关计时器的情况下，可能需要进行的计时器过期处理工作。</span></p><div style="display: block;text-align:center;">
	<img width="894" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/100d427a938212928d46f12ba5d4ee3f.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-20 计时器的过期</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>处</b><b>理</b><b>器</b><b>的</b><b>选</b><b>择</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">插入计时器时还要做出一个
关键决定：选择适合的表，换句话说，就是选择最适合的处理器。首先，内核会检查计时器序列化是否被禁用。如果禁用，随后还会检查计时器的过期是否关联了
DPC。如果DPC已被关联到某个目标处理器，那么此时就会选择该处理器的计时器表。如果该计时器没有与其关联的DPC，或如果DPC未绑定至某个处理
器，则内核会扫描当前处理器组中所有尚未休止的处理器（有关内核休止的详细信息，请参阅卷1第4章）。如果当前处理器已休止，则会选择同一NUMA节点中
尚未休止且距离最接近的处理器，否则会使用当前处理器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种行为的本意是为了改善
Hyper-V服务器系统的性能与可伸缩性，但其实也有助于改善高负荷系统的性能。随着系统计时器的堆积（因为大部分驱动程序并不为自己的DPC设置关联
性），CPU 
0将变得越来越拥堵，有越来越多计时器过期代码需要执行，这会导致延迟增加，甚至导致DPC的处理产生极高延迟以及缺失。此外，计时器过期还可能导致与通
常负责驱动程序（例如网络数据包代码）中断处理的DPC产生竞争，这会导致整个系统速度受到影响。Hyper-V还会让这种情况进一步加剧，此时CPU 
0可能必须处理大量虚拟机所关联的计时器和相关DPC，而每个虚拟机都有自己的计时器和相关联的设备。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通过将计时器分散到多个处理器上（见图8-21），每个处理器的计时器过期负载即可完全由未休止的多个逻辑处理器来分摊。在32位系统中，计时器对象会将与自己关联的处理器的编号存储在调度程序头部；在64位系统中，则会存储在对象本身之内。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/f7d6def6e3502db7a3df95e87ca502e1.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-21 计时器队列行为</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种行为虽然能让服务器系
统大幅获益，但对客户端系统的影响通常并不会太大。此外，这会使得每个计时器的过期事件（例如时钟周期）变得更复杂，因为处理器可能已经闲置，但此时可能
依然关联了计时器，这就意味着该处理器依然需要接收时钟周期，甚至可能还需要扫描其他每个处理器的表。另外，因为多个处理器可能会同时取消和插入计时器，
这也意味着计时器的过期本质上属于一种异步行为，这可能并非始终是我们需要的。这种复杂性使得系统几乎无法实现新型待机
	<sup><img width="11" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="新型待机（Modern Standby）早期也叫Connected Standby，是Windows 8开始引入的一种全新节能模式，意在让计算机实现与手机等移动设备类似的“待机”和唤醒能力，并与手机一样在“待机”状态下维持网络连接，以接收各应用的推送通知。——译者注" title="新型待机（Modern Standby）早期也叫Connected Standby，是Windows 8开始引入的一种全新节能模式，意在让计算机实现与手机等移动设备类似的“待机”和唤醒能力，并与手机一样在“待机”状态下维持网络连接，以接收各应用的推送通知。——译者注" class="epub-footnote"></sup>所
需要的“复原阶段”（resiliency 
phase），因为无法保证始终使用同一个处理器来管理时钟。因此在客户端系统中，如果可使用新型待机功能，计时器序列化将被启用，此时无论何种情况，内
核始终将选择CPU 0。这也使得CPU 0在实际行为上成为默认的时钟所有者，该处理器将始终处于激活状态，以便随时选择时钟中断（具体请参见下文）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
该行为是由内核变量KiSerializeTimerExpiration控制的，这个变量会根据一个注册表设置进行初始化，服务器和客户端
Windows系统中，该设置使用了不同的值。通过在注册表
HKLM\SYSTEM\CurrentControlSet\Control\Session 
Manager\Kernel键下修改或创建一个名为SerializeTimerExpiration的值，并将其数值设置为“0”和“1”之外的其他
任何内容，即可禁用计时器序列化功能，进而使得计时器可以平均分配到不同的处理器。删除该值，或将其设置为“0”，可以让内核根据新型待机功能的可用性自
行决定是否使用计时器序列化。将其设置为“1”，可永久启用序列化，哪怕系统并不支持新型待机。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>系</b><b>统</b><b>计</b><b>时</b><b>器</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以使用内核调试器转储系统中当前已注册的计时器，以及每个计时器所关联的DPC（如果有的话）信息。具体的输出结果类似下列范例所示：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0: kd&gt; !timer </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Dump system timers </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Interrupt time: 250fdc0f 00000000 [12/21/2020 03:30:27.739] </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PROCESSOR 0 (nt!_KTIMER_TABLE fffff8011bea6d80 - Type 0 - High precision) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">List Timer             Interrupt Low/High Fire Time                  DPC/thread</span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PROCESSOR 0 (nt!_KTIMER_TABLE fffff8011bea6d80 - Type 1 - Standard) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">List Timer             Interrupt Low/High Fire Time                DPC/thread </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> 1 ffffdb08d6b2f0b0   0807e1fb 80000000 [         NEVER         ] thread ffffdb08d748f480</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> 4 ffffdb08d7837a20   6810de65 00000008 [12/21/2020 04:29:36.127] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> 6 ffffdb08d2cfc6b0   4c18f0d1 00000000 [12/21/2020 03:31:33.230] netbt!TimerExpiry</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                                                 (DPC @ ffffdb08d2cfc670)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   fffff8011fd3d8a8 A fc19cdd1 00589a19 [ 1/1/2100 00:00:00.054] nt!ExpCenturyDpcRoutine</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                                                 (DPC @ fffff8011fd3d868)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> 7 ffffdb08d8640440   3b22a3a3 00000000 [12/21/2020 03:31:04.772] thread ffffdb08d85f2080</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   ffffdb08d0fef300   7723f6b5 00000001 [12/21/2020 03:39:54.941] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                             FLTMGR!FltpIrpCtrlStackProfilerTimer (DPC @ ffffdb08d0fef340) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">11 fffff8011fcffe70   6c2d7643 00000000 [12/21/2020 03:32:27.052] nt!KdpTimeSlipDpcRoutine</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                                                  (DPC @ fffff8011fcffe30) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   ffffdb08d75f0180   c42fec8e 00000000 [12/21/2020 03:34:54.707] thread ffffdb08d75f0080</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">14 fffff80123475420   283baec0 00000000 [12/21/2020 03:30:33.060] tcpip!IppTimeout</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                                                  (DPC @ fffff80123475460) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">. . . </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">58 ffffdb08d863e280 P 3fec06d0 00000000 [12/21/2020 03:31:12.803] thread ffffdb08d8730080</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   fffff8011fd3d948 A 90eb4dd1 00000887 [ 1/1/2021 00:00:00.054] nt!ExpNextYearDpcRoutine</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                                                  (DPC @ fffff8011fd3d908) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">. . . </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">104 ffffdb08d27e6d78 P 25a25441 00000000 [12/21/2020 03:30:28.699] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                  tcpip!TcpPeriodicTimeoutHandler (DPC @ ffffdb08d27e6d38) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ffffdb08d27e6f10 P 25a25441 00000000 [12/21/2020 03:30:28.699] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                  tcpip!TcpPeriodicTimeoutHandler (DPC @ ffffdb08d27e6ed0) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">106 ffffdb08d29db048 P 251210d3 00000000 [12/21/2020 03:30:27.754] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                             CLASSPNP!ClasspCleanupPacketTimerDpc (DPC @ ffffdb08d29db088) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    fffff80122e9d110 258f6e00 00000000 [12/21/2020 03:30:28.575] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                   Ntfs!NtfsVolumeCheckpointDpc (DPC @ fffff80122e9d0d0) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">108 fffff8011c6e6560  19b1caef 00000002 [12/21/2020 03:44:27.661] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                 tm!TmpCheckForProgressDpcRoutine (DPC @ fffff8011c6e65a0) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">111 ffffdb08d27d5540 P  25920ab5 00000000 [12/21/2020 03:30:28.592] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                               storport!RaidUnitPendingDpcRoutine (DPC @ ffffdb08d27d5580) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ffffdb08d27da540 P  25920ab5 00000000 [12/21/2020 03:30:28.592] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                               storport!RaidUnitPendingDpcRoutine (DPC @ ffffdb08d27da580) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">. . . </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Total Timers: 221, Maximum List: 8 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Current Hand: 139 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
上述范例（为节省版面，有所省略）中，包含多个与驱动程序相关且很快即将过期的计时器，这些计时器分别关联至Netbt.sys和Tcpip.sys驱动
程序（均与网络功能有关）以及Ntfs（存储控制器驱动程序）。此外还有一些在后台负责清理工作的计时器即将过期，例如与电源管理、ETW、注册表刷新、
用户账户控制（UAC）虚拟化有关的计时器。另外，还有十几个计时器没有关联任何DPC，这些可能是等待调度的用户模式或内核模式计时器。我们可以针对线
程指针运行!thread命令来验证这一点。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">最后，Windows系统中还有三个始终存在的有趣计时器，这些计时器分别负责检查夏令时时区的变化、检查新年是否即将到来，以及检查新世纪是否即将到来。根据这些计时器过期时间的远近，除非在相关时间点即将到来时执行该实验，否则就可以很轻松地找出它们。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>计</b><b>时</b><b>器</b><b>时</b><b>钟</b><b>周</b><b>期</b><b>的</b><b>智</b><b>能</b><b>分</b><b>配</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">从图8-20所示的负责处
理时钟的ISR和过期计时器的处理器范例中可知，尽管并不存在相关联的过期计时器（虚线箭头），但处理器1依然会被唤醒多次（实线箭头）。虽然只要处理器
1处于运行状态就会体现出这样的行为（这是为了更新线程/进程运行次数和调度状态），但如果处理器1处于空闲状态（且不包含过期计时器）呢？它是否依然需
要处理时钟中断？上文曾经提到，此时唯一需要做的工作是更新整体系统时间/时钟周期，因此仅指定一个处理器作为时间维持处理器（本例中为处理器0）就已足
够，这样其他处理器就可以继续处于睡眠状态；如果这些处理器被唤醒，任何与时间有关的调整工作均可通过与处理器0重新同步来实现。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">实际上，Windows已
经实现了这样的目标（在内部这称为计时器时钟周期的智能分配），图8-22展示了处于此场景下的处理器状态，其中处理器1正在睡眠（与上文情况不同，当时
我们假定它正在运行代码）。图8-22中，处理器1只被唤醒了5次以处理自己的过期计时器，这就产生了更大的间隙（睡眠时段）。内核所使用的
KiPendingTimerBitmaps变量中包含一个由相关性掩码结构（affinity mask 
structure）组成的数组，该数组决定了哪个逻辑处理器需要按照特定计时器时钟指针（时钟周期间隔）接收时钟间隔。随后即可据此对中断控制器进行恰
当的编程，并确定将向哪些处理器发送IPI以发起计时器处理工作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">留出尽可能大的间隙，这一
点非常重要，这是由电源管理功能在处理器上的工作方式决定的：当处理器检测到工作负载即将越来越少时，它便会降低自己的能耗（P状态），直到自己最终处于
闲置状态。随后处理器可以选择性地将自身的部分电路关闭，逐渐进入更深度的闲置/睡眠状态，例如可能会关闭缓存。然而，处理器的再次唤醒需要耗费电力并花
费一定时间，因此，仅在当处理器处于特定状态下，在时间和能耗方面获得的好处超过进入并退出该状态所需的时间和能耗的情况下，设计者才会冒险让处理器进入
更深度的闲置/睡眠状态（C状态）。很明显，花费10ms进入某种睡眠状态但该状态只维持了1ms，这是一种很不合理的做法。通过防止时钟中断在（由于计
时器的存在而显得）非必要的时候唤醒睡眠中的处理器，才能让处理器在更长时间内处于更深度的C状态。</span></p><div style="display: block;text-align:center;">
	<img width="894" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/c586caf3b34cffa4014268dba7464908.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图8-22 应用于处理器1的计时器时钟周期智能分配</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>计</b><b>时</b><b>器</b><b>合</b><b>并</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在没有计时器将要过期的时
间里让睡眠中的处理器只产生最少量的时钟中断，这种做法虽然能大幅延长C状态的间隔，但在计时器粒度仅为15ms的情况下，很多计时器很可能会在任意时钟
指针范围内排队并频繁过期，哪怕处理器0也会遇到这种情况。减少软件计时器过期所产生的工作量，不仅有助于降低延迟（因为需要在
DISPATCH_LEVEL级别上执行的工作更少），同时可以让其他处理器在睡眠状态下维持更长时间（因为我们可以确信处理器被唤醒只是为了处理即将过
期的计时器，因此过期计时器的数量越少，在睡眠状态维持的时间就越长）。实际上，过期计时器的数量减少不仅会对睡眠状态（以及延迟）产生切实影响，还会对
这些计时器过期的周期性产生影响：6个计时器在同一个时钟指针范围内同时过期，这总好过6个计时器在6个不同时钟指针范围内过期。因此，为了全面优化闲置
时间的持续长度，内核需要通过一种合并（coalescing）算法将不同的计时器时钟指针合并为包含多个过期的同一个时钟指针。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">计时器合并生效依赖的一个
假设前提：对于大部分驱动程序和用户模式应用程序，它们并不非常关心自己计时器的确切激发时长（但某些多媒体应用程序除外）。随着原始计时器时长的增长，
这种“不关心”的范围也会扩大：一个本应每30s被唤醒一次的应用程序可能并不介意自己每31s或每29s被唤醒一次；而一个本应每1s轮询一次的驱动程
序，如果每1s外加50ms，或每1s减去50ms轮询一次，通常也不会造成太大的问题。大部分周期性计时器都依赖一个重要的保证：在某一特定范围内，自
己的激发时长可以保持固定不变。举例来说，如果一个计时器被更改为每1s外加50ms，那么它依旧可以永远在该范围内进行激发，而不会有时候以每2s，有
时候以每0.5s为间隔激发。然而，并非所有计时器可以合并为更粗粒度，因此Windows只会为标记为“可合并”的计时器启用该机制。计时器可通过
KeSetCoalescableTimer这个内核API或用户模式对应的SetWaitableTimerEx添加该标记。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">借助这些API，驱动程序
和应用程序开发者可以自由地为内核提供自己的计时器所能容忍的最大宽容度（或可容忍延迟），这个最大宽容度可理解为一段时间长度的最大值，当发出请求并等
待了这么长的时间后，计时器将依然能正确工作（在上文的例子中，那个1s计时器的宽容度是50ms）。推荐的最小宽容度为32ms，这对应了15.6ms
时钟周期的两倍，任何比这个数字更小的值实际上都不会导致任何合并，因为即将过期的计时器甚至已经无法从一个时钟周期移动到另一个时钟周期。无论指定怎样
的宽容度，Windows都会将计时器与四个首选合并间隔之一进行对齐，这四个首选合并间隔分别为1s、250ms、100ms以及50ms。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在为周期性计时器设置了可
容忍的延迟后，Windows会使用一种名为Shifting（挪动）的过程让该计时器在不同周期之间漂移，直到它与特定宽容度相关的首选合并周期中最优
化的周期间隔倍数保持对齐（随后该信息会被编码至调度程序的头文件中）。对于绝对计时器，则会扫描首选合并间隔列表，并根据距离调用方所指定的最大宽容
度，在最接近的可接受合并间隔内生成一个首选的过期时间。这种行为意味着绝对计时器会始终尽可能远离自己的实际过期时间点，这样可以让计时器尽可能地分
散，并为处理器提供更长的睡眠时间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于计时器的合并，我们可
以参考图8-20并假设所有计时器都指定了宽容度，因此是可以合并的。但在一种情况下Windows会决定合并计时器，如图8-23所示。请注意，处理器
1总共只收到了三个时钟中断，因此会导致闲置睡眠时间大幅延长，进而可以进入能耗更低的C状态。此外，处理器0上某些时钟中断需要执行的工作并不多，因此
在每个时钟中断时，可能会消除降低至DISPATCH_LEVEL级别所需的延迟。</span></p><div style="display: block;text-align:center;">
	<img width="894" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/30e7f527d4b6a8cce723f3601cc0c97c.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-23 计时器合并</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>增</b><b>强</b><b>计</b><b>时</b><b>器</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">首先，增强计时器的出现主
要是为了解决原本的计时器系统经过多次改进后依然无法解决的大量需求问题。例如，虽然计时器合并有助于降低能耗，但也会导致计时器产生不一致的过期时间，
哪怕是在根本无须降低能耗的情况下也是如此（换句话说，计时器合并是一种“全有或全无”的做法）。其次，Windows用于实现高精度计时器的唯一机制就
是让应用程序和驱动程序以全局形式降低时钟的时钟周期，但这种方式会对系统产生巨大的负面影响。出乎意料的是，尽管此时这类计时器的精度可能已经提高，但
实际上可能未必很精确，因为无论粒度精细到何种程度，常规的计时器过期操作依然可能会先于时钟的时钟周期而发生。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后，还请回忆卷1第6章介绍过的新型待机功能，这个功能引入了诸如计时器虚拟化和桌面活动审查器（Desktop Activity Moderator，DAM）
	<sup><img width="11" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="桌面活动审查器是Windows 8客户端系统引入的一个全新组件，主要用于当系统进入新型待机状态后暂停所有桌面应用程序的运行，并限制第三方系统服务的运行。——译者注" title="桌面活动审查器是Windows 8客户端系统引入的一个全新组件，主要用于当系统进入新型待机状态后暂停所有桌面应用程序的运行，并限制第三方系统服务的运行。——译者注" class="epub-footnote"></sup>等功能，在新型待机的复原阶段，这些功能会主动延迟计时器的过期，借此模拟S3的睡眠状态。但是在该阶段，依然需要允许一些重要的系统计时器活动定期运行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这三个需求催生了增强计时
器，这类计时器在内部称为Timer2对象，是由一些新增的系统调用（例如NtCreateTimer2和NtSetTimer2）或驱动程序API（例
如ExAllocateTimer和ExSetTimer）创建的。增强计时器支持四种行为模式，其中某些模式是互斥的：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·No-wake：此类增强计时器是对计时器合并进行的改进，可以提供原本只能在睡眠时段中使用的可容忍延迟。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·High-resolution：此类增强计时器对应于高精度计时器，但具备专属的精确时钟速率。时钟速率只需要在接近计时器到期时间时才需要以此速率运行。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Idle-resilient：此类增强计时器可以在深度睡眠状态（例如新型待机的复原阶段）下依然保持活跃状态。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Finite：此类增强计时器不包含上文所介绍的任何一种特性。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">High-
resolution计时器也可以是Idle 
resilient计时器，反之亦然。但Finite计时器无法具备上述任何一种特性。那么，如果Finite类型的增强计时器不包含任何“特殊”行为，
最初又为何创建这种类型的计时器？实际上，由于新增的Timer2基础架构是对自Windows内核最初开发时就已具备的老旧计时器逻辑的重写，因此，抛
开这些特殊功能不谈，它们还提供了其他一些好处：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·它使用了一种自平衡的红黑二叉树，而没有使用来自计时器表的链表。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·它允许驱动程序明确启用或禁用回调，而无须手动创建DPC。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·它为每个操作提供了全新并且更简洁的ETW跟踪项，这能对故障分析工作起到一定帮助。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·它通过某些指针混淆技术和额外的断言提供了更深入的安全性，从而强化了针对单纯以数据为目标的攻击和破坏行为的防御能力。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">因此，完全以Windows 8.1和后续版本系统为目标的驱动程序开发者，即使不需要这些额外的功能，也强烈建议使用全新的增强计时器基础架构。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 微软技术文档中提到的ExAllocateTimer 
API并不允许驱动程序创建Idle-resilient类型的计时器。实际上，这样的操作企图会导致系统崩溃。只有微软在系统中内置的驱动程序可以使用
ExAllocateTimerInternal 
API创建此类计时器。不建议读者使用该API创建计时器，因为内核维持了一个静态的硬编码列表，其中列出了所有已知的合法调用方，并要求调用方必须提供
唯一标识符对全过程进行跟踪，借此即可知道允许不同组件创建多少个此类计时器。任何违反该规则的操作都会导致系统崩溃（蓝屏死机）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">相比常规计时器，增强计时
器的过期规则也更复杂，因为这类计时器最终会面临两个可能的截止时间。第一个叫作最小截止时间（minimum due 
time），决定了允许该计时器过期的最早系统时钟时间；第二个叫作最大截止时间（maximum due 
time），代表该计时器应该过期的最晚系统时钟时间。Windows可以保证计时器会在这两个时间点间的某一刻过期，这可以是常规的时钟周期每个间隔
（例如15ms）所导致的，或者是因为对计时器过期操作的临时检查（例如当一个中断唤醒了闲置线程时）所导致的。该间隔通过将开发者传入的预期过期时间按
照所传入的“不唤醒容忍度”进行调整计算而来。如果指定了无限制的唤醒容忍度，那么计时器将不具备最大截止时间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">因此，一个Timer2对
象最多可以驻留在红黑二叉树的两个节点中：用于检查最小截止时间的节点0，以及用于检查最大截止时间的节点1。No-wake和High-
resolution计时器位于节点0内，而Finite和Idle-resilient计时器位于节点1内。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上文曾经提到这些属性有些
是可以合并的，那么这又该如何与两个节点配合生效？很明显，一个红黑二叉树是不够的，系统无疑需要更多这种二叉树，这也叫作集合（Collection，
详见公开的KTIMER2_COLLECTION_INDEX数据结构），上文提到的每一类增强计时器对应一个二叉树。随后，计时器可被插入节点0或节点
1，或同时插入这两者，或哪一个也不插入，这主要取决于表8-11中列出的规则与组合。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-11 计时器类型和节点集合索引</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/97f51d321a2d9f97ae65479add242022.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">节点1可以看成对默认的旧
版计时器行为创建的镜像：会在每个时钟周期里检查计时器是否即将过期。因此计时器只要位于节点1中，就注定会过期，这也暗示了其最小截止时间与其最大截止
时间是相同的。然而，有着无限容忍度的计时器是不会被放入节点1的，因为从技术的角度来看，只要CPU永远保持睡眠状态，这样的计时器将永远不过期。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">High-
resolution计时器则完全相反，系统会始终在此类计时器即将过期的“正确”时间点上进行检查，永远不会提前，因此它们会被放入节点0。然而，如果
它们准确的过期时间对于节点0中的检查而言“太早了”，那么也可能会放入节点1，此时它们会像常规（有限）计时器一样处理（也就是说，实际过期时间会比预
期时间略晚一些）。如果调用方提供了容忍度，系统处于闲置状态，并且产生了合并计时器的机会，则也有可能发生这种情况。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">类似地，对于Idle-
resilient计时器，如果系统并不处于复原阶段，那么此类计时器并不同时属于High-resolution计时器（这是增强计时器的默认状态），
将会位于NoWake集合中；其他情况下此类计时器将位于Hr集合中。然而，在需要检查节点1的时钟周期内，尽管系统可能处于深度睡眠状态，只有位于特殊
的Ir集合内的计时器才能被识别成为需要执行的计时器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种情况最初可能会令人感到困惑，但这种状态使得所有以合法方式合并的计时器在系统时钟周期内（节点1，强制实施最大截止时间）进行检查时，或在计算出的下一个最接近的截止时间（节点0，强制实施最小截止时间）进行检查时，能够表现出正确的行为。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当每个计时器被插入相应集
合（KTIMER2_COLLECTION）和相关联的一个或多个红黑树节点时，集合的下一个截止时间会被更新，变更为集合中任意一个计时器最早的截止时
间，此时可通过一个全局变量（KiNextTimer2Due）体现任意集合中任意一个计时器最早的截止时间。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>列</b><b>出</b><b>增</b><b>强</b><b>的</b><b>系</b><b>统</b><b>计</b><b>时</b><b>器</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以使用上文实验中曾经用到的内核调试器查看增强计时器（Timer2），它们会显示在输出结果的最末尾：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">KTIMER2s: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Address,          Due time,                            Exp. Type   Callback, Attributes, </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffffa4840f6070b0  1825b8f1f4 [11/30/2020 20:50:16.089] (Interrupt) [None] NWF (1826ea1ef4 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                                               [11/30/2020 20:50:18.089])</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffffa483ff903e48  1825c45674 [11/30/2020 20:50:16.164] (Interrupt) [None] NW P (27ef6380) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffffa483fd824960  1825dd19e8 [11/30/2020 20:50:16.326] (Interrupt) [None] NWF (1828d80a68 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                                               [11/30/2020 20:50:21.326]) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffffa48410c07eb8  1825e2d9c6 [11/30/2020 20:50:16.364] (Interrupt) [None] NW P (27ef6380) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffffa483f75bde38  1825e6f8c4 [11/30/2020 20:50:16.391] (Interrupt) [None] NW P (27ef6380) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffffa48407108e60  1825ec5ae8 [11/30/2020 20:50:16.426] (Interrupt) [None] NWF (1828e74b68 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                                               [11/30/2020 20:50:21.426]) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffffa483f7a194a0  1825fe1d10 [11/30/2020 20:50:16.543] (Interrupt) [None] NWF (18272f4a10 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                                               [11/30/2020 20:50:18.543]) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffffa483fd29a8f8  18261691e3 [11/30/2020 20:50:16.703] (Interrupt) [None] NW P (11e1a300) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffffa483ffcc2660  18261707d3 [11/30/2020 20:50:16.706] (Interrupt) [None] NWF (18265bd903 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                                               [11/30/2020 20:50:17.157]) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffffa483f7a19e30  182619f439 [11/30/2020 20:50:16.725] (Interrupt) [None] NWF (182914e4b9 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                                               [11/30/2020 20:50:21.725]) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffffa483ff9cfe48  182745de01 [11/30/2020 20:50:18.691] (Interrupt) [None] NW P (11e1a300) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffffa483f3cfe740  18276567a9 [11/30/2020 20:50:18.897] (Interrupt) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">               Wdf01000!FxTimer::_FxTimerExtCallbackThunk (Context @ ffffa483f3db7360) NWF</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                       (1827fdfe29 [11/30/2020 20:50:19.897]) P (02faf080)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffffa48404c02938  18276c5890 [11/30/2020 20:50:18.943] (Interrupt) [None] NW P (27ef6380)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffffa483fde8e300  1827a0f6b5 [11/30/2020 20:50:19.288] (Interrupt) [None] NWF (183091c835</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                                               [11/30/2020 20:50:34.288])</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffffa483fde88580  1827d4fcb5 [11/30/2020 20:50:19.628] (Interrupt) [None] NWF (18290629b5</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                                               [11/30/2020 20:50:21.628])</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
本例中，我们看到的主要是No-wake（NW）增强计时器，以及对应的最小截止时间。其中一些计时器是周期性的（P），会在过期时间里重新插入。此外，
一些计时器还具备最大截止时间，这意味着它们被指定了容忍度，可显示自己将会过期的最晚时间。最后，还有一个增强计时器关联了回调，这个计时器归WDF
（Windows Driver Foundation）框架所有（有关WDF驱动程序的更多信息请参阅卷1第6章）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_23" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>4</b><b>.</b><b>4</b><b> </b><b>系</b><b>统</b><b>工</b><b>作</b><b>线</b><b>程</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在系统初始化过程中，
Windows会在System进程中创建多个名为系统工作线程（system worker 
thread）的线程，这些线程的存在只是为了代表其他线程执行某些工作。很多情况下，运行于DPC/Dispatch级别的线程在执行函数时将只能在更
低的IRQL级别下执行。例如DPC例程，就可以在DPC/Dispatch这个IRQL级别下通过任意线程上下文执行（因为DPC的执行可以抢占系统中
的任意线程），该例程可能需要访问分页池，或等待使用调度程序对象将其与应用程序线程的执行保持同步。由于DPC例程无法降低IRQL，因此必须将此类处
理工作传递给能在低于DPC/Dispatch的IRQL级别下执行的线程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">一些设备驱动程序和执行体
组件会创建自己专用的线程，以便在被动级别上执行此类处理工作，然而，大部分情况下则会直接使用系统工作线程，这样可以避免系统中有额外线程时产生的非必
要调度以及内存开销。执行体组件可调用执行体函数ExQueueWorkItem或IoQueueWorkItem来请求系统工作线程的服务。设备驱动程
序只能使用后者（因为后者可将工作项（work 
item）关联给Device对象，进而实现更强的可追责能力，并能支持工作项处于活跃状态时驱动程序进行卸载操作这样的场景）。这些函数会将工作项放入
线程工作所需的队列调度程序对象中（队列调度程序对象的详细信息请参阅卷1第6章“I/O完成端口”一节）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">IoQueueWorkItemEx、
IoSizeofWorkItem、IoInitializeWorkItem以及IoUninitializeWorkItem这些API的行为也较为
相似，但它们会与驱动程序的Driver对象或自己的某一个Device对象创建关联。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">工作项包含一个指向例程的
指针以及一个参数，线程在处理工作项时可将这些内容传递给例程。需要以被动级别执行的设备驱动程序或执行体组件可实现该例程。举例来说，必须等待调度程序
对象的DPC例程可以初始化一个工作项，该工作项指向驱动程序中等待调度程序对象的例程。在某些阶段中，系统工作线程会从自己的队列中移除工作项并执行驱
动程序的例程。当驱动程序的例程执行完毕后，系统工作线程会检查是否还有更多的工作项等待处理。如果没有更多等待处理的工作项，系统工作线程会被阻塞，直
到新的工作项放入队列。在系统工作线程处理自己的工作项时，DPC例程可能已经执行完毕，但也可能尚未执行完毕。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统工作线程可分为多种类型：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·常规工作线程（normal worker thread），在优先级8级别下执行，其他方面的行为与延迟的工作线程类似。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·后台工作线程（background worker thread），在优先级7级别下执行，会继承与常规工作线程相同的行为。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·延迟的工作线程（delayed worker thread），在优先级12级别下执行，主要处理对时间要求不敏感的工作项。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·关键工作线程（critical worker thread），在优先级13级别下执行，主要用于处理对时间要求敏感的工作项。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·超关键工作线程（super-critical worker thread），在优先级14级别下执行，其他方面与关键工作线程类似。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·极关键工作线程（hyper-critical worker thread），在优先级15级别下执行，其他方面与关键工作线程类似。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·实时工作线程（real-time worker thread），在优先级18级别下执行，是唯一能在实时调度范围（详见卷1第4章）下运行的工作线程，这意味着此类工作线程不会受制于优先级提升或常规的时间切片。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于所有这些工作队列的命名方式开始让人感到混淆，较新版本的Windows引入了自定义优先级工作线程，建议所有驱动程序开发者使用这种新的工作线程，因为它可以让驱动程序传入自己的优先级级别。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统引导的早期阶段会调用
一个特殊的内核函数ExpLegacyWorkerInitialization，该函数可以为延迟的工作队列线程和关键工作队列线程设置初始数值，具体
数值则通过可选的注册表参数进行配置。大家可能在本书之前的版本中看到过相关的细节介绍，不过需要注意，这些变量的存在只是为了兼容外部编排工具，现代的
Windows 10系统和后续版本系统的内核从未真正使用过它们。这是因为较新的内核实现了一种名为Priority 
queue（KPRIQUEUE）的全新内核调度程序对象，将其与数量完全动态的内核工作线程结合在一起，并进一步将原本的单一工作线程队列拆分为每个
NUMA节点的工作线程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在Windows 
10和后续版本中，内核会根据需要动态创建额外的工作线程，默认的数量上限为4096个（可参阅
ExpMaximumKernelWorkerThreads），但可通过修改注册表设置将上限增大至最多16384个线程，或减少至最少32个。我们可
以在注册表HKLM\SYSTEM\CurrentControlSet\Control\Session 
Manager\Executive键下通过MaximumKernelWorkerThreads值修改该设置。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">我们在卷1第5章曾经介绍
过，每个分区对象都包含一个执行体分区，该分区也是与执行体（主要是系统工作线程逻辑）有关的分区对象的一部分。其中包含的一个数据结构可用于跟踪分区中
每个NUMA节点的工作队列管理器（队列管理器由死锁检测计时器、工作队列项收割器及指向实际执行管理工作的线程句柄组成）。此外，其中还包含一个指针数
组，这些指针指向了8个可能的工作队列（EX_WORK_QUEUE）中的每一个。这些队列会关联一个单独的索引，并跟踪最小线程（可保证的）和最大线程
的数量，以及截至目前已处理的工作项数量。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每个系统都包含两个默认工
作队列：ExPool队列和IoPool队列。前者主要被用到了ExQueueWorkItem 
API的驱动程序和系统组件所使用，后者主要适用于IoAllocateWorkItem类型的API。最后，最多还可以为内部系统定义额外的6个队列，
这些队列主要被内部（不可导出）的ExQueueWorkItemToPrivatePool 
API使用，使用了0～5的池标识符（因此对应的队列索引为2～7）。目前，仅内存管理器的存储管理器（详见卷1第5章）用到了这些功能。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">执行体会尽可能尝试着将关
键工作线程的数量与系统执行过程中不断变化的工作负载保持匹配。当工作项处理完毕或被加入队列后，会通过检查来判断是否需要新的工作线程。如果需要，则会
发送一个事件信号，唤醒相关NUMA节点和分区的ExpWorkQueueManagerThread。当遇到下列任一情况时，还会额外创建一个工作线
程：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·队列中线程数量少于最小线程数量。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·尚未达到最大线程数量，所有工作线程都在忙碌，但队列中依然有等待处理的工作项，或上一次尝试将工作项加入队列的操作企图失败了。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，对于每个工作队列管
理器（即每个分区上的每个NUMA节点），ExpWorkQueueManagerThread会以每秒一次的频率确定是否已经发生了死锁。这个死锁的具
体定义是：最后一个时间间隔内，排队的工作项数量增加，但所处理工作项的匹配数未增加。如果发生这种情况，系统将忽略任何线程数量的最大值限制，额外创建
一个工作线程，以便尽可能地清除潜在的死锁。随后这项检测工作会被禁用，直到系统认为有必要再次进行检测（例如达到线程数量最大值时）。由于处理器拓扑可
能因为热添加动态处理器而产生变化，因此这个额外创建的线程还负责更新处理器的相关性和数据结构，以便能继续跟踪新添加的处理器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后，每当经历了工作线程
的超时值分钟数两倍的时间后（默认超时值10分钟，因此也就是每20分钟一次），该线程还会检查自己是否需要摧毁任何系统工作线程。我们可以通过
WorkerThreadTimeoutInSeconds这个注册表值将默认超时值改为2～120分钟。这个过程也称收割（reaping），它保证了
系统工作线程数量不会失控。如果系统工作线程等待了很长时间（具体时间由工作线程超时值定义），并且没有依然在等待处理的工作项，那么该线程就会被收割
（这意味着当前线程数量会以一种及时的方式进行清理）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>列</b><b>出</b><b>系</b><b>统</b><b>工</b><b>作</b><b>线</b><b>程</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">不幸的是，由于系统工作线程每分区改组（reshuffling）功能的存在（已经不再像以前那样按NUMA节点进行，自然也就不再具备全局特性），内核调试器的!exqueue命令已经无法列出按照类型进行分类的系统工作线程列表，这样做将会直接出错。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">由于EPARTITION、EX_PARTITION以及EX_WORK_QUEUE数据结构均已包含在公开的符号中，因此可以使用调试器数据模型查看队列及其管理器。例如，我们可以这样查看主（默认）系统分区NUMA节点0工作线程管理器：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx ((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&amp;nt!PspSystemPartition)-&gt;ExPartition)-&gt;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    WorkQueueManagers[0] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&amp;nt!PspSystemPartition)-&gt;ExPartition)-&gt;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    WorkQueueManagers[0]     : 0xffffa483edea99d0 [Type:_EX_WORK_QUEUE_MANAGER *]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x000] Partition       : 0xffffa483ede51090 [Type:_EX_PARTITION *] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x008] Node            : 0xfffff80467f24440 [Type:_ENODE *] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x010] Event           [Type:_KEVENT] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x028] DeadlockTimer   [Type:_KTIMER] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x068] ReaperEvent     [Type:_KEVENT] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x080] ReaperTimer     [Type:_KTIMER2] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x108] ThreadHandle    : 0xffffffff80000008 [Type: void *] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x110] ExitThread      : 0x0 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x114] ThreadSeed      : 0x1 [Type: unsigned short] </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">或者这样查看NUMA节点0的ExPool，目前其中包含15个线程，并已处理了将近400万个工作项！</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx ((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&amp;nt!PspSystemPartition)-&gt;ExPartition)-&gt;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    WorkQueues[0][0],d </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&amp;nt!PspSystemPartition)-&gt;ExPartition)-&gt;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    WorkQueues[0][0],d       : 0xffffa483ede4dc70 [Type:_EX_WORK_QUEUE *] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x000] WorkPriQueue    [Type:_KPRIQUEUE] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2b0] Partition       : 0xffffa483ede51090 [Type:_EX_PARTITION *] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2b8] Node            : 0xfffff80467f24440 [Type:_ENODE *] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2c0] WorkItemsProcessed : 3942949 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2c4] WorkItemsProcessedLastPass : 3931167 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2c8] ThreadCount      : 15 [Type: long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2cc (30: 0)] MinThreads       : 0 [Type: long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2cc (31:31)] TryFailed        : 0 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2d0] MaxThreads       : 4096 [Type: long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2d4] QueueIndex       : ExPoolUntrusted (0) [Type:_EXQUEUEINDEX] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2d8] AllThreadsExitedEvent : 0x0 [Type:_KEVENT *] </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后即可通过WorkPriQueue的ThreadList字段枚举该队列关联的所有工作线程：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx -r0 @$queue = ((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&amp;nt!PspSystemPartition)-&gt;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ExPartition)-&gt;WorkQueues[0][0] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">@$queue = ((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&amp;nt!PspSystemPartition)-&gt;ExPartition)-&gt;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    WorkQueues[0][0]            : 0xffffa483ede4dc70 [Type:_EX_WORK_QUEUE *] </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx Debugger.Utility.Collections.FromListEntry(@$queue-&gt;WorkPriQueue.ThreadListHead,</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    "nt!_KTHREAD", "QueueListEntry") </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Debugger.Utility.Collections.FromListEntry(@$queue-&gt;WorkPriQueue.ThreadListHead,</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    "nt!_KTHREAD", "QueueListEntry") </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0x0]            [Type:_KTHREAD] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0x1]            [Type:_KTHREAD] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0x2]            [Type:_KTHREAD] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0x3]            [Type:_KTHREAD] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0x4]            [Type:_KTHREAD] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0x5]            [Type:_KTHREAD] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0x6]            [Type:_KTHREAD] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0x7]            [Type:_KTHREAD] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0x8]            [Type:_KTHREAD] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0x9]            [Type:_KTHREAD] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0xa]            [Type:_KTHREAD] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0xb]            [Type:_KTHREAD] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0xc]            [Type:_KTHREAD] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0xd]            [Type:_KTHREAD] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0xe]            [Type:_KTHREAD] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0xf]            [Type:_KTHREAD] </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">这只是ExPool的情况。别忘了系统中还有一个IoPool，它是这个NUMA节点（节点0）上的下一个索引（索引1）。我们可以继续通过实验查看其他私有池，例如存储管理器的池。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx ((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&amp;nt!PspSystemPartition)-&gt;ExPartition)-&gt;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    WorkQueues[0][1],d </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">((nt!_EX_PARTITION*)(*(nt!_EPARTITION**)&amp;nt!PspSystemPartition)-&gt;ExPartition)-&gt;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    WorkQueues[0][1],d        : 0xffffa483ede77c50 [Type:_EX_WORK_QUEUE *] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x000] WorkPriQueue     [Type:_KPRIQUEUE] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2b0] Partition        : 0xffffa483ede51090 [Type:_EX_PARTITION *] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2b8] Node             : 0xfffff80467f24440 [Type:_ENODE *] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2c0] WorkItemsProcessed : 1844267 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2c4] WorkItemsProcessedLastPass : 1843485 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2c8] ThreadCount      : 5 [Type: long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2cc (30: 0)] MinThreads       : 0 [Type: long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2cc (31:31)] TryFailed        : 0 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2d0] MaxThreads       : 4096 [Type: long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2d4] QueueIndex       : IoPoolUntrusted (1) [Type:_EXQUEUEINDEX] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x2d8] AllThreadsExitedEvent : 0x0 [Type:_KEVENT *]</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_24" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>4</b><b>.</b><b>5</b><b> </b><b>异</b><b>常</b><b>调</b><b>度</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">相比可能在任意时间产生的
中断，异常（exception）则是由运行中的程序的执行直接导致的某些状况。Windows使用了一种名为结构化异常处理（structured 
exception 
handling）的设施，可让应用程序控制异常的发生。随后，应用程序即可修复相应状况并返回异常发生时的状态，并解除堆栈（借此终止产生异常的子例程
的执行）或向系统告知异常未被识别，系统应该继续搜索可能处理该异常的异常处理程序。本节会假设读者已经熟悉Windows结构化异常处理背后的基本概
念。对于不熟悉的读者，建议首先阅读Windows SDK中有关Windows API参考文档的概述部分，或者阅读由Jeffrey 
Richter与Christophe Nasarre合作撰写的<span style="font-size:16px;font-style: oblique;font-family:'PingFang SC';"><i>W</i><i>i</i><i>n</i><i>d</i><i>o</i><i>w</i><i>s</i><i> </i><i>v</i><i>i</i><i>a</i><i> </i><i>C</i><i>/</i><i>C</i><i>+</i><i>+</i></span>一书（Microsoft Press，2007年）第23～25章的内容。另外请注意，虽然异常处理可通过语言扩展（例如Microsoft Visual C++中的__try构造）来访问，但这实际上是一种系统机制，因此与具体语言是无关的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在x86和x64处理器
上，所有异常都有预定义的中断号，该中断号直接对应指向特定异常陷阱处理程序的IDT中的项。表8-12列出了x86定义的异常以及所分配的中断号。由于
IDT中的第一个项已经被异常所使用，因此硬件中断会分配表中较为靠后的项，这一点在上文也有所提及。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-12 x86异常及其中断号</span></p><div style="display: block;text-align:center;">
	<img width="424" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b71e66dc726dcb9935e5eb390bab05e5.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="423" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e491454913f5e54d5d86e6b3bae240a8.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="425" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/58ed932565b12e920f0ff1fd3f52778b.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了简单到可以被陷阱处理
程序所处理的异常外，其他所有异常都是由一个名为异常调度程序（Exception 
Dispatcher）的内核模块提供服务的。异常调度程序的作用是查找可以处理异常的异常处理程序。内核定义了很多架构独立的异常，例如内存访问冲突、
整数除以零、整数溢出、浮点异常、调试器断点等。要查看架构独立异常的完整清单，请参阅Windows SDK参考文档。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内核陷阱及其处理程序会使用对用户程序来说透明的方式来处理某些异常。例如，在执行被调试的程序时遇到断点便会产生一个异常，内核会调用调试器处理这样的异常。但内核在处理某些其他异常时也会直接向调用方返回不成功的状态代码。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">少数异常可在未经改动的情
况下通过过滤回到用户模式。例如，某些类型的非法内存访问或算术溢出会生成操作系统无法处理的异常。32位应用程序可建立基于帧的异常处理程序来应对这些
异常。此处的“基于帧”是指异常处理程序是与特定过程（procedure）的激活关联在一起的。调用某个过程时，代表该过程激活的栈帧会被推送到栈上。
一个栈帧可关联一个或多个异常处理程序，其中每个异常处理程序负责保护源程序中特定的代码块。当发生异常时，内核会搜索与当前栈帧关联的异常处理程序。如
果没找到，则内核将搜索与上一个栈帧关联的异常处理程序，以此类推，直到找到基于帧的异常处理程序。如果依然未找到任何异常处理程序，则内核将调用自己的
默认异常处理程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于64位应用程序，结构
化的异常处理并不使用基于帧的处理程序（基于帧的技术已被证明很容易受到恶意用户攻击）。相反，应用程序编译过程中，会在映像中放置一个表，其中包含每个
函数的处理程序。内核会据此查找与每个函数关联的处理程序，这个过程使用了与上文介绍的32位代码处理方式相同的算法。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内核本身在内部大量使用了结构化异常处理，借此可以安全地确认来自用户模式的指针可以安全地执行读取或写入操作。驱动程序在处理运行I/O控制代码（IOCTL）时发送的指针也可以使用相同的技术。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">另一种异常处理机制叫作矢
量异常处理。仅用户模式应用程序可以使用该方法。有关该方法的详细信息可参阅Windows SDK或Microsoft 
Docs：https://docs.microsoft.com/windows/win32/debug/vectored-exception-
handling。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当异常（无论是软件显式产
生的异常还是硬件隐式产生的异常）发生时，会在内核中引发一系列连锁事件。CPU硬件会将控制权转交给内核陷阱处理程序，后者会（像出现中断时那样）创建
一个陷阱帧。在异常解决后，陷阱帧使得系统能够从之前的位置恢复。陷阱处理程序还会创建异常记录，其中包含了出现异常的原因和其他相关信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果异常出现在内核模式
下，异常调度程序会直接调用例程来查找能处理该异常的、基于帧的异常处理程序。由于未处理的内核模式异常会被视为致命的操作系统错误，因此我们可以假设调
度程序始终能找到异常处理程序。然而有些陷阱无法找到适合的异常处理程序，因为内核始终会假设此类错误是致命的，只有内核内部代码中非常严重的Bug或驱
动程序代码中极严重的不一致问题（这只能通过故意修改底层系统代码导致，驱动程序不应对此负责）才会导致此类错误。此类致命错误会导致系统进行错误检查
（Bug Check），并显示UNEXPECTED_KERNEL_MODE_TRAP错误代码。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果异常出现在用户模式
下，异常调度程序会以更精细的方式执行一些操作。Windows子系统有一个调试器端口（这实际上是一个调试器对象，下文很快将会介绍）和一个异常端口，
可用在Windows进程中接收来自用户模式异常的通知（此处的“端口”是指ALPC端口对象，下文将详细介绍）。内核会使用这些端口进行默认的异常处
理，如图8-24所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ebeb241768bc548ef90334e783aff695.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-24 异常的调度</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">调试器断点是异常的常见来
源。因此，异常调度程序所执行的第一个操作就是查看引起异常的进程是否关联了调试器进程。如果是，异常调度程序则会向该进程关联的调试器对象发送一条调试
器对象消息（在内部，系统会将其称为“端口”，这是为了兼容可能依赖Windows 2000中某些行为的程序，因为Windows 
2000使用了LPC端口而非调试对象）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果进程未附加调试器进
程，或者调试器无法处理该异常，那么异常调度程序会切换至用户模式，将该陷阱帧复制到格式为CONTEXT数据结构（详见Windows 
SDK）的用户栈中，并调用例程来查找结构化或矢量异常处理程序。如果未找到，或任何处理程序均无法处理该异常，异常分发程序则会重新切换回内核模式，并
再次调用调试器，以便让用户进一步执行调试操作（这个过程也叫二次通知，即Second-chance notification）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果调试器未运行并且未找
到用户模式的异常处理程序，内核会向与线程的进程相关联的异常端口发送一条消息。该异常端口（如果存在的话）是由控制该线程的环境子系统注册的。该异常端
口使得（大概率正在侦听该端口的）环境子系统有机会将异常转换为与该环境相关的信号或异常。然而，如果内核在异常的处理过程中已经进行到这种程度，并且子
系统并未处理异常，则内核会向Csrss（Client/Server Run-Time 
Subsystem，客户端/服务器运行时子系统）中用于Windows错误报告（WER，详见第10章）的系统范围内的错误端口发送一条消息，并执行默
认异常处理程序，随后直接终止导致该异常的线程所属的进程。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>未</b><b>经</b><b>处</b><b>理</b><b>的</b><b>异</b><b>常</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">所有Windows线程都
具备一个能处理“未经处理的异常”的异常处理程序。该异常处理程序是在Windows内部的Start-of-thread函数中声明的。当用户创建进程
或任何额外的线程时，便会运行Start-of-thread函数。该函数可调用初始线程上下文结构中所指定的、由环境提供的线程启动例程，随后这个例程
会进一步调用CreateThread所指定的、由用户提供的线程启动例程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内部Start-of-thread函数的通用代码如下所示：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">VOID RtlUserThreadStart(VOID) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">{ </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    LPVOID StartAddress = RCX; //Located in the initial thread context structure </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    LPVOID Argument = RDX; //Located in the initial thread context structure </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">       LPVOID Win32StartAddr; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    if (Kernel32ThreadInitThunkFunction != NULL) {</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Win32StartAddr = Kernel32ThreadInitThunkFunction; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    } else {</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Win32StartAddr = StartAddress; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    } </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   __try </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    { </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        DWORD ThreadExitCode = Win32StartAddr(Argument); </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        RtlExitUserThread(ThreadExitCode); </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    } </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   __except(RtlpGetExceptionFilter(GetExceptionInformation())) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    { </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        NtTerminateProcess(NtCurrentProcess(), GetExceptionCode()); </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    } </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">} </span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">请注意，如果线程包含自己
无法处理的异常，则会调用Windows未经处理的异常过滤器。该函数的作用是提供系统定义的行为，以便当存在未经处理的异常时能够启动
WerFault.exe进程。然而在默认配置下，第10章即将介绍的Windows Error 
Reporting（Windows错误报告）服务将处理该异常，因此这个未经处理的异常过滤器将永远不被执行。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>线</b><b>程</b><b>的</b><b>真</b><b>实</b><b>用</b><b>户</b><b>起</b><b>始</b><b>地</b><b>址</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">每个Windows线程都在系统提供的函数（而非用户提供的函数）中开始执行，这个事实解释了为何系统中每个Windows进程的线程0（以及第二个线程）的起始地址都是相同的。我们可以使用Process Explorer或内核调试器查看用户提供的函数地址。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">由
于Windows进程中的大部分线程都始于系统提供的一个包装器函数（wrapper 
function），在显示进程中线程的起始地址时，Process 
Explorer会跳过代表该包装器函数的初始调用帧，并直接显示该栈中的第二个帧。例如，请注意下图所示的Notepad.exe进程的线程起始地址。</span></p><div style="display: block;text-align:center;">
	<img width="614" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/45dbe54444d4af0567c209c30f15e028.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">当显示调用栈时，Process Explorer并不会显示完整的调用层次结构。请注意在点击Stack按钮后显示的结果。</span></p><div style="display: block;text-align:center;">
	<img width="614" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/48606623bb3f4a81c40c703b25c4dafd.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图中第20行是这个栈中的第一个帧，即内部线程包装器的起始位置。第二个帧（第19行）是环境子系统（本例中为Kernel32）的线程包装器，因为我们查看的是一个Windows子系统应用程序。第三个帧（第18行）则是Notepad.exe的主入口点。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">要
显示正确的函数名称，我们应该为Process Explorer配置合适的符号。为此首先需要安装调试工具，该工具已包含在Windows 
SDK或WDK中。随后应选择Options菜单中的Configure 
Symbols菜单项。dbghelp.dll路径应指向调试器工具文件夹中的文件（通常为C:\Program Files\Windows 
Kits\10\Debuggers，但请注意，位于C:\Windows\System32下的dbghelp.dll文件将无法工作），而
Symbols路径也需要正确配置，以便从微软的符号存储库将符号下载到本地文件夹。具体配置如下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="600" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3d82bc55ebfc0bfafc270aad77df8062.jpg" alt="" title=""></div>
</div><div class="header2"><h3><span id="sigil_toc_id_25" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>4</b><b>.</b><b>6</b><b> </b><b>系</b><b>统</b><b>服</b><b>务</b><b>处</b><b>理</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如图8-24所示，内核的
陷阱处理程序可以调度中断、异常和系统服务调用。8.4.5节已经介绍了中断和异常处理的工作过程，本节将介绍系统服务。系统服务的调度（见图8-25）
是通过执行分配给系统服务调度机制的指令所触发的。Windows用于系统服务调度的指令取决于执行时使用的处理器，以及是否启用了虚拟机监控程序代码完
整性（Hypervisor Code Integrity，HVCI），下文将介绍这些内容。</span></p><div style="display: block;text-align:center;">
	<img width="741" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/9f17c1b14857c6ce7dfb2dfde1d2b5e2.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-25 系统服务调度</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>架</b><b>构</b><b>性</b><b>系</b><b>统</b><b>服</b><b>务</b><b>调</b><b>度</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在大部分x64系统中，Windows使用了Syscall指令，这会导致我们在本章中介绍的一些关键处理器状态产生变化，具体变化则取决于某些预编程的特殊模块寄存器（MSR）：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·0xC0000081，也叫STAR（SYSCALL Target Address Register，SYSCALL目标地址寄存器）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·0xC0000082，也叫LSTAR（Long-Mode STAR，长模式STAR）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·0xC0000084，也叫SFMASK（SYSCALL Flags Mask，SYSCALL标记掩码）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当遇到Syscall指令时，处理器会执行下列操作：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·从STAR的第32位到第47位加载代码段（Code Segment，CS），Windows将其设置为0x0010（KGDT64_R0_CODE）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·从STAR的第32位到第47位加载栈段（Stack Segment，SS）并加上“8”，这就得到了0x0018（KGDT_R0_DATA）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
指令指针（Instruction 
Pointer，RIP）被保存到RCX中，并从LSTAR加载新值，如果未启用Meltdown（KVA影子）缓解措施，Windows会将其设置为
KiSystemCall64，否则会设置为KiSystemCall64Shadow。（有关Meltdown漏洞的详情请参阅上文“硬件侧信道漏
洞”一节。）</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·当前处理器标记（RFLAGS）被保存到R11中，随后使用SFMASK添加掩码，后者被Windows设置为0x4700（陷阱标记、方向标记、中断标记以及嵌套任务标记）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·栈指针（Stack Pointer，RSP）以及所有其他段（DS、ES、FS和GS）被保存在各自的当前用户空间值中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">因此，尽管指令的执行只占
用极少量的处理器周期，但确实会让处理器处于不安全且不稳定的状态：因为用户模式的栈指针依然处于载入状态，GS依然指向了TEB，但Ring级别（也就
是CPL）目前为“0”，从而会产生内核模式特权。Windows会快速做出反应，将处理器置于一致的操作环境中。除了可能在老式处理器上发生的与KVA
影子有关的操作外，KiSystemCall64必须精确执行如下这些步骤：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·通过使用swapgs指令，现在GS可以指向PCR，该过程在上文已进行了介绍。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·当前栈指针（RSP）会被保存至PCR的UserRsp字段。由于现在GS已被正确加载，因此无须使用任何栈或寄存器即可完成该操作。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·从PRCB（该结构会被保存为PCR的一部分）的RspBase字段加载新的栈指针。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">至此内核栈已成功加载，该
函数会使用上文介绍的格式构建一个陷阱帧。这个陷阱帧中包含了被设置为KGDT_R3_DATA（0x2B）的SegSs、来自PCR中UserRsp的
Rsp、来自R11的Eflags、被设置为KGDT_R3_CODE（0x33）的SegCs，以及来自RCX的Rip。通常来说，处理器陷阱设置了这
些字段，但是Windows必须根据syscall的运行模拟相关行为。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在从R10加载了RCX
后，一般来说，会由x64 
ABI要求将任意函数（包括Syscall）的第一个参数放置在RCX中，同时Syscall会要求使用调用方的指令指针重写RCX，这一点在上文中已经
介绍了。Windows可以感知到这种行为，并会在发出syscall指令前将RCX复制到R10。很快我们将介绍这步操作会还原相关的值。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后的操作与处理器的缓解
措施有关，例如监管人模式访问保护（Supervisor Mode Access 
Prevention，SMAP）（此时会发出Stac指令）以及各种处理器侧信道缓解措施（比如会清空分支跟踪缓冲区（Branch Tracing 
Buffer，BTB）或返回存储缓冲区（Return Store 
Buffer，RSB））。此外，对于支持控制流强制技术（Control-flow Enforcement 
Technology，CET）的处理器，还必须正确地同步线程的影子栈（shadow 
stack）。除此之外，陷阱帧的其他元素也会被存储起来，例如各种非易失寄存器和调试寄存器，随后开始对系统调用进行非架构性的处理。下面将详细讨论这
些内容。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">然而，并非所有的处理器都
是x64架构的，对于x86处理器还需要注意一些问题，例如，此时会使用一种名为Sysenter的指令。由于32位处理器已经越来越少见了，我们不准备
花费太多篇幅详细介绍该指令，但值得一提的是，该指令的行为是较为类似的：从多种MSR中加载处理器的某些状态，随后由内核执行一些额外的工作，例如设置
陷阱帧。更多信息可参阅Intel处理器的相关手册。类似地，ARM架构的处理器使用了Svc指令，该指令有着自己的行为和操作系统级别的处理方式，但目
前这些处理器在Windows总装机量中都只占据了很小的比例。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows还必须处理
另外一种情况：那些不具备基于模式的执行控制（Mode Base Execution 
Control，MBEC）功能的处理器，在启用虚拟机监控程序代码完整性（HVCI）的情况下，会由于设计上存在的问题导致无法做到HVCI所提供的承
诺（第9章将介绍HVCI和MBEC）。具体来说，攻击者可以分配用户空间的可执行内存，而HVCI允许这种做法（通过将相应的SLAT项标记为可执
行），进而导致PTE损坏（无法针对内核篡改提供保护），并让这块虚拟地址显示为内核页。在MMU看来，由于这个页面是内核页，监管人模式执行保护
（Supervisor Mode Execution 
Prevention，SMEP）机制将无法禁止代码的执行，又因为该页面最初是以用户物理页的形式分配的，所以SLAT项也将无法禁止其执行。借此攻击
者就可以随意执行任何内核模式代码，这违反了HVCI最基本的原则。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">MBEC及其同类技术（受
限用户模式，Restricted User 
Mode）通过在SLAT项的数据结构中引入不同的内核与用户可执行位解决了这个问题，以此可让虚拟机监控程序（或让安全内核通过VTL1特有的超调用）
将用户页标记为“内核不可执行但用户可执行”。遗憾的是，在不具备该功能的处理器上，虚拟机监控程序别无选择，只能用陷阱捕获所有代码特权级别的变更，并
在两组不同的SLAT项之间切换，其中一组会将所有用户物理页标记为不可执行，另一组会将其标记为可执行。虚拟机监控程序通过将IDT标记为空（借此可有
效地将其限制设置为0）和以解码底层指令的方式来捕获CPL变更，这种操作的开销很大。然而，因为中断可以直接被虚拟机监控程序用陷阱捕获，从而避免了这
些开销。因此，如果检测到启用HVCI的系统不具备MBEC这样的功能，那么用户空间中的系统调用调度代码往往会发出中断。共享用户数据（shared 
user data）结构中的SystemCall位（详见卷1第4章）将决定此时的具体处理。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">因此，当
SystemCall被设置为1时，x64 Windows会使用int 
0x2e指令，这会产生一个陷阱，包括一个无须操作系统参与的、完整构建的陷阱帧。有趣的是，此时使用的指令与Pentium 
Pro（奔腾Pro）之前的早期x86处理器所用的指令完全相同。为了与有着三十年以上历史的旧软件（一些此类软件中已经通过硬编码方式写入了这样的指
令）实现向后兼容性，x86系统依然支持这些指令。不过在x64系统中，只有在上述情况下可以使用0x2e，因为其他情况下内核并不会填充相关的IDT
项。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">无论最终使用哪种指令，用
户模式系统调用调度代码时，始终会将系统调用索引存储在一个寄存器中（x86和x64为EAX，32位ARM为R12，ARM64为X8），我们将通过接
下来介绍的非架构性系统调用处理代码进一步查看该索引。此外，为了进一步简化相关工作，标准函数调用处理器ABI（Application Binary
 
Interface，应用程序二进制接口）是跨边界维护的，例如，x86系统中的参数会放置在栈上，而x64系统中的RCX（由于受Syscall行为的
影响，从技术上来说其实应该是R10）、RDX、R8、R9会在该栈的基础上为这四者加上其他参数。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">调度完成后，处理器该如何
返回自己原先的状态呢？对于通过int 
0x2e进行的基于陷阱的系统调用，将由iret指令根据栈上的硬件陷阱帧来还原处理器状态。不过对于Syscall和Sysenter，处理器分别通过
名为Sysret和Sysexit的专用指令再次利用了我们之前在项上看到的MSR和硬编码寄存器。前者的具体行为如下所示：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·从STAR的第48～63位加载栈段（Stack Segment，SS），Windows将其设置为0x0023（KGDT_R3_DATA）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·从STAR的第48～63位加载代码段（Code Segment，CS）并为其加上0x10，这就得到了0x0033（KGDT64_R3_CODE）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·从RCX加载指令指针（RIP）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·从R11加载处理器标记（RFLAGS）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·栈指针（RSP）和其他段（DS、ES、FS与GS）依然保持当前的内核空间值。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">因此，与系统调用的进入一
样，退出机制也必须清理一些处理器状态。也就是说，RSP会从我们之前分析过的进入代码恢复到保存在制造商硬件陷阱帧中的Rsp字段，其他所有保存的寄存
器做法都是类似的。RCX寄存器将从保存的Rip加载，R11将从EFlags加载，swapgs指令会在发出sysret指令之前使用。由于DS、ES
和FS从未被触及，因此它们依然可以维持各自最初的用户空间值。最后，EDX以及XMM0到XMM5会被归零，所有其他的非易失性寄存器会在执行
sysret指令前从陷阱帧中还原。另外还会对Sysexit和ARM64的退出指令（eret）执行等效的操作。此外，如果启用了CET，那么与进入路
径类似，在退出路径上，影子栈也必须执行正确的同步。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>定</b><b>位</b><b>系</b><b>统</b><b>服</b><b>务</b><b>调</b><b>度</b><b>程</b><b>序</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如上文所述，x64系统调用会基于一系列MSR进行，而这些MSR均可使用调试器命令rdmsr查看。首先请注意STAR，其中显示了KGDT_R0_CODE（0x0010）和KGDT64_R3_DATA（0x0023）。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; rdmsr c0000081 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">msr[c0000081] = 00230010`00000000 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后即可开始调查LSTAR，接着就可以使用ln命令来查看它是否指向KiSystemCall64（对于不需要KVA影子的系统）或指向KiSystemCall64Shadow（对于需要KVA影子的系统）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; rdmsr c0000082 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">msr[c0000082] = fffff804`7ebd3740 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; ln fffff804`7ebd3740 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">(fffff804`7ebd3740) nt!KiSystemCall64 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">下面查看SFMASK，其中应包含我们之前介绍过的值：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; rdmsr c0000084 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">msr[c0000084] = 00000000`00004700 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">x86系统调用通过Sysenter进行，并使用了一组不同的MSR，包括0x176，其中存储了32位系统调用处理程序：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; rdmsr 176 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">msr[176] = 00000000'8208c9c0 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; ln 00000000'8208c9c0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">(8208c9c0)   nt!KiFastCallEntry </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在不具备MBEC但使用了HVCI的x86和x64系统中，可以使用调试器命令!idt 2e查看IDT中注册的int 0x2e处理程序：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; !idt 2e </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Dumping IDT: fffff8047af03000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">2e:            fffff8047ebd3040 nt!KiSystemService </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">还可以使用u命令反汇编KiSystemService或KiSystemCall64例程。对于中断处理程序，我们最终会注意到：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">nt!KiSystemService+0x227: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fffff804`7ebd3267 4883c408        add     rsp,8 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fffff804`7ebd326b 0faee8          lfence </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fffff804`7ebd326e 65c604255308000000 mov   byte ptr gs:[853h],0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fffff804`7ebd3277 e904070000      jmp     nt!KiSystemServiceUser (fffff804`7ebd3980)</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">而MSR处理程序会落入下列内容：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">nt!KiSystemCall64+0x227: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fffff804`7ebd3970 4883c408        add     rsp,8 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fffff804`7ebd3974 0faee8          lfence </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fffff804`7ebd3977 65c604255308000000 mov   byte ptr gs:[853h],0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">nt!KiSystemServiceUser: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fffff804`7ebd3980 c645ab02        mov      byte ptr [rbp-55h],2 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">由此可以看到，最终所有代码路径都将抵达KiSystemServiceUser，并由它跨越所有处理器执行大部分通用操作，具体过程将在下一节详细介绍。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>非</b><b>架</b><b>构</b><b>性</b><b>系</b><b>统</b><b>服</b><b>务</b><b>调</b><b>度</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如图8-25所示，内核会
使用系统调用编号，在系统服务调度表中定位系统服务信息。在x86系统中，该表类似于上文介绍过的中断调度表（interrupt dispatch 
table），只是其中的每一项都包含一个指向系统服务（而不是中断处理例程）的指针。在其他平台（包括32位的ARM和ARM64）上，该表的实现方式
略有差异，并不是包含指向系统服务的指针，而是包含与表本身相关的偏移量。这种寻址机制更适合x64和ARM64应用程序二进制接口（ABI）和指令编码
格式，也更符合ARM处理器的RISC本质特征。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 不同版本操作系统中的系统服务编号经常会发生变化，微软不仅会偶尔添加或删除系统服务，而且该表还经常会被随机化并乱序排列，这是为了让那些硬编码系统调用编号发起的攻击失效。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">无论什么架构，系统服务分发程序会在所有平台上执行一些通用操作：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·将额外的寄存器（如调试寄存器或浮点寄存器）保存在陷阱帧中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果线程属于一个微进程（pico process），则将其转发给系统调用的Pico提供程序例程（有关Pico提供程序的详情，请参阅卷1第3章）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果线程是一个UMS调度的线程，则会调用KiUmsCallEntry以便与主线程（primary thread）同步（有关UMS的详细介绍请参阅卷1第1章）。对于UMS主线程，会在线程对象中设置UmsPerformingSyscall标记。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·将系统调用的第一个参数存储到线程对象的FirstArgument字段，并将系统调用编号存储到SystemCallNumber。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·调用共享的用户/内核系统调用处理程序（KiSystemServiceStart），由它将线程对象的TrapFrame字段设置为自己所存储的当前栈指针。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·启用中断交付。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">至此，该线程开始正式经历
系统调用，其状态完全一致并且可以中断。接下来需要选择正确的系统调用表，并可能将线程升级为GUI线程，具体细节则取决于下一节将要介绍的线程对象中的
GuiThread和RestrictedGuiThread字段。随后只要TEB的GdiBatchCount字段非零，就会对GUI线程执行GDI批
处理操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统调用调度程序必须将未
通过寄存器（取决于CPU具体架构）传递的任何调用方参数从线程的用户模式栈复制到其内核模式栈。这是为了避免让每个系统调用手动复制参数（可能需要汇编
代码和异常处理），并确保内核访问参数时用户无法更改这些参数。该操作在一个特殊的代码块中完成，异常处理程序可以识别该代码块，并将其与用户栈的复制关
联在一起，这确保了在攻击者或存在Bug的程序扰乱用户栈后，内核依然不会崩溃。由于系统调用可以接受任意数量的参数（大部分情况下都是这样的），因此下
一节将讨论内核如何知道要复制多少个参数。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这里需要注意，这些参数复
制操作是浅层的：如果传递给系统服务的任何参数指向了用户空间中的缓冲区，则必须先探测是否能够安全地访问，随后内核模式的代码才能读取或写入该缓冲区。
如果缓冲区被多次访问，则可能需要将其捕获或复制到本地的内核缓冲区中。该探测和捕获操作是由每个系统调用分别进行的，并非由处理程序负责。然而系统调用
分发程序还必须执行一个关键操作：设置线程原本的模式（previous 
mode）。该模式的值可以是KernelMode或UserMode，当当前线程执行陷阱时，这个值必须实现同步，借此才可以识别传入异常、陷阱或系统
调用的特权级别。因此，系统调用可以使用ExGetPreviousMode正确地处理用户和内核调用方。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">调度程序的主体还要执行最
后两步操作。首先，如果配置了DTrace并启用了系统调用跟踪，则会围绕系统调用来调用相应的进入/退出回调。或者如果启用了ETW跟踪但未启用
DTrace，则会围绕系统调用记录相应的ETW事件。抑或DTrace或ETW均未启用，那么这个系统调用就不需要任何额外的逻辑。其次也是最后一步，
还需要让PRCB中的KeSystemCalls变量递增，该变量是以性能计数器的形式展现的，我们可以通过性能和可靠性监视器监视该计数器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">至此，系统调用调度已完成，随后在系统调用退出过程中还将执行相反的步骤。这些步骤会酌情还原并复制用户模式的状态，按需处理用户模式APC的交付，处理与各种架构缓冲区有关的侧信道缓解措施，并最终根据具体平台返回相应的CPU指令。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>内</b><b>核</b><b>发</b><b>出</b><b>的</b><b>系</b><b>统</b><b>调</b><b>用</b><b>调</b><b>度</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于系统调用可通过用户模式代码和内核模式代码执行，因此，任何指针、处理程序以及行为均应该被视为来自用户模式，很明显这是不对的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了解决这个问题，内核会
将这些调用导出为专用的Zw版本，也就是说，内核会导出为ZwCreateFile而非NtCreateFile。此外，由于Zw函数必须由内核手动导
出，因此，只有微软希望供第三方使用的API才能导出。例如，ZwCreateUserProcess就无法按照名称导出，因为内核驱动程序不应该启动用
户应用程序。这种导出的API实际上并非为相应的Nt版本简单创建的别名或包装器，它们是相应Nt系统调用的“蹦床”，并且使用了相同的系统调用调度机
制。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与
KiSystemCall64类似，它们也构建了一种假的硬件陷阱帧（在栈上推送CPU时收到来自内核模式的中断后生成的数据），并且与陷阱一样，它们也
禁用了中断。例如在x64系统中，KGDT64_R0_CODE（0x0010）选择器会作为CS来推送，而当前内核栈会作为RSP来推送。每个这种“蹦
床”会将系统调用编号放入相应的寄存器中（例如x86和x64系统中的EAX），再调用KiServiceInternal在陷阱帧中保存额外的数据，读
取当前的“原本的模式”并将其保存在陷阱帧中，随后将“原本的模式”设置为KernelMode（这是一个重大的差异）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>用</b><b>户</b><b>发</b><b>出</b><b>的</b><b>系</b><b>统</b><b>调</b><b>用</b><b>调</b><b>度</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如卷1第1章中介绍的那
样，Windows执行体服务所用的系统服务调度指令位于系统库Ntdll.dll中。子系统DLL可调用Ntdll中的函数来实现自己的公开功能。但
Windows 
USER和GDI函数（包括DirectX内核图形函数）属于例外，这些系统服务调度指令是在Win32u.dll中实现的，并未涉及
Ntdll.dll。这两种情况如图8-26所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/0c76237bd3115787c3660918ab159d87.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-26 系统服务调度</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如图8-26所示，
Kernel32.dll中的Windows WriteFile函数会导入并调用API-MS-Win- 
Core-File-L1-1-0.dll（这是一个MinWin重定向DLL，有关API重定向的详细信息请参阅卷1第3章）中的WriteFile函
数，随后会调用KernelBase.dll（实际实现的位置）中的WriteFile函数。在检查与子系统有关的一些参数后，会调用Ntdll.dll
中的NtWriteFile函数，该函数接下来执行相应指令来产生系统服务陷阱，并传递代表NtWriteFile函数的系统服务编号。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Ntoskrnl.exe
中的系统服务调度程序（本例中为KiSystemService）会调用真正的NtWriteFile来处理I/O请求。对于Windows 
USER、GDI和DirectX内核图形函数，系统服务调度会在Windows子系统可加载的内核模式部分（Win32k.sys）调用该函数，随后可
能会过滤系统调用或将其转发给相应的模块，例如桌面系统中的Win32kbase.sys或Win32kfull.sys，Windows 10X
	<sup><img width="11" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="Windows 10X是Windows 10时期，微软针对双屏幕设备（如双屏幕笔记本电脑，原本的键盘位置被另一块屏幕取代）开发的一种新操作系统。目前该项目已终止，但相关“遗产”已被融入Windows 11中（例如居中显示的开始菜单和任务栏按钮）。——译者注" title="Windows 10X是Windows 10时期，微软针对双屏幕设备（如双屏幕笔记本电脑，原本的键盘位置被另一块屏幕取代）开发的一种新操作系统。目前该项目已终止，但相关“遗产”已被融入Windows 11中（例如居中显示的开始菜单和任务栏按钮）。——译者注" class="epub-footnote"></sup>系统中的Win32kmin.sys或DirectX调用中的Dxgkrnl.sys。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>系</b><b>统</b><b>调</b><b>用</b><b>的</b><b>安</b><b>全</b><b>性</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于内核中包含正确同步系统调用操作的“原本模式”所需的机制，因此每个系统调用服务都可以在处理过程中依赖这个值。上文曾经提到，这些函数必须首先探测指向任何类型用户模式缓冲区的任何参数。这里的“探测”是指：</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）确保该地址低于MmUserProbeAddress，即比最高的用户模式地址低64KB（例如32位系统中的0x7FFF0000）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）确保该地址与调用方意图访问的数据边界对齐，例如Unicode字符为2字节，64位指针为8字节，以此类推。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）如果缓冲区要用于输出，还需要确保当系统调用开始时，该缓冲区实际上是可写的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">请注意，输出缓冲区可能会
在将来的任何时间点变为无效或只读，为了避免内核崩溃，系统调用必须始终使用本章上文介绍过的SEH访问输出缓冲区。出于类似原因，虽然系统不检查输入缓
冲区的可读性（因为无论如何，输入缓冲区都可能被迫投入使用），但必须使用SEH来确保输入缓冲区可以被安全地读取。而SEH并不能防止无法对齐或野内核
指针（wild kernel pointer）的情况，因此必须执行上文列出的前两个步骤。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">很明显，对任何内核模式调
用方进行上述第一项检查都会立即失败，而这也是“原本的模式”开始生效的第一个地方：对非用户模式的调用跳过探测操作，并假定所有缓冲区都是有效的、可读
取的或根据需要可写入的。然而，这并非系统调用唯一需要执行的验证类型，因为可能还会出现其他比较危险的情况：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
调用方可能提供了一个对象句柄。内核在引用对象时通常会绕过所有安全访问检查，并且内核还可以完整访问内核句柄（我们将在本章“对象管理器”一节详细介
绍），但用户模式代码并不会这样做。“原本的模式”可用于通知对象管理器依然需要执行访问检查，因为该请求来自用户空间。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·更复杂的情况下，驱动程序可使用诸如OBJ_FORCE_ACCESS_CHECK等标记来表明：尽管使用了Zw API（以此将原本的模式设置为KernelMode），但对象管理器依然需要像处理来自UserMode的请求那样对待该请求。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
同理，调用方可能已经指定了一个文件名。在打开文件时，系统调用可能会使用IO_FORCE_ACCESS_CHECKING标记迫使安全引用监视器验证
对文件系统的访问，这一点很重要，否则，诸如ZwCreateFile等调用有可能将“原本的模式”更改为KernelMode而绕过访问检查。如果驱动
程序需要代表来自用户空间的IRP创建文件，同样也需要这样做。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·对文件系统的访问也可能带来与符号链接或其他类型的重定向攻击有关的风险，此时高特权内核模式代码可能会错误地使用各种与特定进程有关或用户可访问的重分析点。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一般来说，对于使用Zw接口执行的任何会导致链式系统调用的操作都要注意，该操作会将“原本的模式”重置为KernelMode并酌情做出相应的响应。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>服</b><b>务</b><b>描</b><b>述</b><b>符</b><b>表</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上文曾经提到，在执行系统
调用前，必须由用户模式或内核模式的“蹦床”首先将系统调用编号放入处理器寄存器（如RAX、R12或X8）中。从技术角度来看，该编号包含两个元素，如
图8-27所示。第一个元素存储在低12位中，代表系统调用索引；第二个元素存储在接下来的2位（12～13）中，充当表标识符。很快我们将会介绍，借此
内核即可实现最多四种不同类型的系统服务，每种服务都存储在一个表中，而每个表最多可容纳4096个系统调用。</span></p><div style="display: block;text-align:center;">
	<img width="847" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e67424249ca73519ba62998ad2c3491f.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图8-27 系统服务编号与系统服务之间的转换</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内核会使用三个可能的数组
跟踪系统服务表，这三个数组分别为KeServiceDescriptorTable、KeServiceDescriptorTableShadow以
及KeServiceDescriptorTableFilter。每个数组最多包含两个项，其中存储了下列三类数据：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个指向该服务表所实现的系统调用数组的指针。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·该服务表中包含的系统调用数量，也称Limit（限制）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个指向该服务表中每个系统调用对应的参数字节数组的指针。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">第一个数组中始终只有一
项，指向了KiServiceTable和KiArgumentTable，其中可包含略多于450个系统调用（具体数量取决于Windows版本）。默
认情况下，所有线程都会发出仅访问该表的系统调用。在x86系统中，这是由线程对象中的ServiceTable指针强制执行的，其他所有平台则会将符号
KeServiceDescriptorTable硬编码到系统调用调度程序中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当线程发出的系统调用首次
超过限制时，内核会调用PsConvertToGuiThread，由此向Win32k.sys中的USER和GDI服务告知该线程的情况，并在成功返回
后设置线程对象的GuiThread标记或RestrictedGuiThread标记。具体设置哪个标记取决于是否启用了
EnableFilteredWin32kSystemCalls进程缓解选项（有关该选项的详细介绍请参阅卷1第7章）。在x86系统中，取决于具体设
置了哪个标记，随后线程对象的ServiceTable指针将会指向KeServiceDescriptorTableShadow或
KeServiceDescriptorTableFilter，其他平台上则在每个系统调用时选择一个硬编码的符号（虽然会对性能产生些许影响，但后一
种方式可避免产生容易被恶意软件滥用的挂钩点）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">大家可能已经猜到，其他数
组中包含了第二个项，该项代表了在Windows子系统Win32k.sys的内核模式部分所实现的Windows 
USER和GDI服务。在较新版本的Windows中，该项还代表了由Dxgkrnl.sys实现的DirectX内核子系统服务，不过最初这些服务是通
过Win32k.sys传输的。第二项会分别指向W32pServiceTable或W32pServiceTableFilter，以及
W32pArgumentTable或W32pArgumentTableFilter，这取决于Windows版本，可包含大约1250个或更多的系统
调用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
内核并不链接Win32k.sys，因此会导出一个KeAddSystemServiceTable函数，以便在尚未填写
KeServiceDescriptorTableShadow和KeServiceDescriptorTableFilter表时能够向这些表中添加
额外的项。如果Win32k.sys已经调用了这些API，该函数将会失效，并且一旦调用该函数，PatchGuard就会去保护数组，最终使其结构变为
只读状态。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Filter项之间唯一的
实质性区别在于，它们会使用诸如stub_UserGetThreadState这样的名称指向Win32k.sys中的系统调用，但实际的数组会指向
NtUserGetThreadState。前者的存根（Stub）在部分情况下会根据已为进程加载的过滤器集来检查是否为该系统调用启用了
Win32k.sys过滤。根据检查结果，如果过滤器集明确禁止，则调用会失败并返回STATUS_INVALID_SYSTEM_SERVICE，或最
终调用原始函数（例如NtUserGetThreadState），这种情况下如果启用了审核，则可能还会返回遥测结果。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">另一方面，参数表可以帮助
内核了解要将多少个栈字节从用户栈复制到内核栈，具体过程详见上文的“调度”一节。参数表中的每个项均对应具备该索引并且匹配的系统调用，其中还存储了要
复制的字节数量（最多255字节）。然而，x86系统之外其他所有平台的内核还采用了一种名为系统调用表压缩（system call table 
compaction）的机制，该机制可将调用表中的系统调用指针与参数表中的字节数组合成一个值。该功能的工作原理如下。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）获取系统调用函数指针，并从系统调用表本身开头处开始计算32位差值。由于该表是一个全局变量，位于包含了这些函数的同一个模块内，因此，±2GB的范围应该足够了。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）从参数表中获取栈字节数并将其除以4，以此将其转换为参数数量（某些函数可能采用8字节参数，但从目的的角度考虑，它们将被直接视为两个“参数”）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）将第1步得到的32位差值左移4位，最终使其成为28位差值（再次提醒，这样做没问题，因为没有内核组件会大于256MB）并执行按位或运算以添加第2步得到的参数数量。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）使用第3步获得的值重写系统调用函数指针。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种优化方式虽然乍看起来
并不好，但实际上有很多优点：通过避免在系统调用过程中在两个不同数组中查找减少了缓存的使用，减少了指针取消引用操作的数量，可充当一个混淆层进而使得
更难以针对系统调用表进行挂钩或修补操作，同时也让PatchGuard可以更容易地保护系统调用表。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>将</b><b>系</b><b>统</b><b>调</b><b>用</b><b>编</b><b>号</b><b>映</b><b>射</b><b>为</b><b>函</b><b>数</b><b>和</b><b>参</b><b>数</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们可以重现内核在处理系统调用ID时所进行的查找，以此了解哪个函数负责处理该过程以及总共需要多少个参数。在x86系统中，我们可以直接用调试器通过
dps命令转储每个系统调用表（如KiServiceTable），“dps”代表dump pointer 
symbol（转储指针符号），该命令可以代替我们进行查找。此外，也可通过db（dump 
bytes，转储字节）命令转储KiArgumentTable（或Win32k.sys中的任何系统调用表）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">不过根据上文介绍过的编码方式，更有趣的练习是在ARM64或x64系统中转储这些数据。为此请执行如下操作。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">1）只要撤销上文介绍过的压缩操作，即可转储特定的系统调用。获取基准表并将其添加至所需索引中存储的28位偏移量，如下所示，其中内核系统表中的系统调用3会显示为NtMapUserPhysicalPagesScatter：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; ?? ((ULONG)(nt!KiServiceTable[3]) &gt;&gt; 4) + (int64)nt!KiServiceTable </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">unsigned int64 0xfffff803`1213e030 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; ln 0xfffff803`1213e030 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">(fffff803`1213e030) nt!NtMapUserPhysicalPagesScatter </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">2）通过获取4位的参数数量，即可看到该系统调用所接收的基于栈的4字节参数数量：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx (((int*)&amp;(nt!KiServiceTable))[3] &amp; 0xF) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">(((int*)&amp;(nt!KiServiceTable))[3] &amp; 0xF) : 0 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">3）请注意，这并不意味着该系统调用没有参数。因为这是x64系统，调用可以接受0～4之间任意数量的参数，而所有参数都位于寄存器（RCX、RDX、R8和R9）中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">4）我们还可通过调试器数据模型，使用投射创建LINQ谓词并转储整个表，因为KiServiceLimit变量对应了服务描述符表中相同的限制字段（正如影子描述符表中Win32k.sys的W32pServiceLimit项）。输出结果应类似如下所示：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx @$table = &amp;nt!KiServiceTable </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">@$table = &amp;nt!KiServiceTable : 0xfffff8047ee24800 [Type: void *] </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx (((int(*)[90000])&amp;(nt!KiServiceTable)))-&gt;Take(*(int*)&amp;nt!KiServiceLimit)-&gt;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     Select(x =&gt; (x &gt;&gt; 4) + @$table) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">(((int(*)[90000])&amp;(nt!KiServiceTable)))-&gt;Take(*(int*)&amp;nt!KiServiceLimit)-&gt;Select</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     (x =&gt; (x &gt;&gt; 4) + @$table)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   [0]              : 0xfffff8047eb081d0 [Type: void *] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   [1]              : 0xfffff8047eb10940 [Type: void *] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   [2]              : 0xfffff8047f0b7800 [Type: void *] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   [3]              : 0xfffff8047f299f50 [Type: void *] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   [4]              : 0xfffff8047f012450 [Type: void *] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   [5]              : 0xfffff8047ebc5cc0 [Type: void *] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   [6]              : 0xfffff8047f003b20 [Type: void *] </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">5）我们还可以使用该命令更复杂的版本将指针转换为对应的符号形式，本质上，这等于重新实现了适用于x86 Windows的dps命令：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx @$symPrint = (x =&gt; Debugger.Utility.Control.ExecuteCommand(".printf \"</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    %y\\n\"," + </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ((unsigned__int64)x).ToDisplayString("x")).First()) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">@$symPrint = (x =&gt; Debugger.Utility.Control.ExecuteCommand(".printf \"%y\\n\"," +</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">((unsigned__int64)x).ToDisplayString("x")).First()) </span></p>
</div><div class="header0"><h1><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h1></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx (((int(*)[90000])&amp;(nt!KiServiceTable)))-&gt;Take(*(int*)&amp;nt!KiServiceLimit)-&gt;Select</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    (x =&gt; @$symPrint((x &gt;&gt; 4) + @$table)) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">(((int(*)[90000])&amp;(nt!KiServiceTable)))-&gt;Take(*(int*)&amp;nt!KiServiceLimit)-&gt;Select(x =&gt;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">@$symPrint((x &gt;&gt; 4) + @$table)) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0]              : nt!NtAccessCheck (fffff804`7eb081d0) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [1]              : nt!NtWorkerFactoryWorkerReady (fffff804`7eb10940) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [2]              : nt!NtAcceptConnectPort (fffff804`7f0b7800) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [3]              : nt!NtMapUserPhysicalPagesScatter (fffff804`7f299f50) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [4]              : nt!NtWaitForSingleObject (fffff804`7f012450) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [5]              : nt!NtCallbackReturn (fffff804`7ebc5cc0) </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">6）如果只对内核的服务表感兴趣，但对Win32k.sys项不感兴趣，也可以使用调试器的!chksvctbl -v命令，让输出结果包含所有这些数据，同时以此检查可能被Rootkit附加的内联挂钩：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; !chksvctbl -v </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">#    ServiceTableEntry        DecodedEntryTarget(Address)               CompactedOffset</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">=======================================================================================</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0    0xfffff8047ee24800                 nt!NtAccessCheck(0xfffff8047eb081d0) 0n-52191996</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">1    0xfffff8047ee24804    nt!NtWorkerFactoryWorkerReady(0xfffff8047eb10940) 0n-51637248</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">2    0xfffff8047ee24808           nt!NtAcceptConnectPort(0xfffff8047f0b7800) 0n43188226</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">3    0xfffff8047ee2480c nt!NtMapUserPhysicalPagesScatter(0xfffff8047f299f50) 0n74806528</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">4    0xfffff8047ee24810         nt!NtWaitForSingleObject(0xfffff8047f012450) 0n32359680</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>系</b><b>统</b><b>服</b><b>务</b><b>活</b><b>动</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以通过观察System对象的System Calls/Sec性能计数器来监视系统服务活动。打开性能监视器，点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>监</b><b>视</b><b>工</b><b>具</b></span>”下的“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>性</b><b>能</b><b>监</b><b>视</b><b>器</b></span>”，随后点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>添</b><b>加</b></span>”按钮将计数器添加到图表即可。请选择System对象，选中System Calls/Sec计数器，随后点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>添</b><b>加</b></span>”按钮将其加入图表。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可能还要增大图表的最大值，因为系统中的常态是每秒进行数十万个调用，系统配备的处理器越多，调用数量就越多。下图显示了这些数据在本书作者的计算机上所呈现的样子。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/1c31b44c1af1768a74c2e43ba7280f41.jpg" alt="" title=""></div></div>
	<p style="page-break-after: always;">
</p><div id="Chapter08_0005.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_26" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>5</b><b> </b><b>W</b><b>o</b><b>W</b><b>6</b><b>4</b><b>（</b><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>-</b><b>o</b><b>n</b><b>-</b><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>）</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">WoW64（64位
Windows中模拟的Win32环境）是指用于在64位平台（属于不同的CPU架构）上执行32位应用程序的软件。WoW64最初是一个研究项目，旨在
让旧版Windows NT 
3.51的Alpha和MIPS版本能够运行x86代码。自那时（1995年前后）起，该技术经历了巨大的变化。当微软公司于2001年发布64位
Windows XP版本时，WoW64就已包含在该系统中，借此即可用新的64位操作系统运行旧的x86 
32位应用程序。在现代Windows版本中，WoW64通过进一步扩展，已经可以支持在ARM64系统中运行ARM32和x86应用程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">WoW64核心以一系列用
户模式DLL的形式实现，并由内核提供部分支持，进而创建出通常只有64位原生数据结构才会包含的目标架构版本，例如处理器环境块（Process 
Environment Block，PEB）和线程环境块（Thread Environment 
Block，TEB）。内核还实现了通过Get/SetThreadContext更改WoW64上下文的功能。负责WoW64的核心用户模式DLL包括
以下几方面：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Wow64.dll：
在用户模式下实现了WoW64核心。它所创建的精简的软件层可充当32位应用程序的一种中间内核，并可以此为基础进行仿真模拟。它还可处理CPU上下文状
态更改以及由Ntoskrnl.exe导出的基础系统调用，并负责实现文件系统重定向和注册表重定向。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Wow64win.dll：为Win32k.sys导出的GUI系统调用实现了形式转换（thunking）。Wow64win.dll和Wow64.dll均包含形式转换代码，可将与调用有关的约定从一种架构转换为另一种架构。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">其他模块是特定架构专用
的，主要用于对隶属于不同架构的机器代码进行转换。某些情况下（如ARM64），机器代码需要进行模拟或实时编译（jitting）。本书中我们将使
用“jitting”这个词代表即时编译（just-in-time 
compilation）技术，该技术可在运行过程中编译一小块代码（名叫“编译单元”），而无须每次模拟并执行一条指令。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">机器代码的转换、模拟或实时编译主要由下列DLL负责，随后这些代码即可在目标操作系统中运行：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Wow64cpu.dll：实现了在AMD64操作系统中运行x86 32位代码的CPU模拟器，负责管理WoW64中每个运行中线程的32位CPU上下文，为从32位到64位（以及反向）的CPU模式切换提供处理器架构支持。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Wowarmhw.dll：实现了在ARM64系统中运行ARM32（AArch32）应用程序的CPU模拟器，这实际上是与x86系统中Wow64cpu.dll等效的ARM64组件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Xtajit.dll：
实现了在ARM64系统中运行x86 
32位应用程序的CPU模拟器。其中包含一个完整的x86模拟器、一个实时编译器（负责编译代码），以及实时编译器与XTA缓存服务器之间的通信协议。实
时编译器可创建编译块，其中包含从x86映像转换后的ARM64代码。这些编译块会存储在本地缓存中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">WoW64用户模式库以及其他核心WoW64组件之间的关系如图8-28所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/151696557d25d5fca1a7969c42228b71.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-28 WoW64架构</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 针对安腾（Itanium）架构计算机设计的老版本Windows包含了一个集成在WoW64层中的完整x86模拟器，名为Wowia32x.dll。安腾处理器无法以高效的方式原生执行x86 32位指令，因此需要模拟器介入。安腾架构已于2019年1月正式退役。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">较新的Windows Insider版还支持在ARM64系统上执行64位x86代码，微软针对此行为还设计了一套全新的实时编译器。然而，在ARM系统中模拟AMD64代码并非通过WoW64进行的。AMD64模拟器架构的相关介绍已超出了本书的内容范围。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_27" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>5</b><b>.</b><b>1</b><b> </b><b>W</b><b>o</b><b>W</b><b>6</b><b>4</b><b>核</b><b>心</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如上一节所述，
WoW64核心是独立于平台的：它创建了一个软件层，借此可管理32位代码在64位操作系统中的执行。实际的转换工作由特定于具体平台的另一个名为模拟器
（simulator，也叫二进制转换器）的组件负责。本节将讨论WoW64核心的作用及其与模拟器互操作的方式。虽然WoW64的核心几乎完全在用户模
式下实现（位于Wow64.dll库中），但其中也有一部分位于NT内核中。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>N</b><b>T</b><b>内</b><b>核</b><b>中</b><b>的</b><b>W</b><b>o</b><b>W</b><b>6</b><b>4</b><b>核</b><b>心</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在系统启动（阶段1）过程
中，I/O管理器会调用PsLocateSystemDlls例程，借此将系统可支持的所有系统DLL映射至System进程用户地址空间（并将其基址存
储在一个全局数组中）。其中还包含WoW64版本的Ntdll，如表8-13所示。在进程管理器（PS）开始启动的阶段2期间，会解析内部内核变量中所存
储的DLL的某些入口点。其中的一个导出项LdrSystemDllInitBlock用于将WoW64信息和函数指针传递给新的WoW64进程。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-13 不同的Ntdll版本列表</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/aaa52dca38a2caa70552938eba739b64.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当进程最初被创建时，内核
会使用一种算法来决定该进程是否可以在WoW64下运行，该算法会分析主进程是否可执行PE映像，并检查系统中是否映射了正确版本的Ntdll。如果系统
确定该进程是WoW64进程，当内核初始化其地址空间时，就会同时映射原生版本的Ntdll和正确的WoW64版本Ntdll。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如卷1第3章所述，每个
非最小进程都有一个可从用户模式访问的PEB数据结构。对于WoW64进程，内核也会分配32位版本的PEB，并将指向它的指针存储在一个小型数据结构
（EWoW64PROCESS）中，该数据结构会链接到代表新进程的主EPROCESS结构。随后内核会填充由32位版本的
LdrSystemDllInitBlock符号所描述的数据结构，包括由Wow64 Ntdll导出的指针。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在为进程分配线程时，内核
会经历类似的过程：除了线程的初始用户栈（其初始大小可通过主映像的PE头指定），还要分配执行32位代码所需的另一个栈。这个新栈也叫线程的WoW64
栈。在为线程构建TEB时，内核会分配足够容量的内存，以便同时存储64位TEB以及随后的32位TEB。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，在基础的64位栈之
上还会分配一个小型数据结构（名为WoW64 CPU Area Information，WoW64 
CPU区域信息）。后者包含目标映像机器标识符、一个与平台相关的32位CPU上下文（X86_NT5_CONTEXT或ARM_CONTEXT数据结
构，具体取决于目标架构），以及一个指向每线程WoW64 
CPU共享数据的指针，这些内容都可被模拟器使用。指向这个小型数据结构的指针还会存储在线程的TLS插槽1中，以供二进制转换器快速引用。图8-29展
示了只包含一个初始单线程的WoW64进程的最终配置。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>用</b><b>户</b><b>模</b><b>式</b><b>W</b><b>o</b><b>W</b><b>6</b><b>4</b><b>核</b><b>心</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了上一节描述的各种差异
外，对于非WoW64进程，进程及其初始线程的诞生方式完全相同，但从主线程调用原生版本Ntdll中的加载器初始化函数LdrpInitialize并
开始执行的那一刻起，情况开始发生变化。当检测到该线程是新进程的上下文中第一个开始执行的线程后，加载器会调用进程初始化例程
LdrpInitializeProcess，并结合其他多个因素（详情请参阅卷1第3章“进程初始化的早期工作”一节）来判断该进程是否为WoW64进
程，而具体依据为检查是否存在32位TEB（位于原生TEB之后，会与原生TEB链接在一起）中。如果检查发现存在32位TEB，那么原生Ntdll会将
内部全局变量UseWoW64设置为1，进而构建WoW64核心库（wow64.dll）的路径，并将其映射至4GB虚拟地址空间限制之上的位置（这样就
不会干扰为该进程模拟的32位地址空间）。随后Ntdll会获取负责处理进程/线程挂起、APC与异常调度的WoW64函数的地址，并将该地址存储在某些
内部变量中。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3c679fc5baf5e729a160c58d2bf9430f.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图8-29 只包含一个线程的WoW64进程的内部配置</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当进程初始化例程结束后，
Windows加载器会通过导出的Wow64LdrpInitialize例程将执行过程转换至WoW64核心，随后永远不会返回。至此，每个新线程都将
通过该入口点启动（而无须使用传统的RtlUserThreadStart）。WoW64核心会在TLS插槽1处获得指向内核存储的CPU 
WoW64区域的指针。如果该线程是进程中的第一个线程，则会调用WoW64进程初始化例程，该例程会执行如下操作：</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）尝试加载WoW64 Thunk Logging DLL（wow64log.dll）。该DLL用于记录WoW64调用，但并未包含在商业版的Windows版本中，因此可直接跳过。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）通过NT内核填充的LdrSystemDllInitBlock查找Ntdll32基址和函数指针。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）初始化文件系统和注册表重定向。文件系统和注册表重定向是在WoW64核心的Syscall层实现的，可拦截32位注册表和文件系统的请求，转换其路径，随后再调用原生的系统调用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）初始化WoW64服务表，该表中包含指向NT内核与Win32k GUI子系统所属系统服务的指针（类似于标准内核系统服务），并包含Console与NLS服务（均为WoW64系统服务调用，本章下文将介绍重定向）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">5）填充NT内核为该进程
分配的32位版本的PEB，并根据进程主映像架构加载正确的CPU模拟器。系统会查询
HKLM\SOFTWARE\Microsoft\Wow64\&lt;arch&gt;键的“默认”注册表值（其中的&lt;arch&gt;可以是
x86或arm，这取决于目标架构），该值包含模拟器的主DLL名称。随后将模拟器载入并映射至进程的地址空间。模拟器主DLL的部分导出函数经过解析会
存储在一个名为BtFuncs的内部数组中。该数组是将与平台相关的二进制转换器及WoW64子系统链接在一起的关键：WoW64仅通过它调用模拟器的函
数。例如，BtCpuProcessInit函数就代表了模拟器的进程初始化例程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">6）形式转换跨进程机制通过分配并映射一个16KB的共享内存节来完成初始化。当一个WoW64进程调用一个以另一个32位进程为目标的API时（该操作会在不同进程之间传播形式转换操作），会产生一个合成的工作项。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">7）WoW64层会（通过调用导出的BtCpuNotifyMapViewOfSection）通知模拟器主模块以及32位版本的Ntdll已被映射至地址空间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">8）WoW64核心会将指向32位系统调用调度程序的指针存储在32位版本Ntdll导出的Wow64Transition变量中，这样系统调用调度程序就可以正常工作了。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当进程初始化例程运行完毕
时，线程就准备好开始进行CPU模拟了。线程会调用模拟器的线程初始化函数并准备一个全新的32位上下文，并转换最初由NT内核填充的64位上下文。最
后，还会根据新的上下文准备32位栈，以便执行32位版本LdrInitializeThunk函数。模拟操作是通过模拟器的BTCpuSimulate
导出函数启动的，该函数永远不会返回至调用方（除非模拟器中发生严重错误）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_28" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>5</b><b>.</b><b>2</b><b> </b><b>文</b><b>件</b><b>系</b><b>统</b><b>重</b><b>定</b><b>向</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了维持兼容性，并减少从
Win32向64位Windows移植应用程序的工作量，不同版本的系统目录名称是完全一致的。因此\Windows\System32文件夹中包含了原
生的64位映像。WoW64在拦截所有系统调用时，会对与路径有关的所有API进行转换，并将多种系统路径替换为WoW64的等价路径（主要取决于目标进
程的架构），具体如表8-14所示。该表还列出了通过使用系统环境变量进行重定向的路径（例如%PROGRAMFILES%变量会将32位应用程序设置为
\Program Files (x86)，会将64位应用程序设置为\Program Files文件夹）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-14 WoW64重定向的路径</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/8f1e1da301eff26a52f83d01793fd6ff.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">出于兼容性和安全性方面的原因，\Windows\System32的几个子目录不受重定向的影响，这样32位应用程序对它们的访问实际上会直接访问这些子目录本身。这些不被重定向的子目录包括：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·%windir%\system32\catroot和%windir%\system32\catroot2</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·%windir%\system32\driverstore</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·%windir%\system32\drivers\etc</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·%windir%\system32\hostdriverstore</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·%windir%\system32\logfiles</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·%windir%\system32\spool</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后，WoW64还提供了
一种机制，借此可通过Wow64DisableWow64FsRedirection与Wow64RevertWow64FsRedirection函
数，以每个线程为基础控制内置于WoW64中的文件重定向。该机制会在TLS的“索引8”处存储启用/禁用值，WoW64的内部RedirectPath
函数会参考该值。不过该机制可能会让延迟加载的DLL产生一些问题（例如通过通用文件对话框打开文件甚至在软件的国际化方面），因为一旦禁用了重定向，系
统在内部加载期间也将不再使用重定向，这会导致某些仅64位的文件面临无法找到的情况。对开发者而言，此时一种更安全的方法是使
用%SystemRoot%\Sysnative路径，或者上文提及的那些始终保持一致的路径。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
由于某些32位应用程序可能确实需要能够感知并处理64位映像，此时可让源自32位应用程序的任何I/O访问虚拟目录
\Windows\Sysnative，以避免被文件重定向。该目录实际上并不存在，这是一个虚拟路径，可供应用程序（即使是WoW64下运行的应用程
序）访问真正的System32目录。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_29" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>5</b><b>.</b><b>3</b><b> </b><b>注</b><b>册</b><b>表</b><b>重</b><b>定</b><b>向</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">应用程序和组件会将自己的配置数据存储在注册表中。组件通常会在安装过程中的注册环节将自己的配置数据写入注册表。如果同一个组件分别被安装并注册为32位和64位二进制文件，那么后注册的组件将覆盖先注册的组件，因为它们会写入注册表的同一个位置。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了在无须更改32位组件
代码的情况下以透明的方式解决此问题，注册表被分为两部分：Native和WoW64。默认情况下，32位组件会访问注册表的32位视图，64位组件会访
问注册表的64位视图。这就为32位和64位组件提供了一种安全的执行环境，并能将32位应用程序的状态与64位应用程序的状态（如果存在的话）分隔开。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如下文“系统调用”中将
要介绍的那样，WoW64系统调用层可拦截由32位进程发出的所有系统调用。当WoW64拦截可以打开或创建注册表键的注册表系统调用时，它会将键路径转
换为指向注册表的WoW64视图（除非调用方明确要求访问64位视图）。借助多种树状数据结构，WoW64可跟踪重定向后的注册表键，这些树状数据结构中
存储了共享的和拆分的注册表键与子键列表（锚点树节点定义了系统该从什么位置开始重定向）。WoW64会在下列这些位置重定向注册表：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·HKLM\SOFTWARE</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·HKEY_CLASSES_ROOT</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">并非注册表的上述整个根配
置单元（Hive）都是拆分的。属于这些根键的子键可以存储在注册表中私有的WoW64部分内（此时的子键就是一种拆分键）。否则子键可在32位和64位
应用程序之间共享（此时的子键是一种共享键）。在锚节点所跟踪的每个拆分键下，WoW64会创建一个名为WoW6432Node（针对x86应用程序）或
WowAA32Node（针对ARM32应用程序）的键。该键中存储了32位配置信息。注册表的所有其他部分（例如HKLM\SYSTEM）均是32位和
64位应用程序共享的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">作为一种额外措施，如果
x86 
32位应用程序向注册表写入以数据“%ProgramFiles%”或“%CommonProgramFiles%”开头的REG_SZ或
REG_EXPAND_SZ值，WoW64会将实际的值改
为“%ProgramFiles(x86)%”和“%CommonProgramFiles(x86)%”，以便匹配文件系统重定向以及上文介绍的相关布
局。但为了符合这种情况，32位应用程序必须严格写入上述这些字符串，其他任何数据都会被忽略并正常写入。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于需要将注册表键明确指定为某种视图的应用程序，可以为RegOpenKeyEx、RegCreateKeyEx、RegOpenKeyTransacted、RegCreateKeyTransacted以及RegDeleteKeyEx函数设置下列标记：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·KEY_WoW64_64KEY：从32位或64位应用程序中明确打开64位键，禁用上文提到的REG_SZ或REG_EXPAND_SZ拦截措施。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·KEY_WoW64_32KEY：从32位或64位应用程序中明确打开32位键。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_30" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>5</b><b>.</b><b>4</b><b> </b><b>A</b><b>M</b><b>D</b><b>6</b><b>4</b><b>平</b><b>台</b><b>上</b><b>的</b><b>x</b><b>8</b><b>6</b><b>模</b><b>拟</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">AMD64平台上的x86
模拟器（Wow64cpu.dll）接口相当简单。模拟器进程初始化函数会根据是否存在软件MBEC（Mode Based Execute 
Control，基于模式的执行控制，详见第9章）而启用快速系统调用接口。当WoW64核心通过调用模拟器的接口BtCpuSimulate开始模拟
时，模拟器会（根据WoW64核心提供的32位CPU上下文）构建WoW64栈帧，为快速系统调用的调度初始化Turbo形式转换数组，并准备FS段寄存
器使其指向线程的32位TEB。最后，它还会设置一个以32位段（通常是0x20段）为目标的调用门（call 
gate），切换栈，并发起到最终32位入口点的远跳（首次执行时，入口点会设置为32位版本的LdrInitializeThunk加载器函数）。当
CPU执行该远跳时，会检测到调用门的目标为一个32位段，因此会将CPU执行模式改为32位。只有在调度了中断或系统调用后，代码的执行才会退出32位
模式。有关调用门的详细信息请参阅Intel与AMD的软件开发手册。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 当首次切换至32位模式时，模拟器会使用IRET操作码而不进行远调用（far call）。这是因为所有32位寄存器，包括易失性寄存器和EFLAGS都需要初始化。</span></p>
</div><div class="header2"><h3><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>系</b><b>统</b><b>调</b><b>用</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于32位应用程序，
WoW64层的行为与NT内核本身类似：特殊的32位版Ntdll.dll、User32.dll以及Gdi32.dll均位于
\Windows\Syswow64文件夹中（这里还有其他负责进程间通信的DLL，例如Rpcrt4.dll）。当一个32位应用程序需要操作系统的协
助时，会直接调用这些位于特殊的32位版操作系统库中的函数。与相应的64位版等价物类似，操作系统例程可以直接在用户模式下执行自己的任务，或者也可以
请求NT内核的协助。在后一种情况下，需要通过存根（stub）函数（例如常规64位Ntdll中实现的函数）调用系统调用。存根会将系统调用索引放入一
个寄存器中，但存根并不发出原生的32位系统调用指令，而是会（通过WoW64核心所编译的Wow64Transition变量）调用WoW64系统调用
调度程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">WoW64系统调用调度程
序是在与特定平台相关的模拟器（wow64cpu.dll）中实现的。它会发出另一个远跳以便转换至原生64位执行模式，随后从模拟中退出。二进制转换器
会将栈切换至64位模式并保存CPU原本的上下文。随后会捕获与系统调用相关的参数并对其进行转换。这种转换过程也叫“形式转换”（thunking），
借此通过32位ABI执行的机器代码就可以与64位代码实现互操作。调用过程的相关约定（由ABI描述）定义了数据结构、指针和值在每个函数参数中传递的
方法以及通过机器代码访问的方法。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">模拟器中的形式转换主要通
过两种策略执行。对于无须与客户端所提供的复杂数据结构进行交互操作（但需要处理简单的输入/输出值）的API，将由Turbo形式转换（模拟器中实现的
一种小型转换例程）负责转换并直接调用原生64位API。其他复杂的API需要Wow64SystemServiceEx例程的协助，由该例程从系统调用
索引中提取正确的WoW64系统调用编号，并调用正确的WoW64系统调用函数。WoW64系统调用是在WoW64核心库和Wow64win.dll中实
现的，与原生系统调用同名，但名称包含“wh-”前缀（例如NtCreateFile这个WoW64 API可通过whNtCreateFile调用）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">正确完成转换后，模拟器会发出相应的原生64位系统调用。当原生系统调用返回后，WoW64会在必要时对任何输出参数进行转换或形式转换，将其从64位格式转换为32位格式，并重新启动模拟过程。</span></p>
</div><div class="header2"><h3><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>异</b><b>常</b><b>调</b><b>度</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">与WoW64系统调用类
似，异常调度也会迫使CPU退出模拟。当发生异常时，NT内核会确定该异常是否由执行用户模式代码的线程所产生。如果是，NT内核会在活跃栈上构建一个扩
展的异常帧，并通过返回到64位Ntdll中的用户模式KiUserExceptionDispatcher函数来调度该异常。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">请注意，异常产生时，64
位异常帧（其中包含捕获的CPU上下文）会被分配到当时处于活动状态的32位栈中。因此需要在调度到CPU模拟器之前对其进行转换。这正是
Wow64PrepareForException函数（由WoW64核心库导出）所起的作用：在原生64位栈上分配空间，并将原生异常帧从32位栈复制
到64位栈中。随后它会切换至64位栈，并将原生异常和上下文记录转换为相应的32位形式，将结果存储到32位栈中（取代64位异常帧）。至此，
WoW64核心即可从32位版的KiUserExceptionDispatcher调度程序函数重启模拟，通过与原生32位Ntdll相同的方式调度异
常。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">32位用户模式APC交付
也遵循了类似的实现方式。常规的用户模式APC可通过原生Ntdll的KiUserApcDispatcher进行交付。当64位内核即将向WoW64进
程调度用户模式APC时，它会将32位APC地址映射至64位地址空间中更高的范围。随后64位Ntdll将调用WoW64核心库所导出的
Wow64ApcRoutine例程，借此捕获用户模式的原生APC和上下文记录，并将其重新映射回32位栈。随后它会准备一个32位用户模式APC和上
下文记录，并通过32位版的KiUserApcDispatcher函数重启CPU模拟，进而使用与原生32位Ntdll相同的方式调度APC。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_31" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>5</b><b>.</b><b>5</b><b> </b><b>A</b><b>R</b><b>M</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">ARM是一系列精简指令集
计算（Reduced Instruction Set Computing，RISC）架构，最初由ARM 
Holding公司设计而来。与英特尔公司和AMD公司不同，该公司主要设计CPU的架构并将其授权给其他公司（例如高通和三星），由获得授权的公司生产
CPU成品。因此ARM架构包含很多发行版和版本，经过近些年的快速发展，已从1993年发布的ARMv3版本所实现的简单的32位CPU快速发展至目前
的ARMv8。最新的ARM64v8.2 
CPU可原生支持多种执行模式（或状态），最常见的模式包括AArch32、Thumb-2以及AArch64：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·AArch32是最经典的执行模式，该模式下的CPU仅执行32位代码，可使用32位寄存器，通过32位总线从主内存读/写数据。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Thumb-2执行模式属于AArch32模式的一个子集。Thumb指令集旨在提高低功耗嵌入式系统的代码密度。在该模式下，CPU可以混合执行16位和32位指令，同时依然可访问32位寄存器和内存。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·AArch64是现代执行模式。该执行模式下的CPU可以访问64位通用寄存器，并通过64位总线从主内存读/写数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">适用于ARM64的
Windows 
10系统可运行于AArch64或Thumb-2执行模式下（一般不使用AArch32）。Thumb-2主要适用于之前的Windows 
RT系统。ARM64处理器的当前状态是由当前异常级别（Exception 
Level，EL）决定的，该级别定义了不同的特权级：ARM目前定义了三个异常级别和两个安全状态。本书的第9章将详细介绍这些内容，此外也可参阅
ARM架构参考手册。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_32" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>5</b><b>.</b><b>6</b><b> </b><b>内</b><b>存</b><b>模</b><b>型</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在“硬件侧信道漏洞”一
节，我们曾提到缓存一致性协议（cache coherency 
protocol）的概念，这种协议保证了在被多个处理器访问时，可从一个CPU的核心缓存中观察到相同的数据（MESI就是一种知名的缓存一致性协
议）。与缓存一致性协议类似，现代CPU还需要提供内存一致性（或排序）模型，以解决多处理器环境中的另一个问题：内存重排序（memory 
reordering）。一些架构（例如ARM64）确实可以自由地对内存访问进行重排序，这是为了更高效地使用内存子系统并实现内存访问指令的并行运行
（可在访问慢速内存总线时实现更好的性能）。此类架构遵循了一种弱内存模型，这与遵循强内存模型的AMD64架构截然不同，AMD64架构中的内存访问指
令一般会按照程序顺序来执行。弱模型可以让处理器以更高效的方式更快速地访问内存，但这会为多处理器软件的开发带来很多与同步有关的问题。作为对比，强模
型更直观也更稳定，但其不足在于速度太慢。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">可以进行内存重排序（即遵
循弱模型）的CPU提供了一些可充当内存屏障的机器指令。屏障可以防止处理器对屏障前后的内存访问进行重排序，有助于解决多处理器系统的同步问题。内存屏
障速度很慢，因此只在Windows中的关键多处理器代码严格需要这种功能时才会使用，尤其是在基元（如自旋锁、互斥、推锁）的同步过程中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">下一节将会介绍，在多处理
器环境中转换x86代码时，ARM64的实时编译总是会用到内存屏障。但实际上，该过程并不能推断将要执行的代码是否可以由多个线程同时并行执行（因此可
能会产生同步问题。x86遵循强内存模型，因此不会遇到重排序问题。上一节也从通用的角度介绍了乱序执行问题）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 除了CPU，内存重排序也会对编译器产生影响。在编译过程中，出于效率和速度方面的原因，编译器可以重排序（并可能移除）源代码中的内存引用。这种重排序也叫编译器重排序，而上文所描述的主要是处理器重排序。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_33" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>5</b><b>.</b><b>7</b><b> </b><b>A</b><b>R</b><b>M</b><b>6</b><b>4</b><b>平</b><b>台</b><b>上</b><b>的</b><b>A</b><b>R</b><b>M</b><b>3</b><b>2</b><b>模</b><b>拟</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">ARM64下模拟
ARM32应用程序的方式与AMD64下模拟x86的方式极为类似。如上一节所述，ARM64v8 
CPU能够在AArch64和Thumb-2执行状态之间动态切换（因此可以直接通过硬件执行32位指令）。然而与AMD64系统不同，该CPU无法在用
户模式下通过某种特殊指令切换执行模式，因此需要WoW64层来调用NT内核以请求切换执行模式。为此需要使用ARM-on-ARM64 
CPU模拟器（Wowarmhw.dll）导出的BtCpuSimulate函数将非易失AArch64寄存器保存到64位栈中，还原WoW64 
CPU区域中存储的32位上下文，并最终发出一个明确定义的系统调用（该调用具备一个无效的Syscall编号：−1）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NT内核异常处理程序（在
ARM64架构中，该异常处理程序也是Syscall处理程序）检测到由于系统调用而引发了异常，因此将检查Syscall编号。如果该编号是特殊
的“−1”，NT内核就知道该请求是因为来自WoW64的执行模式变更所引发的。此时，NT内核会调用KiEnter32BitMode例程，借此将更低
的EL（异常级别）的新执行状态设置为AArch32，消除异常，然后返回到用户模式。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后，代码会在AArch32状态下开始执行。与AMD64系统的x86模拟器类似，只有在引发异常或调用了系统调用的情况下，执行控制才会返回给模拟器。异常与系统调用的调度方式均与AMD64中的x86模拟器完全相同。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_34" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>5</b><b>.</b><b>8</b><b> </b><b>A</b><b>R</b><b>M</b><b>6</b><b>4</b><b>平</b><b>台</b><b>上</b><b>的</b><b>x</b><b>8</b><b>6</b><b>模</b><b>拟</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">x86-on-ARM64
 
CPU模拟器（Xtajit.dll）与上文介绍的其他二进制转换器均不相同，这主要是因为它无法通过硬件直接执行x86指令。ARM64处理器完全无法
理解任何x86指令。因此x86-on-ARM模拟器实现了一套完整的x86模拟器和实时编译器，借此转换AArch64代码中的x86操作码块，并直接
执行转换后的代码块。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在为新的WoW64进程调
用模拟器进程初始化函数（BtCpuProcessInit）时，会将
HKLM\SOFTWARE\Microsoft\Wow64\x86\xtajit路径与主进程映像的名称相结合，为该进程构建实时编译器的主注册表
键。如果该键已存在，则模拟器会从中查询多种配置信息（最常用的信息包括多处理器兼容性和JIT块阈值大小。请注意，模拟器还会通过应用程序的兼容性数据
库查询配置信息）。随后模拟器会分配并编译Syscall页面，顾名思义，该页面会用于发出x86 
Syscall（随后在Wow64Transition变量的影响下，该页面会被链接至Ntdll）。至此，模拟器即可确定该进程是否可以使用XTA缓
存。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">模拟器使用两种缓存来存储
预编译的代码块：为每个线程分配的内部缓存，其中包含模拟器在编译供线程执行的x86代码过程中生成的代码块（这些代码块也叫实时编译块）；由
XtaCache管理的外部XTA缓存，其中包含由XtaCache服务为x86映像延迟生成的所有实时编译的块。每个映像的XTA缓存存储在一个外部缓
存文件（下面将介绍相关信息）中。进程初始化例程还会分配CHPE位图，该位图涵盖可能被32位进程使用的整个4GB地址空间。这个位图可以使用一位来代
表包含CHPE代码的内存页面（下文还将详细讨论CHPE）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">模拟器线程初始化例程
（BtCpuThreadInit）初始化编译器，并在原生栈上分配每个线程的CPU状态，原生栈是一个包含每线程编译器状态的重要数据结构，其中包括
x86线程上下文、x86代码发射器（Emitter）状态、内部代码缓存，以及模拟x86 CPU的配置（段寄存器、FPU状态、模拟的CPUID）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>模</b><b>拟</b><b>器</b><b>的</b><b>映</b><b>像</b><b>加</b><b>载</b><b>通</b><b>知</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与任何其他二进制转换器不
同，当新映像被映射到进程地址（包括CHPE Ntdll）空间时，x86-on-ARM64 
CPU模拟器必须接收到通知。这是通过WoW64核心实现的，在从32位代码中调用NtMapViewOfSection这个原生API时，它可以进行拦
截，并通过导出的BTCpuNotifyMapViewOfSection例程通知Xtajit模拟器。这种通知功能很重要，因为模拟器需要据此更新内部
编译器数据，例如：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·CHPE位图（当目标映像包含CHPE代码页时，需要将位设置为1来进行更新）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·内部模拟的CFG（Control Flow Guard，控制流防护）状态。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·映像的XTA缓存状态。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">尤其是当新加载一个x86
或CHPE映像时，模拟器需要（通过注册表和应用程序兼容性填充码）决定是否为该模块使用XTA缓存。如果检查成功，模拟器会向XtaCache服务请求
更新后的映像缓存，借此更新全局每个进程的XTA缓存状态。如果XtaCache服务可以识别并打开该映像更新后的缓存文件，则可向模拟器返回一个节对
象，该节对象可用于加速映像的执行（节中包含预编译的ARM64代码块）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>编</b><b>译</b><b>的</b><b>混</b><b>合</b><b>可</b><b>移</b><b>植</b><b>可</b><b>执</b><b>行</b><b>文</b><b>件</b><b>（</b><b>C</b><b>H</b><b>P</b><b>E</b><b>）</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在ARM64环境中实时编
译x86进程是一项充满挑战性的工作。为了保证应用程序的响应性，编译器必须保留足够的性能。而最主要的问题之一在于两种架构的内存排序机制有很大差异。
x86模拟器并不知道原始x86代码是如何设计的，因此不得不在x86映像每次访问内存时频繁用到内存屏障。执行内存屏障，这本身就是一个速度缓慢的操
作，平均来说，很多应用程序大约40%的时间都会用于运行操作系统代码。这意味着如果无须模拟操作系统库，那么将会显著改善应用程序的性能。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这些因素催生了编译的混合
可移植可执行文件（Compiled Hybrid Portable 
Executable，CHPE）机制。CHPE二进制文件是一种特殊的混合可执行文件，其中同时包含可兼容x86和ARM64的代码，而这些代码是在完
全了解原始源代码的情况下生成的（编译器非常确切要在哪里使用内存屏障）。与ARM64兼容的机器代码叫作混合（或CHPE）代码，这些代码依然在
AArch64模式下执行，但实际上是按照32位ABI生成的，因此能与x86代码实现更好的互操作性。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">CHPE二进制文件会被创
建为标准的x86可执行文件（其机器ID依然是x86对应的014C），主要区别在于CHPE文件中包含由混合映像（hybrid 
image）元数据（这些元数据可存储为映像加载配置目录的一部分）中的表所描述的混合代码。当CHPE二进制文件被载入WoW64进程的地址空间时，模
拟器将会为每个包含混合元数据中所描述的混合代码的页面设置一个位为“1”，借此更新CHPE位图。当实时编译器编译x86代码块并检测到代码正在试图调
用混合函数时，就不再浪费时间进行编译，而是（使用32位栈）直接执行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">实时编译的x86代码会按
照自定义的ABI来执行，这意味着在ARM64寄存器的使用方式以及参数在不同函数之间的传递方式等方面，并没有什么标准的约定。CHPE代码并不遵循与
实时编译代码相同的寄存器约定（尽管混合代码依然会遵循32位ABI）。这意味着我们无法从编译器构建的实时编译代码块直接调用CHPE代码。为了解决这
个问题，CHPE二进制文件还包含三种类型的形式转换函数，借此实现CHPE与x86代码的互操作性。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·pop形式转换，可将来自客户端（x86）调用方的传入（或传出）参数转换为CHPE约定，并直接将执行转移至混合代码，借此让x86代码调用混合函数。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·push形式转换，可将来自混合代码的传入（或传出）参数转换为客户端（x86）约定，并调用模拟器以恢复x86代码的执行，借此让CHPE代码调用x86例程。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·export
形式转换，这是一种兼容性形式转换，用于为从操作系统模块导出x86函数绕路（detour）以修改其功能的应用程序提供支持。从CHPE模块导出的函数
依然包含少量x86代码（通常有8字节），这些代码在语义方面不提供任何功能，但可供外部应用程序插入绕路。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">x86-on-ARM模拟器会尽最大努力始终加载CHPE系统二进制文件，而非标准的x86二进制文件，但这种做法并非始终可行。如果CHPE二进制文件不存在，则模拟器将从SysWoW64文件夹加载标准x86二进制文件。此时操作系统模块需要进行完全实时编译。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>转</b><b>储</b><b>混</b><b>合</b><b>代</b><b>码</b><b>地</b><b>址</b><b>范</b><b>围</b><b>表</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">Windows SDK和WDK中提供的Microsoft Incremental linker（link.exe）工具可以显示CHPE映像的映像加载配置目录中所存储的混合元数据中包含的某些信息。有关该工具的更多信息以及安装方法请参阅第9章。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
这个实验中，我们将转储kernelbase.dll的混合元数据，这个系统库文件在编译时就添加了对CHPE的支持。读者也可以通过其他CHPE库文件
执行该实验。在ARM64计算机上安装SDK或WDK后，请打开Visual Studio Developer Command 
Prompt（如果使用了EWDK的ISO镜像，则请打开LaunchBuildEnv.cmd脚本文件）。随后进入CHPE文件夹，并通过下列命令转储
kernelbase.dll文件的映像加载配置目录：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">cd c:\Windows\SyChpe32 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">link /dump /loadconfig kernelbase.dll &gt; kernelbase_loadconfig.txt </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请注意，在本例中，命令的输出结果已被重定向至kernelbase_load-config.txt文本文件中，因为输出内容太多，所以无法在控制台窗口中直观显示出来。随后请用记事本打开该文本文件，并向下拖动，直到看到类似下面的内容：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Section contains the following hybrid metadata: </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">               4 Version </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        102D900C Address of WowA64 exception handler function pointer </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        102D9000 Address of WowA64 dispatch call function pointer </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        102D9004 Address of WowA64 dispatch indirect call function pointer </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        102D9008 Address of WowA64 dispatch indirect call function pointer (with CFG check)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        102D9010 Address of WowA64 dispatch return function pointer </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        102D9014 Address of WowA64 dispatch leaf return function pointer </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        102D9018 Address of WowA64 dispatch jump function pointer </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        102DE000 Address of WowA64 auxiliary import address table pointer </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        1011DAC8 Hybrid code address range table </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">               4 Hybrid code address range count </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Hybrid Code Address Range Table </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part"><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/c3421a233299cea191be2d7d67cf7062.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">该工具确认了kernelbase.dll在混合代码地址范围表中有四个范围：其中两部分包含x86代码（实际上模拟器并未使用），另外两部分包含CHPE代码（该工具错误地将其显示为“arm64”）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>X</b><b>T</b><b>A</b><b>缓</b><b>存</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上述几节所述，x86-
on-ARM64模拟器除了使用内部每个线程的缓存外，还使用一种名为XTA缓存的外部全局缓存，该缓存由负责实现延迟实时编译的受保护服务
XtaCache所管理。这是一个自启动服务，在启动时会打开（或创建）C:\Windows\XtaCache文件夹，并通过恰当的ACL保护该文件夹
（仅XtaCache服务和Administrators组成员可以访问该文件夹）。该服务会通过{BEC19D6F-
D7B2-41A8-860C-8787BB964F2D}连接端口启动自己的ALPC服务器，随后在退出前会分配ALPC以及延迟实时编译工作线程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ALPC工作线程负责将所
有请求调度给ALPC服务器。尤其是，当模拟器（客户端）在WoW64进程的上下文中运行时，需要连接到XtaCache服务，创建一个跟踪x86进程的
全新数据结构，并将其与218KB的已映射内存节一起存储在内部列表中，这个内存节会在客户端与XtaCache之间共享（为该节提供支撑的内存在内部被
称为跟踪缓冲区，即Trace 
buffer）。模拟器会使用这个内存节来发送提示信息，借助这些提示信息可以了解哪些x86代码已通过实时编译而成为可执行应用程序，但目前并不包含在
任何缓存中，以及了解这些代码所属的模块ID。内存节中存储的信息会由XTA缓存每秒处理一次，或在缓冲区已满的情况下立即处理一次。这取决于列表中有效
项的数量，XtaCache可决定是否直接启动延迟实时编译。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当新映像被映射至x86进
程后，WoW64层会通知模拟器，并由模拟器向正在寻找已存在XTA缓存文件的XtaCache发送一条消息。为找到缓存文件，XtaCache服务首先
需要打开并映射可执行映像，然后计算其哈希值。根据可执行映像的路径及其内部二进制数据可生成两个哈希值。这些哈希值非常重要，可避免执行为可执行映像的
老版本编译的实时编译代码块。随后会使用如下命名方案生成XTA缓存文件名称：&lt;module name&gt;.&lt;module 
header hash&gt;.&lt;module path hash&gt;.&lt;multi/uniproc&gt;.&lt;cache
 file 
version&gt;.jc。缓存文件包含所有预编译代码块，后者可直接被模拟器执行。因此，如果存在有效的缓存文件，XtaCache会创建一个文件
映射节，并将其注入客户端WoW64进程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">延迟实时编译器可看作
XtaCache的驱动引擎。当该服务决定调用时，会创建并初始化一个代表实时编译x86模块的新版缓存文件。随后延迟实时编译器会调用XTA脱机编译器
（xtac.exe），开始进行延迟编译。编译器会在受保护的低特权环境中启动（AppContainer进程），并以低优先级模式运行。编译器唯一的作
用是编译即将由模拟器执行的x86代码。新代码块会被添加到老版缓存文件（如果存在的话）所在位置，并存储于新版缓存文件中。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>X</b><b>T</b><b>A</b><b>缓</b><b>存</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">较
新版本的Process Monitor（进程监视器）可在ARM64环境中原生运行。我们可以使用Process 
Monitor来观察为x86进程生成并使用XTA缓存的过程。在本实验中，我们需要一个运行Windows 
10的2019年5月更新（1903）或后续版本的ARM64系统。最开始，必须确保本实验即将使用的x86应用程序还未被系统执行过。在本例中，我们将
安装一个旧版本的x86版MPC-HC媒体播放器，该播放器可从https://sourceforge.net/projects/mpc-hc/
files/lat-est/download下载。其他任何x86应用程序同样可用在该实验中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">安装MPC-HC（或其他x86应用程序），在运行该程序前，首先打开Process Monitor并为XtaCache服务的进程名称（XtaCache.exe，该服务通过自己的进程运行，并未使用共享进程）添加一个过滤器。该过滤器的配置情况可参阅下图。</span></p><div style="display: block;text-align:center;">
	<img width="710" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a7b8443be9c4da724b4861687b5c0443.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如
果尚未执行该操作，请从File菜单选择Capture 
Events开始捕获事件。随后启动MPC-HC并尝试着播放一些视频。退出MPC-HC并在Process 
Monitor中停止事件捕获。此时Process 
Monitor已经显示了大量事件信息。我们可以点击工具栏上对应的图标来删除与注册表有关的活动（本实验无须关注注册表活动）以便过滤出需要的结果。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">拖
动事件列表会发现，XtaCache服务首先会尝试打开MPC-HC缓存文件，但该文件并不存在，因此尝试失败了。这意味着模拟器将要开始自行编译x86
映像并将信息定期发送给XtaCache。随后，XtaCache的工作线程会调用延迟实时编译器，进而创建一个新版的Xta缓存文件并调用Xtac编译
器，将缓存文件节映射给其本身以及Xtac。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3085cb455e91778604d1de2d34539c9a.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">重
新进行该实验就会发现，Process Monitor中出现了不同的事件：缓存文件会被立即映射给MPC-HC 
WoW64进程。这样模拟器即可直接开始执行，因此执行速度应该会更快。我们也可以试着删除已生成的XTA缓存文件。随后，如果再次启动MPC-HC 
x86应用程序，XtaCache服务会自动重建缓存文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">然而要注意，%SystemRoot%\XtaCache文件夹受到XtaCache服务所拥有的ACL的妥善保护。要访问该文件夹，需要首先以管理员身份打开命令提示符窗口，然后运行下列命令：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">takeown /f c:\windows\XtaCache </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">icacls c:\Windows\XtaCache /grant Administrators:F</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>时</b><b>编</b><b>译</b><b>和</b><b>执</b><b>行</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了启动客户进程，
x86-on-ARM64 
CPU模拟器必须解释或实时编译x86代码。解释客户代码意味着需要每次转换并执行一条机器指令，这是一个缓慢的过程，因此模拟器只支持实时编译策略：借
此将x86代码动态地编译为ARM64代码，并将结果存储在客户“代码块”中，直到发生下列这些情况：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·检测到非法的操作码、数据或指令断点。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·遇到一条以已经访问过的代码块为目标的分支指令。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·代码块大于预先确定的限制（512字节）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">模拟引擎首先会在本地和
XTA缓存中检测（由RVA进行索引的）代码块是否已经存在。如果缓存中存在这样的代码块，则模拟器将直接使用调度程序例程来执行，进而构建出ARM64
上下文（其中包含主机寄存器值）并将其存储在64位栈中，随后切换至32位栈并为客户x86线程状态做好准备。此外，它还会准备用于运行实时编译后x86
代码（其中也包括x86上下文）的ARM64寄存器。请注意，这方面存在一个明确定义的非标准调用约定：调度程序的作用，类似于负责将执行过程从CHPE
转移到x86上下文的Pop形式转换的作用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">代码块执行完毕后，调度程
序还会执行一系列相反的操作：将新的x86上下文保存在32位栈中，切换回64位栈，并还原老的ARM64上下文（包含模拟器状态信息）。当调度程序退出
时，模拟器将能准确得知执行被打断时的确切x86虚拟地址，随后即可从这个新的内存地址重新开始进行模拟。与缓存的项类似，模拟器也会检查目标地址是否指
向包含CHPE代码的内存页面（可通过全局CHPE位图得知该信息）。如果包含，那么模拟器将会解析目标函数的pop形式转换，将其地址添加到线程的本地
缓存中，并直接开始执行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果上述两个条件之一得到验证，模拟器即可实现与执行原生映像类似的性能，否则将调用编译器来构建原生转换后的代码块。编译过程分为如下三个阶段：</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）<span style="font-size:16px;font-weight: bold;font-family:'PingFang SC';"><b>解</b><b>析</b></span>阶段，为需要添加到代码块的每个操作码构建指令描述符。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）<span style="font-size:16px;font-weight: bold;font-family:'PingFang SC';"><b>优</b><b>化</b></span>阶段，优化指令流。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）<span style="font-size:16px;font-weight: bold;font-family:'PingFang SC';"><b>代</b><b>码</b><b>生</b><b>成</b></span>阶段，将最终的ARM64机器码写入新的代码块。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后，生成的代码块会被添
加到每线程的本地缓存。请注意，模拟器无法将其添加到XTA缓存，这主要是出于安全性和性能方面的考虑。否则攻击者将污染更高特权进程的缓存（进而导致恶
意代码有可能在更高特权进程的上下文中执行）。此外，模拟器没有足够的CPU时间，以便在保证应用程序响应能力的前提下生成高度优化的代码（尽管有一个专
门的代码优化阶段）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">不过，有关已编译x86代
码块的信息，已经与承载该x86代码的二进制文件ID信息一起被插入共享的Trace缓冲区所映射的列表中。在Trace缓冲区的帮助下，XTA缓存的延
迟实时编译器知道自己需要对模拟器实时编译的x86代码进行编译。因此它可以生成优化的代码块，并将其加入模块的XTA缓存文件中，随后由模拟器直接执
行。因此，x86进程只有首次执行时的速度会略慢于其他时候。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>系</b><b>统</b><b>调</b><b>用</b><b>和</b><b>异</b><b>常</b><b>调</b><b>度</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在x86-on-
ARM64 
CPU模拟器中，当x86线程执行系统调用时，它会调用模拟器所分配的Syscall页面中的代码，从而引发0x2E异常。每个x86异常都会迫使代码块
退出。当从代码块退出时，根据异常的矢量编号，调度程序会通过内部函数调度异常，进而调用标准的WoW64异常处理程序或系统调用调度程序。相关内容已在
上文有关AMD64平台上进行x86模拟的章节中讨论过。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>在</b><b>A</b><b>R</b><b>M</b><b>6</b><b>4</b><b>环</b><b>境</b><b>中</b><b>调</b><b>试</b><b>W</b><b>o</b><b>W</b><b>6</b><b>4</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">较
新版本的WinDbg（Windows调试器）可以调试任何模拟器中运行的机器代码。这意味着在ARM64系统中，我们可以调试原生ARM64、ARM 
Thumb-2以及x86应用程序；而在AMD64系统中，我们只能调试32位和64位的x86程序。调试器还能轻松地在原生64位和32位栈之间切换，
借此我们可以同时调试原生（包括WoW64层和模拟器）以及客户端代码（此外，调试器还支持CHPE）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
这个实验中，我们将使用ARM64计算机启动x86应用程序，并在ARM64、ARM 
Thumb-2和x86这三个执行模式之间切换。对于该实验，我们需要安装最新版的调试工具，该工具已包含在WDK或SDK中。安装其中任何一个工具包
后，请打开ARM64版本的Windbg（位于开始菜单中）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
启动调试会话前，我们应该禁用XtaJit模拟器生成的异常，例如数据未对齐（data misaligned）和页面内I/O错误（in-page 
I/O error）（这些异常已经被模拟器本身处理过了）。为此请在Debug菜单中点击Event Filters，随后从列表中选择Data 
Misaligned事件并选中Execution组所对应的Ignore选项。请针对In-page 
I/O错误重复执行该操作。最后我们的配置应该类似下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="660" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/f06436fecb90a336650c05b16fcba209.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">点
击Close，并在调试器主界面上选中File菜单下的Open 
Executable。接着选择一个位于%SystemRoot%\SysWOW64文件夹下的32位x86可执行文件（本例中我们将使用
notepad.exe，但其他任意x86应用程序都可以使用）。另外请通过View菜单打开Disassembly窗口。如果符号已经正确配置（有关配
置符号的方法请参阅https://docs.microsoft.com/windows-hardware/drivers/debugger/
symbol-path），随后应该能看到第一个原生Ntdll断点，我们可以使用k命令显示栈信息加以确认：</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/78ee934d228b75b4157ba28cec9657bb.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">此
时模拟器尚未加载：NT内核已将原生和CHPE版Ntdll映射至目标二进制文件，而WoW64核心二进制文件已经在断点之前被原生Ntdll通过
LdrpLoadWow64函数加载。我们可以（使用lm命令）枚举当前已加载的模块，并通过.f+命令移动到栈的下一个帧，借此确认这一点。在
Disassembly窗口中，应当能看到LdrpLoadWow64例程的调用：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">00007ffb`bd47dde4 97fed31b bl        ntdll!LdrpLoadWow64 (00007ffb`bd432a50) </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后使用g命令（或F5键）恢复执行。我们应该能看到有多个模块被载入进程地址空间，并且这一次会在x86上下文中引发另一个断点。如果使用k命令再次显示栈信息，应该可以注意到会显示一个新列。此外调试器还会在自己的提示符中添加“x86”的字样：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0:000:x86&gt; k </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> #   Arch ChildEBP RetAddr </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">00    x86 00acf7b8 77006fb8 ntdll_76ec0000!LdrpDoDebuggerBreak+0x2b </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">01   CHPE 00acf7c0 77006fb8 ntdll_76ec0000!#LdrpDoDebuggerBreak$push_thunk+0x48</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">02   CHPE 00acf820 76f44054 ntdll_76ec0000!#LdrpInitializeProcess+0x20ec </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">03   CHPE 00acfad0 76f43e9c ntdll_76ec0000!#_LdrpInitialize+0x1a4 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">04   CHPE 00acfb60 76f43e34 ntdll_76ec0000!#LdrpInitialize+0x3c </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">05   CHPE 00acfb80 76ffc3cc ntdll_76ec0000!LdrInitializeThunk+0x14 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如
果将新老两个栈进行比较就会发现，栈地址发生了巨大的变化（因为进程现在正在使用32位栈执行）。另外请注意，某些函数前面显示了#符号，WinDbg使
用该符号代表包含CHPE代码的函数。至此，我们可以像常规x86操作系统中那样以步进的方式执行x86代码。模拟器会负责模拟并隐藏所有细节。若要观察
模拟器的运行方式，我们需要使用.effmach命令转移至64位上下文。该命令可接收不同的参数，“x86”代表32位x86上下
文，“arm64”或“amd64”（取决于目标平台）代表原生64位上下文，“arm”代表32位ARM 
Thumb2上下文，“CHPE”代表32位CHPE上下文。本例中可使用“arm64”参数切换至64位栈：</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3f8acbb8656b7a59530f539f73a16e1e.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">通
过这两个栈可以看到，模拟器原本在执行CHPE代码，随后调用了一个push形式转换借此重启动对LdrpDoDebuggerBreak这个x86函数
的模拟，进而借助Wow64pNotifyDebugger例程向调试器告知一个异常（通过原生Wow64RaiseException管理）。通过使用
Windbg的.effmach命令，即可调试包括原生、CHPE以及x86代码在内的不同上下文。借助g 
@$exentry命令，即可移动到Notepad的x86入口点并继续运行x86代码或模拟器本身的调试会话。大家也可以在其他环境中重复进行该实验，
例如对SysArm32下的应用进行调试。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter08_0006.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_35" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>6</b><b> </b><b>对</b><b>象</b><b>管</b><b>理</b><b>器</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如本书卷1第2章所述，
为了向执行体实现的各种内部服务提供一致且安全的访问，Windows实现了一种对象模型。本节要介绍的Windows对象管理器就是负责创建、删除、保
护和跟踪对象的执行体组件。对象管理器与资源控制有关的操作集中到了一起，否则这些操作将只能分散在操作系统的各处。对象管理器在设计上满足了一系列目标
的要求，这些内容将在实验之后详细介绍。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>浏</b><b>览</b><b>对</b><b>象</b><b>管</b><b>理</b><b>器</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">本节会通过一系列实验向大家展示如何查看对象管理器数据库。这些实验会用到下列工具，建议不熟悉这些工具的读者先掌握这些工具的用法：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·WinObj
（可通过Sysinternals获得）可显示对象管理器的内部命名空间以及与对象有关的信息（例如引用计数、打开的句柄数量、安全描述符等）。
GitHub上提供的WinObjEx64是一个类似工具，提供了更多高级功能，它是开源的，但未经微软认可或签名。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Sysinternals
提供的Process Explorer、Handles以及Resource 
Monitor（详细介绍可参阅本书卷1第1章）可显示进程已打开的句柄。Process 
Hacker也可以显示打开的句柄，并能显示某些对象类型的其他详细信息。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·内核调试器!handle扩展，可显示进程打开的句柄及进程内部的Io.Handles数据模型对象，例如@$curprocess。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">WinObj和WinObjEx64提供了一种对对象管理器所维护的命名空间进行遍历的方法（稍后将介绍，并非所有对象都有名称）。运行这两个工具中的任何一个即可查看布局，如下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/29a45d623b16f6f09c82ddc0b762a81f.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">Windows
的Openfiles/query命令可列出当前在系统中打开的本地和远程文件，该命令需要启用一个名为Maintain objects 
list的Windows全局标记（有关全局标记的详情请参阅第10章“全局标记”一节）。输入Openfiles/Local即可得知该标记是否已启
用。可以用Openfiles/Local ON命令启用该标记，但为了让设置生效，需要重启动系统。Process 
Explorer、Handle和Resource 
Monitor无须启用对象跟踪，因为它们可以查询所有系统句柄并创建每进程对象列表。Process Hacker使用最新的Windows 
API查询每进程句柄，也无须该标记。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对象管理器在设计上可满足下列目标：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·提供通用、统一的系统资源使用机制。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·将对象保护隔离到操作系统的一个位置内，以保证统一且一致的对象访问策略。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·提供一种对进程使用的对象进行“收费”的机制，从而限制对系统资源的使用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·建立一种能够很容易纳入现有对象（如设备、文件、文件系统目录或其他独立对象集合）的命名方案。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
为各种操作系统的环境要求提供支持，如进程从父进程继承资源的能力（该能力是Windows和UNIX子系统应用程序所必需的），以及创建可区分大小写文
件名的能力（这是UNIX子系统应用程序所必需的）。虽然UNIX子系统应用程序已被弃用，但这些机制对随后开发的Windows Subsystem 
for Linux提供了一定帮助。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·建立统一的对象保留规则（即在所有进程全部使用完之前，确保对象始终可用）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·提供为特定会话隔离对象的能力，以便在命名空间中同时实现本地对象和全局对象。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·允许通过符号链接重定向对象名称和路径，并允许对象所有者（如文件系统）实现自己类型的重定向机制（如NTFS交接点，即junction point）。这些重定向机制结合在一起形成所谓的重分析（reparsing）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在内部，Windows有
三种主要的对象类型：执行体对象、内核对象及GDI/用户对象。执行体对象是由执行体的各个组件（例如进程管理器、内存管理器、I/O子系统等）所实现的
对象。内核对象是由Windows内核实现的一种类似基元的对象。这些对象对用户模式代码不可见，只能在执行体内部创建和使用。内核对象提供构建执行体对
象所需的一些基本功能，例如同步。因此很多执行体对象会包含（封装）一个或多个内核对象，如图8-30所示。</span></p><div style="display: block;text-align:center;">
	<img width="390" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/8da485416287bda8797a7336abbaeffa.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-30 包含内核对象的执行体对象</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
从另一方面来看，大部分GDI/用户对象都属于Windows子系统（Win32k.sys），并不与内核交互。因此这些内容已超出本书范围，读者可通过
Windows SDK进一步了解有关此类对象的信息。但Desktop和Windows Station 
User对象是两个例外，它们被包装在执行体对象中，此外大部分DirectX对象（Shaders、Surfaces、Compositions）也会
包装为执行体对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">下文将进一步介绍内核对象的结构及用它们实现同步的方法。本节后续部分将专注于介绍对象管理器的工作方式，以及执行体对象、句柄和句柄表的结构。这里只简要介绍如何通过对象来实现Windows的安全访问检查，有关该话题的详细讨论请参阅本书卷1第7章。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_36" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>6</b><b>.</b><b>1</b><b> </b><b>执</b><b>行</b><b>体</b><b>对</b><b>象</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">每个Windows环境子系统都会向其应用程序投射不同的操作系统映像。执行体对象和对象服务是环境子系统用来构建自己版本的对象与其他资源的基元。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">执行体对象通常由环境子系
统代表用户应用程序创建，或由操作系统的各种组件在其正常操作的过程中创建。例如，若要创建一个文件，Windows应用程序会调用Windows的
CreateFileW函数，该函数是在Windows子系统DLL 
Kernelbase.dll中实现的。经过一些验证和初始化后，CreateFileW函数将调用原生Windows服务NtCreateFile来创
建一个执行体文件对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">环境子系统为其应用程序提
供的对象集可能大于或小于执行体提供的对象集。Windows子系统会使用执行体对象导出自己的对象集，其中很多对象是与执行体对象直接对应的。例如，
Windows互斥体（mutex）和信号量（semaphores）就直接基于执行体对象（而执行体对象又基于对应的内核对象）。此外，Windows
子系统还提供命名管道和邮件槽（mailslot），这些资源基于执行体文件对象。当使用Windows Subsystem for 
Linux（WSL）时，其子系统驱动程序（LxCore.sys）会使用执行体对象和服务作为向其应用程序呈现Linux风格进程、管道和其他资源的基
础。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">表8-15列出了执行体提
供的主要对象，并简单介绍了它们所呈现的内容。本书在描述执行体组件的相关章节里进一步介绍了有关这些执行体对象的详细信息（对于直接导出到
Windows的执行体对象，也可参阅Windows 
API参考文档）。要查看完整的对象类型列表，请在提升权限的命令提示符窗口中运行Winobj并打开ObjectTypes目录。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 执行体总共实现了约69个对象类型（取决于Windows版本）。其中一些对象仅限于定义了它们的执行体组件使用，并不能被Windows API直接访问，例如Driver、Callback以及Adapter。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">表8-15 暴露给Windows API的执行体对象</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/61cb2836b6b9cce2f6d4375b79485e9b.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e8b091b49c71d2280980a7752fc089a1.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3f484c5a55e92949ff80f6636eca166e.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a5f4decd84275252d83b53c3fdb31f62.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/2a3a11e12d0d75ba7c1a7eb305c91958.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/70c389f88a4a277bb25f8cafb405f07a.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/0bd96d8a0bd48b9e92c436cd00a8cc55.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">①游戏模式（Game Mode）是Windows 10中曾经提供过的一种功能，将系统置于该模式下可暂时禁用一些后台系统服务和任务，进而改善计算机游戏游玩体验。——译者注</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 因为Windows NT最初需要支持OS/2操作系统，因此其互斥（Mutex）必须与S/2的互斥对象（Mutual-exclusion 
object）设计保持兼容，这种设计要求线程能够放弃对象，并使其无法访问。由于在此类对象看来这种行为是不寻常的，因此又创建了另一种内核对象：
Mutant（突变体）。最终，Windows NT放弃了对OS/2的支持，Windows 
32子系统开始以Mutex的名称使用此类对象（但内部依然将其称为Mutant）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_37" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>6</b><b>.</b><b>2</b><b> </b><b>对</b><b>象</b><b>结</b><b>构</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如图8-31所示，每个对
象都有一个对象头（object header）、一个对象主体（object body），并且可能还有一个对象尾（object 
footer）。对象管理器控制着对象头和对象尾，而拥有它们的执行体组件控制着自己所创建对象类型的对象主体。每个对象头还包含一个特殊对象的索引，该
对象名为类型（Type）对象，其中包含与每个对象实例有关的共同信息。此外，最多还存在8个可选的子头（Subheader）：名称信息对象头、配额信
息对象头、进程信息对象头、句柄信息对象头、审核信息对象头、填充信息对象头、扩展信息对象头，以及创建者信息对象头。如果存在扩展信息对象头，这意味着
该对象也有对象尾，并且对象头会包含指向对象尾的指针。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4d04c9b93f2114116199b94e02458692.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-31 对象的结构</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>对</b><b>象</b><b>头</b><b>和</b><b>对</b><b>象</b><b>主</b><b>体</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对象管理器使用存储在对象头中的数据来管理对象，这一过程并不考虑对象本身的类型。表8-16简要介绍了对象头字段，而表8-17介绍了可选对象子头中包含的字段。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了对象头中包含可适用于
任何类型对象的信息外，子头中还包含与特定对象有关的可选信息。请注意，这些结构位于从对象头开始处不同的偏移位置上，具体的值则取决于主对象头所关联的
子头数量（但上文提到的创建者信息除外）。对于所存在的每个子头，InfoMask字段都会进行必要的更新以反映其存在。当对象管理器检查特定子头时，它
会检查InfoMask字段是否设置了对应的位，随后会使用剩余的位在全局ObpInfoMaskToOffset表中选择正确的偏移量，进而找到从对象
头开始处计算的子头偏移量。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-16 对象头字段</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b3059b6d37bf8887a3c2f6a7b4bc9a61.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/25c91f6e9e657d58268a622606f41806.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当子头以任何一种组合方式
出现时都会存在这些偏移量，但由于只要存在子头，就会始终以固定且恒定的顺序进行分配，因此特定对象头仅具备与先于对象头的子头数量最大值相等的可能位置
数。例如，由于名称信息子头始终是最先分配的，因此只有一个可能的偏移量，而句柄信息子头（第三个被分配）就会有三个可能的位置，因为它可能在配额子头之
后分配了，也可能未分配，该子头也可能是在名称信息之后分配的。表8-17列出了所有的可选对象子头及其位。至于创建者信息子头，会通过对象头标记中的一
个值来决定该子头是否存在（有关这些标记的详细信息请参阅表8-20）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-17 可选对象子头及其位</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/17cc8eac2d198d84601dd1c6e9b3865b.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上述每个子头都是可选的，并且只在系统引导或对象创建的特定条件下出现。表8-18列出了所有这些条件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-18 需要对象子头出现的不同条件</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e5cc811e420e4de0b1fcb4ae6c1ec690.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，如果存在扩展信息对象头，那么在对象主体的尾部还会分配对象尾。与对象子头不同，对象尾是一种静态大小的结构，会为所有可能的对象尾类型进行预分配。此类对象尾有两种，如表8-19所示。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-19 对象尾的存在条件</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/054dda433c11cbdd81ccf42657e1540e.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后，一些属性和标记决定
了对象在创建时或某些操作过程中所体现出的行为。每当创建任何新对象时，对象管理器就会以一种名为对象属性（object 
attribute）的结构收到这些标记。该结构定义了对象名称、对象应插入的根对象目录、对象的安全描述符，以及对象属性标记（object 
attribute flag）。表8-20列出了可关联到对象的不同标记。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
当通过Windows子系统中的API（例如CreateEvent或CreateFile）创建对象时，调用方无须指定任何对象属性，子系统DLL会在
后台处理这些工作。因此，通过Win32创建的所有具名对象，无论是全局实例还是每个会话实例，都会进入BaseNamedObjects目录，因为这是
Kernelbase.dll在对象属性结构中指定的根对象目录。有关BaseNamedObjects的详细信息以及它与每个会话命名空间之间的关系，
请参阅下文的介绍。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-20 对象标记</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b49d33e96687c3a137698d56570b3853.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了对象头，每个对象还包
含一个对象主体，每一类对象主体的格式与内容均是唯一的，相同类型的所有对象共享相同的对象主体格式。通过创建对象类型并为其提供服务，执行体组件可以控
制该类型所有对象主体中数据的相关操作。因为对象头的大小是静态且已知的，对象管理器可以轻松查找某个对象的对象头，为此只需要从对象指针的大小中减去对
象头的大小即可。正如上文所述，为了访问子头，对象管理器还会从对象头指针中减去另一个已知的值。对于对象尾，可以使用扩展信息子头来查找指向对象尾的指
针。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于对象头、对象尾以及子
头的结构均已实现了标准化，对象管理器可以提供一小部分通用服务，所以可对存储在任何对象头中的属性进行操作，并将其用于任何类型的对象（不过一些通用服
务对某些对象来说是无意义的）。Windows子系统会将某些此类通用服务提供给Windows应用程序使用，这些服务的相关信息请参阅表8-21。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-21 通用对象服务</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/6622b5b1c34a851cbd47bb31cb4a9b70.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然大部分对象类型并不会实现所有服务，但它们至少会提供创建、打开、基本管理等服务。例如，I/O系统会为自己的文件对象提供“创建文件”服务，进程管理器会为自己的进程对象提供“创建进程”服务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">某些对象可能不会直接暴露此类服务，并且它们可能是由用户的某些操作而在内部创建的。例如，在用户模式下打开WMI数据块时会创建一个WmiGuid对象，但不会向应用程序暴露任何能用于关闭或查询服务的句柄。这里需要注意的重点是：并不存在某种单一的通用创建例程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这样的例程可能会相当复杂。举例来说，初始化一个文件对象所需的一系列参数，肯定会不同于初始化一个进程对象所需的参数。此外，当线程调用一个对象服务来确定句柄所引用的对象类型并调用相应版本的服务时，对象管理器都会产生额外的处理开销。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>类</b><b>型</b><b>对</b><b>象</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对象头包含所有对象的共有
数据，但对于对象的每个实例可能会采用不同的值。例如，每个对象都有一个唯一的名称，并可能有唯一的安全描述符。然而，对象还可能包含一些对特定类型的所
有对象都保持不变的数据。举例来说，在打开某类型对象的句柄后，即可针对该类型对象独有的一系列访问权限进行选择。执行体为线程对象提供了终止和挂起等访
问权限，并为文件对象提供了读取、写入、追加和删除等访问权限。下文很快将要介绍的同步，也是一个与特定类型对象有关的属性范例。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了节省内存，对象管理器
只会在新建某个对象类型时，将这些静态的、与对象类型有关的属性存储一次。对象管理器会使用自己独有的一种类型对象来记录这些数据。如图8-32所示，如
果已经设置了对象跟踪调试标记（详见下文“Windows全局标记”一节），则类型对象会与相同类型的所有对象链接在一起（例如图中的进程类型），这样对
象管理器就可以在需要时找到并枚举所有对象。该功能用到了上文介绍过的创建者信息子头。</span></p><div style="display: block;text-align:center;">
	<img width="851" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/5b3ec68d3e153cde74f04ab46fbfe7bd.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-32 进程对象和进程类型对象</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>对</b><b>象</b><b>头</b><b>和</b><b>类</b><b>型</b><b>对</b><b>象</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以通过内核调试器查看进程对象类型的数据结构，为此，首先需要使用调试器数据模型命令dx @$cursession.Processes识别出进程对象：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx -r0 &amp;@$cursession.Processes[4].KernelObject </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">&amp;@$cursession.Processes[4].KernelObject :         0xffff898f0327d300 [Type:_EPROCESS *]</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后使用进程对象的地址作为参数执行!object命令：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; !object 0xffff898f0327d300 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Object: ffff898f0327d300 Type: (ffff898f032954e0) Process </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ObjectHeader: ffff898f0327d2d0 (new version) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    HandleCount: 6 PointerCount: 215645 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请注意，在32位Windows中，对象头始于对象主体开头位置之前的0x18（十进制等于24）字节处，而在64位Windows中，始于对象头本身大小之前的0x30（十进制等于48）字节处。我们可通过下列命令查看对象头：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx (nt!_OBJECT_HEADER*)0xffff898f0327d2d0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">(nt!_OBJECT_HEADER*)0xffff898f0327d2d0     : 0xffff898f0327d2d0 [Type:_OBJECT_HEADER *]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x000] PointerCount     : 214943 [Type:__int64] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x008] HandleCount      : 6 [Type:__int64] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x008] NextToFree       : 0x6 [Type: void *] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x010] Lock             [Type:_EX_PUSH_LOCK] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x018] TypeIndex        : 0x93 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x019] Traceflags       : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x019 ( 0: 0)] DbgRefTrace      : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x019 ( 1: 1)] DbgTracePermanent : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x01a] InfoMask         : 0x80 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x01b] flags            : 0x2 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x01b ( 0: 0)] NewObject        : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x01b ( 1: 1)] KernelObject     : 0x1 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x01b ( 2: 2)] KernelOnlyAccess : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x01b ( 3: 3)] ExclusiveObject  : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x01b ( 4: 4)] PermanentObject  : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x01b ( 5: 5)] DefaultSecurityQuota : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x01b ( 6: 6)] SingleHandleEntry : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x01b ( 7: 7)] DeletedInline    : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x01c] Reserved         : 0xffff898f [Type: unsigned long]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x020] ObjectCreateInfo : 0xfffff8047ee6d500 [Type:_OBJECT_CREATE_INFORMATION *]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x020] QuotaBlockCharged : 0xfffff8047ee6d500 [Type: void *]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x028] SecurityDescriptor : 0xffffc704ade03b6a [Type: void *]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x030] Body             [Type:_QUAD]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ObjectType       : Process</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    UnderlyingObject [Type:_EPROCESS]</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后可复制刚才用!object命令显示的指针来查看对象类型的数据结构：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx (nt!_OBJECT_TYPE*)0xffff898f032954e0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">(nt!_OBJECT_TYPE*)0xffff898f032954e0         : 0xffff898f032954e0 [Type:_OBJECT_TYPE *]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x000] TypeList         [Type:_LIST_ENTRY]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x010] Name             : "Process" [Type:_UNICODE_STRING]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x020] DefaultObject     : 0x0 [Type: void *]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x028] Index            : 0x7 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x02c] TotalNumberOfObjects : 0x2e9 [Type: unsigned long]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x030] TotalNumberOfHandles : 0x15a1 [Type: unsigned long]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x034] HighWaterNumberOfObjects : 0x2f9 [Type: unsigned long]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x038] HighWaterNumberOfHandles : 0x170d [Type: unsigned long]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x040] TypeInfo         [Type:_OBJECT_TYPE_INITIALIZER]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x0b8] TypeLock         [Type:_EX_PUSH_LOCK]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x0c0] Key              : 0x636f7250 [Type: unsigned long]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x0c8] CallbackList     [Type:_LIST_ENTRY] </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">输
出结果显示的对象类型结构包含对象类型名称、跟踪到的此类型活跃对象的总数，以及跟踪到的此类型句柄和对象峰值数量。CallbackList还会跟踪与
此类型对象相关的对象管理器过滤回调。TypeInfo字段则存储了为所有该类型对象保存通用属性、标记和设置的数据结构，以及指向对象类型的自定义方法
的指针，下文很快将介绍这些内容：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx ((nt!_OBJECT_TYPE*)0xffff898f032954e0)-&gt;TypeInfo </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">((nt!_OBJECT_TYPE*)0xffff898f032954e0)-&gt;TypeInfo         [Type:_OBJECT_TYPE_INITIALIZER]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x000] Length           : 0x78 [Type: unsigned short]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002] ObjectTypeflags  : 0xca [Type: unsigned short]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002 ( 0: 0)] CaseInsensitive  : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002 ( 1: 1)] UnnamedObjectsOnly : 0x1 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002 ( 2: 2)] UseDefaultObject : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002 ( 3: 3)] SecurityRequired : 0x1 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002 ( 4: 4)] MaintainHandleCount : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002 ( 5: 5)] MaintainTypeList : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002 ( 6: 6)] SupportsObjectCallbacks : 0x1 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002 ( 7: 7)] CacheAligned     : 0x1 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x003 ( 0: 0)] UseExtendedParameters : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x003 ( 7: 1)] Reserved         : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x004] ObjectTypeCode   : 0x20 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x008] InvalidAttributes : 0xb0 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x00c] GenericMapping   [Type:_GENERIC_MAPPING] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x01c] ValidAccessMask  : 0x1fffff [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x020] RetainAccess     : 0x101000 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x024] PoolType         : NonPagedPoolNx (512) [Type:_POOL_TYPE] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x028] DefaultPagedPoolCharge : 0x1000 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x02c] DefaultNonPagedPoolCharge : 0x8d8 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x030] DumpProcedure    : 0x0 [Type: void (__cdecl*)(void *,_OBJECT_DUMP_CONTROL *)]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x038] OpenProcedure    : 0xfffff8047f062f40 [Type: long (__cdecl*) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                  (_OB_OPEN_REASON,char,_EPROCESS *,void *,unsigned long *,unsigned long)]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x040] CloseProcedure   : 0xfffff8047F087a90 [Type: void (__cdecl*) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                   (_EPROCESS *,void *,unsigned__int64,unsigned__int64)]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x048] DeleteProcedure  : 0xfffff8047f02f030 [Type: void (__cdecl*)(void *)] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x050] ParseProcedure   : 0x0 [Type: long (__cdecl*)(void *,void *,_ACCESS_STATE *,</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                           char,unsigned long,_UNICODE_STRING *,_UNICODE_STRING *,void *,</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                                _SECURITY_QUALITY_OF_SERVICE *,void * *)]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x050] ParseProcedureEx : 0x0 [Type: long (__cdecl*)(void *,void *,_ACCESS_STATE *,</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                           char,unsigned long,_UNICODE_STRING *,_UNICODE_STRING *,void *, </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                _SECURITY_QUALITY_OF_SERVICE *,_OB_EXTENDED_PARSE_PARAMETERS *,void * *)]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x058] SecurityProcedure : 0xfffff8047eff57b0 [Type: long (__cdecl*) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                 (void *,_SECURITY_OPERATION_CODE,unsigned long *,void *,unsigned long *, </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                             void * *,_POOL_TYPE,_GENERIC_MAPPING *,char)]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x060] QueryNameProcedure : 0x0 [Type: long (__cdecl*)(void *,unsigned char,_</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                            OBJECT_NAME_INFORMATION *,unsigned long,unsigned long *,char)]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x068] OkayToCloseProcedure : 0x0 [Type: unsigned char (__cdecl*)(_EPROCESS *, </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                                                      void *,void *,char)]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x070] WaitObjectflagMask : 0x0 [Type: unsigned long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x074] WaitObjectflagOffset : 0x0 [Type: unsigned short] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x076] WaitObjectPointerOffset : 0x0 [Type: unsigned short] </span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">类型对象无法从用户模式操作，因为对象管理器没有为它们提供服务。不过类型对象所定义的一些属性对某些原生服务以及Windows API例程是可见的。类型初始化程序中所存储的信息如表8-22所示。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-22 类型初始化程序字段</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/441405bb33479d825bb82d84580b147e.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">作为Windows应用程
序可见的属性之一，同步（synchronization）是指线程通过等待对象改变自己的状态而对执行过程实现同步的能力。线程可以与执行体作业、进
程、线程、文件、事件、信号量、互斥、计时器以及很多其他不同类型的对象保持同步。不过其他执行体对象并不支持同步。对象对同步的支持能力基于下列三种可
能：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·执行体对象是调度程序对象的封装，包含调度程序头，这种内核结构将在下文“低IRQL同步”中介绍。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·对象类型的创建者请求了一个默认对象，随后对象管理器提供了这个对象。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·执行体对象包含内嵌的调度程序对象，例如对象主体内部的某些事件，并且对象的所有者在注册该对象类型（详见表8-14）时向对象管理器提供了自己的偏移量（或指针）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>对</b><b>象</b><b>方</b><b>法</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">表8-22中的最后一个属
性Methods由一系列内部例程组成，这些例程类似于C++构造函数和解析函数，也就是说，在创建或销毁对象时会自动调用这些例程。对象管理器还会在其
他情况下调用对象方法，进而对这种设计进行扩展，例如，当某人打开或关闭对象句柄，或者某人试图更改对象的保护机制时。一些对象类型指定了这些方法，但其
他一些对象类型并未指定，这主要取决于对象类型的使用方式。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当执行体组件新建对象类型时，可以向对象管理器注册一个或多个方法。随后，对象管理器即可在此类型的对象生命周期内某些明确的时间点上调用这些方法，这通常会发生在以某种方式创建、删除或修改对象时。对象管理器可支持的方法如表8-23所示。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-23 对象方法</span></p><div style="display: block;text-align:center;">
	<img width="812" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/62ca0b16406fe31fe2721ac3beaa00cf.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">使用这些对象方法的原因之
一是为了解决一些明显的问题：某些对象操作是通用的（关闭、复制、安全等）。完全概括这些通用例程要求对象管理器的设计者必须预测所有对象类型。这不仅会
给内核带来极大的复杂性，而且必须由内核导出创建对象类型所需的这些例程。由于这会允许外部内核组件创建自己的对象类型，内核将无法预测潜在的自定义行
为。不过这样的能力并未以文档的形式提供给驱动程序开发者，仅Pcw.sys、Dxgkrnl.sys、Win32k.sys、FltMgr.sys等内
部驱动程序可以由此定义WindowStation、Desktop、PcwObject、Dxgk*、FilterCommunication/
ConnectionPort、NdisCmState等对象。借助对象方法的可扩展性，这些驱动程序可以通过定义例程来处理诸如删除和查询等操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">使用这些方法的另一个原因
在于，可以在对象生命周期的管理过程中实现一种虚拟构造函数和解析函数机制。借此，底层组件即可在句柄的创建、关闭和对象销毁的过程中执行额外操作。在需
要时，这些机制甚至可用于实现禁止句柄的关闭和创建操作，例如卷1第3章中介绍的受保护进程机制，就利用了自定义句柄创建方法来防止低保护级别的进程打开
高保护级别进程的句柄。这些方法还针对对象管理器内部API提供了可见性，例如通过通用服务实现的复制和继承。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后，由于这些方法还可覆
盖名称解析和查询功能，因此可用于在对象管理器的范围之外实现一种辅助命名空间。实际上File和Key对象就是这样工作的：它们的命名空间由文件系统驱
动程序和配置管理器负责内部管理，对象管理器仅能看到\REGISTRY和\Device\HarddiskVolumeN对象。稍后我们将详细介绍这些
方法的细节和用例。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对象管理器只有在其类型初
始化程序的指针未设置为NULL的情况下才会调用例程，但有一个例外：安全例程，该例程默认会设置为SeDefaultObjectMethod。该例程
不需要知道对象的内部结构，因为它只处理对象的安全描述符，并且之前已经提过，安全描述符的指针会存储在通用对象头中，而非对象主体中。然而，如果某个对
象确实需要自行进行额外的安全检查，则会定义一种自定义安全例程，它会像File和Key对象一样工作，即使用一种能够由文件系统或配置管理器直接管理的
方式存储安全信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在创建、打开、复制或继承
对象时，对象管理器会在创建对象句柄时调用Open方法。例如，WindowStation和Desktop对象就提供了Open方法。实际上，
WindowStation对象类型需要Open方法，以便让Win32k.sys能够将内存共享给充当桌面相关内存池的进程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">我们可以用I/O系统中使
用的Close方法作为另一个例子。I/O管理器会为文件对象类型注册一个Close方法，当对象管理器关闭一个文件对象句柄时，它会调用该Close方
法。这个Close方法会检查正在关闭文件句柄的进程是否拥有文件上任何未完成的锁，如果有，则会删除这些锁。检查文件锁，这并非对象管理器本身能够或应
该做的事情。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在从内存中删除临时对象之
前，对象管理器会调用Delete方法（如果已注册这样的方法）。例如，内存管理器会为节对象类型注册一个Delete方法，用来释放被该节占用的物理页
面，同时还可验证节对象被删除之前，内存管理器曾为该节分配的所有内部数据结构是否均已删除。需要再次提醒的是，对象管理器无法执行这项工作，因为它不了
解内存管理器的内部工作。其他类型对象的Delete方法也是按照类似方式工作的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当发现有对象存在于对象管
理器的命名空间范围以外时，Parse方法（以及类似的Query 
name方法）可以让对象管理器将查找对象的控制权转交给辅助（secondary）对象管理器。当对象管理器查找对象名称时，如果遇到关联了Parse
方法的路径，此时查找工作将会暂停。随后对象管理器会调用Parse方法，并将自己正在查找的对象名称的剩余查找工作传递给该方法。除了对象管理器的命名
空间外，Windows中还有两个命名空间：包含了配置管理器实现的注册表命名空间，以及I/O管理器在文件系统驱动程序的帮助下所实现的文件系统命名空
间（有关配置管理器的详情请参阅第10章，有关I/O管理器和文件系统驱动程序的详情请参阅卷1第6章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">例如，当一个进程打开了名
为\Device\HarddiskVolume1\docs\resume.doc的对象句柄时，对象管理器会遍历其名称树，直到自己到达名为
HarddiskVolume1的设备对象。在看到该对象关联了Parse方法后，对象管理器会调用该方法，并将自己正在搜索的对象名称的其余部分传递给
该方法，本例中所传递的为字符串docs\resume.doc。设备对象的Parse方法是一种I/O例程，因为I/O管理器定义了设备对象的类型并为
其注册了Parse方法。I/O管理器的Parse例程会接收该名称字符串，并将其传递给相应的文件系统，由文件系统找到并打开磁盘中的文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与Parse方法类似，
I/O系统还会使用Security方法。当有线程试图查询或更改用于保护文件的安全信息时，都会调用Security方法。文件对象与其他对象的安全信
息有所差异，因为安全信息存储在文件本身而非内存中。因此，必须调用I/O系统来查找安全信息，随后才能读取或更改这些信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后，Okay to 
close方法可充当额外保护层，防止系统工作使用的句柄被恶意（或错误地）关闭。例如，每个进程都有一个指向Desktop对象或指向自己线程的可见窗
口所在对象的句柄。在标准安全模型下，这些对象可以关闭自己的桌面句柄，因为进程可以完全控制自己的对象。但这种情况会导致线程最终没有与之关联的桌面，
违背了窗口模型。为防止产生这种情况，Win32k.sys会为Desktop和WindowStation对象注册一个Okay to 
close例程。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>对</b><b>象</b><b>句</b><b>柄</b><b>和</b><b>进</b><b>程</b><b>句</b><b>柄</b><b>表</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当进程按照名称创建或打开
对象时，它会收到一个句柄，该句柄代表了自己对该对象的访问。使用句柄引用对象，这种方式比使用名称引用速度更快，因为对象管理器可以跳过名称查找环节直
接找到对象。正如上文所述，在创建进程的时候，进程还可以通过继承句柄的方式获得对象句柄（前提是创建者在CreateProcess调用中指定了继承句
柄标记且句柄被标记为可继承，或者在创建时或创建后使用Windows的SetHandleInformation函数）。另外，进程还可以从其他进程复
制句柄（详见Windows的DuplicateHandle函数）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">所有用户模式进程必须先拥有一个对象句柄，随后进程的线程才能使用该对象。使用句柄操作系统资源并不是一种新做法。例如，C和C++运行时库就可以返回指向已打开文件的句柄。句柄可以充当指向系统资源的间接指针，这种间接性使得应用程序无法直接操作系统数据结构。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对象句柄还提供了其他的优
点。首先，除了所引用指代的目标外，文件句柄、事件句柄和进程句柄之间没有任何区别。这种相似性为引用的（无论任何类型的）对象提供了一种统一的接口。其
次，对象管理器拥有创建句柄和定位句柄所引用对象的专有权利。这意味着对象管理器可以对对象产生影响的每一个用户模式操作进行仔细检查，并查看调用方的安
全配置文件是否允许针对目标对象执行所请求的操作。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
执行体组件和设备驱动程序可以直接访问对象，这是因为它们运行在内核模式下，因此可以访问系统内存中的对象结构。然而，它们必须增加对象的引用计数，用来
声明自己对这些对象的使用，这样对象才不会在依然使用的过程中被撤销分配（详情可参阅下文“对象保留”一节）。但是要成功使用对象，设备驱动程序需要知道
对象的内部结构定义，可大部分对象并未提供这些信息。因此，我们需要尽量让设备驱动程序使用相应的内核API来修改或读取对象的此类信息。例如，设备驱动
程序可以获得指向Process对象（EPROCESS）的指针，但其结构是不透明的，而必须使用Ps* 
API代替。对于其他对象，类型本身也是不透明的（例如大部分执行体对象会包装一个调度程序对象，如事件或互斥）。对于这些对象，驱动程序必须使用与用户
模式应用程序最终调用相同的系统调用（如ZwCreateEvent），并使用句柄而不是对象指针。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>打</b><b>开</b><b>的</b><b>句</b><b>柄</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">运
行Process Explorer并确保底部窗格已启用，随后即可通过配置查看打开的句柄。（点击View→Lower Pane 
View，然后点击Handles。）随后打开命令提示符窗口即可查看新创建的Cmd.exe进程的句柄表。我们应当可以看到代表当前目录的打开文件句
柄。例如，假设当前目录为C:\Users\Public，Process Explorer会显示如下内容。</span></p><div style="display: block;text-align:center;">
	<img width="831" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4dec5c66d353a2c1b7294ddcea45e593.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随
后按下空格键，或选择View→Update Speed，再选择Pause Now，这样可以暂停Process 
Explorer的运行。接下来使用cd命令更改当前目录，并按下F5刷新显示结果。我们可以在Process 
Explorer中看到指向上一个当前目录的句柄已关闭，并且打开了一个指向新的当前目录的新句柄。之前的句柄会使用红色强调显示，新句柄则会用绿色突出
显示。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">Process
 Explorer的将差异之处用不同颜色突出显示的功能，让我们可以轻松发现句柄表中的变化。举例来说，如果某个进程正在泄漏句柄，使用Process
 
Explorer查看句柄表就可以快速发现已经打开但没有关闭的句柄（一般来说，我们会看到同一个对象包含很长的句柄列表）。这些信息可以帮助程序员发现
句柄泄漏。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">资源监视器也可以针对我们选择的进程显示所有打开的具名句柄，为此只需选择进程名称旁边的复选框。下图展示了命令提示符进程所打开的句柄。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/9fb802ee361d018a07d61a038031f9d2.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们还可以使用Sysinternals的命令行工具Handle查看打开的句柄表。例如，下列精简后的Handle输出结果展示了在更改目录前后，
Cmd.exe进程的句柄表中所包含的文件对象句柄。默认情况下，Handle会过滤掉所有非文件句柄，除非使用–a开关，使用后可以像Process 
Explorer那样显示进程中的所有句柄。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\Users\aione&gt;\sysint\handle.exe -p 8768 -a users </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Nthandle v4.22 - Handle viewer </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright (C) 1997-2019 Mark Russinovich </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sysinternals - www.sysinternals.com </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">cmd.exe            pid: 8768 type: File            150: C:\Users\Public </span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对象句柄可以看成该对象相
关句柄表的索引，由执行体进程（EPROCESS）块（详见本书卷1第3章）进行指向。将该索引乘以4（移动2位）即可为某些API行为所使用的每个句柄
位腾出空间，例如禁止I/O完成端口的通知或更改进程调试的工作方式。因此第一个句柄索引为4，第二个为8，以此类推。使用句柄5、6、7将直接重定向至
与句柄4相同的对象，而句柄9、10、11则引用了与句柄8相同的对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">进程句柄表包含指向进程当
前已打开句柄的所有对象的指针，并且句柄值会尽可能地重用，这样下一个新的句柄索引将会尽可能地利用现有的已关闭句柄索引。如图8-33所示，句柄表实现
了一种三级结构，这种结构类似于传统x86内存管理单元所实现的虚拟到物理地址转换机制，但出于兼容性方面的原因，其上限为24位，这导致每个进程最多可
以有16777215（2<span style="font-size:13px;font-family:'PingFang SC';"><sup>2</sup><sup>4</sup></span>−1）
个句柄。图8-34展示了Windows的句柄表中每个条目的布局。为节约内核内存成本，创建进程时只分配最底层的句柄表，其他层级将按照需求创建。子句
柄表（Subhandle 
table）包含一个内存页可装下尽可能多数量的条目，但需要减去一个用于审核的条目。例如，对于64位系统，一个内存页为4096字节，除以句柄表一个
条目的大小（16字节）得到256，再减去1得到255，也就是说，最底层的句柄表共可包含255个条目。中层句柄表可包含一整页指向子句柄表的指针，因
为子句柄表的数量取决于内存页的大小以及平台指针的大小。同样以64位系统为例，只需计算4096/8即可得知共包含512个条目。但由于存在24位的上
限，因此顶级指针表只能包含32个条目。由这些数量相乘可知，总共可以包含32×512×255，即16711680个句柄。</span></p><div style="display: block;text-align:center;">
	<img width="744" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/0f17e053a0011ca3839f831c6212e563.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图8-33 Windows进程句柄表的架构</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>创</b><b>建</b><b>最</b><b>大</b><b>数</b><b>量</b><b>的</b><b>句</b><b>柄</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">Sysinternals
提供的测试程序Testlimit包含了一个选项，可以打开尽可能多的对象句柄，直到无法继续打开。我们可以此查看自己系统中的一个进程最多可以创建多少
个句柄。由于句柄表是从分页缓冲池中分配的，因此我们可能在实际达到一个进程可创建的句柄数量最大值之前，就遇到分页缓冲池耗尽的情况。要查看自己系统可
以创建多少句柄，可执行如下步骤：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">1）根据32/64位Windows版本下载对应的Testlimit可执行文件：https://docs.microsoft.com/sysinternals/downloads/testlimit。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">2）
运行Process Explorer，点击View，再点击System 
Information。接下来点击Memory选项卡。请留意分页缓冲池的当前大小和最大大小（要显示缓冲池大小的最大值，需要将Process 
Explorer配置为能够正确访问内核映像，即Ntoskrnl.exe的符号）。为了在运行Testlimit程序时可以看到缓冲池的使用量，请不要
关闭该系统信息界面。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">3）打开一个命令提示符窗口。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">4）使用-h开关运行Testlimit程序（运行testlimit –h）。当Testlimit无法继续打开新句柄时，会显示自己已经创建的句柄总数。如果该数值小于约1600万，那么可能意味着在达到每线程句柄数的理论最大值之前，分页缓冲池就已耗尽。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">5）关闭命令提示符窗口，这样即可直接终止Testlimit进程，进而关闭所有打开的句柄。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如图8-34所示，在32
位系统中，每个句柄表条目由一种具备两个32位成员的结构组成：一个指向对象的指针（该指针包含3个标记，因此消耗了最低的3位，又因为所有对象都是8字
节对齐的，因此这些位可以假定为0），以及所授予的访问掩码（访问掩码只需要25位，因为通用权限永远不会存储在句柄条目中）。此外，还有另外两个标记和
引用使用量计数，下文将会介绍这些内容。</span></p><div style="display: block;text-align:center;">
	<img width="770" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e11c11497495c79cc400c31f7c17dbef.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-34 32位句柄表条目的结构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">64位系统中存在相同的基
本数据段，但编码方式有所差异。举例来说，64位系统只需要44位即可对指针对象进行编码（假设处理器具备四级分页和48位虚拟内存），因为对象是16字
节对齐的，因此现在可以假设最低的4位为0。借此即可将“Protect from 
close”（保护防止关闭）标记编码到上文提到的32位系统最初所使用的3个标记中，因此总共可以使用4个标记。另一个变化在于，引用使用量计数会被编
码至指针旁边的剩余16位中，而不再编码到访问掩码旁。最后，“No rights 
upgrade”（无升级权限）标记依然保留在访问掩码旁，但剩余的6位是空闲的，并且依然有32位的对齐是空闲的，因此总共需要16字节。对于具有五级
分页的LA57系统
	<sup><img width="10" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="LA57系统是指处理器的Linear Address（线性地址）为57位的系统，这是通过Intel EM64T模式下的x86_64处理器新增的一种五级分页模式实现的。顾名思义，五级分页可通过一种包含五个层级的分页结构来转译处理器的线性地址，相比原本的四级分页，可将处理器线性地址由48位扩展至57位，进而让处理器和应用程序可以访问更大容量的内存。——译者注" title="LA57系统是指处理器的Linear Address（线性地址）为57位的系统，这是通过Intel EM64T模式下的x86_64处理器新增的一种五级分页模式实现的。顾名思义，五级分页可通过一种包含五个层级的分页结构来转译处理器的线性地址，相比原本的四级分页，可将处理器线性地址由48位扩展至57位，进而让处理器和应用程序可以访问更大容量的内存。——译者注" class="epub-footnote"></sup>，情况又产生了变化，此时指针必须为53位，而使用量计数位将仅剩7位。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">既然已经提到了各种标记，
那么接下来一起看看这些标记是做什么用的。首先，第一个标记是一个锁定位，代表对应的条目当前是否正被使用。从技术上来看，这个位代表“解锁”，意味着我
们通常期待这个最低位已被正常设置。第二个标记是继承标志，决定了该进程创建的其他进程能否在自己的句柄表中获得该句柄的一个副本。如上文所述，句柄能否
继承，可在创建句柄时指定，或在句柄创建完毕后使用SetHandleInformation函数设置。第三个标记代表关闭该对象是否要生成审核消息（该
标记并未暴露给Windows，仅供对象管理器在内部使用）。随后的“Protect from 
close”位决定了是否允许调用方关闭该句柄（该标记也可使用SetHandleInformation函数设置）。最后的“No rights 
upgrade”位决定了如果句柄被复制给具备更高特权的进程，是否应该同步地升级访问权限。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">后4个标记可通过传递给
ObReferenceObjectByHandle等API的OBJECT_HANDLE_INFORMATION结构暴露给驱动程序，并能映射至
OBJ_INHERIT (0x2)、OBJ_AUDIT_OBJECT_CLOSE (0x4)、OBJ_PROTECT_CLOSE 
(0x1)和OBJ_NO_RIGHTS_UPGRADE 
(0x8)，这也正好与上文提到的在创建对象时设置的OBJ_attribute定义中的“缺口”完全对应。因此，运行时的对象属性最终可对某对象的特定
行为及特定对象的句柄所表现的特定行为进行编码。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后，我们还曾提过，对象
头的指针计数器字段的编码和句柄表条目中都存在引用使用量计数器。这个方便的功能可将预先存在的引用的缓存数量（基于可用位的数量）编码为每个句柄表条目
的一部分，随后将具有相同对象句柄的所有进程的使用量计数相加后放入对象头的指针计数器中。因此指针计数器的数值是句柄数、通过
ObReferenceObject产生的内核引用数，以及每个句柄缓存的引用数三者的总和。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每当进程用完一个对象时，
只需取消对句柄的引用（基本上，这是通过调用任意可接受句柄作为输入，并最终将其转换为对象的Windows 
API实现的）即可减少缓存的引用数，也就是说，这会让计数器的数值减少1，直到数值最终归零，随后将不再对其进行跟踪。由此我们可以通过特定进程的句柄
准确推断特定对象被使用/访问/管理的次数。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">将调试器命令!trueref与-v标记配合使用，即可显示引用对象的每个句柄，以及准确的使用次数（但需要同时统计已使用/已丢弃用量计数器的数值）。在下文的一个实验中，我们将使用该命令进一步了解对象的使用情况。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统组件和设备驱动程序通
常需要打开用户模式应用程序无法访问或从一开始就根本不应绑定到特定进程的对象句柄。为此可在与System进程关联的内核句柄表（内部以
ObpKernelHandleTable名称引用）中创建句柄。该表中的句柄只能从内核模式以任意进程上下文访问，这意味着内核模式函数可在任意进程上
下文中引用该句柄而不影响性能。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当句柄的高位被设置（即当
内核句柄表中的句柄引用数量在32位系统中大于0x80000000，或在64位系统中大于0xFFFFFFFF80000000）时，对象管理器即可从
内核句柄表中识别对句柄的引用（从数据类型的角度来看，因为句柄实际上被定义为指针，因此编译器会强制进行符号扩展）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内核句柄表还充当了
System进程和最小化进程的句柄表，因此System进程创建的所有句柄（例如System线程中运行的代码）都被隐式地作为内核句柄，因为这些进程
EPROCESS结构的ObjectTable已设置了ObpKernelHandleTable符号。理论上，这意味着具备足够特权的用户模式进程可以
使用DuplicateHandle API将内核句柄提取到用户模式中，但自Windows 
Vista引入了受保护进程的概念（详见本书卷1）后，以这种方式发起的攻击已经得到了缓解。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，作为一种安全缓解措施，任何由内核驱动程序创建的句柄，只要将“原本的模式”设置为KernelMode，就会在新版Windows中自动被转换为内核句柄，这样即可防止句柄被无意泄漏给用户模式下的应用程序。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>使</b><b>用</b><b>内</b><b>核</b><b>调</b><b>试</b><b>器</b><b>查</b><b>看</b><b>句</b><b>柄</b><b>表</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">内核调试器中的!handle命令可接收三个参数：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">!handle &lt;handle index&gt; &lt;flags&gt; &lt;processid&gt; </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">“handle index”（句柄索引）代表句柄表中的句柄条目（“0”意味着“显示所有句柄”）。第一个句柄的索引为4，第二个为8，以此类推。例如，输入!handle 4可显示当前进程的第一个句柄。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">“flags”则是一种位掩码，其中“位0”意味着“仅显示句柄条目中的信息”，“位1”意味着“显示可用句柄（而非仅显示已使用句柄）”，“位2”意味着“显示句柄所引用对象的相关信息”。下列命令可显示ID为0x1540的进程在句柄表中的完整信息：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; !handle 0 7 1540 </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PROCESS ffff898f239ac440 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    SessionId: 0 Cid: 1540    Peb: 1ae33d000 ParentCid: 03c0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    DirBase: 211e1d000 ObjectTable: ffffc704b46dbd40 HandleCount: 641. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Image: com.docker.service </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Handle table at ffffc704b46dbd40 with 641 entries in use </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0004: Object: ffff898f239589e0 GrantedAccess: 001f0003 (Protected) (Inherit) Entry:</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffffc704b45ff010 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Object: ffff898f239589e0 Type: (ffff898f032e2560) Event </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ObjectHeader: ffff898f239589b0 (new version) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        HandleCount: 1 PointerCount: 32766 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0008: Object: ffff898f23869770 GrantedAccess: 00000804 (Audit) Entry: ffffc704b45ff020</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Object: ffff898f23869770 Type: (ffff898f033f7220) EtwRegistration </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ObjectHeader: ffff898f23869740 (new version) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        HandleCount: 1 PointerCount: 32764 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">并
不需要记住所有这些位的含义并将进程ID转换为十六进制，也可以借助调试器数据模型，使用进程的Io.Handles命名空间来访问句柄。例如，输入dx
 @$curprocess. 
Io.Handles[4]即可显示当前进程的第一个句柄，包括访问权和名称。下列命令可以显示PID为5440（即0x1540）进程的所有句柄的详细
信息：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx -r2 @$cursession.Processes[5440].Io.Handles </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">@$cursession.Processes[5440].Io.Handles </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0x4] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Handle           : 0x4 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Type             : Event </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        GrantedAccess    : Delete | ReadControl | WriteDac | WriteOwner | Synch |</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">QueryState | ModifyState </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Object           [Type: OBJECTHEADER] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0x8] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Handle           : 0x8 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Type            : EtwRegistration </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        GrantedAccess </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Object          [Type:_OBJECT_HEADER] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0xc] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Handle          : 0xc </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Type            : Event </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        GrantedAccess   : Delete | ReadControl | WriteDac | WriteOwner | Synch |</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">QueryState | ModifyState </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Object          [Type:_OBJECT_HEADER] </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">还可以使用支持LINQ谓词的调试器数据模型执行更有趣的搜索，例如查找可读取/写入的具名节对象映射：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx @$cursession.Processes[5440].Io.Handles.Where(h =&gt; (h.Type == "Section") &amp;&amp;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">(h.GrantedAccess.MapWrite) &amp;&amp; (h.GrantedAccess.MapRead)).Select(h =&gt; h.ObjectName)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">@$cursession.Processes[5440].Io.Handles.Where(h =&gt; (h.Type == "Section") &amp;&amp; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">(h.GrantedAccess.MapWrite) &amp;&amp; (h.GrantedAccess.MapRead)).Select(h =&gt; h.ObjectName)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0x16c]         : "Cor_Private_IPCBlock_v4_5440" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0x170]         : "Cor_SxSPublic_IPCBlock" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0x354]         : "windows_shell_global_counters" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0x3b8]         : "UrlZonesSM_DESKTOP-SVVLOTP$" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [0x680]         : "NLS_CodePage_1252_3_2_0_0" </span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>使</b><b>用</b><b>内</b><b>核</b><b>调</b><b>试</b><b>器</b><b>搜</b><b>索</b><b>打</b><b>开</b><b>的</b><b>文</b><b>件</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">虽
然可以使用Process Hacker、Process 
Explorer、Handle以及OpenFiles.exe工具搜索打开的文件句柄，但在查看故障转储或进行远程分析时，这些工具可能并非总是可用。
此时也可以使用!devhandles命令搜索特定卷上打开的文件句柄（有关设备、文件和卷的详细信息请参阅第11章）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">1）选择感兴趣的盘符，并获得指向其Device对象的指针，为此可使用!object命令，如下所示：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; !object \Global??\C: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Object: ffffc704ae684970 Type: (ffff898f03295a60) SymbolicLink </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ObjectHeader: ffffc704ae684940 (new version) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    HandleCount: 0  PointerCount: 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Directory Object: ffffc704ade04ca0 Name: C: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    flags: 00000000 ( Local ) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Target String is '\Device\HarddiskVolume3' </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Drive Letter Index is 3 (C:) </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">2）使用!object命令获得目标卷Device对象的名称：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">1: kd&gt; !object \Device\HarddiskVolume1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Object: FFFF898F0820D8F0 Type: (fffffa8000ca0750) Device </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">3）将Device对象的指针与!devhandles命令配合使用，所显示的每个对象都会指向一个文件：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; !devhandles 0xFFFF898F0820D8F0 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Checking handle table for process 0xffff898f0327d300 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Kernel handle table at ffffc704ade05580 with 7047 entries in use </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PROCESS ffff898f0327d300 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    SessionId: none Cid: 0004    Peb: 00000000 ParentCid: 0000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    DirBase: 001ad000 ObjectTable: ffffc704ade05580 HandleCount: 7023. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Image: System </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">019c: Object: ffff898F080836a0 GrantedAccess: 0012019f (Protected) (Inherit) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">(Audit) Entry: ffffc704ade28670 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Object: ffff898F080836a0 Type: (ffff898f032f9820) File </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ObjectHeader: ffff898F08083670 (new version) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        HandleCount: 1 PointerCount: 32767 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Directory Object: 00000000 Name: \$Extend\$RmMetadata\$TxfLog\</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                         $TxfLog.blf {HarddiskVolume4} </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">尽管该扩展可以正常生效，但大家可能注意到需要等待30秒到1分钟才能开始看到前几个句柄。实际上，我们可以使用支持LINQ谓词的调试器数据模型实现相同的效果，这种方式可以立刻显示返回的结果：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx -r2 @$cursession.Processes.Select(p =&gt; p.Io.Handles.Where(h =&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     h.Type == "File").Where(f =&gt; f.Object.UnderlyingObject.DeviceObject == </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     (nt!_DEVICE_OBJECT*)0xFFFF898F0820D8F0).Select(f =&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     f.Object.UnderlyingObject.FileName)) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">@$cursession.Processes.Select(p =&gt; p.Io.Handles.Where(h =&gt; h.Type == "File"). </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Where(f =&gt; f.Object.UnderlyingObject.DeviceObject == (nt!_DEVICE_OBJECT*)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0xFFFF898F0820D8F0).Select(f =&gt; f.Object.UnderlyingObject.FileName))</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   [0x0]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   [0x19c]    : "\$Extend\$RmMetadata\$TxfLog\$TxfLog.blf" [Type:_UNICODE_STRING]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   [0x2dc]    : "\$Extend\$RmMetadata\$Txf:$I30:$INDEX_ALLOCATION" [Type:_UNICODE_STRING]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   [0x2e0]    : "\$Extend\$RmMetadata\$TxfLog\$TxfLogContainer00000000000000000002"</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                [Type:_UNICODE_STRING]</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>保</b><b>留</b><b>对</b><b>象</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对象可以代表从事件到文件
再到进程间消息的一切东西，因此，应用程序和内核代码创建对象的能力，对任何一段Windows代码的正常运行及运行时需要表现的行为都至关重要。如果对
象分配失败，通常会导致功能丢失（进程无法打开文件）甚至数据丢失或系统崩溃（进程无法分配同步对象）等各种问题。更糟糕的是，在某些情况下，对象创建失
败所导致的错误报告行为本身也需要分配新的对象。为了处理这种情况，Windows实现了两个特殊的保留对象：用户APC保留对象（user APC 
reserve object）和I/O完成数据包保留对象（I/O completion packet reserve 
object）。请注意，保留对象机制是完全可扩展的，未来版本的Windows可能增加其他保留对象类型，从广义上来看，保留对象机制可以将任何内核模
式的数据结构包装为对象（具备关联的句柄、名称和安全性）以供后续使用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如上文所述，APC可用
于诸如挂起、终止和I/O完成等操作，并与希望提供异步回调的用户模式应用程序进行通信。当用户模式应用程序请求一个以其他线程为目标的用户APC时，需
要用到Kernelbase.dll中的QueueUserApc 
API，以此调用NtQueueApcThread这个系统调用。在内核中，该系统调用会尝试着分配一块分页缓冲池，并在其中存储与APC关联的KAPC
控制对象结构。在内存不足的情况下，该操作会失败，从而阻止APC的交付，根据该APC的用途，这可能导致数据丢失或功能丢失。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了防止这种情况，用户模
式应用程序可以在启动时使用NtAllocateReserveObject这个系统调用请求内核预分配KAPC结构。随后应用程序可以使用另一个系统调
用NtQueueApcThreadEx，该系统调用包含一个额外的参数，可用于存储保留对象的句柄。这样，内核就不需要分配新的结构，而是可以尝试着获
取保留对象（通过将其InUse位设置为True）并一直使用该保留对象，直到不再需要KAPC对象，此时该保留对象会被释放回系统中。目前，为防止第三
方开发者无法妥善管理系统资源，保留对象API仅在内部通过操作系统组件的系统调用使用。例如，RPC库可使用保留的APC对象来保证当内存不足时，异步
回调依然可以正常返回。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当应用程序需要以无故障方
式交付I/O完成端口的消息或数据包时，也可能发生类似的情况。一般来说，可以使用Kernelbase.dll中的
PostQueuedCompletionStatus API（该API会调用NtSetIoCompletion 
API）发送数据包。与用户APC类似，内核必须分配一个I/O管理器结构来包含完成数据包的相关信息，如果该分配失败，则将无法创建数据包。借助保留对
象，应用程序可以在启动时使用NtAllocateReserveObject 
API让内核预分配I/O完成数据包，并使用系统调用NtSetIoCompletionEx为该保留对象提供句柄，以此保证提供成功操作的路径。与用户
APC保留对象类似，该功能同样是为系统组件保留的，RPC库和Windows Peer-To-Peer 
BranchCache服务可以使用该功能保证异步I/O操作能够成功完成。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>对</b><b>象</b><b>安</b><b>全</b><b>性</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当打开一个文件时，必须指
定自己是要进行读取还是写入操作。如果试图针对一个以读取访问方式打开的文件执行写入操作，那么将会收到错误信息。同理，在执行体中，当进程创建对象或打
开现有对象的句柄时，进程也必须指定一系列自己需要的访问权限，也就是说，需要指定自己希望对该对象执行怎样的操作。进程可以请求一组可适用于所有对象类
型的标准访问权限（例如读取、写入、执行），或者指定对特定对象类型执行不同权限的访问。例如，进程可以对文件对象请求删除或附加访问，同样也可以针对线
程对象请求挂起或终止的权限。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当进程打开对象句柄时，对
象管理器会调用安全引用监视器（安全系统在内核模式中的一部分）并传递进程的一组所需访问权限。安全引用监视器会检查该对象的安全描述符是否允许执行进程
所请求的访问类型。如果允许，则安全引用监视器会返回一组访问权限并将其授予该进程，随后对象管理器会将这些权限存储在自己创建的对象句柄中。本书卷1第
7章曾介绍过安全系统是如何确定谁可以访问哪些对象的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后，每当进程的线程通过
服务调用的方式使用该句柄时，对象管理器都可以快速检查句柄中所存储的已授予的访问权限是否与线程调用的对象服务所暗含的用法相匹配。举例来说，如果调用
方请求对一个节对象进行读取访问，但随后调用了一个服务试图进行写入访问，那么该操作将会失败。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>对</b><b>象</b><b>的</b><b>安</b><b>全</b><b>性</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们可以使用Process Hacker、Process 
Explorer、WinObj、WinObjEx64或AccessChk（这些均为Sysinternals提供的工具，或发布到GitHub的开源
工具）来查看对象的各种访问权限。下面一起查看对象访问控制列表（ACL）的不同方法：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·我们可以使用WinObj或WinObjEx64查看系统中的任何对象（包括对象目录），</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">为
此只需右键点击对象并选择Properties。例如，选择BaseNamedObjects目录，选择Properties，随后打开Security
选项卡，就可以看到一个类似下图所示的对话框。由于WinObjEx64支持更广泛的对象类型，因此可以通过该对话框查看更多类型系统资源的相关信息。</span></p><div style="display: block;text-align:center;">
	<img width="607" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/18b68ecd9e40a33a4e597e598fb3a1ed.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">检查该对话框中的设置可以发现一些有趣的情况，例如Everyone组没有该目录的删除访问权限，但SYSTEM账户有该权限（因为具备SYSTEM特权的Session 0服务会将自己的对象存储在这里）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
除了使用WinObj或WinObjEx64，我们也可以按照上文“查看打开的句柄”实验中介绍的方法，使用Process 
Explorer查看进程的句柄表，或者使用Process 
Hacker查看此类信息。在查看Explorer.exe进程的句柄表时会发现一个指向
\Sessions\n\BaseNamedObjectsdirectory目录的Directory对象句柄（其中n是在引导时定义的任意数字的会话
编号，下文很快将介绍会话命名空间）。双击该对象句柄后打开Security选项卡即可看到类似的对话框（不过显示了更多用户和授予的权限）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·还可以使用AccessChk配合-o开关查询任意对象的安全信息，输出结果如下文所示。请注意，使用AccessChk还可以查看对象的完整性级别（有关完整性级别和安全引用监视器的详细信息，请参阅本书卷1第7章）。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\sysint&gt;accesschk -o \Sessions\1\BaseNamedObjects </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Accesschk v6.13 - Reports effective permissions for securable objects </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright (C) 2006-2020 Mark Russinovich </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sysinternals - www.sysinternals.com </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">\Sessions\1\BaseNamedObjects </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  Type: Directory </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  RW Window Manager\DWM-1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  RW NT AUTHORITY\SYSTEM </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  RW DESKTOP-SVVLOTP\aione </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  RW DESKTOP-SVVLOTP\aione-S-1-5-5-0-841005 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  RW BUILTIN\Administrators </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  R  Everyone </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     NT AUTHORITY\RESTRICTED </span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows还支持Ex
（扩展）版本的API（例如CreateEventEx、CreateMutexEx、CreateSemaphoreEx），并能添加另一个参数来指定
访问掩码。这样，应用程序就可以使用随机访问控制列表（Discretionary Access Control 
List，DACL）正确地保护自己的对象，而不会破坏自己使用创建对象API打开对象句柄的能力。有人可能会纳闷客户端应用程序为何不直接使用
OpenEvent，毕竟它们也可以支持所需的访问参数。在处理失败的打开调用时，使用打开对象API会造成一种固有的竞争状况，即客户端应用程序会试图
在事件创建出来之前打开该事件。在大部分这种类型的应用程序中，失败都是因为打开API后紧跟了创建API。然而，我们无法保证这个创建操作符合原子性的
要求，也就是说，无法保证创建操作只发生一次。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">实际上，多个线程或进程可能同时执行创建API，并且它们会试图同时创建事件。这种竞争状况及处理这种情况所额外需要的复杂性，使得打开对象API并不适合成为这种问题的解决方案，因此会使用Ex API代替。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>对</b><b>象</b><b>的</b><b>保</b><b>留</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对象可分为两种类型：临时
对象和永久对象。大部分对象都是临时对象，也就是说，会在使用过程中保留临时对象，但会在用完后释放。永久对象则会在明确释放之前始终被保留。由于大部分
对象是临时对象，因此后续内容将介绍对象管理器如何实现对象的保留，即只在需要的过程中保留临时对象，在不需要时将其删除。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于所有需要访问对象的用
户模式进程必须先打开对象句柄，因此对象管理器可以轻松地跟踪进程数量，以及有多少进程正在使用某一个对象。这些句柄的跟踪工作也是实现保留对象的工作之
一。对象管理器会通过两个环节实现对象保留。第一个环节叫作名称保留，由已存在对象的打开句柄数控制。每次有进程打开一个对象句柄后，对象管理器会增大对
象头中打开句柄计数器的数值。当进程用完该对象并关闭句柄后，对象管理器会减小打开句柄计数器的数值。当该计数器数值归零后，对象管理器就会将该对象的名
称从自己的全局命名空间中删除。这种删除操作可防止进程继续打开该对象的句柄。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对象保留的第二个环节是当
对象不再被使用时，停止维持对象本身（即彻底删除对象）。操作系统代码通常会使用指针而非句柄来访问对象，因此对象管理器还必须记录自己已经分配给操作系
统进程的对象指针数量。每次发出一个对象指针时，对象管理器都会增大该对象引用计数器的数值，这个计数器也叫指针计数器。当内核模式组件用完指针后，会调
用对象管理器减小该对象的引用计数器数值。系统也会在增大句柄计数器数值的同时增大引用计数器的数值，并在减小句柄计数器数值的同时减小引用计数器的数
值，因为句柄也是对对象的引用，必须加以跟踪。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后，我们还要介绍使用量
引用计数器，该计数器可以缓存指针计数器的引用数量，数值会在每次进程使用句柄时减小。出于性能原因，Windows 
8开始增加了使用量引用计数器。当内核被要求从自己的句柄中获取对象指针时，内核能在无须获取全局句柄表锁的情况下进行解析。这意味着在较新版本的
Windows中，上文“对象句柄和进程句柄表”一节介绍的句柄表条目将包含一个使用量引用计数器，该计数器会在应用程序或内核驱动程序首次“使用”对象
句柄时进行初始化。请注意，在该语境中，“使用”这个词是指通过句柄解析对象指针的行为，该操作是由ObReferenceObjectByHandle
等API在内核中执行的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">让我们通过图8-35这个
例子来看看这三个计数器。该图中描绘了64位系统中使用的两个事件对象。进程A创建了第一个事件，并获得了该事件的句柄。该事件具备名称，这也意味着对象
管理器会将其插入正确的目录对象（例如\BaseNamedObjects）中，并为其分配初始引用计数器“2”和句柄数“1”。初始化操作完成后，进程
A等待第一个事件，该操作使得内核可以使用（或引用）事件句柄，并将句柄的使用量引用计数器分配为32767（十六进制的0x7FFF，将第15位设置为
1）。该数值会被添加到第一个事件对象的引用计数器中，使得该计数器的数值加一，因此最终值变为32770（此时句柄计数器的值依然为1）。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/56beec73ee90a98c405c5d2ff8f2f596.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-35 句柄和引用计数器</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">进程B初始化，创建第二个
具名事件并发出信号。最后一个操作将使用（引用）第二个事件，使其引用计数器数值也达到32770。随后，进程B打开第一个事件（由进程A分配）。该操作
会让内核创建一个新句柄（仅在进程B的地址空间内有效），这会让第一个事件对象的句柄计数器和引用计数器的数值增加到2和32771（注意，此时新句柄表
条目的使用量引用计数器尚未初始化）。进程B在向第一个事件发送信号之前，会将自己的句柄使用三次：第一个操作会将句柄的使用量引用计数器初始化为
32767，并将该数值添加到对象引用计数器中，让该计数器进一步增加1个单位，并让总体值最终达到65539。针对句柄的后续操作则会在不影响对象的引
用计数器前提下减小使用量引用计数器的值。当内核用完该对象后，总是会取消对对象指针的引用，而该操作会释放内核对象的引用计数器。因此使用4次（包括信
号发送操作）之后，第一个对象的句柄计数器变成了2，引用计数器变成了65535。此外，第一个事件还会被某些内核模式的结构所引用，因此其最终的引用计
数器将变为65536。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当进程关闭一个对象的句柄
时（该操作会导致在内核中执行NtClose例程），对象管理器知道自己需要从对象的引用计数器中减去句柄使用量引用计数器的数值。这样即可正确地取消对
句柄的引用。在上述例子中，即使进程A和进程B同时关闭了自己第一个对象的句柄，该对象也可以继续存在，因为其引用计数器会变为1（但其句柄计数器会变为
0）。然而，当进程B关闭了第二个事件对象的句柄后，该对象将被撤销分配，因为其引用计数器归零了。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种行为意味着即便对象的
打开句柄计数器归零，对象的引用计数器可能依然保持为正数，操作系统依然在以某种方式使用着这个对象。最终，只有当引用计数器归零后，对象管理器才会从内
存中删除该对象。该删除操作需要遵守某些规则，并且在某些情况下还需要调用方的配合。例如，因为对象可以存在于分页和非分页内存池中（取决于对象类型中的
设置），如果在DISPATCH_LEVEL的IRQL或更高层面上发生了取消引用操作，并且该操作导致指针计数器归零，那么系统在试图立即释放分页池中
对象占用的内存时将立即崩溃（回想一下可以知道，这种访问其实是非法的，因为永远不应该为页面错误提供服务）。这种情况下，对象管理器会执行延迟删除操
作，将操作放入被动级别（IRQL 0）运行的工作线程队列中。下面将详细介绍系统工作线程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">另一个需要延迟删除的场景
是处理内核事务管理器（Kernel Transaction 
Manager，KTM）对象。某些情况下，一些驱动程序可能持有与这种对象有关的锁，删除这种对象会导致系统试图获取锁。然而，驱动程序可能永远没机会
释放自己的锁，从而导致死锁。处理KTM对象时，驱动程序开发者必须使用ObDereferenceObjectDeferDelete，以便在忽略
IRQL级别的情况下强制进行延迟删除。最后，I/O管理器会将这种机制用作一种优化措施，以此让某些I/O操作可以更快速地完成，而无须等待对象管理器
删除对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于对象的保留会通过这种
方式起效，应用程序只需要维持一个打开的对象句柄，即可保证对象及其名称始终保留在内存中。如果开发者需要编写包含两个或更多协作进程的应用程序，那么完
全无须担心一个进程可能在其他进程还在使用的情况下删除了某个对象。此外，只要操作系统还在使用某个对象，那么关闭应用程序的对象句柄并不会导致该对象被
删除。例如，一个进程可能会创建第二个进程以便在后台执行程序，随后该进程立即关闭了进程句柄。由于操作系统需要通过第二个进程来运行程序，因此会维持其
进程对象的引用。只有当后台程序运行完毕，对象管理器减小了第二个进程的引用计数后，该进程对象才会被删除。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于可能会泄漏内核池内存
并最终导致整个系统范围的内存不足，甚至以某些微妙的方式破坏应用程序，对象泄漏会对系统造成极大的危险。Windows包含了一系列调试机制，我们可以
通过这些机制监视、分析、调试与句柄和对象有关的问题。此外，WinDbg也提供了两个可以纳入这些机制的扩展，进而提供更简单的图形化分析能力。表
8-24介绍了这些调试机制。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-24 适用于对象句柄的调试机制</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/f275e254420c4ae9afe53d80eb385eff.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当试图了解每个句柄在应用
程序或系统上下文中的使用情况时，启用句柄跟踪数据库将能为我们提供巨大的帮助。调试器扩展!htrace可以显示特定句柄被打开时所捕获的栈跟踪结果。
在发现句柄泄漏后，可通过栈跟踪确定创建该句柄的代码，并可分析是否缺少对某些函数（如CloseHandle）的调用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对象引用跟踪!
obtrace扩展通过展示每个新建句柄的栈跟踪结果，以及内核每次引用（以及每次打开、复制或继承）并取消引用句柄时的栈跟踪结果进行更多的监视。通过
分析这些模式，即可在系统层面上更轻松地对对象的滥用情况进行调试。此外，这些引用跟踪也为我们提供了一种方法，可用于理解在处理某些对象时的系统行为。
例如，通过跟踪进程，可显示系统中所有已经注册回调通知的驱动程序（如Process 
Monitor）的引用情况，并有助于检测可能在内核模式下引用句柄但从不取消引用的恶意或有Bug的第三方驱动程序。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
在为特定对象类型启用对象引用跟踪时，只需使用dx命令查看OBJECT_TYPE结构的关键成员即可了解池标记的名称。系统中的每个对象类型都有一个引
用该结构的全局变量，例如PsProcessType。此外，我们也可以使用!object命令查看指向该结构的指针。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与前两种机制不同，对象引
用标记并非一种必须通过全局标记或调试器启用的调试功能，而是一系列API，可以让设备驱动程序开发者使用这些API（包括
ObReferenceObjectWithTag和ObDereferenceObjectWithTag）引用对象或取消引用。与池标记类似（有关池
标记的详细信息请参阅本书卷1第5章），这些API可供开发者提供一个四字符的标记，以此区分每个引用/取消引用对。在使用上文提到的!obtrace扩
展时，也会显示出每个引用和取消引用操作的标记，这就避免了仅使用调用栈这种机制来找出可能存在的泄漏或引用不足等问题，尤其是当驱动程序将特定调用执行
了数千次时。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>资</b><b>源</b><b>记</b><b>账</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与对象保留类似，资源记账
（resource 
accounting）也与对象句柄的使用密切相关。打开的句柄数为正数时意味着有进程正在使用该资源，同时也意味着一些进程正在为对象所占用的内存
而“计费”。当对象的句柄数和引用计数归零后，曾经使用该对象的进程将不再为此“计费”。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">很多操作系统会使用类似配
额的系统限制进程对系统资源的访问。然而，强加给进程的配额有时候是多种多样并且复杂的，用于跟踪配额的代码会分散在操作系统各处。例如，在某些操作系统
中，I/O组件可能会记录并限制进程打开的文件数量，而内存组件可能限制进程的线程分配的内存数量，进程组件可能会限制用户创建的新进程的最大数量或限制
一个进程中可以包含的线程最大数量。这些限制中的每一个都是在操作系统的不同部分跟踪执行的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">相比之下，Windows对象管理器为资源的记账提供了一种中央设施。每个对象头都包含一个名为Quota charges的属性，以此记录当进程中的线程打开一个对象句柄时，对象管理器从该进程所分配的分页或非分页内存池配额中扣减的配额数量。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows中的每个进
程都会指向一种配额结构，其中记录了非分页池、分页池和分页文件使用量的限制和当前值。这些配额默认为0（无限制），但可通过修改注册表值的方式修改（需
要添加/编辑注册表HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Memory 
Management下的NonPagedPoolQuota、PagedPoolQuota和PagingFileQuota）。请注意，同一个交互式
会话中的所有进程将共享同一个配额块（没有公开的方法可供我们用进程自己的配额块来创建进程）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>对</b><b>象</b><b>名</b><b>称</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当创建大量对象时，考虑的一个重要因素是需要设想一个成功的系统来跟踪所有对象。对象管理器需要通过以下信息来帮助我们做到这一点：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一种将对象相互区分的方式。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一种寻找和检索特定对象的方法。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">第一个要求是通过为对象分
配名称来实现的。这是一种大多数操作系统都会提供的扩展，例如为特定的资源、文件、管道或共享内存块命名的能力。相比之下，执行体也允许由对象代表的任何
资源具备名称。第二个要求，即查找和获取对象的方法，也是通过对象名称满足的。只要对象管理器按照名称存储对象，即可按照名称来查找对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对象名称还可用于满足第三
个要求：允许进程共享对象。执行体的对象命名空间是一种全局命名空间，对系统中的所有进程可见。进程可以创建对象并将其名称放入这个全局命名空间，随后另
一个进程即可通过指定对象名称的方式打开该对象的句柄。如果对象不以这种方式共享，那么对象的创建者就不应该为对象分配名称。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为提高效率，对象管理器不
会在每次有人使用对象时都查找对象的名称。相反，对象管理器只会在两种情况下查找名称。首先是当进程创建了具名对象时，此时对象管理器会查找名称以验证该
名称尚未被使用，随后才会将这个新名称存储在全局命名空间中。其次是当进程打开具名对象的句柄时，对象管理器会查找该名称，找到对象，随后将对象句柄返回
给调用方，进而调用方就可以使用句柄引用这个对象。在查找名称时，对象管理器可允许调用方选择进行区分大小写或不区分大小写的搜索功能，该功能为
Windows Subsystem for Linux（WSL）和其他需要区分大小写文件名的环境提供了必要的支持。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>对</b><b>象</b><b>目</b><b>录</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对象管理器会使用对象目录
（object 
directory）对象来为具备层次结构的命名机制提供支持。该对象类似于文件系统目录，可包含其他对象的名称，甚至可以包含其他对象目录。对象目录对
象维持了足够的信息，借助这些信息可将对象名称转换为指向对象自身对象头的指针。对象管理器使用这些指针来构造返回给用户模式调用方的对象句柄。内核模式
代码（包括执行体组件和设备驱动程序）和用户模式代码（例如子系统）都可以创建对象目录并在其中存储对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对象可以存储在命名空间中
的任何位置，但某些对象类型始终会出现在特定目录中，因为它们是由专门的组件以特定的方式创建的。例如，I/O管理器会创建名为\Driver的对象目
录，其中包含了代表已加载的非文件系统的内核模式驱动程序的对象名称。由于I/O管理器是唯一负责（使用IoCreateDriver 
API）创建驱动程序对象的组件，因此这里只应该包含驱动程序对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">表8-25列出了所有
Windows系统中都具备的标准对象目录，以及这些目录中可以存储的对象类型。在下列所有目录中，仅
\AppContainerNamedObjects、\BaseNamedObjects和\Global??是可供符合公开API要求的标准
Win32或UWP应用程序普遍使用的（详情请参阅“会话命名空间”一节）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-25 标准对象目录</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3f66cc34bda26d401bc02de786d37965.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/2cb4acf36fff0e49009481cc4eb9707f.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/50f84c7950596468cdcbff5cec6327c6.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/928ad336f4fac3d8ffdfc5fe6611e6c7.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对象名称对计算机（或对多
处理器计算机中的所有处理器）来说是全局的，但跨越网络时不可见。不过对象管理器的解析方法可以让我们访问另一台计算机中的具名对象。例如，提供文件对象
服务的I/O管理器可将对象管理器的功能拓展给远程文件。当要求打开远程文件对象时，对象管理器会调用一种解析方法，进而让I/O管理器拦截请求并将其交
付给网络重定向器（可跨越网络访问文件的驱动程序）。远程Windows系统中的服务器代码会调用自己所在系统中的对象管理器和I/O管理器找到文件对
象，并跨越网络返回相关信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于非应用容器进程通过
Win32和UWP 
API创建的内核对象（例如互斥、事件、信号量、可等待计时器以及节）都将自己的名称存储在单个对象目录中，因此这些对象中的任意两个都不能使用相同名
称，哪怕它们属于不同类型。这种限制使得我们必须更慎重地选择名称，以避免与其他名称的冲突。例如，我们可以为名称添加GUID作为前缀，以及/或者将名
称与用户的安全标识符（SID）相结合，但即便如此也只能让每个用户的单一应用程序实例受益。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">名称冲突问题看似无关紧
要，但在处理具名对象时必须注意一个与安全性有关的问题：对象名称的恶意抢注。虽然不同会话中的对象名称相互间会受到保护，但当前会话命名空间内部并不具
备可通过标准Windows 
API来设置的标准保护措施。这会使得与特权应用程序在同一个会话中运行的非特权应用程序有可能访问高特权应用程序的对象，导致上文对象安全性一节中提到
的问题。不幸的是，即便对象创建者使用适当的DACL保护自己的对象，也无法防止恶意抢注攻击，在这种攻击中，非特权应用程序会先于特权应用程序创建对
象，从而拒绝合法应用程序的访问。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了缓解这种问题，
Windows提供了私有命名空间（private 
namespace）的概念。私有命名空间可以让用户模式应用程序通过CreatePrivateNamespace 
API创建对象目录，并将这些目录与使用CreateBoundaryDescriptor API创建的边界描述符（boundary 
descriptor，一种可保护目录的特殊数据结构）关联在一起。这些描述符中包含的SID指定了允许访问对象目录的安全主体。通过这种方式，特权应用
程序就可以确信非特权应用程序将无法对自己的对象发起拒绝服务攻击（虽然这种方式无法阻止特权应用程序针对非特权应用程序发起这样的攻击，但这样的攻击毫
无意义）。此外，边界描述符还可以包含完整性级别，借此根据进程的完整性级别，保护可能与应用程序属于相同用户账户的其他对象（有关完整性级别的详细信息
请参阅卷1第7章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">边界描述符可有效缓解恶意
抢注攻击的原因之一在于，与对象不同，边界描述符的创建者（在SID和完整性级别两方面）必须具备边界描述符的访问权限。因此非特权应用程序只能创建非特
权边界描述符。同理，当一个应用程序想要打开私有命名空间中的对象时，必须使用创建该命名空间的相同边界描述符来打开命名空间。因此，特权应用程序或服务
提供的特权边界描述符将无法与非特权应用程序创建的相匹配。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>基</b><b>础</b><b>具</b><b>名</b><b>对</b><b>象</b><b>和</b><b>私</b><b>有</b><b>对</b><b>象</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们可以使用Sysinternals提供的WinObj工具或WinObjEx64来查看具名基础对象列表。不过在本实验中，我们会使用
WinObjEx64，因为它支持额外的对象类型，并且可以显示私有命名空间。运行Winobjex64.exe，点击树状列表中的
BaseNamedObjects节点，随后可以看到类似下图所示的内容。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/f2f802914898011acc485e48e701c114.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">右侧列出了具名对象，图标代表了不同的对象类型。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·互斥会显示为停止符号。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·节（Windows文件映射对象）会显示为内存芯片。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·事件会显示为感叹号。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·信号量会显示为类似交通信号灯的图标。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·符号链接会显示弯曲的箭头图标。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·文件夹代表对象目录。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·电源/网络插头代表ALPC端口。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·计时器会显示为钟表。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·各种类型的齿轮、锁、芯片等图标代表其他类型的对象。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后在Extras菜单下选择Private Namespaces，将能看到类似下图所示的列表。</span></p><div style="display: block;text-align:center;">
	<img width="757" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/6e7c0a5067e6768afcf21fa5939ccf40.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">对
于每个对象，我们可以看到边界描述符的名称（例如Installing这个互斥就是LoadPerf边界的一部分）以及相关的一个或多个SID与完整性级
别（本例中未明确设置完整性，并且SID包含在Administrators组中）。请注意，为了正常使用该功能，我们必须在运行该工具的计算机上启用
（本地或远程）内核调试，因为WinObjEx64需要使用WinDbg的本地内核调试驱动程序读取内核内存。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>篡</b><b>改</b><b>单</b><b>实</b><b>例</b><b>应</b><b>用</b><b>程</b><b>序</b><b>的</b><b>“</b><b>单</b><b>开</b><b>”</b><b>行</b><b>为</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">Windows
 Media Player以及Microsoft 
Office等应用程序是通过具名对象实现单实例运行方式最常见的例子。我们发现，当启动Wmplayer.exe可执行文件时，Windows 
Media Player只会出现一次，再次尝试启动只能让已经启动的窗口切换至最前端。我们可以使用Process 
Explorer篡改句柄列表，将计算机变成混音器！方法如下。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">1）
启动Windows Media Player和Process Explorer，查看句柄表（点击View-Lower Pane 
View和Handles）。随后应该能看到一个名称中包含Microsoft_WMP_70_CheckForOtherInstanceMutex的
句柄，如下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3f43e22abc530358302053eecaa78608.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">2）右键点击该句柄并选择Close Handle，询问时确认该操作。注意，需要以管理员身份启动Process Explorer才能关闭其他进程的句柄。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">3）再次运行Windows Media Player，这次会创建第二个进程。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">4）分别在每个实例中播放不同的歌曲。我们也可以使用系统托盘中的混音器（点击<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>音</b><b>量</b></span>图标）增大任意一个进程的音量，进而产生混音的效果。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">应用程序可以先于Windows Media Player运行并创建具备相同名称的对象，而非关闭具名对象的句柄。这种情况下，Windows Media Player将永远无法运行，因为它会以为自己已经在系统中运行了。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>符</b><b>号</b><b>链</b><b>接</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在某些文件系统（例如
NTFS，以及Linux和macOS的文件系统）中，符号链接（symbolic 
link）可以让用户创建一种文件名或目录名，在使用这些名称时，操作系统会将名称转换为不同的文件或目录名。符号链接是一种简单的方法，可以帮助用户以
间接的方式共享文件或目录内容，在原本具备层级的目录结构的不同目录之间创建交叉链接。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对象管理器实现了一种名为
符号链接的对象，这种对象可对自己对象命名空间中的名称产生类似的作用。符号链接可以出现在对象名称字符串中的任意位置。当调用方引用符号链接的对象名称
时，对象管理器会遍历其对象命名空间，直到抵达符号链接对象。对象管理器会查看符号链接的内容，查找可替代该符号链接名称的字符串，然后重新开始查找名
称。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">执行体会在一个地方使用符
号链接对象：将MS-DOS样式的设备名称转换为Windows内部设备名称。在Windows中，用户可以使用“C:”“D:”这样的名称代表硬盘驱动
器，并使用“COM1”“COM2”这样的名称代表串口。Windows子系统会创建这些符号链接对象，并将其放置在对象管理器命名空间的
\Global??目录下，也可以通过DefineDosDevice API为其他驱动器盘符执行类似的操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">某些情况下，符号链接的底
层目标并非静态的，而是可能取决于调用方的上下文。例如，旧版本Windows在\KernelObjects目录下有一个名为
LowMemoryCondition的事件，但由于内存分区（详见卷1第5章）的引入，事件信号的条件现在取决于调用方具体是在哪个分区中运行（以及能
看到哪些分区）的。因此，现在每个内存分区都有一个LowMemoryCondition事件，调用方必须重定向至自己所在分区对应的事件。这是通过对象
上一个特殊的标记、缺乏目标字符串，以及对象管理器每次解析链接时执行的符号链接回调多方因素共同作用实现的。借助WinObjEx64，我们可以看到已
注册的回调，如图8-36所示（此外也可以在调试器中运行!object 
\KernelObjects\LowMemoryCondition命令并使用dx命令转储_OBJECT_SYMBOLIC_LINK结构）。</span></p><div style="display: block;text-align:center;">
	<img width="848" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/cdb74a0b6490db82bc35133f4b54e764.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图8-36 LowMemoryCondition符号链接重定向回调</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>会</b><b>话</b><b>命</b><b>名</b><b>空</b><b>间</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">服务可以完整访问全局
（global）命名空间，该全局命名空间也是命名空间的第一个实例。随后，常规的用户应用程序即可对这个全局命名空间进行读/写（但无法删除）访问（但
也有少量例外，下文将会介绍）。然而接下来，交互式用户会话会被分配一个该命名空间的“会话专用”视图，这也叫本地（local）命名空间。本地命名空间
为会话中运行的所有应用程序提供了基础具名对象的读取/写入访问权限，并可用于隔离与某些Windows子系统有关的对象（特权对象）。每个会话的本地化
命名空间包括\DosDevices、\Windows、\BaseNamedObjects以及\AppContainerNamedObjects。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为命名空间中相同的部分创
建单独副本，这个过程也叫命名空间的实例化（instancing）。对\DosDevices进行实例化，即可让用户获得不同的网络驱动器盘符和
Window对象（例如串口）。在Windows中，全局\DosDevices目录名为\Global??，\DosDevices实际上就指向了这个
目录，本地\DosDevices目录则是由登录会话ID加以区分的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Win32k.sys会将
Winlogon创建的交互式窗口站\WinSta0插入\Windows目录中。一个终端服务环境可以为多个交互式用户提供支持，但每个用户需要通过单
独版本的WinSta0来维持一种“错觉”，让用户以为自己正在访问Windows中预定义的交互式窗口站。最后，常规的Win32应用程序和系统还会在
\BaseNamedObjects中创建共享的对象，包括事件、互斥及内存节。如果两个用户正在运行同一个会创建具名对象的应用程序，那么每个用户会话
必须具备该对象的私有版本，这样该应用程序的两个实例才不会因为访问同一个对象而相互干扰。然而，如果通过AppContainer运行Win32应用程
序，或应用程序属于UWP应用程序，沙盒机制会阻止应用程序访问\BaseNamedObjects，此时将使用
\AppContainerNamedObjects这个对象目录代替，而该目录也进一步包含更多子目录，其名称完全与AppContainer的
Package SID保持对应（有关AppContainer和Windows沙盒模型的详细信息，请参阅本书卷1第7章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通过在
\Sessions\n（其中n是会话标识符）下与用户会话相关的目录中创建上文提到的4个目录的私有版本，对象管理器实现了本地命名空间。例如，当远程
会话2中的一个Windows应用程序创建了一个具名事件后，Win32子系统（作为Kernelbase.dll中
BaseGetNamedObjectDirectory 
API的一部分）会以透明的方式将对象名称从\BaseNamedObjects重定向为\Sessions\2\BaseNamedObjects，或
者对于AppContainer会重定向为
\Sessions\2\AppContainerNamedObjects\&lt;PackageSID&gt;\。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">访问具名对象的另一种方法
是使用一项名为基础具名对象隔离（Base Named Object 
Isolation）的安全功能。父进程可以使用ProcThreadAttributeBnoIsolation进程属性启动子进程（有关进程启动属性
的详情可参阅卷1第3章），并提供自定义对象目录前缀。这也使得KernelBase.dll能够创建目录并初始化一组对象（例如符号链接）为其提供支
持，随后让NtCreateUserProcess在子进程的Token对象中通过原生版本进程属性数据设置前缀和相关初始句柄（更具体来说需要设置
BnoIsolationHandlesEntry字段）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后，
BaseGetNamedObjectDirectory会查询Token对象以检查BNO隔离是否已启用，如果已启用，则会将该前缀附加给任何具名对象
操作，举例来说，这会让\Sessions\2\BaseNamedObjects变为
\Sessions\2\BaseNamedObjects\IsolationExample。因此，无须使用AppContainer功能即可为进程
创建沙盒。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">所有与命名空间管理有关的
对象管理器功能均能感知实例化的目录，并参与营造出一种所有会话都使用了同一个命名空间的“假象”。由Windows应用程序传递的Windows子系统
DLL前缀名会使用\??来引用\DosDevices目录中的对象（例如C:\Windows会变为\??\C:\Windows）。当对象管理器看到
特殊的\??前缀后，随后要执行的操作取决于具体的Windows版本，但始终会依赖执行体进程对象（EPROCESS，详见卷1第3章）中一个名为
DeviceMap的字段，该字段会指向同一个会话中其他进程共享的数据结构。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">DeviceMap结构的
DosDevicesDirectory字段会指向代表进程本地\DosDevices的对象管理器目录。当对象管理器看到对\??的引用后，便会使用
DeviceMap结构的DosDevicesDirectory字段定位进程的本地\DosDevices。如果对象管理器在该目录中未找到对象，随后
会检查目录对象的DeviceMap字段。如果该字段有效，则会在DeviceMap结构的GlobalDosDevicesDirectory字段所指
向的目录（始终为\Global??）中查找对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在某些情况下，即使应用程
序运行在另一个会话中，可感知会话的应用程序可能依然需要访问全局会话中的对象。应用程序这样做，可能是为了与自己运行在远程会话中的其他实例，或与控制
台会话（即会话0）同步。对于这些情况，对象管理器提供了一种特殊的覆盖\Global，应用程序可以在任何对象名称前添加前缀，进而访问该全局命名空
间。例如，当会话2中的应用程序打开一个名为\Global\ApplicationInitialized的对象时，会被重定向至
\BaseNamedObjects\ApplicationInitialized，而非
\Sessions\2\BaseNamedObjects\ApplicationInitialized。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">希望访问全局
\DosDevices目录中对象的应用程序，只要对象并非存在于自己的本地\DosDevices目录中，就无须使用\Global前缀。这是因为，如
果在本地目录中找不到，那么对象管理器会自动在全局目录中查找对象。不过应用程序也可以使用\GLOBALROOT来强制在全局目录中查找。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">会话目录之间会彼此隔离，
但正如上文所述，常规的用户应用程序也可以创建带有\Global前缀的全局对象。不过这方面还存在一个重要的安全缓解措施，即节和符号链接对象无法以全
局方式创建，除非调用方运行在会话0中；或者如果调用方具备一个名为Create global 
object的特殊权限，除非对象的名称被包含在一个“未保护名称”授权列表中（该列表存储在注册表
HKLM\SYSTEM\CurrentControlSet\Control\Session 
Manager\kernel键的ObUnsecureGlobalNames值中）。默认情况下，这些名称通常包括：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·netfxcustomperfcounters.1.0；</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·SharedPerfIPCBlock；</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Cor_Private_IPCBlock；</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Cor_Public_IPCBlock_。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>命</b><b>名</b><b>空</b><b>间</b><b>的</b><b>实</b><b>例</b><b>化</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们登录后即可看到会话0命名空间与其他会话命名空间之间所存在的隔离。原因在于第一个控制台用户会登录至会话1（服务则运行在会话0中）。以管理员身份运
行Winobj.exe并点击\Sessions目录，随后即可看到一个子目录，其中列出了每个活跃会话的数值名称。如果打开其中一个目录，就可以看到名
为DosDevices、Windows、AppContainerNamedObjects以及BaseNamedObjects的子目录，这些就是对
应会话的本地命名空间子目录。本地命名空间如下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/f4c3e0fbfeb50a739c9528b3b070b94f.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随
后运行Process Explorer，选择我们自己会话中的一个进程（例如Explorer.exe）并查看其句柄表（点击View→Lower 
Pane 
View，随后点击Handles）。我们应该可以在\Sessions\n（其中“n”是会话ID）下看到一个到
\Windows\WindowStations\WinSta0的句柄。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4cd0ee3a5fed714f00c594c018f67e72.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>对</b><b>象</b><b>过</b><b>滤</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows在对象管理器中包含了一个过滤器模型，该模型有些类似于将在第10章介绍的文件系统微型过滤器模型以及注册表回调。该过滤模型所提供的主要价值之一在于，借此能够使用现有过滤技术中使用的海拔高度（altitude）概念
	<sup><img width="11" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="此处所说的“海拔高度”是一种以十进制数字形式表示的无限精度字符串，决定了微型过滤器驱动程序在系统启动时的加载位置。简单来说，可以将从最底层物理硬件到最上层应用的整个I/O栈看成一座山，海拔高度数值越低的驱动程序，加载到的位置越靠近“地面”。当数据沿着I/O栈传输时，可被不同海拔高度的驱动程序按顺序依次过滤处理。——译者注" title="此处所说的“海拔高度”是一种以十进制数字形式表示的无限精度字符串，决定了微型过滤器驱动程序在系统启动时的加载位置。简单来说，可以将从最底层物理硬件到最上层应用的整个I/O栈看成一座山，海拔高度数值越低的驱动程序，加载到的位置越靠近“地面”。当数据沿着I/O栈传输时，可被不同海拔高度的驱动程序按顺序依次过滤处理。——译者注" class="epub-footnote"></sup>，
这意味着在整个过滤栈上，可以由多个驱动程序在相应的位置对对象管理器的事件进行过滤。此外，该模型还可以让驱动程序拦截诸如NtOpenThread和
NtOpenProcess之类的调用，甚至可以修改从进程管理器处获取的访问掩码。以此可防止对打开的句柄执行某些操作，例如防止恶意软件终止善意的安
全进程或阻止密码转储应用程序，以获取对LSA进程内存进行读取的权限。不过要注意，由于兼容性方面的原因，读取操作是无法彻底阻止的，例如，无法借此让
任务管理器不能查询命令行或进程的映像名。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，驱动程序还可以充分
利用前回调（pre callback）和后回调（post 
callback），进而在某个操作发生之前为其做好准备，并在操作发生后做出反应或确定最终信息。每个操作都可以指定这些回调（目前仅支持打开、创建和
复制），并且可以针对每种对象类型进行指定（目前仅支持进程、线程和桌面对象）。对于每个回调，驱动程序可以指定自己的内部上下文值，该值可跨越所有调用
返回给驱动程序，甚至跨越前后回调对。这些回调可以使用ObRegisterCallbacks 
API注册，并使用ObUnregisterCallbacks API撤销注册，驱动程序需要负责保证切实执行了取消注册操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这些API的使用仅限符合下列这些特征的映像：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
即使在32位计算机上，也必须根据内核模式代码签名（KMCS）策略中规定的相同规则对映像签名。映像编译时需使用/integritycheck链接器
标记，该标记会在PE头中设置IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY值。借此可以让内存管理器检查映像签
名，而无须考虑其他默认设置是否会导致不进行检查。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·必须使用包含可执行代码加密后每页面哈希的编录对映像签名，这样系统即可检测出加载到内存中之后的映像是否产生了什么变化。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在执行回调前，对象管理器会在目标函数指针上调用MmVerifyCallbackFunction，进而定位与拥有该地址的模块关联的加载器数据表条目，并验证LDRP_IMAGE_INTEGRITY_FORCED标记是否已设置。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter08_0007.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_38" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>7</b><b> </b><b>同</b><b>步</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">互相排斥（mutual 
exclusion）是操作系统开发过程中的一个关键概念。互相排斥是指确保同一时间有且仅有一个线程可以访问特定资源。当资源本身不适合共享访问或共享
可能导致不可预测的结果时，互相排斥就很有必要了。举例来说，如果两个线程同时将一个文件复制到打印机端口，则可能会输出相互穿插的结果。类似地，如果当
一个线程读取某个内存位置的同时，另一个线程在写入该内存位置，第一个线程将会收到无法预测的数据。一般来说，可写资源不能无限制地共享，而无须修改的资
源是可以这样共享的。图8-37展示了当运行在不同处理器上的两个线程同时向一个循环队列写入数据会发生的事情。</span></p><div style="display: block;text-align:center;">
	<img width="774" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/58fe1612871d6c0cc598a87f8210e8bf.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-37 内存的错误共享方式</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">因为第二个线程在第一个线
程更新操作完成前已经获得了队列尾部指针的值，所以它将自己的数据插入第一个线程所在的相同位置，进而覆盖数据并导致一个队列位置为空。虽然图8-37展
示的是多处理器系统中可能发生的情况，但如果操作系统在第一个线程更新队列尾部指针之前就将上下文切换到第二个线程，单处理器系统也会发生类似的问题。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">访问不可共享资源的代码片
段，也可称为临界区（critical 
section）。为保证代码正确，临界区中一次只能执行一个线程。当一个线程正在写入文件、更新数据库或修改共享的变量时，其他线程均不能访问相同的资
源。图8-37所示的伪代码就是一个在不存在互相排斥的情况下以错误方式访问共享数据结构的临界区。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">尽管互相排斥问题对大部分
操作系统来说都很重要，但对Windows这种紧密耦合的对称多处理器（SMP）操作系统来说尤其重要（且非常复杂）。因为在这种操作系统中，相同的系统
代码会同时运行在多个处理器上，且需要共享存储全局内存中的某些数据结构。Windows内核的作用是提供一种机制，系统代码可以通过这种机制防止两个线
程同时修改同一个数据。内核提供了互相排斥的基元，内核与执行体的其他部分可以实现全局数据结构的同步访问。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于调度程序需要在
DPC/Dispatch这个IRQL级别上对其数据结构进行同步访问，因此，当IRQL为DPC/Dispatch级别或更高级别（提升级别或高
IRQL级别）时，内核与执行体将无法依赖那些可能导致页面错误或需要通过重调度操作实现数据同步访问的同步机制。下文将介绍当IRQL为高级别时，内核
与执行体如何使用互相排斥机制保护自己的全局数据结构，以及当IRQL为低级别（低于DPC/Dispatch级别）时内核与执行体会使用怎样的互相排斥
与同步机制。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_39" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>7</b><b>.</b><b>1</b><b> </b><b>高</b><b>I</b><b>R</b><b>Q</b><b>L</b><b>同</b><b>步</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在执行过程的不同阶段，内核必须保证同一时间有且仅有一个进程正在临界区中执行。内核临界区是一种可以修改全局数据结构（例如内核的调度程序数据库或其DPC队列）的代码片段。除非内核能保证线程能够以互相排斥的方式访问这些数据结构，否则操作系统将无法正常运行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这方面最大的担忧来自中
断。举例来说，内核可能正在更新全局数据结构，但此时发生的一个中断，其中断处理例程也更改了这个结构。简单的单处理器操作系统有时会禁止这种操作，为此
只需要在自己访问全局数据时禁用所有中断即可，但Windows内核使用了一种更成熟的解决方案。在使用全局资源之前，内核会暂时屏蔽同样会使用该资源的
中断处理程序所对应的中断。为此，内核会将处理器的IRQL提高至有可能访问该全局数据的任何潜在中断来源使用的最高IRQL级别。例如，一个位于
DPC/Dispatch级别的中断会导致调度程序通过调度程序数据库开始运行，因此，内核中任何需要使用调度程序数据库的其他部分，只要将IRQL提高
至DPC/Dispatch级别，就可以在自己使用调度程序数据库之前屏蔽所有DPC/Dispatch级别的中断。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种策略适合单处理器系统，但并不适合多处理器系统。在一个处理器上提高IRQL并不能防止其他处理器产生中断。内核还需要保证能跨越多个处理器实现互相排斥的访问。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>互</b><b>锁</b><b>操</b><b>作</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">同步机制的最简单形式依赖
于硬件对整数值的多处理器安全操作和执行比较能力所提供的支持。这些支持包括InterlockedIncrement、
InterlockedDecrement、InterlockedExchange以及InterlockedCompareExchange等函数。
举例来说，InterlockedDecrement函数会使用x86和x64的Lock指令前缀（如lock 
xadd），借此在执行加法操作期间锁定多处理器总线，进而让另一个同时修改该内存位置以进行减法操作的处理器在“减法处理器读取原始值”和“将相减后的
值写入”这两个操作之间无法修改内存。内核与驱动程序都使用了这种形式的基本同步。在目前的微软编译器套件中，这些函数也被称为内部函数，因为这些函数的
代码是在编译阶段通过内联汇编器直接生成的，而非通过函数调用生成（将参数推送到栈中，调用函数，将参数复制到寄存器，随后将参数从栈中取出并返回给调用
方，这一系列操作的开销很可能远高于这些函数最初实际需要承担的工作）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>自</b><b>旋</b><b>锁</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内核用于实现多处理器互相排斥的机制叫作自旋锁（spinlock）。自旋锁是一种与全局数据结构关联的锁定基元，例如，图8-38所示的DPC队列就是一种自旋锁。</span></p><div style="display: block;text-align:center;">
	<img width="857" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/7eb47eb4199640accc26bfaae4b1bcca.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-38 自旋锁的使用</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在进入图8-38所示的任何一个临界区之前，内核必须获得与受保护DPC队列相关的自旋锁。如果自旋锁非空闲，内核会持续尝试获取锁，直到成功。自旋锁之所以使用这个名称是因为内核（以及处理器）会等待它“旋转”，直到自己获得该锁。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">自旋锁与它所保护的数据结
构一样，都位于映射到系统地址空间的非分页内存中。获取和释放自旋锁的代码使用汇编语言编写，这主要是为了提高速度并充分利用底层处理器架构所提供的各种
锁定机制。在很多体系结构中，自旋锁是通过硬件支撑的测试和设置（test-and-set）操作实现的，会测试锁变量的值，并通过一条原子指令获取锁。
通过一条指令测试并获取锁，可以防止第二个线程在“第一个线程测试变量”以及“第一个线程获得锁”两个操作期间得到该锁。另外，诸如上文提到的Lock这
样的硬件指令也可用于测试和设置操作，进而让x86和x64处理器的lock 
bts操作码组合在一起，同样可用于锁定多处理器总线，否则，可能会有许多个处理器将以原子化的方式执行该操作（如果不使用锁，则只能在当前处理器上保证
该操作的原子性）。类似地，在ARM处理器上，也可以用类似的方式使用ldrex和strex等指令。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows中的所有内
核自旋锁都有一个关联的IRQL，并且始终处于DPC/Dispatch级别或更高级别。因此，当线程试图获取自旋锁时，该处理器上所有与自旋锁处于相等
或更低IRQL的操作都将停止。由于线程的调度是在DPC/Dispatch级别上进行的，因此，持有自旋锁的线程将永远不会被抢占，因为该IRQL会屏
蔽调度机制。这种屏蔽使得在受到自旋锁保护的临界区中运行的代码可以继续执行，只有这样，才能更快地释放锁。内核对自旋锁的使用非常慎重，会最大限度地减
少在持有自旋锁情况下执行的指令数量。任何试图获取自旋锁的处理器基本上都会很繁忙，会陷入无尽的等待，消耗电量（繁忙的等待会导致CPU 
100%占用率），但无法执行任何实际工作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在x86和x64处理器上，可以在繁忙的等待循环中插入一个特殊的Pause汇编指令；而在ARM处理器上，可通过Yield实现类似效果。这个指令可以告知处理器正在处理的循环指令是自旋锁（或类似构造）获取循环的一部分。这种指令可以提供三个好处。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·通过让核心略微延迟而非不断循环，可显著降低能耗。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·在SMT内核上，可以让CPU意识到旋转逻辑内核所做的“工作”并不是非常重要的，因而可将更多的CPU时间分配给第二个逻辑内核。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
由于繁忙的等待循环会导致从发出等待的线程到总线的读取请求风暴（可能是乱序生成的），因此，CPU在检测到写入操作（也就是当拥有锁的线程释放锁）之
后，会试图尽快纠正内存乱序的情况。因此，一旦自旋锁被释放，CPU就会对任何挂起的内存读取操作重排序，以保证顺序的正确。这个重排序会导致系统性能的
巨大损耗，但可通过Pause指令避免。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果内核检测到自己运行在
可支持自旋锁启发（详见第9章）且兼容Hyper-V的虚拟机监控程序中，当检测到自旋锁当前由另一个CPU拥有时，自旋锁设施可以使用
HvlNotifyLongSpinWait库函数，而无须继续旋转并使用Pause指令。该函数会发出一个
HvCallNotifyLongSpinWait虚拟化调用（Hypercall），借此告知虚拟机监控程序调度器，应该由另一个虚拟处理器接管，而不
应模拟旋转。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内核通过一组内核函数（包
括KeAcquireSpinLock和KeReleaseSpinLock）让自旋锁可被执行体的其他部分所用。例如，设备驱动程序需要自旋锁来保证，
设备寄存器和其他全局数据结构一次只能被设备驱动程序的一个部分（并且仅通过一个处理器）访问。自旋锁无法被用户程序使用，用户程序应该使用下一节将要介
绍的对象。设备驱动程序还需要保护自己的数据结构不受相关中断的影响。由于自旋锁API通常只将IRQL提升至DPC/Dispatch级别，这还不足以
防止中断。因此，内核还会导出KeAcquireInterruptSpinLock和KeReleaseInterruptSpinLock 
API，它们可将本章开头介绍的KINTERRUPT对象作为参数。系统会在中断对象内部查找与中断关联的DIRQL，并将IRQL提升至适当的级别以确
保能正确地访问与ISR共享的结构。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">设备还可以使用KeSynchronizeExecution API将整个函数与ISR同步，而不仅仅只同步一个临界区。任何情况下，中断自旋锁保护的代码都必须以极快的速度执行，任何延迟会导致高于正常的中断延迟，并会大幅影响性能。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内核自旋锁对使用自己的代码进行了一定限制。如上文所述，由于自旋锁始终具备DPC/Dispatch或更高级别的IRQL，因此，如果试图让调度器执行调度操作，或如果导致页面错误，持有自旋锁的代码会让整个系统崩溃。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>队</b><b>列</b><b>自</b><b>旋</b><b>锁</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为提高自旋锁的可扩展性，很多情况下会使用一种名为队列自旋锁（queued spinlock）的特殊自旋锁来替代标准自旋锁，尤其是在预计会发生争用且需要保证公平性的情况下。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">队列自旋锁工作方式如下：
当处理器想要获取当前正被其他处理器持有的队列自旋锁时，会将自己的标识符放入一个与该自旋锁关联的队列中。当持有该自旋锁的处理器释放锁后，该锁会被交
给队列中标识出的下一个处理器。同时，如果处理器正在等待忙碌的自旋锁，它并不会检查自旋锁本身的状态，而是会检查该队列中排在自己前面的每个处理器所设
置的每处理器标记的状态，以此了解自己的等待何时会结束。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">队列自旋锁会在每个处理器
标记上旋转，而非在全局自旋锁上旋转，这一事实会产生两个影响。首先，多处理器的总线不会被处理器之间的同步严重占用，并且位的内存位置不在单个NUMA
节点中，因此必须通过每个逻辑处理器的缓存才能窥探。其次，不再只能由等待组中的随机处理器获得自旋锁，队列自旋锁强制让处理器以先进先出（FIFO）的
顺序获得锁。FIFO顺序意味着当多个处理器访问同一个锁时可以实现更一致的性能（公平性）。虽然减小总线流量和提高公平性都是很大的好处，但队列自旋锁
也会产生额外的开销，包括额外的互锁操作都会增加成本。开发者必须权衡管理负担和好处，以决定是否值得使用队列自旋锁。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows使用了两种
类型的队列自旋锁。第一类仅用于内核内部，第二类还能被外部和第三方驱动程序使用。首先，Windows定义了一系列全局队列自旋锁，为此会将指向这些自
旋锁的指针存储到每个处理器的处理器控制区（PCR）所包含的数组中。例如在x64系统中，这些指针会被存储在KPCR数据结构的LockArray字
段。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">全局自旋锁可通过调用
KeAcquireQueuedSpinLock获取，并需指定指向存储了自旋锁指针的数组索引。全局自旋锁的数量最初在每个版本的操作系统中都有所增
加，但随着时间的推移，开始使用更高效的锁层级，不再需要全局每处理器锁定（global per-processor 
locking）。我们可以在WDK头文件Wdm.h的KSPIN_LOCK_QUEUE_NUMBER枚举中查看这些锁的索引定义表，然而请注意，通过
设备驱动程序获取这样的一个队列自旋锁，已经是一种不受支持且不建议使用的操作。毕竟这些锁是为内核的内部使用而保留的。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>全</b><b>局</b><b>队</b><b>列</b><b>自</b><b>旋</b><b>锁</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以使用内核调试器命令!qlocks来查看全局队列自旋锁（被每个处理器的PCR中的队列自旋锁数组指向的自旋锁）的状态。在下列范例中请注意，任何处理器都没有获得任何锁，对于进行实时调试的本地系统来说，这是一种非常标准的情况。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; !qlocks </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Key: O = Owner, 1-n = Wait order, blank = not owned/waiting, C = Corrupt</span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                       Processor Number </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Lock Name         0  1  2  3  4  5  6  7 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">KE   - Unused Spare </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">MM   - Unused Spare </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">MM   - Unused Spare </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">MM   - Unused Spare </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">CC   - Vacb </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">CC   - Master </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">EX   - NonPagedPool </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">IO   - Cancel </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">CC   - Unused Spare </span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>队</b><b>列</b><b>自</b><b>旋</b><b>锁</b><b>的</b><b>入</b><b>栈</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">设备驱动程序可通过
KeAcquireInStackQueuedSpinLock和KeReleaseInStackQueuedSpinLock函数使用动态分配的队列
自旋锁。一些组件（包括缓存管理器、执行体池管理器以及NTFS）会使用此类锁，而不是全局队列自旋锁。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">KeAcquireInStackQueuedSpinLock
可接收指向自旋锁数据结构的指针和自旋锁队列的句柄。自旋锁队列的句柄实际上是一种数据结构，内核会在其中存储有关锁状态的信息，包括锁的所有者，以及正
在排队等待该锁变为可用状态的处理器。因此，该句柄不应是全局变量，它通常是一种栈变量，能对调用方线程提供有保证的本地性，并负责自旋锁的
InStack部分以及API名称。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>读</b><b>取</b><b>方</b><b>/</b><b>写</b><b>入</b><b>方</b><b>自</b><b>旋</b><b>锁</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然使用队列自旋锁可大幅
改善高争用情况下的延迟，但Windows还支持另一种自旋锁，可消除很多情况下的争用，进一步提供更多好处。多读单写自旋锁也叫执行自旋锁
（executive 
spinlock），是对常规自旋锁增强后的产物，可通过ExAcquireSpinLockExclusive、
ExAcquireSpinLockShared 
API及其ExReleaseXxx等价物暴露。此外还有可用于更多高级用例的
ExTryAcquireSpinLockSharedAtDpcLevel和
ExTryConvertSharedSpinLockToExclusive函数。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">顾名思义，此类锁可在不存
在写入方的情况下以非争用共享的方式获取自旋锁。如果锁具备写入方，读取方最终必须释放锁，并且在写入方活跃的情况下不允许进一步产生读取方（也不会有其
他写入方）。举例来说，如果驱动程序开发者发现自己经常需要对链表进行迭代，但很少需要插入或删除内容，则大部分情况下都可通过此类锁消除争用，从而避免
使用更复杂的队列自旋锁。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>执</b><b>行</b><b>体</b><b>互</b><b>锁</b><b>操</b><b>作</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为执行更高级的操作（如在
单链表和双链表中添加和删除条目），内核提供了一些在自旋锁基础上构建的简单同步函数。例如用于单链表的
ExInterlockedPopEntryList和ExInterlockedPushEntryList，以及用于双链表的
ExInterlockedInsertHeadList和ExInterlockedRemoveHeadList。此外还有其他函数，如
ExInterlockedAddUlong和ExInterlockedAddLargeInteger。所有这些函数都要将一个标准自旋锁作为参数，
并在整个内核与设备驱动程序代码中使用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这些函数并不依赖标准
API来获取和释放自旋锁参数，而是会将所需代码嵌入函数中，并使用不同的排序方案。为此，Ke自旋锁API会首先测试并设置位，以查看该锁是否已被释
放；随后会以原子性的方式执行一个锁测试和设置操作，以便获取该锁，这些例程会禁用处理器上的中断并立即尝试进行原子性的测试与设置。如果最初的尝试失
败，则会再次启用中断，并继续使用标准的忙碌等待算法，直到测试和设置操作返回“0”，此时整个函数都会再次重启动。由于存在这些细微差异，用于执行体互
锁函数的自旋锁绝对不能与上文介绍过的标准内核API结合使用。当然，非互锁操作也不能与互锁操作混用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
某些执行体互锁操作会在可能的情况下静默地忽略自旋锁。例如ExInterlockedIncrementLong或
ExInterlockedCompareExchange 
API会使用与标准互锁函数和内部函数相同的锁前缀。这些函数在锁操作不适合或不可用的老系统（如非x86系统）中很有用。因此这些调用现已被弃用，并以
静默的方式通过内联为内部函数提供支持。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_40" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>7</b><b>.</b><b>2</b><b> </b><b>低</b><b>I</b><b>R</b><b>Q</b><b>L</b><b>同</b><b>步</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在多处理器环境中，内核之
外的执行软件也需要以同步的方式访问全局数据结构。例如，内存管理器只有一个页帧（page 
frame）数据库，该数据库可作为全局数据结构访问，而设备驱动程序需要保证自己能以独占方式访问自己的设备。通过调用内核函数，执行体即可创建、获取
并释放自旋锁。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">然而，自旋锁只能在部分程度上满足执行体对同步机制的需求。因为等待自旋锁的过程实际上会让处理器停止运行，而自旋锁只能在以下这些严格受限的情况下使用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·必须快速访问受保护资源，并且不与其他代码进行复杂的交互。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·临界区代码不能通过分页操作移出内存，不能引用可分页数据，不能调用外部程序（包括系统服务），不能产生中断或异常。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这些限制是有界限的，可能无法在所有情况下都能得到满足。此外，除了互相排斥，执行体还需要执行其他类型的同步，还必须为用户模式提供同步机制。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当自旋锁不可用时，还有其他一些额外的同步机制可供选择：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·内核调度程序对象（互斥、信号量、事件、计时器）</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·快速互斥和受保护互斥</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·推锁（Pushlock）</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·执行体资源</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·运行一次初始化（InitOnce）</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，同样以低IRQL执行的用户模式代码需要拥有自己的锁定基元，Windows支持各种用户模式专用锁定基元。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·引用内核调度程序对象（突变体、信号量、事件、计时器）的系统调用</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·条件变量（CondVars）</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Slim Reader-Writer锁（SRW锁）</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·基于地址的等待</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·运行一次初始化（InitOnce）</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·临界区</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">稍后我们会详细介绍用户模式基元及其底层的内核模式支持，现在将专注于内核模式对象。表8-26对比了这些机制的功能以及它们与内核模式APC交付所进行的交互。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-26 内核同步机制</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/738814faaf0d014c9a262e497b515ab1.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>内</b><b>核</b><b>调</b><b>度</b><b>程</b><b>序</b><b>对</b><b>象</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内核还以内核对象形式为执
行体提供额外的同步机制，内核对象统称为调度程序对象。Windows 
API可见的同步对象可从这些内核调度程序对象获得它们的同步能力。每个支持同步的Windows 
API可见对象都封装了至少一个内核调度程序对象。Windows程序员可通过WaitForSingleObject和
WaitForMultipleObjects函数查看执行体的同步语义，而这些函数是Windows子系统调用对象管理器所提供的类似系统服务实现的。
Windows应用程序中的线程可以与各种对象同步，包括Windows进程、线程、事件、信号量、互斥、可等待计时器、I/O完成端口、ALPC端口、
注册表键或文件对象。实际上，内核暴露出的几乎所有对象都可等待。其中一些是适宜的调度程序对象，另外一些则是其中包含调度程序对象的更大的对象（例如端
口、键或文件）。表8-27（详见“对象的信号状态”一节）列出了适宜的调度程序对象，Windows 
API允许等待的其他任何对象在内部都可能包含其中一个基元。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">执行体资源和推锁是另外两
种值得一提的执行体同步机制。这些机制提供了独占访问（如互斥）和共享读取访问（多个读取方针对同一个结构共享只读访问）的能力。然而，它们仅对内核模式
代码可用，因此无法通过Windows API访问。同时它们也不是真正的对象，它们具备一种通过原始指针和Ex 
API暴露的API，但并不涉及对象管理器及其句柄系统。下文将介绍等待调度程序对象的实现细节。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>等</b><b>待</b><b>调</b><b>度</b><b>程</b><b>序</b><b>对</b><b>象</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">线程与调度程序对象同步的传统方式是等待对象句柄，或对于某些类型的对象，可直接等待对象的指针。NtWaitForXxx类API（亦可暴露给用户模式）可使用句柄，而KeWaitForXxx API可直接处理调度程序对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">一方面，由于Nt 
API需要与对象管理器（ObWaitForXxx类函数）通信，因此会按照上文“对象类型”一节介绍的方式进行抽象。例如，Nt 
API允许将句柄传递给文件对象，因为对象管理器会使用对象类型中的信息将等待重定向到FILE_OBJECT内部的Event字段。另一方面，Ke 
API只适用于真正的调度程序对象，即以DISPATCHER_HEADER结构开头的对象。无论采用何种方法，这些调用最终都会导致内核将线程置于等待
状态。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">另一种截然不同且更现代的
调度程序对象等待方式是依赖异步等待。该方式可利用现有的I/O完成端口基础设施，通过一种名为等待完成数据包（wait completion 
packet）的中间对象，将调度程序对象与支撑I/O完成端口的内核队列进行关联。在这种机制下，线程本质上注册了一个等待，但不会直接阻塞调度程序对
象，也不会进入等待状态。相反，当等待被满足后，I/O完成端口将插入等待完成数据包，并作为通知发送给需要从该I/O完成端口拉取内容或进行等待的任何
一方。借此，一个或多个线程将能针对各种对象注册等待，并由一个单独的线程（或线程池）实际进行等待。大家可能已经猜到，这种机制正是线程池API（在
CreateThreadPoolWait和SetThreadPoolWait等API中）支持等待回调功能的关键。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后，较新版本的
Windows 10还借助目前为Hyper-V保留的DPC Wait 
Event功能，对这种异步等待机制进一步进行扩展（虽然该API已导出，但尚未提供相关文档）。这也为调度程序提供了最后一种仅供内核模式驱动程序使用
的等待方式。在该方式中，延迟过程调用（DPC，详见上文介绍）可与调度程序对象相关联，而无须与线程或I/O完成端口关联。与上文介绍的机制类似，
DPC可向对象注册，当等待满足后，DPC会在当前处理器队列中排队（就好像驱动程序刚调用了KeInsertQueueDpc那样）。当调度程序锁被丢
弃且IRQL返回到低于DISPATCH_LEVEL的级别后，DPC会在当前处理器上执行，此时驱动程序提供的回调即可针对对象信号状态做出反应。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">无论哪种等待机制，正被等
待的同步对象均可处于两种状态之一：信号状态（signaled state）或非信号状态（nonsignaled 
state）。线程在等待满足前无法恢复执行，而这种情况主要发生在当线程正在等待的句柄所对应的调度程序对象同时发生了状态变化，从非信号状态变为信号
状态（例如其他线程设置了事件对象）时。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了与对象同步，线程需要
调用对象管理器所提供的某种等待系统服务，并传递自己希望同步的对象的句柄。线程可以等待一个或多个对象，同时可指定如果在一定时间内没有结束，自己的等
待应当被取消。每当内核将一个对象设置为信号状态时，内核的某个信号例程就会检查是否有线程正在等待该对象，而不是正在等待其他对象变为信号状态。如果
有，内核会从等待状态中释放一个或多个线程，使其可以继续执行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了以异步方式通知对象已
变为信号状态，线程会创建一个I/O完成端口，并调用NtCreateWaitCompletionPacket来创建等待完成数据包对象，并接收返回给
自己的句柄。随后，线程会调用NtAssociateWaitCompletionPacket传入I/O完成端口以及刚创建的等待完成数据包的句柄，并
将其与自己想通知的对象的句柄结合在一起。当内核将对象设置为信号状态时，信号例程都会意识到当前没有任何线程在等待该对象，进而检查该等待是否关联了
I/O完成端口。如果有，则内核会向与端口关联的队列对象发送信号，这会导致当前等待它的任何线程被唤醒并使用等待完成数据包（或者队列只是发出信号，直
到有线程进入并试图进行等待）。或者如果该等待没有关联I/O完成端口，则会检查是否关联了DPC，这会导致在当前处理器上排队。这样即可处理上文提到的
仅内核的DPC Wait Event机制。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">下列有关设置事件的范例演示了同步机制与线程调度进行交互的方式：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·用户模式线程等待事件对象的句柄。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·内核将线程的调度状态改为等待中，随后将该线程加入等待某事件的线程列表。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·另一个线程设置了事件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·内核沿着等待事件的线程列表向下移动。如果某个线程的等待条件已满足（参阅下方的注意事项），那么内核会让该线程从等待状态脱离。如果是优先级可变的线程，内核可能还会提高其执行优先级（有关线程调度的详情请参阅卷1第4章）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 一些线程可能正在等待多个对象，因此会继续等待，除非指定了WaitAny等待，在这种等待中，只要一个对象（而非全部对象）变为信号状态，线程就会被唤醒。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>对</b><b>象</b><b>的</b><b>信</b><b>号</b><b>状</b><b>态</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">不同对象的信号状态截然不
同。线程对象在其生命周期内会处于非信号（nonsignaled）状态，并会在线程终止时由内核设置为信号状态。类似地，当进程的最后一个线程被终止
时，内核也会将进程对象设置为信号状态。相比之下，计时器对象（如警报）会在某一时间被设置为“关闭”。当其时间到期时，内核会将计时器对象设置为信号状
态。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在选择同步机制时，程序员必须考虑决定各种同步对象行为的规则。当对象被设置为信号状态时，线程的等待是否结束取决于线程正在等待的对象类型，具体如表8-27所示。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当一个对象被设置为信号状态后，等待它的线程通常会立即从等待状态中释放。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-27 信号状态的定义</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/502b2614722fbfacb6d66a8a3f6f5aaa.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/792c8488b6c1250288dd866086b78b87.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">例如，通知事件对象（在
Windows API中称为手动重置事件，manual reset 
event）可用于宣布某个事件的发生。当事件对象被设置为信号状态时，所有等待该事件的线程均会被释放。但一次等待多个对象的线程属于例外，此类线程可
能需要继续等待，直到所等待的其他对象也变为信号状态。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与事件对象相比，互斥对象
具有与之关联的所有权（除非是在DPC期间获得的）。它可用于对资源获得互斥的访问，同一时间仅一个线程可以持有互斥。当互斥对象空闲时，内核会将其设置
为信号状态，随后选择一个等待中的线程来执行，同时还会继承已应用的任何优先级提升操作（有关优先级提升的详情，请参阅卷1第4章）。内核选择的线程将获
得互斥对象，所有其他线程则需要继续等待。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">互斥对象亦可被放弃，当目前拥有互斥对象的线程被终止后，便会发生这种情况。当线程被终止时，内核会枚举该线程拥有的所有互斥，并将其设置为已放弃的状态，就信号逻辑而言，该状态会被视为一种信号状态，因为互斥的所有权会被转移给等待中的线程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上述简短的讨论并不是为了
列举使用各种执行体对象的所有原因和应用方式，而是为了介绍它们的基本功能和同步行为。有关如何在Windows程序中使用这些对象的详细信息，请参阅
Windows参考文档中与对象同步有关的话题，以及由Jeffrey Richter和Christophe Nasarre撰写的Microsoft
 Press出版的<span style="font-size:16px;font-style: oblique;font-family:'PingFang SC';"><i>W</i><i>i</i><i>n</i><i>d</i><i>o</i><i>w</i><i>s</i><i> </i><i>v</i><i>i</i><i>a</i><i> </i><i>C</i><i>/</i><i>C</i><i>+</i><i>+</i></span>一书。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>无</b><b>对</b><b>象</b><b>等</b><b>待</b><b>（</b><b>线</b><b>程</b><b>警</b><b>报</b><b>）</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然等待或通知线程变为信
号状态的功能非常强大，并且程序员可以使用的调度程序对象种类十分丰富，但有时也需要更简单的方式。一个线程想要等待一种特定状况的发生，而另一个线程可
能需要在该状况发生后发出信号。虽然可以通过将事件与状况绑定来达到这种目的，但这样做需要一些资源（例如内存和句柄），资源的获取和创建操作可能失败，
整个过程需要一定时间，并且很复杂。Windows内核为不依赖调度程序对象的同步提供了两种机制：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·线程警报（thread alert）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·按ID发出的线程警报（thread alert by ID）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然名称类似，但这两种机
制工作方式并不相同。先来看看线程警报的工作方式。首先，希望同步的线程使用SleepEx（最终导致NtDelayExecutionThread）进
入可告警睡眠状态。内核线程也可选择使用KeDelayExecutionThread。上文在有关软件中断和APC的章节曾介绍过可告警功能这一概念。
这种情况下，线程可以指定超时值或让睡眠状态无限持续。其次，另一方可使用NtAlertThread（或KeAlertThread）API向线程告
警，这会导致睡眠状态被中止，返回状态代码STATUS_ALERTED。为了完整讲述所有可能的情况，还需要注意，线程也可以选择不进入可告警的睡眠状
态，而是稍后在自己选择的时间调用NtTestAlert（或KeTestAlertThread）API。最后，线程还可以选择挂起自己（通过
NtSuspendThread或KeSuspendThread）以避免进入可告警的等待状态。这种情况下，另一方可以使用
NtAlertResumeThread向线程告警并恢复该线程的运行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">尽管这种机制优雅又简单，
但也存在一些问题，首先是无法区分警报是否与等待有关，换句话说，任何其他线程也可能提醒正在等待的线程，此时将无法区分不同的警报。其次，警报API并
未提供官方文档，这意味着虽然内部内核与用户服务可以使用该机制，但第三方开发者不应使用这种警报。然后，一旦线程收到警报，任何排队等待的APC都会开
始执行，例如当这些警报API被应用程序使用后，用户模式APC也会开始执行。最后，NtAlertThread依然需要打开目标线程的句柄，从技术上来
看，该操作会被视作一种获取资源的操作，但也可能失败。调用方理论上可以提前打开句柄，从而保证告警操作成功完成，但这依然会让整个机制增加句柄方面的成
本。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为应对这些问题，
Windows内核从Windows 
8开始采用了一种更现代的机制：按ID发出线程警报。虽然该机制背后的系统调用（NtAlertThreadByThreadId和
NtWaitForAlertByThreadId）并未提供公开文档，但稍后要介绍的Win32用户模式等待API是有相关文档的。这些系统调用非常简
单，无需资源，只使用线程ID作为输入。当然，由于未使用句柄，可能会造成一些安全问题，这些API的一个不足之处在于只能用于与当前进程中的线程同步。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种机制的行为解释起来也
相当明显：首先，线程使用NtWaitForAlertByThreadId 
API进行阻塞，传入一个可选的超时。这会让线程进入真正的等待状态且无须考虑可告警性的问题。实际上，虽然名称有警报二字，但这类等待按照设计是不可告
警的。其次，另一个线程调用NtAlertThreadByThreadId 
API会导致内核查找线程ID，以确保该线程属于发起调用的进程，随后会检查该线程是否确实阻塞了对NtWaitForAlertByThreadId的
调用。如果该线程属于这种情况，那么只需直接唤醒。这种简单、优雅的机制是下文要介绍的很多用户模式同步基元的核心，可用于包括从壁垒到更复杂的同步方法
在内的很多东西。</span></p>
</div><div class="header1"><h2><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>数</b><b>据</b><b>结</b><b>构</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在跟踪谁正在等待，它们如
何等待，它们在等待什么，以及整个等待操作正处于怎样的状态方面，有三个数据结构起到了关键作用。这三个结构分别为：调度程序头（dispatcher 
header）、等待块（wait block）以及等待状态寄存器（wait status 
register）。前两个结构是在WDK的包含文件Wdm.h中公开定义的，最后一个结构虽未提供相关文档，但在类型为
KWAIT_STATUS_REGISTER的公开符号中可见（且Flags字段对应了KWAIT_STATE枚举）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">调度程序头是一种打包的结
构，因为它需要在一个固定大小的结构中保存大量信息（有关调度程序头数据结构定义的详细信息，请参阅“实验：查看等待队列”一节）。其定义中使用的一种主
要技术是将互斥的标记存储在与结构相同的内存位置（偏移量），在编程理论中这种做法也叫联合。通过使用Type字段，内核可以知道这些字段中的哪些是相关
的。例如，互斥可以为Abandoned状态，但计时器可以为Relative状态。同理，计时器可以Inserted到计时器列表，但调试器只能对一个
进程保持Active状态。除了这些特定字段，调度程序头还包含与调度程序对象无关但有意义的信息：与对象关联的等待块的信号状态和等待列表头。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这些等待块代表着一个线程
（或者在异步等待情况下，代表一个I/O完成端口）被绑定到某一个对象。处于等待状态的每个线程都有一个最多包含64个等待块的数组，这些等待块代表了线
程正在等待的对象（可能还包括一个指向内部线程计时器的等待块，可用于满足调用方已经指定的超时值）。或者如果使用了“按ID发出的警报”基元，则会存在
一个带有特殊指示的块，以此表明这并非基于调度程序的等待。Object字段会被NtWaitForAlertByThreadId的调用方所指定的
Hint替代。维护该数组主要有以下两个目的。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·当线程终止时，它所等待的所有对象必须取消引用，等待块需要删除并与对象断开连接。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·当线程被正在等待的一个对象唤醒（即变为信号状态并满足等待）后，它可能一直在等待的其他所有对象必须取消引用，删除等待块并断开连接。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如上文提到的每个线程都
拥有一个数组，其中包含自己所等待的所有对象那样，每个调度程序对象也有一个与自己绑定的等待块相关的链表。保存该链表的目的在于，在一个调度程序对象收
到信号后，内核可以快速确定谁在等待该对象（或哪个I/O完成端口被绑定到该对象），并应用下文很快会介绍的等待满足逻辑。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">因为在每个CPU上运行的
平衡集管理器线程（有关平衡集管理器的详情请参阅卷1第5章）需要分析每个线程一直在等待的时间（这是为了决定是否将内核栈换出页面），每个PRCB也会
有一个列表，其中包含正在等待且符合要求，最后会在该处理器上运行的线程。这一过程重用了KTHREAD结构的Ready 
List字段，因为线程不能同时处于就绪状态和等待状态。符合要求的线程必须满足下列三个条件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·等待必须以UserMode的等待模式发出（KernelMode的等待会假设为时间敏感的，不值得付出栈交换成本）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·线程必须设置EnableStackSwap标记（内核驱动程序可使用KeSetKernelStackSwapEnable API禁用）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·线程的优先级必须处于或低于Win32实时优先级范围起点（24，即“实时”进程优先级类中普通线程的默认值）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">等待块的结构始终是固定
的，但它的一些字段会根据等待的类型以不同方式使用。例如，通常来说，等待块会有一个指向正被等待的对象的指针，但正如上文所述，“按ID发出警报”的等
待并不涉及任何对象，因此这可以代表由调用方指定的Hint。类似地，虽然等待块通常会指回等待该对象的线程，但也可以指向I/O完成端口队列，此时，作
为异步等待的一部分，等待完成数据包会与对象相关联。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外还需要始终维持两个字
段：wait type（等待类型）和wait block state（等待块状态），并且取决于类型，可能还存在wait 
key（等待键）。等待类型在等待是否被满足过程中非常重要，因为它决定了具体要使用五种可能的等待满足机制中的哪一种：对于wait 
any（等待任意）机制，内核并不关心其他对象的状态，因为至少其中一个对象（当前对象）已经收到了信号。另外，对于wait 
all（等待全部）机制，只有在所有其他对象同时处于信号状态后，内核才会唤醒线程，这需要针对等待块及其关联对象进行迭代。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外还有wait 
dequeue（等待出队）这种特殊情况，此时调度程序对象实际上是一个队列（I/O完成端口），有一个线程等待该队列提供可用的完成数据包（通过调用
KeRemoveQueue(Ex)或(Nt)IoRemoveIoCompletion）。附加到队列的等待块以LIFO（后进先出，而不像其他调度程
序对象那样使用FIFO，即先进先出顺序）唤醒顺序运行，因此，在队列收到信号后即可执行正确的操作（请注意，线程可能在等待多个对象，因此可能还有其他
等待块正处于Wait any或Wait all状态，这些状态也需要定期处理）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于wait notification（等待通知），内核知道没有任何线程与对象关联，并且这是一个异步等待，因此会向相关I/O完成端口的队列发送信号（因为队列本身就是一个调度程序对象，这会导致队列以及任何潜在等待队列的线程满足二级等待）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后还有wait DPC（等待DPC），这是最新引入的等待类型，可以让内核知道没有与此等待相关的线程或I/O完成端口，只有相关的DPC对象。此时，指针会指向一个初始化后的KDPC结构，一旦调度程序锁被丢弃，内核就会立刻执行当前处理器的队列。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">等待块还包含一个易失的等待块状态（KWAIT_BLOCK_STATE），该状态定义了该等待块在当前所从事的事务等待操作中的当前状态。表8-28详细列出了不同状态、这些状态的含义及其在等待逻辑代码中所产生的效果。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-28 等待块状态</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/c9173be46c6ce4ee26d8d20ef0e24874.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上文还提到了等待状态计时
器。随着Windows 
7全局内核调度程序锁的移除，线程（或为了开始等待而需要的其他任何对象）的整体状态可以在等待操作仍在进行的过程中发生变化。由于不再有任何全局状态同
步，因此没有什么可以阻止（在其他逻辑处理器上执行的）另一个线程向正在等待的对象发送信号、向线程告警，甚至向其发送APC。因此内核调度程序会对每个
等待中的线程对象跟踪多个额外的数据点：线程当前的细化等待状态（KWAIT_STATE，请勿将其与等待块状态混淆）以及任何可能修改正在进行中的等待
操作结果的挂起状态变更。这两类数据构成等待状态寄存器（KWAIT_STATUS_REGISTER）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当线程接到指示（例如
WaitForSingleObject调用）开始等待特定对象时，它首先会尝试通过进入等待而转入进行中的等待状态（WaitInProgress）。
如果此时该线程没有挂起的警报，那么操作会成功（基于等待的可告警性以及等待的当前处理器模式，这决定了警报是否可以抢占等待）。如果有警报，则完全不会
进入等待状态，调用方会收到相应的状态代码；否则随后线程会进入WaitInProgress状态，此时主线程的状态会被设置为Waiting（等待
中），等待原因和等待时间会被记录在案，同时还会注册所指定的任何超时值。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">等待开始后，线程可以根据
需要初始化等待块（并在进程中将其标记为WaitBlockActive），随后继续锁定属于此等待的所有对象。由于每个对象都有自己的锁，因此，当多个
处理器可能需要分析包含很多对象的等待链（由WaitForMultipleObjects调用产生）时，内核必须要能维持一致的锁定顺序方案。内核使用
了一种名为地址排序（address 
ordering）的技术来实现这一点：因为每个对象都有一个各异且静态的内核模式地址，因此可以按照单调递增的地址顺序对这些对象进行排序，从而保证所
有调用方总是以相同的顺序获取和释放锁。这意味着调用方提供的对象数组将被复制并酌情进行排序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">下一步需要检查是否可以立
即满足等待，例如，线程可能被告知需要等待一个已经被释放的互斥对象或事件已经收到信号。这种情况下，等待可以立即被满足，该过程涉及相关等待块的取消链
接（然而这种情况下尚未插入任何等待块），同时需要执行等待退出操作（处理等待状态寄存器中标记的所有挂起的调度程序操作）。如果这种捷径失败，随后内核
会尝试着检查该等待指定的超时（如果存在的话）是否已过期。这种情况下等待的并非“被满足”，而是“过期”，尽管结果可能相同，但这会让退出代码的处理速
度略微加快一些。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果上述捷径均无效，那么
等待块会被插入线程的等待列表中，随后线程会试图提交自己的等待（同时对象锁会被释放，进而其他处理器可以修改该线程目前理应试图等待的所有对象的状
态）。假如是其他处理器对该线程或其等待对象不感兴趣的非争用场景，只要等待状态寄存器未标记为包含未决变更，等待就会切换至已提交状态。提交操作会链接
至PRCB列表中的等待线程，如果需要，还会激活一个额外的等待队列线程，并插入与等待超时有关的计时器（如果有的话）。因为此时可能已经过去了相当多的
周期，因此可能已经超过了超时时间。这种情况下，插入计时器会导致立即向线程发送信号，从而满足计时器的等待以及等待的总超时值。否则在更常见的情况下，
CPU会通过上下文切换运行准备好执行的下一个线程（有关调度的详细信息请参阅卷1第4章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在多处理器计算机上高度争
用的代码路径中，尝试提交等待的线程很可能并且很大概率已经在等待的过程中经历了更改。一种可能的情况是：正在等待的某一个对象刚刚收到信号。如前文所
述，这会导致相关等待块进入WaitBlockBypassStart状态，并且线程的等待状态寄存器现在会显示为WaitAborted等待状态。另一
种可能的情况是：已经向等待的线程发出了警报或APC，但并不设置WaitAborted状态，而是启用等待状态寄存器中的一个与之相对应的位。因为
APC可以打断等待（取决于APC类型、等待模式和可告警性），此时会交付APC并中止等待。可以修改等待状态寄存器而不产生完整中止周期的操作包括：修
改线程的优先级或相关性，与上文提到的情况类似，这些操作会在因为提交失败而退出等待时进行处理。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如在卷1第4章“调
度”一节中简单提过的，在使用SuspendThread和ResumeThread的情况下，最新版本的Windows实现了一种轻量级挂起机制，该机
制不再总是将APC放入队列，然后获取线程对象中嵌入的挂起事件。相反，如果符合以下情况，现有等待将被转换为挂起状态。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·KiDisableLightWeightSuspend
为0（管理员可以使用注册表HKLM\SYSTEM\CurrentControlSet\Session 
Manager\Kernel键下的DisableLightWeightSuspend值关闭这项优化措施）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·线程状态为Waiting，即线程已经处于等待状态。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·等待状态寄存器被设置为WaitCommitted，即线程的等待已被完全占用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·该线程不是UMS主线程或调度线程（有关用户模式调度的详细信息请参阅卷1第4章），因为这需要在调度器的挂起APC中实现额外的逻辑。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·线程在IRQL 0（被动级别）发出等待，因为APC_LEVEL级别的等待所需的特殊处理只有“挂起APC”可以提供。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·线程当前没有已禁用的APC，也没有进行中的APC，因为这些情况需要额外的同步，只有调度器的挂起APC交付可以实现这种同步。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·由于调用了KeStackAttachProcess，线程当前没有附加到不同的进程，因为与上一种情况类似，这也需要特殊的处理。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果与线程等待关联的第一个等待块不处于WaitBlockInactive块状态，其等待类型必须为WaitAll，否则这意味着至少有一个活跃的WaitAny块。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如上述列表所暗示的那
样，这种转换是通过获取当前活跃的等待块，并将其转换为WaitBlockSuspended状态的方式实现的。如果等待块当前指向一个对象，就会从其调
度程序头的等待列表中取消链接（这样，向对象发送的信号将不再能唤醒该线程）。如果线程关联了计时器，则会被取消并从线程的等待块数组中移除，同时设置一
个标记代表该操作已完成。最后，最初的等待模式（Kernel或User）也会被保存在一个标记中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于不再使用真正的等待对
象，这种机制需要引入表8-28中列出的三个额外的等待块状态及四个全新的等待状态：WaitSuspendInProgress、
WaitSuspended、WaitResumeInProgress以及WaitResumeAborted。这些新状态的行为方式与它们常规的等价
物类似，但解决了上文所提到的轻量级挂起操作中所提到的争用状况。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">例如，当一个线程恢复时，
内核会检测它是否被置于轻量级挂起状态，并会撤销该操作，然后将等待寄存器设置为WaitResumeInProgress。随后将枚举每个等待块，对于
任何处于WaitBlockSuspended状态的块，会将其置于WaitBlockActive状态然后重新链接回对象调度程序头的等待块列表，除非
在此期间对象收到信号，此时则会将对象设置为WaitBlockInactive状态，这也与常规的唤醒操作类似。最后，如果线程有一个与自己的等待相关
的超时被取消，线程的计时器会被重新插入计时器表中，并保持原先的过期（超时）时间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图8-39展示了调度程序
对象到等待块，再到线程，最后到PRCB之间的关系（前提是线程有资格进行栈交换）。在本例中，CPU 
0有两个等待中（已提交）的线程：线程1正在等待对象B，线程2正在等待对象A和对象B。如果对象A收到信号，内核会注意到这一点，因为线程2也在等待另
一个对象，线程2还无法准备好开始执行。另一方面，如果对象B收到信号，内核可以立即让线程1准备好执行，因为该线程无须等待其他对象（或者，如果线程1
也在等待其他对象，但它的等待类型为WaitAny，此时内核依然可以唤醒线程1）。</span></p><div style="display: block;text-align:center;">
	<img width="850" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ed0e6a2550693baf6d937dacddffde88.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-39 “等待”的数据结构</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>等</b><b>待</b><b>队</b><b>列</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以使用内核调试器的!thread命令查看线程正在等待的对象列表。例如，下列命令摘录自!process命令的输出结果，显示了该线程正在等待一个事件对象：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; !process 0 4 explorer.exe </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    THREAD ffff898f2b345080 Cid 27bc.137c Teb: 00000000006ba000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">            ffff898f2b64ba60 SynchronizationEvent </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">也可以使用dx命令解读对象的调度程序头，如下所示：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx (nt!_DISPATCHER_HEADER*)0xffff898f2b64ba60 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">(nt!_DISPATCHER_HEADER*)0xffff898f2b64ba60: 0xffff898f2b64ba60 [Type:_DISPATCHER_HEADER*] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x000] Lock             : 393217 [Type: long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x000] LockNV           : 393217 [Type: long] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x000] Type             : 0x1 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x001] Signalling       : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002] Size             : 0x6 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x003] Reserved1        : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x000] TimerType        : 0x1 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x001] TimerControlFlags : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x001 ( 0: 0)] Absolute         : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x001 ( 1: 1)] Wake             : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x001 ( 7: 2)] EncodedTolerableDelay : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002] Hand             : 0x6 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x003] TimerMiscFlags   : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x003 ( 5: 0)] Index            : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x003 ( 6: 6)] Inserted         : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x003 ( 7: 7)] Expired          : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x000] Timer2Type       : 0x1 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x001] Timer2Flags      : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x001 ( 0: 0)] Timer2Inserted   : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x001 ( 1: 1)] Timer2Expiring   : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x001 ( 2: 2)] Timer2CancelPending : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x001 ( 3: 3)] Timer2SetPending : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x001 ( 4: 4)] Timer2Running    : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x001 ( 5: 5)] Timer2Disabled   : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x001 ( 7: 6)] Timer2ReservedFlags : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002] Timer2ComponentId : 0x6 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x003] Timer2RelativeId : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x000] QueueType        : 0x1 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x001] QueueControlFlags : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x001 ( 0: 0)] Abandoned        : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x001 ( 1: 1)] DisableIncrement : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x001 ( 7: 2)] QueueReservedControlFlags : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002] QueueSize        : 0x6 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x003] QueueReserved    : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x000] ThreadType       : 0x1 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x001] ThreadReserved   : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002] ThreadControlFlags : 0x6 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002 ( 0: 0)] CycleProfiling   : 0x0 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002 ( 1: 1)] CounterProfiling : 0x1 [Type: unsigned char] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002 ( 2: 2)] GroupScheduling  : 0x1 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002 ( 3: 3)] AffinitySet      : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002 ( 4: 4)] Tagged           : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002 ( 5: 5)] EnergyProfiling  : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002 ( 6: 6)] SchedulerAssist  : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002 ( 7: 7)] ThreadReservedControlFlags : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x003] DebugActive      : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x003 ( 0: 0)] ActiveDR7        : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x003 ( 1: 1)] Instrumented     : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x003 ( 2: 2)] Minimal          : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x003 ( 5: 3)] Reserved4        : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x003 ( 6: 6)] UmsScheduled     : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x003 ( 7: 7)] UmsPrimary       : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x000] MutantType       : 0x1 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x001] MutantSize       : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x002] DpcActive        : 0x6 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x003] MutantReserved   : 0x0 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x004] SignalState      : 0 [Type: long]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x008] WaitListHead     [Type:_LIST_ENTRY]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        [+0x000] Flink            : 0xffff898f2b3451c0 [Type:_LIST_ENTRY *]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        [+0x008] Blink            : 0xffff898f2b3451c0 [Type:_LIST_ENTRY *] </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">该结构是一种联合，因此我们可以忽略与特定对象类型不对应的值，因为这些值是不相关的。然而，除了查看Windows内核源代码或WDK头文件的注释，我们还很难判断哪些字段与哪个类型相关。为了方便起见，表8-29列出了调度程序头标记及其适用的对象。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-29 调度程序头标记的用法和含义</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3f66191780c59bb1146be005c3dc2117.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e2f4187c74807b6a1a8e86a3bcaadd5f.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/496594fa7771779af776de66ad2532f4.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/726f85b120aa52807f2d7c7054312bc5.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/021aa770713981049555ba196cb1a8da.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">最
后，调度程序头也包含上文提到的SignalState字段以及WaitListHead字段。不过需要注意，在等待列表头指针相同时，这可能意味着没有
正在等待的线程，或意味着有一个线程正在等待该对象。若要区分这两种情况，可以看看相同的指针是否恰好是列表本身的地址，如果是，那么代表完全没有正在等
待的线程。在上文的例子中，0XFFFF898F2B3451C0并非列表本身的地址，因此可以这样转储等待块：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dx (nt!_KWAIT_BLOCK*)0xffff898f2b3451c0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">(nt!_KWAIT_BLOCK*)0xffff898f2b3451c0       : 0xffff898f2b3451c0 [Type:_KWAIT_BLOCK *]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x000] WaitListEntry     [Type:_LIST_ENTRY]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x010] WaitType          : 0x1 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x011] BlockState        : 0x4 [Type: unsigned char]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x012] WaitKey           : 0x0 [Type: unsigned short]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x014] SpareLong         : 6066 [Type: long]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x018] Thread            : 0xffff898f2b345080 [Type:_KTHREAD *]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x018] NotificationQueue : 0xffff898f2b345080 [Type:_KQUEUE *]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x020] Object            : 0xffff898f2b64ba60 [Type: void *]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [+0x028] SparePtr          : 0x0 [Type: void *] </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">本例中，等待类型是WaitAny，因此可以知道有一个线程正在阻塞事件，还能得到线程的指针。此外还能看到，该等待块是活跃的。接下来可以进一步调查线程结构中与等待相关的几个字段：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; dt nt!_KTHREAD 0xffff898f2b345080 WaitRegister.State WaitIrql WaitMode </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">WaitBlockCount</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     WaitReason WaitTime</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x070 WaitRegister       : </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x000 State              : 0y001</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x186 WaitIrql           : 0 ''</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x187 WaitMode           : 1 ''</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x1b4 WaitTime           : 0x39b38f8</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x24b WaitBlockCount     : 0x1 ''</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x283 WaitReason         : 0x6 '' </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">数据显示是一个在IRQL 0（被动级别）下执行的已提交等待，其等待模式为UserMode，其时间显示为自启动以来15ms的时钟周期，而产生的原因在于用户模式应用程序的请求。我们还可以发现，这是该线程唯一的等待块，意味着该线程并未等待其他任何对象。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如
果等待列表头包含多个条目，我们还可以对等待块的WaitListEntry字段中的第二个指针值执行相同命令（并最终在等待块的线程指针上执行!
thread），借此来遍历列表并查看等待该对象的其他线程。如果这些线程正在等待多个对象，则可以查看其WaitBlockCount以了解还存在多少
个其他等待块，并直接为指针增加sizeof(KWAIT_BLOCK)所对应的值。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">另
一种可能是，等待类型为WaitNotification，此时可以使用通知队列指针来转储Queue 
(KQUEUE)结构，这本身是一个调度程序对象。此外可能还会有自己的非空等待块列表，这会显示与工作线程相关的等待块，而这个工作线程将以异步方式接
收到对象已获得信号的通知。要确定最终会执行哪个回调，我们需要转储用户模式线程池数据结构。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>键</b><b>控</b><b>事</b><b>件</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">一种名为键控事件
（keyed 
event）的同步对象特别值得一提，因为它在用户模式独占同步基元和按照ID发出警报基元的开发过程中扮演了关键角色。通过下文的介绍大家会知道，这实
际上是Windows中实现的一种类似于Linux操作系统中Futex（一种经过了充分研究的计算机科学概念）的东西。最初实现键控事件是为了帮助进程
在使用临界区时处理内存不足的情况，是一种用户模式的同步对象，很快我们还将详细介绍。有一种未公开的键控事件允许线程指定自己要等待的“键”，当同一个
进程的另一个线程使用相同的键向该事件发送信号后，这个线程就会被唤醒。但正如上文所述，如果觉得这与警报机制比较类似，那是因为键控事件实际上可以看成
警报的前兆。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果发生争用，
EnterCriticalSection会动态分配一个事件对象，想要获取临界区的线程会等待拥有该临界区的其他线程向
LeaveCriticalSection发送信号。显然，在内存不足的时候这会导致一个问题：临界区的获取可能会失败，因为系统无法分配所需的事件对
象。在“病态”情况下，内存不足本身也可能是应用程序试图获取临界区而导致的，这种情况下系统将会遇到死锁。但内存不足并非导致这种失败的唯一情况，一些
较为罕见的情况下可能是句柄耗尽导致的。如果进程达到句柄数量上限，事件对象的新句柄创建就会失败。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">似乎预先分配一个全局标准
事件对象可以解决这种问题，就像上文曾介绍过的保留对象那样。然而，由于一个进程可以有多个临界区，每一个都有自己的锁定状态，这种做法需要预先分配未知
数量的事件对象，因此这种方法并不会有效。不过键控事件最主要的特点在于，一个事件可以在不同线程之间重用，只要每个线程提供一个不同的键加以区分即可。
通过使用临界区的虚拟地址本身作为这个“键”，这种做法可以有效地让多个临界区（进而让等待方）使用同一个键控事件句柄，而这个句柄是可以在进程启动时预
先分配的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当线程发出键控事件信号或
等待键控事件时，会使用一种名为“键”的唯一标识符，键可用于区分不同的键控事件实例（键控事件与单一临界区之间的关联）。当所有者线程发送信号释放键控
事件后，只会唤醒等待该键的一个线程（与同步事件行为类似，与通知事件行为相反）。继续介绍使用自己的地址作为键的临界区的例子，这也意味着每个进程依然
需要自己的键控事件，因为虚拟地址很明显只能在一个进程的地址空间内维持唯一性。然而事实证明，内核只能唤醒当前进程中的等待方，因此，不同进程之间的键
实际上是被隔离的，这意味着整个系统只能有一个键控事件对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">因此，当
EnterCriticalSection调用NtWaitForKeyedEvent等待键控事件时，会给出一个NULL句柄作为该键控事件的参数，告
诉内核自己无法创建键控事件。内核会识别出这种行为并使用一个名为ExpCritSecOutOfMemoryEvent的全局键控事件。这样做的好处在
于，进程不再需要为具名的键控事件浪费一个句柄，因为内核会跟踪该对象及其引用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">然而，键控事件不仅仅是低
内存情况下的后备目标。当多个等待方在等待同一个键并且需要被唤醒时，该键会多次收到信号，这需要由对象维持一个列出了所有等待方的列表，以便针对每个等
待方执行“唤醒”操作（回想一下，向一个键控事件发送信号的结果与向一个同步事件发送信号的结果是一样的）。即使等待方列表不包含任何线程，线程也可以向
键控事件发送信号，这种情况下，将由发出信号的线程来等待事件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果没有这种后备机制，那
么发出信号的线程可能会在用户模式代码中将键控事件视为未收到信号，并尝试进行等待的情况下向键控事件发出信号。等待可能是在发出信号的线程向键控事件发
出信号之后发生的，这会导致错过脉冲，进而导致等待中的线程死锁。通过在这种情况下强制发出信号的线程进行等待，实际上保证了只在当有一方正在寻找（等
待）的情况下，才会真正向键控事件发出信号。这种行为也使得键控事件与Linux 
Futex较为相似但也并不完全相同，并使得键控事件可以跨越多个用户模式基元使用，例如SRW（Slim Read 
Writer）锁，我们很快将介绍这些内容。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 当键控事件等待代码需要等待时，它会使用内核模式线程对象（ETHREAD）中一种名为KeyedWaitSemaphore的内置信号量（该信号量会与ALPC等待信号量共享自己的位置）。有关线程对象的详情请参阅卷1第4章。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">然而，键控事件并未取代临
界区所实现的标准事件对象。最开始在Windows 
XP时代，这是因为键控事件在大量使用的情况下无法提供可扩展性能。仔细回忆一下会发现，之前介绍的所有算法都只能用于关键的低内存场景中，此时性能和可
扩展性并没有那么重要。取代标准事件对象，会给键控事件造成本不应承担的压力。主要的性能瓶颈在于，键控事件通过一种双链表列出了所有等待方，此类列表的
遍历速度很慢，这意味着遍历整个列表需要花费大量时间。这种情况下，具体所需的时间取决于正在等待的线程数量。由于对象是全局的，列表中可能会包含数十个
线程，因此每次设置或等待键的时候都需要花费很长时间进行遍历。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 该列表的头保存在键控事件对象中，而线程会通过内核模式线程对象（ETHREAD）的KeyedWaitChain字段（会与线程的退出时间共享，存储为LARGE_INTEGER，其大小与双链表的大小相同）链接在一起。有关该对象的详细信息请参阅卷1第4章。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows 
Vista使用哈希表（而非链表）保存等待方线程，由此改善了键控事件的性能。这项优化措施最终使得Windows能够提供三个全新的轻量级用户模式同步
基元（下文很快将会介绍），这些基元都需要依赖键控事件。不过临界区会继续使用事件对象，这主要是为了保证应用程序的兼容性和调试功能，因为事件对象及其
内部原理都是公开且记录在案的，而键控事件是不透明的，也并未暴露给Win32 API。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">不过随着Windows 
8引入了全新的按照线程ID进行报警的功能，一切又再次发生了变化，取消了整个系统对键控事件的使用（但键控事件依然保留供init 
once同步中的一种情况使用，下文很快将会提到）。随着时间推移，临界区结构最终放弃了对常规事件对象的使用，转为使用这种新的功能（需要时可通过应用
程序兼容性铺垫来恢复对原始事件对象的使用）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>快</b><b>速</b><b>互</b><b>斥</b><b>和</b><b>受</b><b>保</b><b>护</b><b>互</b><b>斥</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">快速互斥（fast 
mutex）也叫执行体互斥，相较互斥对象，它们可提供更好的性能，因为它们尽管建立在调度程序对象（一种事件）上，但只有在执行快速互斥时才会等待。与
总是通过调度程序获取的标准互斥不同，在存在争用的情况下，这种特性会让快速互斥获得更好的性能。快速互斥已被广泛应用在设备驱动程序中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">然而，这种效率也要付出成
本，因为快速互斥仅适用于所有内核模式APC（上文进行过介绍）交付可以被禁用的情况下，不像常规互斥对象只需要阻止常规APC的交付。有鉴于这一点，执
行体定义了两个可用于获取快速互斥的函数：ExAcquireFastMutex和ExAcquireFastMutexUnsafe。前者可以将处理器
的IRQL提升至APC级别以阻止所有APC交付，后一个“不安全”函数可在将IRQL提升至APC级别，进而将所有内核模式APC交付全部禁用的情况下
调用。ExTryToAcquireFastMutex的执行过程与第一个函数类似，但如果快速互斥已经被持有，实际上它并不会等待，而是直接返回
FALSE。快速互斥的另一个局限在于，无法以递归的方式获取，这一点与互斥对象有所差异。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows 
8和后续版本中的受保护互斥（guarded 
mutex）与快速互斥相同，但要通过KeAcquireGuardedMutex和KeAcquireGuardedMutexUnsafe获取。与快
速互斥类似，受保护互斥也存在KeTryToAcquireGuardedMutex方法。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在Windows 
8之前，这些函数并不会通过将IRQL提升至APC级别而禁用APC，而是会进入一个受保护区域，借此可在线程的对象结构中设置一个特殊计数器以禁用
APC交付，直到该区域退出，这一点上文也有提及。在使用PIC（本章上文同样进行了介绍）的老版本系统中，这种方式比通过IRQL的做法速度更快。此
外，受保护互斥使用了一种门调度程序对象，因此速度会比事件略快一些，但这个差异目前也已经不复存在。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">受保护互斥的另一个问题在
于内核函数KeAreApcsDisabled。在Windows Server 
2003之前，该函数通过检查代码是否在临界区运行而判断常规APC是否被禁用。在Windows Server 
2003中，该函数被改为确定代码是否处于临界区或受保护部分中，如果特殊内核APC被禁用，该函数也会返回TRUE。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">因为当特殊内核APC被禁
用时，驱动程序不应执行某些操作，因此，我们调用KeGetCurrentIrql来检查IEQL是否为APC级别，这种做法是有意义的，这也是禁用特殊
内核APC的唯一方法。然而，随着受保护区域和受保护互斥的引入，即使内存管理器大量使用了这些机制，这些检查也会因为受保护互斥不提升IRQL而失败。
为此，驱动程序必须调用KeAreAllApcsDisabled，以此通过受保护部分来检查特殊内核APC是否被禁用。这种特性与驱动程序验证器
（Driver Verifier）中脆弱的检查功能相结合，会导致误报，最终这一切还导致决定使用快速互斥代替受保护互斥。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>执</b><b>行</b><b>体</b><b>资</b><b>源</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">执行体资源是一种支持共享
访问和独占访问的同步机制，与快速互斥类似，获取执行体资源之前需要禁用所有内核模式APC交付。执行体资源也建立在调度程序对象基础上，只会用于存在争
用的情况下。整个系统中都用到了执行体资源，尤其是文件系统驱动程序，因为此类驱动程序往往有较长的等待期，并且在等待期间依然要在一定程度上允许进行
I/O操作（例如读取）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果线程要等待获取可共享
访问的执行体资源，需要等待该资源相关联的信号量；而如果线程要等待获取可独占访问的执行体资源，需要等待事件。共享的等待方会使用一种包含无限计数器的
信号量，因为当独占的持有者通过向信号量发送信号释放资源后，所有等待方都会被唤醒并获得资源访问权。当线程等待独占访问的资源目前被其他线程所拥有时，
该线程会等待一个同步事件对象，因为当该事件收到信号后，只有一个等待方会被唤醒。在上文关于同步事件的介绍中曾经提过，一些事件的取消等待
（Unwait）操作实际上可能导致优先级提升，使用执行体资源时就会出现这种情况，而这也是执行体资源需要像互斥那样跟踪所有权的原因（有关执行体资源
优先级提升的详情，请参阅本书卷1第4章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">共享访问和独占访问提供的
灵活性催生了多种资源获取函数：ExAcquireResource 
SharedLite、ExAcquireResourceExclusiveLite、ExAcquireSharedStarveExclusive
以及ExAcquireShareWaitForExclusive。这些函数均在WDK中提供了相关文档。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">新版Windows增加了
使用相同API名称但辅以“Fast”字样的快速执行体资源，如ExAcquireFastResourceExclusive、
ExReleaseFastResource等。因为通过不同的方式来处理锁的所有权，这些资源的速度更快，但除了弹性文件系统（Resilient 
File 
System，ReFS），其他组件并未使用这种资源。在高争用的文件系统访问场景中，ReFS的性能略优于NTFS，部分原因也是因为锁定速度更快。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>列</b><b>出</b><b>已</b><b>获</b><b>得</b><b>的</b><b>执</b><b>行</b><b>体</b><b>资</b><b>源</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">内
核调试器的!locks命令可以使用内核的执行体资源链表并转储其状态。默认情况下，该命令只能列出当前拥有的执行体资源，通过曾经公开记录的–d选项可
列出所有执行体资源，但现在已不再支持。不过我们依然可以使用-v标记转储所有资源的详细信息。该命令的部分输出结果如下：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; !locks -v </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">**** DUMP OF ALL RESOURCE OBJECTS **** </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource @ nt!ExpFirmwareTableResource (0xfffff8047ee34440)   Available </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource @ nt!PsLoadedModuleResource (0xfffff8047ee48120)   Available </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Contention Count = 2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource @ nt!SepRmDbLock (0xfffff8047ef06350)   Available </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Contention Count = 93 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource @ nt!SepRmDbLock (0xfffff8047ef063b8)   Available </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource @ nt!SepRmDbLock (0xfffff8047ef06420)   Available </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource @ nt!SepRmDbLock (0xfffff8047ef06488)   Available </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource @ nt!SepRmGlobalSaclLock (0xfffff8047ef062b0)   Available </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource @ nt!SepLsaAuditQueueInfo (0xfffff8047ee6e010)   Available </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource @ nt!SepLsaDeletedLogonQueueInfo (0xfffff8047ee6ded0)   Available </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource @ 0xffff898f032a8550   Available </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource @ nt!PnpRegistryDeviceResource (0xfffff8047ee62b00)   Available </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Contention Count = 27385 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource @ nt!PopPolicyLock (0xfffff8047ee458c0)   Available </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Contention Count = 14 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource @ 0xffff898f032a8950   Available </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource @ 0xffff898f032a82d0   Available </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请注意，从资源结构中提取的争用计数（contention count）记录了线程试图获取资源，但因为资源被其他线程所拥有而只能等待的次数。通过调试器进入运行中的系统后，我们可能足够幸运捕获到一些这种被持有的资源，例如：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">2: kd&gt; !locks </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">**** DUMP OF ALL RESOURCE OBJECTS **** </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">KD: Scanning for held locks..... </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource @ 0xffffde07a33d6a28   Shared 1 owning threads </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Contention Count = 28 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     Threads: ffffde07a9374080-01&lt;*&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">KD: Scanning for held locks.... </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource @ 0xffffde07a2bfb350   Shared 1 owning threads </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Contention Count = 2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     Threads: ffffde07a9374080-01&lt;*&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">KD: Scanning for held locks...................................................</span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource @ 0xffffde07a8070c00   Shared 1 owning threads </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     Threads: ffffde07aa3f1083-01&lt;*&gt; *** Actual Thread ffffde07aa3f1080 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">KD: Scanning for held locks...................................................</span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource @ 0xffffde07a8995900   Exclusively owned </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     Threads: ffffde07a9374080-01&lt;*&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">KD: Scanning for held locks...................................................</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    9706 total locks, 4 locks currently held </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以查看特定资源对象的详情，包括拥有该资源的线程以及正在等待该资源的其他线程。为此需要指定–v开关并提供资源地址，但前提是当前存在被获取（拥有）的资源。例如，下列这个被持有的共享资源似乎与NTFS有关，有线程正试图从文件系统执行读取操作：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">2: kd&gt; !locks -v 0xffffde07a33d6a28 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource @ 0xffffde07a33d6a28    Shared 1 owning threads </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Contention Count = 28 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     Threads: ffffde07a9374080-01&lt;*&gt; </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     THREAD ffffde07a9374080 Cid 0544.1494   Teb: 000000ed8de12000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     Win32Thread: 0000000000000000 WAIT: (Executive) KernelMode Non-Alertable </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">         ffff8287943a87b8  NotificationEvent </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     IRP List: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">         ffffde07a936da20: (0006,0478) flags: 00020043 Mdl: ffffde07a8a75950 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">         ffffde07a894fa20: (0006,0478) flags: 00000884 Mdl: 00000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     Not impersonating </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     DeviceMap                 ffff8786fce35840 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     Owning Process            ffffde07a7f990c0       Image:       svchost.exe</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     Attached Process          N/A            Image:         N/A </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     Wait Start TicksCount     3649           Tickss: 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     Context Switch Count      31             IdealProcessor: 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     UserTime                  00:00:00.015 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     KernelTime                00:00:00.000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Win32 Start Address 0x00007ff926812390 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Stack Init ffff8287943aa650 Current ffff8287943a8030 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Base ffff8287943ab000 Limit ffff8287943a4000 Call 0000000000000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Priority 7 BasePriority 6 PriorityDecrement 0 IoPriority 0 PagePriority 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Child-SP          RetAddr           Call Site </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffff8287`943a8070 fffff801`104a423a nt!KiSwapContext+0x76 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffff8287`943a81b0 fffff801`104a5d53 nt!KiSwapThread+0x5ba </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffff8287`943a8270 fffff801`104a6579 nt!KiCommitThreadWait+0x153 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffff8287`943a8310 fffff801`1263e962 nt!KeWaitForSingleObject+0x239 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffff8287`943a8400 fffff801`1263d682 Ntfs!NtfsNonCachedIo+0xa52 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffff8287`943a86b0 fffff801`1263b756 Ntfs!NtfsCommonRead+0x1d52 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffff8287`943a8850 fffff801`1049a725 Ntfs!NtfsFsdRead+0x396 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffff8287`943a8920 fffff801`11826591 nt!IofCallDriver+0x55</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>推</b><b>锁</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">推锁（pushlock）
是另一种基于事件对象的优化同步机制，与快速互斥和受保护互斥类似，推锁仅在锁争用时才会等待事件。不过推锁也提供了优于两种互斥的优势：推锁与执行体资
源一样，能够以共享或独占的模式获取。然而与执行体资源的不同之处在于，推锁由于其大小而提供了一种额外优势：资源对象的大小为104字节，而推锁的大小
和指针相当。因此推锁无须进行分配或初始化，可以保证在内存不足时正常工作。内核中的很多组件已经从执行体组件转为使用推锁，现代的第三方驱动程序也全部
使用了推锁。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">推锁可分为四种类型：常规
（Normal）、缓存感知（Cache-aware）、自动扩展（Auto- 
expand）以及基于地址（Address-based）。常规推锁只需要与指针一样大小的存储容量（32位系统为4字节，64位系统为8字节）。当线
程获得常规推锁后，如果该推锁目前尚未被任何一方拥有，推锁代码会将该推锁标记为“已被拥有”。如果推锁被独占拥有，或线程希望独占拥有但该推锁目前正被
其他线程所共享，该线程会在线程栈上分配一个等待块，在等待块中初始化一个事件对象，随后将该等待块添加到与该推锁相关的等待列表中。当其他线程释放该推
锁后，线程会唤醒一个等待方（如果存在的话），为此会为等待方的等待块中的事件发送信号。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于推锁的大小与指针相同，因此其中会包含各种位，并借助这些位来描述自己的状态。随着推锁从争用状态变为非争用状态，这些位的含义也会发生变化。在初始状态下，推锁包含下列结构。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个锁定位，如果锁已被获取，则会被设置为“1”。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个等待位，如果锁处于争用状态并且有其他方正在等待，则会被设置为“1”。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个等待位，如果锁已经被分配给某个线程并且等待方的列表需要优化，则会被设置为“1”。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个多重共享位，如果推锁被共享并且目前被多个线程所获取，则会被设置为“1”。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·28（32位Windows）或60（64位Windows）个共享计数位，包含目前获取该推锁的线程的数量信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如上文所述，当线程需要
以独占方式获取推锁，而该推锁已被多个读取方或一个写入方所获取时，内核会分配一个推锁等待块。而推锁值本身的结构也会发生变化，共享计数位将变为等待块
的指针。因为该等待块是在栈上分配的，并且头文件包含一个特殊的对齐指令来强制保证16字节对齐，任何推锁等待块结构中底部的4位都将归零。因此在指针取
消引用的目的中，这些位会被忽略，而上文提到的4位会与指针值结合在一起。由于这种对齐移除了共享计数位，因此共享计数会被存储在等待块中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存感知推锁通过为系统中
的每个处理器分配一个推锁，将其与缓存感知推锁相关联，为常规（基本）推锁添加了一个额外的“层”。当线程想要获取可共享访问的缓存感知推锁时，只需获取
分配给共享模式下当前处理器的推锁即可；如果要以独占方式获得缓存感知推锁，则线程可以获取独占模式下当前处理器的推锁。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">不过大家可能已想到，随着
Windows现在最多已经可以支持包含2560个处理器的系统，缓存感知推锁中潜在的缓存填充插槽（Cache-padded 
slot）需要进行大量的固定分配，即便处理器较少的系统也是如此。系统对处理器热添加功能的支持让问题变得更棘手，因为从技术的角度来看，这需要提前预
分配所有的2560个插槽，从而导致数KB大小的锁结构。为了解决这个问题，现代版本的Windows还实现了一种自动扩展推锁。顾名思义，此类缓存感知
推锁可以根据需要，基于争用或基于处理器数量动态增加缓存插槽的数量，借此保证能够顺利扩展，同时借助执行体的插槽分配程序，预留出分页或非分页内存池
（取决于分配自动展开推锁时锁传入的标记）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">然而对第三方开发者来说，
缓存感知推锁（以及以此为基础发展出来的自动扩展推锁）的相关用法并未提供官方文档，尽管某些数据结构（例如Windows 10 
21H1以及后续版本中的FCB头）确实以不透明的方式使用了这些机制（有关FCB头的详细信息请参阅第11章）。内核中使用了自动扩展推锁的内部部分还
包括内存管理器，内存管理器会通过该机制保护地址窗口扩展（Address Windowing Extension，AWE）数据结构。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后，还有另一种未提供文
档，但可导出的推锁：基于地址的推锁，它使用了一种类似于稍后要介绍的用户模式下基于地址的等待机制，进一步完善了推锁的实现。除了作为一种不同“类
型”的推锁，基于地址的推锁更多地被用于代表其背后所使用的接口。在一端，一个调用方使用ExBlockOnAddressPushLock传入一个推
锁、感兴趣的某个变量的虚拟地址、变量大小（最多8字节），及一个包含预期或期望变量值的比较地址。如果该变量当前没有预期值，将使用
ExTimedWaitForUnblockPushLock初始化一个等待。这种行为与争用推锁的获取行为类似，不同之处在于可指定超时值。在另一端，
另一个调用方在对监视的地址进行更改后使用ExUnblockOnAddressPushLockEx向等待方发出信号，告知对方值已更改。这种技术在处
理受到锁或互锁操作保护的数据时非常有用，借此相互竞争的读取方就可以在锁之外等待写入方通知更改已完成。除了内存占用更小，推锁相较于执行体资源的另一
个优势在于，在争用情况下，推锁不需要冗长的“记账”和整数操作即可获取或释放。因为与指针一样小，内核可以使用原子CPU指令执行这些任务（例如在
x86和x64处理器上使用的lock 
cmpxchg指令，能以原子方式将新老锁进行对比和交换）。如果这种原子性的对比和交换失败，锁将包含调用方未预料到的值（调用方通常期待锁未被使用，
或以共享的方式获取锁），随后即可调用更复杂的争用版本。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了进一步改善性能，内核
会将推锁功能暴露为内联函数，这意味着在非争用获取期间不会产生任何函数调用，汇编代码会直接插入每个函数中。这会让代码的大小略微增加，但避免了缓慢的
函数调用。最终，推锁还会使用多种算法上的小技巧来避免锁护送（lock 
convoy，这种情况是指多个相同优先级的线程都在等待同一个锁，因而导致几乎没有完成什么实际的工作），并借此实现自我优化：等待推锁的线程列表会定
期重新排序，以便在推锁被释放时提供更公平的行为。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">另一种适用于推锁（包括基
于地址的推锁）获取的性能优化措施是：发生争用的过程中，在让调度程序对象等待推锁等待块事件之前，执行类似于机会性自旋锁的行为。如果系统还有至少一个
尚未休止（unparked）的处理器（有关内核休止的详细信息，请参阅卷1第4章），内核会像自旋锁那样进入一种紧密的、基于旋转的
ExpSpinCycleCount循环，但并不会提升IRQL，而是会为每次迭代发出一个Yield指令（例如x86/x64的Pause指令）。如果
在任何迭代期间推锁似乎已被释放，那么将执行互锁操作获取该推锁。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果旋转周期超时，或者互
锁操作（因为竞争）失败，或者没有至少一个额外的尚未休止的处理器，则会在推锁等待块中为事件对象使用KeWaitForSingleObject。在包
含一个以上逻辑处理器的计算机中，ExpSpinCycleCount会被设置为10240个周期，且无法修改。如果系统搭载AMD处理器并实现了
MWAITT（MWAIT计时器）规范，则会使用Monitorx和Mwaitx指令代替旋转循环。这种基于硬件的功能可以在无须进入循环的前提下，在
CPU层面上等待某个地址的值发生变化，同时还可允许提供超时值（由内核根据ExpSpinCycleCount提供），这样就无须陷入无尽的等待。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后需要注意的是，随着自
动提升功能（详见卷1第4章）的引入，推锁也默认利用了这个功能，除非调用方使用新的ExXxxPushLockXxxEx函数，允许传入禁用该功能的
EX_PUSH_LOCK_FLAG_DISABLE_AUTOBOOST标记（该标记未提供官方文档）。在默认情况下，非Ex函数现在可以调用更新的
Ex函数，但无法提供这个标记。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>基</b><b>于</b><b>地</b><b>址</b><b>的</b><b>等</b><b>待</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">考虑到键控事件中存在的一
些情况，Windows内核现在暴露给用户模式的键同步基元是一种按照ID发送警报（alert-by-ID）的系统调用（以及对应的按照ID等待警报，
wait-on-alert-by-ID）。借助这两种无须内存分配和句柄的简单系统调用，可以构建任意数量的进程本地同步，其中就包括下面即将介绍的基
于地址的等待机制。在此之上还有其他基元，例如临界区以及SRW锁，都是基于此形成的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">基于地址的等待基于三个已
经提供了文档的Win32 
API调用：WaitOnAddress、WakeByAddressSingle以及WakeByAddressAll。KernelBase.dll
中的这些函数只是Ntdll.dll的转发器，其中真正的实现也以类似的名称存在，这些名称均以“Rtl”字样开头，代表Run Time 
Library（运行时库）。Wait API会接收指向自己感兴趣值的地址、值的大小（最大8字节）、不需要的值的地址及超时值。Wake 
API只能接收地址。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">首先，
RtlWaitOnAddress会构建一个本地地址等待块，借此跟踪线程ID和地址，并将其插入进程环境块（Process Environment 
Block，PEB）中的一个进程哈希表中。这与之前介绍过的ExBlockOnAddressPushLock的实际工作较为类似，但后者不需要这个哈
希表，因为调用方需要将推锁指针存储在某个位置。随后，与内核API类似，RtlWaitOnAddress会检查目标地址是否包含与“不需要的值”不同
的值，如果包含，则会移除该地址等待块并返回FALSE；否则会调用一个内部函数加以阻塞。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果有多个可用的未休止处
理器，阻塞函数会先尝试着在用户模式下对代表可用性的地址等待块位的值进行旋转，以避免进入内核，该位基于
RtlpWaitOnAddressSpinCount的值，如果系统包含超过一个处理器，则该值会被写死为“1024”。如果等待块依然存在争用，则会
使用NtWaitForAlertByThreadId向内核发出系统调用，并将作为提示参数的地址和超时值传入。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果函数因为超时而返回，
那么地址等待块中会设置标记来代表这种情况，并且该块会被移除，函数将返回STATUS_TIMEOUT。不过还有一种较为微妙的竞争关系：调用方可能恰
巧在等待超时后的几个周期内调用了Wake函数。由于等待块标记被一条比较-交换指令所修改，所以代码可以检测到这种情况并再一次实际调用
NtWaitForAlertByThreadId，这次将不包含超时。借此可保证能够返回，因为代码知道唤醒正在进行中。不过要注意，在非超时的情况
下，无须移除等待块，因为唤醒方已经移除了。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在等待方这一端，
RtlWakeOnAddressSingle和RtlWakeOnAddressAll都利用了相同的辅助函数，该函数可对输入的地址进行哈希处理，并
在本节上文提到的PEB哈希表中查找。通过与比较-交换指令慎重地进行同步，即可从哈希表中移除地址等待块，并且，如果已通过提交唤醒了任何等待方，还会
遍历相同地址的所有匹配等待块，在该API单一版本的全部或第一个应用中，为每个等待块调用NtAlertThreadByThreadId。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">借助这样的实现，我们基本上已经具备了键控事件的用户模式实现，该实现不依赖任何内核对象或句柄，甚至不依赖任何全局对象，从而彻底避免了资源不足时的失败。因此，内核只需要负责将线程置于等待状态，或将处于等待状态的线程唤醒。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">下面将介绍在争用期间利用该功能提供同步的各类基元。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>临</b><b>界</b><b>区</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">临界区是Windows在
基于内核的同步基元基础上为用户模式应用程序开发者提供的主要同步基元之一。相较于内核模式的对应基元，临界区相对下文涉及的其他用户模式基元的最大优势
之一在于，在锁未被争用的情况（99%甚至更多时候都是这种情况）下，节省了一次到内核模式的往返。然而，存在争用的情况下依然需要调用内核，因为这是系
统中唯一可以执行复杂的唤醒和调度逻辑，以便让这些对象可以正常工作的地方。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">临界区可使用一个本地位提
供主要的独占锁逻辑（类似于推锁），以便让自己维持在用户模式下。如果该位设置为“0”，临界区即可被获取，随后所有者会将该位设置为“1”。该操作无须
调用内核，而是会使用上文介绍过的互锁CPU操作。临界区的释放也会产生类似行为，通过互锁操作将这个位的状态由“1”改为“0”。另外，很多人可能已经
猜到了，如果该位已经为“1”并且其他调用方试图获取该临界区，必须调用内核以便让线程进入等待状态。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">类似于推锁和基于地址的等
待，为避免进入内核，临界区也实现了进一步优化措施：旋转（spinning），这有些类似于锁定位上的自旋锁（尽管处于IRQL 
0被动级别），借此实现足够快速的清除以避免阻塞等待。在默认情况下，旋转会设置为2000个周期，但可在创建时使用
InitializeCriticalSectionEx或InitializeCriticalSectionAndSpinCount 
API设置为其他值，创建之后也可调用SetCriticalSectionSpinCount修改默认值。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 正如上文所述，为了进行优化，WaitForAddressSingle已经实现了繁忙的旋转等待，且默认为1024个周期。因此从技术上来看，旋转操作默认将花费3024个周期：首先在临界区的锁定位上旋转，随后在等待地址块的锁定位上旋转，最后才能真正进入内核。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在确实需要进入真正的争用
路径时，临界区会在首次被调用时尝试着初始化自己的LockSemaphore字段。在现代版本的Windows中，只有在设置
RtlpForceCSToUseEvents后才会这样做，如果通过应用程序兼容性数据库为当前进程设置了
KACF_ALLOCDEBUGINFOFORCRITSECTIONS 
(0x400000)标记，就会发生这种情况。然而，如果该标记已设置，还会创建底层的调度程序事件对象（即使该字段代表了信号量，该对象也是一种事
件）。随后假设事件已创建，还会调用WaitForSingleObject以阻塞临界区（通常会使用每个进程可配置的超时值以便为死锁的调试提供帮助，
然后重新尝试进行等待）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在未请求应用程序兼容性铺
垫，或内存严重不足时虽然请求了铺垫但无法创建事件的情况下，临界区将不再使用该事件（也不再使用上文提到的任何键控事件功能）。相反，此时将直接利用上
文介绍的基于地址的等待机制（并同样使用上一段所介绍的相同的死锁检测超时机制）。本地位的地址会提供对WaitOnAddress的调用，只要临界区被
LeaveCriticalSection释放，即可调用事件对象的SetEvent，或调用本地位的WakeAddressSingle。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
尽管我们一直使用Win32名称来指代API，但实际上，临界区是由Ntdll.dll实现的，而KernelBase.dll只是将函数转发给
以“Rtl”字样开头的相同函数，因为它们是运行时库的一部分。因此RtlLeaveCriticalSection会调用NtSetEvent、
RtlWakeAddressSingle等函数。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">因为临界区并非内核对象，因此也存在某些局限。主要是我们无法获得临界区的内核句柄，因此对象管理器的安全、命名或其他功能都不适用于临界区。两个进程无法使用相同的临界区来协调自己的操作，也不能进行复制或继承。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>用</b><b>户</b><b>模</b><b>式</b><b>资</b><b>源</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">用户模式资源也提供了比内
核基元更细化的锁定机制。资源能够以共享模式或独占模式获取，进而使其可充当数据库等数据结构的多读取方（共享）、单写入方（独占）锁。当以共享模式获取
一个资源而其他线程试图获取同一个资源时，将无须访问内核，因为没有正处于等待状态的线程。只有当一个线程试图以独占访问方式获取资源时，或资源已经被独
占的所有者锁定时，才需要访问内核。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了使用与内核中相同的调
度和同步机制，资源会直接使用现有的内核基元。资源数据结构（RTL_RESOURCE）包含指向两个内核信号量对象的句柄。当资源被多个线程独占获取
后，该资源会通过一个释放计数释放独占信号量，因为资源最多只能有一个所有者。当资源被多个线程共享获取后，资源会释放共享信号量，以及与共享的所有者数
量相同的释放计数。这种级别的细节通常会对开发者隐藏起来，并且这些内部对象也永远不应直接使用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">资源最初是为了支持SAM
（Security Account Manager，安全账户管理器，详见本书卷1第7章）而实现的，并未通过Windows 
API暴露给标准应用程序。下文将要介绍的精简读取器-写入器（Slim 
Reader-Writer，SRW）锁会通过具备详细文档的API实现一个类似但高度优化的锁定基元，不过一些系统组件依然使用了资源机制。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>条</b><b>件</b><b>变</b><b>量</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">条件变量
（condition 
variable）为等待条件测试特定结果的一系列线程的同步提供了一种Windows原生实现。尽管通过用户模式的其他同步方法也能实现该操作，但缺乏
用于检查条件测试结果并开始结果中某一变化所需的原子机制。系统需要围绕这些代码进行额外的同步。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">用户模式线程通过调用
InitializeConditionVariable来初始化条件变量并设置其初始状态。在需要发起对变量的等待时，会调用
SleepConditionVariableCS，借此使用一个临界区（线程必须已经完成该临界区的初始化）来等待变量的更改，更好的情况则是使用
SleepConditionVariableSRW，借此将使用下文即将介绍的SRW锁，从而让调用方获得对独占（写入方）获取进行共享（读取方）的优
势。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">同时，设置线程还必须在修
改了变量后使用WakeConditionVariable（或WakeAllConditionVariable）。取决于实际使用的函数，该调用可释
放一个或全部等待中线程的临界区或SRW锁。这听起来像是基于地址的等待，因为这就是基于地址的等待，并且还能对比较和等待操作的原子性提供额外保证。此
外，条件变量是在基于地址的等待之前实现的（也就先于按照ID发出的警报），并且必须依赖键控事件，因此只能近似实现所需行为。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在条件变量出现前，通常需
要使用通知事件或同步事件（回忆可知，它们在Windows 
API中被称为“自动重置”或“手动重置”）来指示变量的更改，例如工作队列的状态。等待这种更改需要获取一个临界区随后将其释放，然后等待一个事件。等
待之后，还需要重新获取临界区。在这一系列获取和释放过程中，线程可能已经切换了上下文，如果其中一个线程调用了PulseEvent就会导致问题（类似
于键控事件在没有等待方的情况下强制等待其他线程发出信号所要解决的问题）。有了条件变量后，临界区或SRW锁的获取可以由应用程序来维护，此时会调用
SleepConditionVariableCS/SRW，并且只有在实际工作完成后才会释放。这使得写操作工作队列的代码（和类似的实现）可以用更简
单，更可预测的方式完成。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">然而，随着SRW锁和临界
区移动至基于地址的等待基元，条件变量已经可以直接利用NtWaitForAlertByThreadId并直接向线程发出信号，同时可以构建在结构上类
似于上文介绍的地址等待块的条件变量等待块。借此可完全消除对键控事件的需求，只不过为了实现向后兼容性，依然需要保留键控事件。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>精</b><b>简</b><b>读</b><b>取</b><b>器</b><b>/</b><b>写</b><b>入</b><b>器</b><b>（</b><b>S</b><b>R</b><b>W</b><b>）</b><b>锁</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">尽管条件变量是一种同步机
制，但并非完整的基元锁，因为它们会围绕自己锁定的行为进行隐式值比较，并且依赖于更高级的抽象（也就是“锁”）。同时，基于地址的等待是一种基元操作，
但只提供了基本的同步基元，而非真正的锁定。在这两个世界之间，Windows有一种真正的锁定基元，它几乎与推锁完全相同，那就是精简读取器/写入器锁
（SRW锁）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与内核中的对应物一样，
SRW锁的大小同样与指针相等，使用原子操作来获取和释放，可防止锁护送并会重新调整等待方列表，能够以共享和独占的模式获取。与推锁类似，SRW锁可以
从共享模式升级或转换为独占模式，反之亦然，并且在递归获取方面也遵循相同的限制。唯一的真正区别在于：SRW锁是用户模式代码独有的，而推锁是内核模式
代码独有的，两者无法从一层共享或暴露给另一层。因为SRW锁同样使用了NtWaitForAlertByThreadId基元，因此无须进行内存分配，
并且可以保证永远不会失败（除非使用方法有误）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SRW锁不仅可以彻底取代
应用程序代码中的临界区，从而减少分配大型CRITICAL_SECTION结构（原本需要创建事件对象）的需求，而且提供了多读取方、单写入方功能。
SRW锁必须首先使用InitializeSRWLock进行初始化，或者使用Sentinel值进行静态初始化，随后即可通过相应的API
（AcquireSRWLockExclusive、ReleaseSRWLockExclusive、AcquireSRWLockShared以及
ReleaseSRWLockShared）以独占的或共享的模式获取或释放。此外，还可通过API以机会性的方式获取锁，保证不会发生阻塞操作，以及将
锁从一种模式转换为另一种模式。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 与大部分其他Windows 
API不同，SRW锁函数不返回任何值，相反，它们会在无法获取锁时生成异常。这会让获取操作失败变得更明显，遇到这种情况，原本假设成功获取锁的代码就
可以直接终止，而不用冒着可能损坏用户数据的风险继续处理。由于SRW锁不会因资源耗尽而失败，因此在共享模式下错误地释放了非共享SRW锁之后，
STATUS_RESOURCE_NOT_OWNED将成为唯一可能的异常。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows 
SRW锁会以平等的方式对待读取方和写入方，这意味着在这两种情况下都应该能实现相同的性能。这也使得SRW锁成为临界区的绝佳替代品，因为临界区是写入
方独有或独占的同步机制，并且也针对资源优化提供了替代方案。如果SRW锁针对读取方进行优化，那么将成为一种糟糕的独占锁，好在事实并非如此。因此上文
我们曾提到，条件变量也可以通过SleepConditionVariableSRW 
API使用SRW锁。也就是说，键控事件虽然不再用于一种机制（SRW）中，但依然用在其他机制（CS）中，因此，基于地址的等待削弱了除代码更小之外的
其他所有好处，并削弱了具备共享锁以及独占锁的能力。尽管如此，以老版本Windows为目标的代码也应当使用SRW锁，以保证在依然使用了键控事件的内
核中提供更多好处。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>运</b><b>行</b><b>一</b><b>次</b><b>初</b><b>始</b><b>化</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在多线程编程领域存在一个
典型问题：如何保证以原子性的方式执行一段负责某类初始化任务（如分配内存、初始化某些变量，甚至按需创建对象）的代码。如果一段代码可以被多个线程同时
调用（例如负责初始化DLL的DllMain例程），即可通过多种方法尝试着以正确、原子性、唯一的方式执行初始化任务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于这种情况，
Windows实现了一次性初始化（Init once）机制，即One-time初始化（在内部也叫Run 
once初始化）。该API以Win32变体的形式存在，可调用Ntdll.dll的运行时库（Rtl），就好像上文介绍的其他各种机制一样。此外，它还
能调用一系列记录在案的Rtl 
API集，这些API可通过Ntoskrnl.exe暴露给内核程序员（很明显，用户模式开发者也可以绕过Win32直接使用Ntdll.dll中的
Rtl函数，但不推荐这样做）。这两种实现唯一的差别在于，内核最终会使用事件对象进行同步，而用户模式会使用键控事件（实际上需要传入一个NULL句
柄，以使用曾被临界区使用过的低内存键控事件）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
由于最新版本的Windows在内核模式实现了一种基于地址的推锁，并在用户模式下实现了基于地址的等待基元，因此，Rtl库可能会通过更新转为使用
RtlWakeAddressSingle和ExBlockOnAddressPushLock，实际上，未来版本的Windows将可能始终这样做：键
控事件只是为老版本Windows中的调度程序事件对象提供了一个类似的接口。必须再次提醒的是，请不要完全依赖本书所介绍的各种内部细节，因为这些细节
随时有可能出现变化。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Init once机制允许以同步方式（意味着其他线程必须等待初始化完成）和异步方式（意味着其他线程可以试着进行自己的初始化并展开竞争）执行某些代码。在了解了同步机制后，再来看看异步执行背后的逻辑。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在同步执行情况下，开发者
所编写的代码通常可以在专用函数中的全局变量被复查之后开始执行。例程所需的任何信息均可通过Init 
once例程中可接受的参数变量传递。而任何输出信息都会通过上下文变量返回（初始化操作本身的状态可作为布尔值返回）。为确保正确执行，开发者只需要在
使用InitOnceInitialize 
API初始化INIT_ONCE对象后，通过参数、上下文以及Run-once函数指针调用InitOnceExecuteOnce即可。其余工作将由系
统完成。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于想要使用异步模型的应
用程序，线程可调用InitOnceBeginInitialize，并收到一个BOOLEAN挂起状态以及上文所提到的上下文。如果挂起状态为
FALSE，意味着初始化已经发生，线程将使用结果所包含的上下文值（函数也可能返回FALSE，这意味着初始化失败）。然而，如果挂起状态返回
TRUE，则线程应当通过竞争优先创建对象。随后执行的代码将完成所需的各种初始化任务，例如创建对象或分配内存。当这些工作完成后，线程会使用之前工作
的结果作为上下文调用InitOnceComplete，并收到BOOLEAN状态。如果该状态为TRUE，意味着线程赢得了竞争，它所创建或分配的对象
将成为全局对象。随后取决于具体用法，该线程可以保存该对象或将其返回给调用方。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在更复杂的情况下，如果状
态为FALSE，这意味着线程竞争失败。此时该线程必须撤销自己所做的全部工作，如删除对象或释放内存，随后再次调用
InitOnceBeginInitialize。不过这一次不用像第一次那样请求重新开始竞争，而是可以使用INIT_ONCE_CHECK_ONLY
标记，这样线程就知道自己曾经在竞争中输过，并转为请求竞争胜利者的上下文（例如胜利者所创建或分配的对象或内存）。这会返回另一个状态，可以是
TRUE，意味着上下文有效，可以直接使用或返回给调用方；但也可以是FALSE，意味着初始化已失败，大家都不能执行工作（例如可能是因为内存不足）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在这两种情况下，运行一次
初始化机制类似于条件变量和SRW锁机制。Init 
once结构大小与指针相同，内联的汇编版本SRW获取/释放代码可用于非争用情况，键控事件则可用于争用已经发生（该机制以同步模式使用时会发生这种情
况）而其他线程必须等待初始化的情况下。异步模式下会以共享模式使用锁，因此多个线程可以同时进行初始化。尽管不像按照ID发出警报基元那么高效，但键控
事件保证了Init once机制在内存耗尽时依然能够工作。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter08_0008.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_41" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>8</b><b> </b><b>高</b><b>级</b><b>本</b><b>地</b><b>过</b><b>程</b><b>调</b><b>用</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">所有现代操作系统都需要一
种机制，以便在用户模式下的一个或多个进程之间，或在内核的服务和用户模式下的客户端之间，安全、高效地传输数据。通常情况下，邮件槽、文件、命名管道和
套接字等UNIX机制可用于实现可移植性，但在其他情况下，开发者也可以利用操作系统特定的功能，例如Win32图形应用程序中无处不在的窗口消息。此
外，Windows还实现了一种名为高级（或异步）本地过程调用（Advanced Local Procedure 
Call，ALPC）的内部IPC机制，这是一种高速、可扩展、安全的设施，可用于传递任意大小的消息。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 ALPC取代了最初伴随Windows 
NT第一个内核设计中所采用的古老的IPC机制：LPC。因此，至今某些变量、字段和函数可能依然将其称为“LPC”。不过要注意，为了保证兼容性，目前
的LPC是在ALPC基础上模拟而来的，已经从内核中移除（遗留的系统调用依然存在，但会被包装成ALPC调用）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">尽管ALPC作为内部机制无法供第三方开发者使用，但在Windows的各个部分依然实现了广泛应用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
使用远程过程调用（RPC）的Windows应用程序，作为一种公开的API，当通过ncalrpc传输指定本地RPC时，会间接用到ALPC，这是一种
用于在同一系统的进程之间进行通信的RPC形式。ALPC现已成为几乎所有RPC客户端的默认传输，此外，当Windows驱动程序使用内核模式RPC
时，也会暗含地使用ALPC作为唯一允许的传输。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·当Windows进程或线程启动时，以及在任何Windows子系统运行期间，都会使用ALPC与子系统进程（CSRSS）通信。所有子系统均会通过ALPC与会话管理器（SMSS）通信。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·当Windows进程引发异常时，内核的异常调度程序会使用ALPC与Windows错误报告（Windows Error Reporting，WER）服务通信。进程也可以自行与WER通信，例如，通过未处理的异常处理程序进行通信（WER详见第10章）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Winlogon会使用ALPC与本地安全认证进程（LSASS）通信。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·安全引用监视器（一种执行体组件，详见本书卷1第7章）会使用ALPC与LSASS进程通信。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·用户模式电源管理器和电源监视器会通过ALPC与内核模式电源管理器通信，例如，当LCD亮度被更改后。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·用户模式驱动程序框架（User-Mode Driver Framework，UMDF）使得用户模式驱动程序能够通过ALPC与内核模式反射器驱动程序进行通信。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·CoreUI所用的全新核心消息（core messaging）机制以及现代UWP UI组件会使用ALPC与Core Messaging Registrar注册，并发送序列化消息对象，这种方式取代了老旧的Win32窗口消息模型。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·在启用凭据保护（credential guard）功能后，隔离的LSASS进程会使用ALPC与LSASS通信。类似地，安全内核也会通过ALPC向WER传输Trustlet崩溃转储信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">从这些例子可以看出，ALPC通信涵盖了所有可能的安全边界类型：从非特权应用程序到内核，从VTL 1 Trustlet到VTL 0服务，以及这之间的一切。因此，安全性和性能成了相关设计中的一个关键要求。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_42" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>8</b><b>.</b><b>1</b><b> </b><b>连</b><b>接</b><b>模</b><b>型</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">通常来说，ALPC消息会
被用于服务器进程以及该服务器的一个或多个客户端进程之间。两个或更多个用户模式进程之间，或内核模式组件与一个或多个用户模式进程之间，甚至两个内核模
式组件之间（尽管这并非是最有效的通信方式）也可建立ALPC连接。为了维持通信所需要的状态，ALPC会暴露出一个名为端口对象（port 
object）的执行体对象。虽然这只是一个对象，但可以代表多种类型的ALPC端口。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>服</b><b>务</b><b>器</b><b>连</b><b>接</b><b>端</b><b>口</b></span>。一种命名端口，充当了服务器连接的请求点。客户端可以连接到这种端口进而连接到服务器。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>服</b><b>务</b><b>器</b><b>通</b><b>信</b><b>端</b><b>口</b></span>。一种未命名端口，服务器可借此与自己的客户端通信。服务器会为每个活跃的客户端提供一个这种端口。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>客</b><b>户</b><b>端</b><b>通</b><b>信</b><b>端</b><b>口</b></span>。一种未命名端口，每个客户端需要借此与自己的服务器通信。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>未</b><b>连</b><b>接</b><b>通</b><b>信</b><b>端</b><b>口</b></span>。一种未命名端口，客户端可以借此与自己进行本地通信。这种模型在从LPC到ALPC的转换过程中被废除了，但为了保证兼容性，依然会对遗留的LPC进行模拟。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ALPC遵循了一种连接和
通信模型，这一点类似于BSD 
Socket编程。服务器首先需要创建一个服务器连接端口（NtAlpcCreatePort），随后客户端尝试着连接到该端口
（NtAlpcConnectPort）。如果服务器处于侦听状态（使用NtAlpcSendWaitReceivePort），则将会收到连接请求消息
并可选择接受该请求（NtAlpcAcceptConnectPort）。以此将创建客户端和服务器通信端口，并且每个端点进程将会收到一个指向其通信端
口的句柄。随后将通过该句柄发送消息（依然使用NtAlpcSendWaitReceivePort），服务器继续使用相同API接收这些消息。因此，在
最简单的情况下，将有一个位于循环中的服务器线程调用NtAlpcSendWaitReceivePort接收被自己接受的连接请求，以及自己所要处理并
响应的消息。服务器可读取PORT_HEADER结构以区分不同消息，这个结构位于每个消息的头部，包含了与消息类型有关的信息。表8-30列出了各种不
同的消息类型。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-30 ALPC消息类型</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/72ab44e9b0dcd604c538ed5e8b98c6e3.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">服务器也可以拒绝连接，这
可能是出于安全性方面的原因，或者仅仅是由于协议或版本方面的问题。因为客户端可以通过连接请求发送自定义载荷，这种特性通常被各种服务用来确保正确的客
户端，或仅一个客户端可以与服务器通信。如果发现任何异常，那么服务器可以拒绝连接，并且可以选择返回一个包含拒绝客户端连接原因等信息的载荷（这样客户
端就可以酌情采取必要应对措施，或进行调试）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">连接建立后，会通过一种连接信息结构（实际上是一个Blob，下文很快将会提到）存储所有不同端口之间的联系信息，如图8-40所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/74ca6b87f05a96d63a253cb83775ede8.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-40 ALPC端口的使用</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_43" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>8</b><b>.</b><b>2</b><b> </b><b>消</b><b>息</b><b>模</b><b>型</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">通过使用ALPC，客户端
和使用阻塞消息的线程将轮流执行围绕NtAlpcSendWaitReceivePort系统调用的循环，其中一端发送请求并等待回复，另一端则反向重复
该过程。然而，因为ALPC支持异步消息，任何一方都有可能不进行阻塞，而是选择执行其他一些运行时任务并在稍后检查消息（下文很快将介绍其中一些方
法）。ALPC支持以下几种交换消息载荷的方法：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
消息可通过标准双缓冲机制发送给另一个进程，在这期间，内核将保持消息的副本（从源进程复制），切换到目标进程，然后从内核缓冲区中复制数据。为了实现兼
容性，如果使用了遗留LPC，则只能通过这种方式发送最大256字节的消息，而ALPC可以为最大64KB的消息分配扩展缓冲区。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·消息可以存储在ALPC节对象中，客户端和服务器进程可通过该对象映射视图（有关节映射的详情请参阅卷1第5章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">发送异步消息的能力产生了一个重要的副作用：消息可以被取消，例如，当一个请求花费了太长时间，或用户发出指示想要取消所实现的操作时。ALPC通过NtAlpcCancelMessage系统调用为此提供支持。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ALPC消息可处于ALPC端口对象所实现的下列五个不同队列中的任何一个之内。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>m</b><b>a</b><b>i</b><b>n</b><b> </b><b>q</b><b>u</b><b>e</b><b>u</b><b>e</b><b>（</b><b>主</b><b>队</b><b>列</b><b>）</b><b>：</b></span>消息已发送，客户端正在进行处理。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>p</b><b>e</b><b>n</b><b>d</b><b>i</b><b>n</b><b>g</b><b> </b><b>q</b><b>u</b><b>e</b><b>u</b><b>e</b><b>（</b><b>挂</b><b>起</b><b>队</b><b>列</b><b>）</b><b>：</b></span>消息已发送，调用方正在等待回复，但尚未发送回复。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>l</b><b>a</b><b>r</b><b>g</b><b>e</b><b> </b><b>m</b><b>e</b><b>s</b><b>s</b><b>a</b><b>g</b><b>e</b><b> </b><b>q</b><b>u</b><b>e</b><b>u</b><b>e</b><b>（</b><b>大</b><b>消</b><b>息</b><b>队</b><b>列</b><b>）</b><b>：</b></span>消息已发送，但调用方的缓冲区太小无法接收。调用方将获得另一次机会分配更大的缓冲区，随后再次请求消息载荷。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>c</b><b>a</b><b>n</b><b>c</b><b>e</b><b>l</b><b>e</b><b>d</b><b> </b><b>q</b><b>u</b><b>e</b><b>u</b><b>e</b><b>（</b><b>已</b><b>取</b><b>消</b><b>队</b><b>列</b><b>）</b><b>：</b></span>消息已发送到端口但随后被取消了。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>d</b><b>i</b><b>r</b><b>e</b><b>c</b><b>t</b><b> </b><b>q</b><b>u</b><b>e</b><b>u</b><b>e</b><b>（</b><b>直</b><b>接</b><b>队</b><b>列</b><b>）</b><b>：</b></span>消息已发送，并附加了一个直接事件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">请注意，还有第六个名为wait queue（等待队列）的队列，该队列并不将消息连接在一起，而是会将等待某个消息的所有线程连接在一起。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>子</b><b>系</b><b>统</b><b>A</b><b>L</b><b>P</b><b>C</b><b>端</b><b>口</b><b>对</b><b>象</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们可以通过Sysinternals的WinObj工具或GitHub上提供的WinObjEx64查看命名的ALPC端口对象。以管理员模式运行这两个
工具中的任意一个，并选择根目录。随后WinObj会用齿轮图标代表端口对象，WinObjEx64则会用电源插头图标代表，如下图所示（我们也可以点击
Type字段并按照类型为对象排序）。</span></p><div style="display: block;text-align:center;">
	<img width="882" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/c74657c1f94f552e7fc1600b1b24566b.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们应当可以看到电源管理器、安全管理器以及Windows的其他内部服务所使用的ALPC端口。如果想要查看RPC使用的ALPC端口对象，可以选择
\RPC 
Control目录。除了本地RPC外，ALPC的主要用户之一是Windows子系统，它们会使用ALPC与所有Windows进程中的Windows
子系统DLL通信。由于CSRSS会为每个会话加载一次，因此可以在相应的\Sessions\X\Windows目录下找到它的ALPC端口对象，如下
图所示。</span></p><div style="display: block;text-align:center;">
	<img width="868" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/6a26babe063a627b6d64c770cfa7182b.jpg" alt="" title=""></div>
</div><div class="header2"><h3><span id="sigil_toc_id_44" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>8</b><b>.</b><b>3</b><b> </b><b>异</b><b>步</b><b>操</b><b>作</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">ALPC的同步模型与早期
NT设计中的原始LPC架构有所关联，并且与诸如Mach端口等其他阻塞式IPC机制较为类似。尽管设计上很简单，但阻塞式IPC算法包含很多死锁的可能
性，为了应对这些情况，产生了很多复杂代码，因而需要更灵活的异步（非阻塞）模型。因此ALPC主要设计为同时也能支持异步操作，这是可扩展的RPC和其
他用途所必需的，例如，在用户模式驱动程序中支持挂起I/O。ALPC还有一项基本功能，即阻塞具备超时参数的调用，这在最初的LPC中并未实现。借此，
遗留应用程序即可避免某些死锁场景。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">然而，ALPC也为异步消
息进行了优化，并为异步通知提供了三种不同的模型。第一种模型实际上并不通知客户端或服务器，而是直接复制数据载荷。在该模型下，需要由实现方来选择可靠
的同步方法。例如，客户端和服务器可以共享同一个通知事件对象，或者客户端可以轮询抵达的数据。该模型使用的数据结构是ALPC完成列表（请不要将它与
Windows 
I/O完成端口相混淆）。ALPC完成列表是一种高效、非阻塞的数据结构，可以在客户端之间进行原子性的数据传递，下文的“性能”一节将进一步介绍其内部
结构。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">另一种通知模型是使用
Windows完成端口机制（位于ALPC完成列表基础之上）的等待模型。这使得线程能够一次检索多个载荷，控制并发请求的最大数量，并充分利用原生的完
成端口功能。用户模式线程池的实现提供了内部API，进程可以使用这些API管理与同样使用该模型实现的工作线程所在相同基础结构中的ALPC消息。
Windows中的RPC系统在（通过ncalrpc）使用本地RPC时，也会通过该功能，进而充分利用内核所提供的支持来提供高效的消息传递，而
Msrpc.sys中的内核模式RPC运行时也是如此。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">因为驱动程序可在任意上下
文中运行，并且通常不会为自己的运行创建专用系统线程，ALPC也提供了另一种机制，借此使用执行体回调对象实现一种更基础、基于内核的通知。驱动程序可
使用NtSetInformationAlpcPort注册自己的回调和上下文，随后每当收到消息，自己就会被调用。例如，内核中的电源相关性协调器
（Power Dependency 
Coordinator，Pdc.sys）就会通过该机制与自己的客户端通信。值得注意的是，使用执行体回调对象能在性能方面带来一些优势，但也会产生一
些安全风险。因为回调是以阻塞的方式（在接到信号后）执行的，并且与信号代码内联，因此总会在ALPC消息发送方的上下文中运行（即与调用
NtAlpcSendWaitReceivePort的用户模式线程内联）。这意味着内核组件可能有机会检查其客户端的状态，而无须付出上下文切换的成
本，并且还有可能在发送方的上下文中直接使用消息的载荷。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">然而，这并非绝对的保证
（如果实现方不了解这种情况，这本身也会成为一种风险），原因在于多个客户端可能同时向同一个端口发送消息，而现有消息可能是客户端在服务器注册自己的执
行体回调对象之前发出的。另外，当服务器还在处理其他客户端之前发送的消息时，另一个客户端也有可能发出了另一条消息。在这些情况下，服务器可能运行在发
送了消息的客户端上下文中，但实际分析的消息可能来自另一个客户端。服务器应该区分这种情况（因为发送端的客户端ID已编码到消息的
PORT_HEADER中），并附加或分析正确的发送端状态（可能需要付出上下文切换的成本）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_45" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>8</b><b>.</b><b>4</b><b> </b><b>视</b><b>图</b><b>、</b><b>区</b><b>域</b><b>和</b><b>节</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">服务器和客户端可以选择更
高效的数据传递机制，而非在各自进程之间发送消息缓冲区，这种机制也是Windows内存管理器的核心：节对象（详见卷1第5章）。借此内存将能以共享的
方式分配，为客户端和服务器提供一致、平等的内存视图。这种情况下可以传输尽可能多的数据，数据只需要复制到一个地址范围，便会立即在另一个范围内可用。
然而共享内存通信（例如LPC原本提供的通信机制）也有一些不足之处，尤其是对安全性产生的影响。例如，因为客户端和服务器必须访问共享的内存，非特权客
户端可以借此破坏服务器的共享内存，甚至借助潜在漏洞构建可执行的载荷。此外，因为客户端知道服务器数据的位置，因此可以使用这些信息绕过ASLR保护
（详见卷1第5章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ALPC在节对象基础上提
供了自己的安全机制。在ALPC中，必须使用相应的NtAlpcCreatePortSection 
API创建特定的ALPC节对象，借此产生对端口的正确引用，并实现原子性的节垃圾回收（也可通过手动API进行删除）。随着ALPC节对象的所有者开始
使用该节，所分配的块（Chunk）将会创建为ALPC区域（Region），它代表了该节中已使用的地址范围，并为消息提供了一个额外的引用。最后，在
共享内存范围内，客户端可以获得该内存的视图（View），这代表了自己地址空间内部的本地映射。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">区域还支持多种安全选项。
首先，区域可以通过安全模式或不安全模式进行映射。在安全模式下，区域只能包含两个视图（映射），当服务器希望以私密的方式与客户端进程分享数据时，通常
会使用该模式。此外，在特定端口的上下文中，只能为特定的共享内存范围打开一个区域。最后，区域可以标记为写访问保护，这样将只有一个进程上下文（服务
器）可以对视图进行写入操作（使用MmSecureVirtualMemoryAgainstWrites），而其他客户端只能进行只读访问。这些设置缓
解了很多以共享内存为目标的特权提升攻击，也让ALPC比传统IPC机制更具弹性。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_46" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>8</b><b>.</b><b>5</b><b> </b><b>属</b><b>性</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">ALPC不仅可以进行简单
的消息传递，还能将特定上下文信息添加到每个消息中，并让内核借此跟踪消息的有效性、寿命和具体的实现等信息。ALPC的用户也可以分配自己的自定义上下
文信息。无论是由系统管理或由用户管理，ALPC都会把这些数据称为属性（Attribute）。内核总共管理了七个属性。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·安全属性，包含模仿客户端，以及高级ALPC安全功能（详见下文）所需的关键信息。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·数据视图属性，负责管理与ALPC节相关区域所关联的不同视图，此外也可用于设置某些标记，例如auto-release（自动释放）标记，回复时，需要手动撤销对视图的映射。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·上下文属性，可将用户管理的上下文指针放置在端口，或通过某个端口发送的消息上。此外，序列号、消息ID以及回调ID也保存在这里并由内核负责管理，借此ALPC用户即可实现唯一性、基于消息的哈希和排序。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·句柄属性，包含与消息相关的句柄有关的信息（详见下文“句柄处理”一节）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·令牌属性，可用于在无须使用完整安全属性的情况下，获取消息发送方的Token ID、Authentication ID和Modified ID（但无法单独用于实现模仿）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·直接属性，可用于发送关联有同步对象的直接消息（详见下文“直接事件”一节）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·代表xxx工作（work-on-behalf-of）属性，用于对工单（work ticket）进行编码，进而实现更完善的电源管理和资源管理决策（详见下文“电源管理”一节）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上述部分属性最初由服务器
或客户端在发送消息时传入，会被转换为内核自己的内部ALPC表达。如果ALPC用户请求返回这些数据，内核会以安全的方式提供。在少数情况下，服务器或
客户端始终可请求这些属性，因为ALPC在内部已将其关联给消息，并使其始终可用（如上下文属性或令牌属性）。通过实现这种模型并将其与内部的句柄表相结
合（详见下文），ALPC可以在客户端和服务器之间保持关键数据的不透明，同时依然维持内核模式下真正的指针。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了正确定义属性，内部的ALPC用户可以使用多种API，例如AlpcInitializeMessageAttribute和AlpcGetMessageAttribute。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_47" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>8</b><b>.</b><b>6</b><b> </b><b>B</b><b>l</b><b>o</b><b>b</b><b>、</b><b>句</b><b>柄</b><b>和</b><b>资</b><b>源</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">尽管ALPC子系统只暴露
了一个对象管理器对象类型（端口），也必须在内部管理一些数据结构，以便执行相关机制所需要的任务。例如，ALPC需要分配并跟踪与每个端口相关的消息以
及消息属性，这些跟踪工作需要涵盖消息的完整生命周期。但ALPC并未使用对象管理器的数据管理例程，而是自行实现了一种名为Blob的轻量级对象。与对
象类似，Blob可以自动分配和垃圾回收，可引用跟踪，并通过同步进行锁定。此外，Blob可以使用自定义的分配和撤销分配回调，借此其所有者就可以控制
跟踪每个Blob可能需要的额外信息。最后，ALPC还使用了执行体的句柄表实现（会被用于对象和PID/TID），借此提供了ALPC专用句柄表，可供
ALPC为Blob生成私有句柄，而无须使用指针。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">例如，在ALPC模型中，消息就是Blob，消息的构造函数会生成一个消息ID，该ID本身就是一种包含在ALPC句柄表中的句柄。其他ALPC Blob还包括：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·连接Blob，存储了客户端和服务器通信端口信息，以及服务器连接端口和ALPC句柄表。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·安全Blob，存储了模仿客户端所必需的安全性数据，同时还存储了安全属性。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·节、区域和视图Blob，描述了ALPC的共享内存模型。视图Blob最终还要负责存储数据视图属性。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·保留Blob，实现了对ALPC保留对象的支持（详见本章上文“保留对象”一节）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·句柄数据Blob，包含实现ALPC句柄属性支持所需的信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于Blob是从可分页内
存中分配的，因此必须仔细地跟踪，以保证能在适当的时候将其删除。对于某些类型的Blob这很容易，例如，当发出ALPC消息后，包含该消息的Blob便
会被删除。然而某些类型的Blob可能代表了附加到同一条ALPC消息的多个属性，内核必须适当地管理此类Blob的寿命。例如，由于一条消息可以关联多
个视图（例如多个客户端访问同一个共享内存时），必须将这些视图与引用它们的消息一起进行跟踪。ALPC通过一种资源的概念实现了该功能。每个消息都关联
了一个资源列表，在为消息分配关联的Blob（而非简单的指针）时，该Blob也会以消息资源的形式添加。而ALPC库提供了查找、刷新和删除相关资源的
功能。安全Blob、保留Blob以及视图Blob都会存储为资源。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_48" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>8</b><b>.</b><b>7</b><b> </b><b>句</b><b>柄</b><b>的</b><b>传</b><b>递</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">UNIX域套接字和
Mach端口（分别是Linux和macOS中最复杂且最常用的IPC机制）的一个重要特征是，能够在所发送的消息中编码一个文件描述符，随后在接收过程
中对该描述符进行复制，进而实现UNIX风格的文件（如管道、套接字或实际的文件系统位置）访问。借助ALPC，Windows也能从这样的模型中获益，
并由ALPC暴露句柄属性。借助该属性，发送方可以将一个对象类型、与句柄复制方法有关的信息，以及该句柄在发送方句柄表中的索引进行编码。如果句柄索引
与发送方宣称发送的对象类型匹配，即可在系统（内核）句柄表中暂时创建复制的句柄。这部分操作保证了发送方真正发出了自己所宣称的内容，并且此刻发送方所
进行的任何操作都不会让句柄或对应的对象失效。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后，接收方请求暴露句柄
属性，并指定自己期望的对象类型。如果匹配，则内核句柄会被再次复制一次，这一次会复制为接收方句柄表中的用户模式句柄（随后内核中的副本会被关闭）。句
柄的传递就此结束，接收方可以保证有一个与发送方所引用对象完全相同的句柄，并且是接收方所期望的类型。此外，由于复制工作是由内核进行的，这意味着有特
权的服务器可以向无特权客户端发送消息，而无须客户端对发送消息的进程具备任何类型的访问权。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种句柄传递机制在最初实
现时，主要被Windows子系统（CSRSS）所使用，它需要获知现有Windows进程所创建的所有子进程，这样，当轮到自己执行时才能成功连接到
CSRSS，因为CSRSS已经获知了父进程的创建操作。然而，这会造成几个问题，例如无法发送超过一个的句柄（当然也无法发送超过一种类型的对象）。此
外，这种方式还会迫使接收方必须始终接收与端口上消息有关的所有句柄，而无法在一开始提前得知该消息是否有与之相关的句柄。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了解决这些问题，
Windows 
8和后续版本实现了一种间接的句柄传递机制，借此可发送不同类型的多个句柄，而接收方可以针对每个消息手动接收对应的句柄。如果有端口接收并启用这种间接
句柄（基于非RPC 
ALPC的服务器通常不使用间接句柄），当使用NtAlpcSendWaitReceivePort接收新消息时，句柄将不再根据传入的句柄属性自动复
制，此时ALPC客户端和服务器将手动查询特定消息包含多少个句柄，分配足够的数据结构以接收句柄值及其类型，随后再请求复制所有句柄，使用
NtAlpcQueryInformationMessage解析与所期待类型相符的句柄（关闭/丢弃非期待句柄），并最终传入收到的消息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种新行为还在安全性方面
带来了一个好处：句柄不再因为调用方指定了句柄属性和匹配的类型而立即自动复制，而是只有在针对每个消息发出请求时才会复制。因为服务器尽管可能期待消息
A的句柄，但并不一定期待其他所有消息的句柄，如果服务器在解析消息B或消息C时没有考虑到需要关闭这些句柄，那么依然可能遇到非直接句柄问题。如果使用
间接句柄，那么服务器将永远不会为此类消息调用NtAlpcQueryInformationMessage，句柄也永远不会被复制（或必须将其关闭）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">借助这些改进，ALPC句
柄传递机制的用途已经远远超出了上文列出的这几种有限的用例，并且还与RPC运行时与IDL编译器实现了集成。现在，我们已经可以使用
system_handle(sh_type)语法来代表RPC从客户端封送（Marshal）给服务器（反之亦然）的20多种不同的类型句柄。此外，如
上文所述，尽管ALPC从内核的角度提供了类型检查，RPC运行时本身也需要进行额外的类型检查，例如检查命名管道、套接字和实际的文件是否均为“文件对
象”（因此具备“文件”类型的句柄），例如，RPC运行时可通过封送和撤销封送检查进行检测，当IDL文件代表
system_handle(sh_pipe)时，是否传递了套接字句柄（通过调用GetFileAttribute、GetDeviceType等
API实现）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这项新功能被
AppContainer基础架构大量使用，也是各种代理（在执行完能力检查后）打开的句柄被WinRT 
API传送并复制回沙盒应用程序以供直接使用的主要句柄传送方式。DNS客户端也使用了该功能，借此可以填充GetAddrInfoEx 
API的ai_resolutionhandle字段。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_49" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>8</b><b>.</b><b>8</b><b> </b><b>安</b><b>全</b><b>性</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">为防止基于IPC常规解析
Bug发起的攻击，ALPC实现了多种安全机制、完整的安全边界，以及相关缓解措施。在基础层面上，ALPC端口对象将由负责管理对象安全性的同一个对象
管理器接口进行管理，借此可防止非特权应用程序通过ACL得到服务器端口句柄。在此基础上，ALPC提供了基于SID的信任模型，该模型继承自最初的
LPC设计，可供客户端凭借端口名称之外的其他因素验证自己所连接的服务器。客户端进程可通过安全端口向内核提交自己所期待连接的对端服务器进程SID。
在连接时，内核会验证该客户端是否真的连接到自己期待的服务器，借此缓解命名空间仿冒攻击（在这种攻击中，不可信的服务器会伪造真正服务器的端口）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ALPC还可让客户端与服
务器以符合原子性、唯一性的方式标识负责每条消息的线程和进程。它还能通过NtAlpcImpersonateClientThread 
API支持完整的Windows模拟（Impersonation）模型。其他API则使ALPC能查询与所有已连接客户端有关的SID，并查询客户端安
全令牌中的LUID（本地唯一标识符详见卷1第7章）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>A</b><b>L</b><b>P</b><b>C</b><b>端</b><b>口</b><b>所</b><b>有</b><b>权</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">端口所有权的概念对
ALPC非常重要，它为感兴趣的客户端和服务器提供了各种安全保证。首先最重要的是，仅ALPC连接端口的所有者可以接收该端口的连接。这确保了如果端口
句柄被以某种方式复制或继承给其他进程，其他进程也无法非法地接收传入连接。此外，在直接或间接使用句柄属性的情况下，无论当前由谁解析消息，句柄属性都
能始终在端口所有者进程的上下文中复制。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当内核组件与客户端使用ALPC通信时，这些检查必不可少，此时内核组件可能被附加至一个完全不同的进程（甚至作为System进程的一部分，使用系统线程运行，借此使用ALPC端口消息），获知端口的所有者，意味着ALPC不会错误地依赖当前进程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">然而反过来看，对内核组件
来说，不考虑当前进程是什么，在一个端口上任意接收传入连接，这种行为可能是有益的。一个明显的例子是：在使用执行体回调对象进行消息传送时。在这种情况
下，因为回调是一个或多个发送方进程上下文中的同步调用，而内核连接端口很可能是在System上下文（例如DriverEntry）中执行时创建的，那
么在接收该连接时，当前进程和端口所有者进程可能出现不匹配的情况。ALPC提供了一种只能由内核调用方使用的特殊端口属性标记，该标记使得连接端口成为
一种系统端口，此时将忽略对端口所有者的检查。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">端口所有权的另一个重要用例是：通过执行服务器SID验证来检查客户端是否发出了请求，详见上文“安全性”一节。该验证总是会通过检查连接端口所有者令牌的方式完成，此时并不考虑谁正在监听该端口的消息。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_50" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>8</b><b>.</b><b>9</b><b> </b><b>性</b><b>能</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">ALPC会通过多种策略改
善性能，主要用到了ALPC对完成列表的支持，这一点在上文已经简单介绍过。在内核层面上，完成列表在本质上是一种用户内存描述符列表（Memory 
Descriptor 
List，MDL），它会被探测并锁定，然后映射至某个地址（有关MDL的详情请参阅卷1第5章）。因为与负责跟踪物理页面的MDL相关联，当客户端向服
务器发送消息时，载荷复制操作可以直接发生在物理层面，而不需要像其他IPC机制的常见做法那样，要求内核对消息进行双重缓冲。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">完成列表本身是作为一个已
完成项的64位队列来实现的，用户模式和内核模式的使用者都可以使用互锁的“比较-交换”操作向队列中插入或移除项。此外，为了简化分配，一旦一个MDL
成功进行了初始化，将使用一个位图来识别可用的内存区域，这些区域可用来容纳依然在排队的新消息。该位图的算法还会使用处理器上的本地锁指令来提供物理内
存区域的原子性分配和撤销分配操作，这些操作可被完成列表使用。完成列表则可通过NtAlpcSetInformationPort设置。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后一个值得介绍的优化措
施是：内核不会在发送消息的时候复制数据，而是会设置延迟复制载荷，借此可在无须进行任何复制的情况下只捕获需要的信息。只有当接收方请求消息时才会真正
复制消息数据。很明显，如果使用了共享的内存，这种方法将无法提供任何优势，但在异步的内核缓冲区消息传递机制中，可以通过这种方法优化取消场景和高流量
场景。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_51" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>8</b><b>.</b><b>1</b><b>0</b><b> </b><b>电</b><b>源</b><b>管</b><b>理</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如上文提到的，在供电能力有限的环境（如移动平台）中运行时，Windows会通过多种技术更好地管理能耗和处理器可用性，例如，在支持的架构（如ARM64的big.LITTLE
	<sup><img width="11" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="即所谓的“大小核”：在一个“处理器”中同时配备多个“性能核（大核）”和“能效核（小核）”，并根据需求动态地选择适合的内核来运行。目前一些较新的处理器均采用了类似技术，如ARM64的big.LITTLE以及Intel的Performance Hybrid Architecture（性能混合架构）。——译者注" title="即所谓的“大小核”：在一个“处理器”中同时配备多个“性能核（大核）”和“能效核（小核）”，并根据需求动态地选择适合的内核来运行。目前一些较新的处理器均采用了类似技术，如ARM64的big.LITTLE以及Intel的Performance Hybrid Architecture（性能混合架构）。——译者注" class="epub-footnote"></sup>）上采用异构处理，以及通过新型待机等方式进一步降低系统在轻量级负载下的能耗。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了更好地支持这些机制，
ALPC额外实现了两个功能：ALPC客户端将唤醒引用（wake reference）推送至自己ALPC服务器唤醒通道的能力，以及Work On 
Behalf 
Of（代表xxx工作）这一新属性。后者是一个属性，当发送方需要将请求与当前工单关联在一起，或新建工单来描述发送消息的线程时，即可选择为消息关联该
属性。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种工单的用法如下：举例
来说，当发送方目前是作业对象的一部分（可能因为作业位于Silo/Windows容器中，或发送方是异构调度系统和新型待机系统的一部分）时，发送方与
线程的关联会导致系统多个部分将CPU周期、I/O请求数据包、磁盘/网络带宽的使用，以及能耗的估测值归因于“所代表”的线程，而非实际承担工作的线
程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，为避免big.LITTLE优先级倒置问题（出现这种问题时，RPC线程会仅仅因为自己是后台服务而被卡在小核心上），系统还会采取前台优先级捐赠和其他调度步骤。通过使用工单，线程会被强行调度至大核心，并获得一个“捐助”而来的前台提升。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后，还可以使用唤醒引用
来避免系统进入新型待机（也叫现代待机，详见卷1第6章）状态时，或者当UWP应用程序成为被挂起的目标时遭遇死锁。这些引用可将拥有ALPC端口的进程
寿命“固定起来”，以此防止进程生命周期管理器（或电源管理器，针对Win32应用程序）试图针对这些进程强制执行挂起/深度冻结操作。一旦消息传递并处
理完毕，唤醒引用即可被丢弃，这样，如果需要，就可以让进程挂起了（回想一下可知，终止进程不会造成问题，因为向已终止进程/已关闭端口发送消息，会通过
特殊的PORT_CLOSED回复立即唤醒发送方，而不会阻塞并等待一个永远不会到来的回应）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_52" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>8</b><b>.</b><b>1</b><b>1</b><b> </b><b>A</b><b>L</b><b>P</b><b>C</b><b>直</b><b>接</b><b>事</b><b>件</b><b>属</b><b>性</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">回顾一下，ALPC为客户
端和服务器的通信提供了两种机制：请求和数据报。其中，前者是双向的，需要得到响应；而后者是单向的，永远不会收到同步的回复。此时还需要一种“中间地
带”，即数据报类型的消息，它无法收到回复，但其接收方可以通过某种方式进行确认，这样发送方就会知道消息已成功执行，而无须实现复杂的响应处理机制。实
际上，直接事件属性（direct event attribute）恰恰提供了这样的功能。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通过让发送方将内核事件对
象的句柄（通过CreateEvent）与ALPC消息相关联，直接事件属性可以获得底层的KEVENT，并为其添加一个引用，借此将其附着在
KALPC_MESSAGE结构上。随后，当接收进程收到该消息后，即可暴露出这个直接事件属性，并导致进程收到信号。客户端可以使用一个与I/O完成端
口相关联的等待完成数据包（Wait Completion 
Packet），或者可以处于一个同步等待的调用中，例如事件句柄上的WaitForSingleObject，此时客户端将收到通知和等待满足信号，这
样即可得知消息已经成功交付。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">该功能以前是由RPC运行
时手动提供的，可以让调用RpcAsyncInitializeHandle的客户端传入RpcNotificationTypeEvent，并使用异步
RPC消息将HANDLE与事件对象关联在一起。但这并不需要强迫另一端的RPC在运行时响应所请求的消息，这样发送方的RPC运行时就可以在本地向事件
发出信号以示完成，ALPC则会将其放入直接事件属性，并将消息放置到直接消息队列，而不是常规消息队列中。ALPC子系统将在消息交付时发出信号，在内
核模式下这很有效，可避免额外的跳转和上下文切换。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_53" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>8</b><b>.</b><b>1</b><b>2</b><b> </b><b>调</b><b>试</b><b>和</b><b>跟</b><b>踪</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在已检验版本（checked build）
	<sup><img width="10" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="checked build是为了便于开发者进行调试等操作而通过MSDN订阅等渠道提供的一种“特殊版本”的Windows，与之对应的，我们日常使用的“普通版”Windows可称为free build。——译者注" title="checked build是为了便于开发者进行调试等操作而通过MSDN订阅等渠道提供的一种“特殊版本”的Windows，与之对应的，我们日常使用的“普通版”Windows可称为free build。——译者注" class="epub-footnote"></sup>的
内核中，ALPC消息可以记录到日志中。所有ALPC属性、Blob、消息区域（message 
zone）以及调度事务都可以分别记录，WinDbg中未公开的!alpc命令可以转储这些日志。在零售版系统中，IT管理员和排错人员可以启用NT内核
记录器的ALPC事件来监控ALPC消息。ETW（Event Tracing for 
Windows，Windows事件跟踪，详见第10章）不包含载荷数据，但包含连接、断开连接、发送/接收以及等待/解锁等信息。最后，即使在零售版系
统中，也可以通过某些!alpc命令获取有关ALPC端口和消息的信息。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>转</b><b>储</b><b>连</b><b>接</b><b>端</b><b>口</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在这个实验中，我们将为会话1（控制台用户的典型交互式会话）中运行的Windows进程使用CSRSS API端口。当Windows应用程序启动时，它都会连接到所在会话对应的CSRSS的API端口上。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">1）使用!object命令获得指向连接端口的指针：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; !object \Sessions\1\Windows\ApiPort </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Object: ffff898f172b2df0 Type: (ffff898f032f9da0) ALPC Port </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ObjectHeader: ffff898f172b2dc0 (new version) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    HandleCount: 1  PointerCount: 7898 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Directory Object: ffffc704b10d9ce0 Name: ApiPort </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">2）使用!alpc /p转储端口对象本身的信息，由此可确认一些情况，例如，CSRSS就是所有者：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; !alpc /P ffff898f172b2df0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Port ffff898f172b2df0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  Type                      : ALPC_CONNECTION_PORT </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  CommunicationInfo         : ffffc704adf5d410 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ConnectionPort          : ffff898f172b2df0 (ApiPort), Connections </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ClientCommunicationPort : 0000000000000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ServerCommunicationPort : 0000000000000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  OwnerProcess              : ffff898f17481140 (csrss.exe), Connections </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  SequenceNo                : 0x0023BE45 (2342469) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  CompletionPort            : 0000000000000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  CompletionList            : 0000000000000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  ConnectionPending         : No </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  ConnectionRefused         : No </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  Disconnected              : No </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  Closed                    : No </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  FlushOnClose              : Yes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  ReturnExtendedInfo        : No </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  Waitable                  : No </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  Security                  : Static </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  Wow64CompletionList       : No </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  5 thread(s) are waiting on the port: </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    THREAD ffff898f3353b080  Cid 0288.2538  Teb: 00000090bce88000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Win32Thread: ffff898f340cde60 WAIT </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    THREAD ffff898f313aa080  Cid 0288.19ac  Teb: 00000090bcf0e000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Win32Thread: ffff898f35584e40 WAIT </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    THREAD ffff898f191c3080  Cid 0288.060c  Teb: 00000090bcff1000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Win32Thread: ffff898f17c5f570 WAIT </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    THREAD ffff898f174130c0  Cid 0288.0298  Teb: 00000090bcfd7000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Win32Thread: ffff898f173f6ef0 WAIT </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    THREAD ffff898f1b5e2080  Cid 0288.0590  Teb: 00000090bcfe9000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Win32Thread: ffff898f173f82a0 WAIT </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    THREAD ffff898f3353b080  Cid 0288.2538  Teb: 00000090bce88000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Win32Thread: ffff898f340cde60 WAIT </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Main queue is empty. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Direct message queue is empty. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Large message queue is empty. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Pending queue is empty. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Canceled queue is empty. </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">3）
可以使用未公开的!alpc 
/lpc命令查看哪些客户端连接到了该端口，其中包含该会话中运行的所有Windows进程。或者也可以在新版WinDbg中直接点击ApiPort名称
旁边的Connections链接。此外，还可以看到与每个链接相关的服务器和客户端通信端口，以及任何队列中存在的任何未决消息：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; !alpc /lpc ffff898f082cbdf0 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ffff898f082cbdf0('ApiPort') 0, 131 connections </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">         ffff898f0b971940 0 -&gt;ffff898F0868a680 0 ffff898f17479080('wininit.exe')</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">         ffff898f1741fdd0 0 -&gt;ffff898f1742add0 0 ffff898f174ec240('services.exe')</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">         ffff898f1740cdd0 0 -&gt;ffff898f17417dd0 0 ffff898f174da200('lsass.exe')</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">         ffff898f08272900 0 -&gt;ffff898f08272dc0 0 ffff898f1753b400('svchost.exe')</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">         ffff898f08a702d0 0 -&gt;ffff898f084d5980 0 ffff898f1753e3c0('svchost.exe') </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">         ffff898f081a3dc0 0 -&gt;ffff898f08a70070 0 ffff898f175402c0('fontdrvhost.ex')</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">         ffff898F086dcde0 0 -&gt;ffff898f17502de0 0 ffff898f17588440('svchost.exe') </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">         ffff898f1757abe0 0 -&gt;ffff898f1757b980 0 ffff898f17c1a400('svchost.exe') </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">4）请注意，如果运行了其他会话，则可以在这些会话中重复上述实验（甚至在系统会话，即会话0中进行）。最终即可得到计算机中运行的所有Windows进程的列表。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter08_0009.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_54" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>9</b><b> </b><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>通</b><b>知</b><b>设</b><b>施</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows通知设施
（Windows Notification Facility，WNF）是一种无须注册的现代化发布/订阅机制的核心支撑，最早于Windows 
8中引入，主要是为了解决系统架构方面的一些缺陷问题，例如，向感兴趣的各方通知某些操作、事件或状态的存在，并提供与这些状态变化有关的数据载荷。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了说明其具体用途，请考
虑这样的情况：服务A想要通知潜在客户端B、C和D，告诉它们磁盘已经过扫描可安全地执行写操作，同时告知扫描过程中发现的损坏扇区数量（如果有的话）。
但因为无法保证客户端B、C和D会在服务A之后启动，实际上，它们有很大概率先于服务A启动。这种情况下，如果它们继续执行，就将成为一种不安全的做法，
正确的做法是等待服务A执行并报告磁盘已经可以安全地进行写操作。但如果服务A尚未运行呢？其他方又该如何从一开始就进行等待？</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">一种典型的解决方案是让B
创建一个CAN_I_WAIT_FOR_A_YET事件，然后让A在启动后查找该事件，创建一个A_SAYS_DISK_IS_SAFE事件并发送
CAN_I_WAIT_FOR_A_YET信号，这样B就知道已经可以安全地等待A_SAYS_DISK_IS_SAFE了。在只有一个客户端的情况下这
是一种可行的做法，但如果还要同时考虑C和D，情况就变得更复杂，因为它们可能需要经历相同的逻辑，并可能在CAN_I_WAIT_FOR_A_YET事
件的创建方面展开竞争，进而打开现有事件（本例中该事件由B创建）并等待该事件收到的信号。虽然这也可以做到，但如何保证该事件真的是由B创建的呢？这就
造成一种围绕名称所进行的恶意“仿冒”以及以此为基础导致的拒绝服务攻击。最终，我们可以设计一种安全的协议，但这需要A、B、C和D的开发者做大量复杂
的工作。如果还要同时考虑坏扇区数量这件事，情况还将变得更复杂。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_55" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>9</b><b>.</b><b>1</b><b> </b><b>W</b><b>N</b><b>F</b><b>功</b><b>能</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">上述场景是操作系统设计中一个很常见的问题，而该问题显然不应交由单独的开发者来处理。操作系统的部分工作正是为这种与架构有关的常见挑战提供简单、可扩展、高性能的解决方案，现代Windows平台中的WNF正是以此为目标诞生的，它提供了：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·定义状态名称的能力，该状态名称可订阅或发布给任意线程，这一点可由标准的Windows安全描述符（通过DACL和SACL）来保证。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·将此类状态名称与最多4KB载荷关联在一起的能力，该载荷能够与所订阅状态发生的变化一起检测到（并能将变化一起发布出去）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·拥有众所周知的状态名称的能力，这些名称由操作系统提供，无须由发布者创建，并可能与使用者产生竞争，这样，即使发布者尚未启动，使用者也可以对状态变化通知进行阻塞。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·在系统重启后持久保存状态数据的能力，这样，使用者即可看到之前发布的数据，哪怕自己当时尚未启动。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·为每个状态名称分配状态变化时间戳的能力，这样，即使系统重启动，使用者无须激活也可以知道新数据是否在某个时间点发布（以及是否需要针对之前发布的数据采取行动）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·为特定状态名称分配范围的能力，这样，同一个状态名称的多个实例即可存在于一个交互式会话ID、一个服务器Silo（容器）、特定用户令牌/SID，甚至一个单独的进程中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·在跨越内核/用户边界的同时，执行与WNF状态名称有关的所有发布和使用工作的能力，这样组件就可以与另一端的其他组件进行交互。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_56" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>9</b><b>.</b><b>2</b><b> </b><b>W</b><b>N</b><b>F</b><b>用</b><b>户</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">可想而知，通过提供所有这些丰富的语义，各类服务与内核组件能够利用WNF向数百个客户端提供通知以及其他状态变化信号（该做法可以细化，从不同系统库中的每个API到更大规模的进程均可支持）。实际上，一些关键的系统组件和基础架构已经在使用WNF了，例如：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·电源管理器和各种相关组件会使用WNF为某些操作发送信号，如笔记本电脑上盖的关闭和打开、电池充电状态、显示器关闭和开启、用户存在检测等。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·外壳（Shell）及其组件会使用WNF跟踪应用程序启动、用户活动、锁屏行为、任务栏行为、Cortana的使用，以及开始菜单行为。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·系统事件代理（System Events Broker，SEB）是一种完整的基础架构，UWP应用程序和代理会利用它接收有关系统事件的通知，例如音频输入和输出。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·进程管理器会使用每进程临时WNF状态名称来实现唤醒通道，进程生命周期管理器会使用该通道实现自己的部分机制，让某些事件能强制唤醒被标记为暂停（深度冻结）的进程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">WNF的所有用户可能需要
一整本书才能完整列举，因为除了各种临时名称（例如每处理器唤醒通道），目前使用的各种众所周知的状态名称已经超过6000种。不过下文的实验介绍了如何
使用本书随附工具中包含的wnfdump实用工具列举系统的所有WNF事件及其数据，并与其进行交互。Windows调试工具还提供了!wnf扩展，我们
会在后续实验中介绍如何通过该扩展实现相同的目的。同时，表8-31列出了一些重要的WNF状态名称前缀及其用途。我们会在Windows的各种SKU版
本中遇到大量Windows组件和代号（从Windows Phone到Xbox），这也体现了WNF机制的丰富性和普遍性。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-31 WNF状态名称前缀</span></p><div style="display: block;text-align:center;">
	<img width="620" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3b6f805f10d2a1af79d9b399b32758a1.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="617" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/132b99cd9c225fbc85002454c00ae15f.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="617" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b1c54e17b32dd5885147172de8e47676.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="618" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/f0763043d667b1cbf9eae995eaea5c26.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="618" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/7e46463dfc5f918b8d3b0f3240498341.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="620" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/bb09b012c4727473ad9b9f255e9fff0d.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="617" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/442de6df7f4ecc396bcb8bc195601682.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="613" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/2b471e6e220d91ef139bc04bb55632be.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="621" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/135f891ebe61789308f6581b46b77689.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="615" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4171339f42797518d8b34d8e2aa45119.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="616" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/acdc8180deef2e620bbecbc3c713c2ec.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="619" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a2e04f44ee8bc621295ea089bb314510.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="617" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/fd53f92371a4547480aedfbafd139b28.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="616" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/042019c3fae680fcc12fcd6029e407f3.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="616" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3d45d60ff91667353e4c220bf9798546.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="617" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/bc9e08470f83374c0ed9824dac52cd4d.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="615" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/56506406e301316fa34dc5b7bfe6f0bb.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="615" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/6f38f586fad7712c61b4e82c35e1bda3.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="613" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/501f1d5129479bcec1e231985ed374fd.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="616" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b6837c6a6a6b7e95b72799e5816d70bd.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="616" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/8c3514660f83c4f2b4facb0394f92d31.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="621" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e0eb80efa3f12e858a3f96eea401de48.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="619" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3f76d0e0a76ba995525566162dc1da4d.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="619" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/6fcb87050f588af0dd88a5a996720620.jpg" alt="" title=""></div>
</div><div class="header2"><h3><span id="sigil_toc_id_57" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>9</b><b>.</b><b>3</b><b> </b><b>W</b><b>N</b><b>F</b><b>状</b><b>态</b><b>名</b><b>称</b><b>和</b><b>存</b><b>储</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">WNF状态名称用看起来像
是随机的64位标识符来表示，例如0xAC41491908517835，然后使用C预处理器宏（如WNF_AUDC_CAPTURE_ACTIVE）来
定义一个友好名称。然而实际上，这些数字会用于对版本号（1）、寿命（持久和临时）、范围（进程实例、容器实例、用户实例、会话实例、计算机实例）、永久
数据标记进行编码，而对于众所周知的状态名称，还会通过一个前缀代表状态名称的所有者，后跟唯一序列号。图8-41展示了这种格式。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/7b9dbd7e0dac38835f6e1508d77bb4e6.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-41 WNF状态名称的格式</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如上文所述，状态名称可
能是众所周知的，这意味着它们可以被预先配置，以便能够以任意顺序使用。为了实现这一点，WNF会使用注册表作为支撑该功能的存储，将安全描述符、最大数
据大小、类型ID（如果有的话）编码后存储在注册表
HKLM\SYSTEM\CurrentControlSet\Control\Notifications键下。对于每个状态名称，这些信息会被存储在
一个与64位编码的WNF状态名称标识符相匹配的值中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，WNF状态名称还可
注册为持久（persistent）名称，这意味着无论注册方进程的寿命如何，在系统持续运行过程中，这些名称都会始终保持为已注册状态。这种做法类似
于“对象管理器”一节所介绍的持久对象，同样，注册这种状态名称需要SeCreatePermanentPrivilege权限。此类WNF状态名称同样
存在于注册表中，不过会保存在注册表HKLM\SOFTWARE\Microsoft\Windows 
NT\CurrentVersion\VolatileNotifications键下，并会充分利用注册表的易失（volatile）标记
	<sup><img width="11" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="应用了“易失标记”的注册表键不会保存在注册表数据库中，只位于内存中，因此，当系统重启动后，这些键会直接丢失。——译者注" title="应用了“易失标记”的注册表键不会保存在注册表数据库中，只位于内存中，因此，当系统重启动后，这些键会直接丢失。——译者注" class="epub-footnote"></sup>功
能，在系统重启动后直接消失。使用“易失的”注册表键来保存“持久的”WNF数据，这一点可能让人有些疑惑。不过要注意，如上文所述，这里所谓的“持
久”是指系统启动完毕后，下次启动之前这段时间内的“持久”（而非与进程寿命直接关联，因此WNF将其称为“临时的”，下文将详细介绍这个问题）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，WNF状态名称也可
以注册为永久（permanent）名称，这样的状态名称在系统重启动后依然存在。而这可能也是很多人期待的“持久”类型。这是通过另一个注册表键实现
的，只不过此时没有使用易失标记，会被保存在注册表HKLM\SOFTWARE\Microsoft\Windows 
NT\CurrentVersion\Notifications键下。这种程度的持久性同样需要具备
SeCreatePermanentPrivilege权限。对于这些类型的WNF状态，在注册表层级中还有一个额外的、名为Data的注册表键，对于每
个64位编码的WNF状态名称，其中包含标识符、最后更改时间戳以及二进制数据。请注意，如果计算机上从未写入过WNF状态名称，那么后面这些信息可能会
缺失。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>注</b><b>册</b><b>表</b><b>中</b><b>的</b><b>W</b><b>N</b><b>F</b><b>状</b><b>态</b><b>名</b><b>称</b><b>和</b><b>数</b><b>据</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在这个实验中，我们将使用注册表编辑器查看众所周知的WNF状态名称，以及一些永久和持久的名称范例。通过查看注册表的原始二进制数据，还可看到数据和安全描述符信息。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">打开注册表编辑器并转向HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Notifications键。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">查看这里列出的数值，应该能看到类似下图所示的界面。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/15795b10578c921c5bfa9f99fb1cb305.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">双
击名为41950C3EA3BC0875的值（WNF_SBS_UPDATE_AVAILABLE），随后会打开原始注册表数据二进制编辑器。注意下图所
示内容，在这里可以看到安全描述符（选中的二进制数据，其中包含SID S-1-5-18）以及最大数据大小（0字节）。</span></p><div style="display: block;text-align:center;">
	<img width="875" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/0737d142ebd9a088a315d90c891c5df3.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请注意，不要修改这里看到的任何值，随意修改可能导致系统无法运行或易于受到攻击。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">最
后，如果想要查看永久的WNF状态名称，可以使用注册表编辑器打开
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows 
NT\CurrentVersion\Notifications\Data键，并查看418B1D29A3BC0C75这个值
（WNF_DSM_DSMAPPINSTALLED）。如下图所示，在这里可以看到该系统中最后安装的应用程序
（MicrosoftWindows.UndockedDevKit）。</span></p><div style="display: block;text-align:center;">
	<img width="823" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/7a89a0e934808b769e6311d8defc5d5f.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">完全任意的状态名称也可以
注册为临时名称。此类名称与上文介绍的名称有些区别。首先，因为其名称事先是未知的，因此需要名称的使用方和生成方能通过某种方式相互传递标识符。一般来
说，无论谁先试图使用或创建这样的状态数据，最终都会在内部创建并/或使用匹配的注册表键存储相关数据。然而，对于临时的WNF状态名称，这一点是无法实
现的，因为名称将完全基于单调递增的序列号。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">其次还要注意这样一种情况：无法使用注册表键对临时的状态名称进行编码，这种名称会与注册特定状态名称实例的进程所绑定，所有数据仅存储在内核池中。例如，此类名称可用于实现上文提到的每个进程的唤醒通道。其他用途包括电源管理器通知，以及由SCM使用的直接服务触发器。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>W</b><b>N</b><b>F</b><b>的</b><b>发</b><b>布</b><b>和</b><b>订</b><b>阅</b><b>模</b><b>型</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当发布方使用WNF时，需
要遵循一种标准化的模式来注册状态名称（如果是非众所周知的名称）并发布自己想要暴露的数据。此外，发布方也可以选择不发布任何数据，而是直接提供一个0
字节缓冲区，这样即可作为一种“点亮”状态的方式向订阅方发送信号，哪怕此时并未存储任何数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">另一端的使用方会使用
WNF的注册功能将回调与特定WNF状态名称关联在一起。每当发布了变更后，就会激活该回调。对于内核模式，调用方需要调用适当的WNF 
API以接收与该状态名称相关的数据（会提供一定大小的缓冲区，这样调用方就可以在需要时分配内存池，或者选择使用栈）。对于用户模式，该
Ntdll.dll内部的底层WNF负责分配一个由堆支撑的缓冲区，并直接向订阅方所注册的回调提供一个指向该数据的指针。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在上述两种情况下，回调提
供了变更戳，它作为一个具备唯一性的单调序列号，可用于检测缺失的已发布数据（如果订阅方因为某些原因不再活跃，而发布方还在继续发生变化，就会出现这种
情况）。此外，该回调还可以关联一个自定义的上下文，这在C++的情况下非常有用，可将静态函数指针与它的类关联起来。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
WNF提供了一个API，可用于查询特定WNF状态名称是否已被注册（借此，使用方就可以在检测到发布方尚未激活时实现特殊的逻辑），同时还提供了一个用
于查询特定状态名称当前是否有任何活跃订阅的API（借此，发布方即可实现一些特殊逻辑，例如延迟额外数据的发布，因为这可能会覆盖之前发布的状态数
据）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">WNF可能需要管理数千个
订阅，为此它会为每个内核或用户模式的订阅关联一种数据结构，并将同一个WNF状态名称的所有订阅绑定在一起。这样，在发布了一个状态名称后，即可解析订
阅列表，随后用户模式会将一个交付载荷添加到一个链表中，并向每个进程的通知事件发出信号。这样Ntdll.dll中的WNF交付代码即可调用API以使
用该载荷（以及同时添加到列表中的任何其他额外的交付载荷）。对于内核模式，相关机制会简单一些：直接在发布方的上下文中以同步的方式执行回调。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">请注意，我们可以通过两种
模式订阅通知：数据（Data）通知模式和元（Meta）通知模式。前者会执行大部分人所期待的操作，当新数据被关联给WNF状态名称后执行回调；后者则
更有趣一些，因为当新的使用方变得活跃或不活跃，以及当发布方被终止（易失状态名会存在此类概念）时，它会发出通知。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">还要注意，用户模式订阅会
产生一个额外的问题：因为Ntdll.dll管理着整个进程的WNF通知，因此多个组件（例如动态链接库/DLL）可能会对同一个WNF状态名称请求自己
的回调（但会出于不同原因并使用不同的上下文）。这种情况下，Ntdll.dll库需要将注册上下文与每个模块关联起来，这样每个进程的交付载荷才能被转
换为正确的回调，并且仅在所请求的交付模式与订阅方的通知类型相符时才进行交付。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>使</b><b>用</b><b>W</b><b>n</b><b>f</b><b>D</b><b>u</b><b>m</b><b>p</b><b>实</b><b>用</b><b>工</b><b>具</b><b>转</b><b>储</b><b>W</b><b>N</b><b>F</b><b>状</b><b>态</b><b>名</b><b>称</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在这个实验中，我们将使用本书随附工具（WnfDump）向WNF_SHEL_DESKTOP_APPLICATION_STARTED状态名称和WNF_AUDC_RENDER状态名称注册WNF订阅。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请在命令提示符下使用下列标记执行wnfdump：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> -i WNF_SHEL_DESKTOP_APPLICATION_STARTED -v </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">该工具会显示状态名称信息并读取其数据，并产生类似这样的输出结果：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;wnfdump.exe -i WNF_SHEL_DESKTOP_APPLICATION_STARTED -v </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">WNF State Name                                  | S | L | P | AC | N | CurSize | MaxSize</span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">WNF_SHEL_DESKTOP_APPLICATION_STARTED            | S | W | N | RW | I |      28 |     512</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">65 00 3A 00 6E 00 6F 00-74 00 65 00 70 00 61 00 e.:.n.o.t.e.p.a. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">64 00 2E 00 65 00 78 00-65 00 00 00             d...e.x.e... </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">由
于该事件与启动桌面应用程序的Explorer（“外壳”）相关联，所以可以看到自己通过双击、开始菜单或运行菜单等方式所启动的最后几个应用程序之一
（通常是ShellExecute 
API用到的应用程序）。输出结果中还显示了变更戳，这是一个计数器，借此可以知道自当前Windows实例启动以来（因为这是一个持久事件，而非永久事
件），通过这种方式启动的桌面应用程序数量。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">使用开始菜单启动另一个新的桌面应用程序（例如“画图”），尝试再次执行wnfdump命令。随后可以看到变更戳的数值增加了，并且输出结果会包含新的二进制数据。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_58" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>9</b><b>.</b><b>4</b><b> </b><b>W</b><b>N</b><b>F</b><b>事</b><b>件</b><b>聚</b><b>合</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">尽管WNF本身已经为客户端和服务提供了一种交换状态信息并将状态通知给对方的强大方法，但一些情况下特定客户端/订阅方可能会对不止一个WNF状态名称感兴趣。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">例如，可能有一个WNF状态名称会在屏幕背光关闭后发布，另一个则会在无线网卡被关闭后发布，还有一个会在用户离开设备后发布。可能会有一个订阅方希望在上述任何一个WNF状态名称发布之后收到通知，但另一个订阅方可能希望前两个或最后一个名称发布之后收到通知。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">然而，Ntdll.dll提供给用户模式客户端的WNF系统调用和基础架构（以及内核所提供的API表面）只能针对单个WNF状态名称执行操作。因此，上述例子需要通过每个订阅方自行实现的状态机手动处理。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了向这种常见需求提供方
便，用户模式以及内核模式都有一个组件可以处理此类状态机的复杂性，并暴露出一个简单的API：Common Event 
Aggregator（CEA，通用事件聚合器），内核模式调用方是在CEA.SYS中实现的，用户模式调用方则是在
EventAggregation.dll中实现的。这些库可导出一组API（例如EaCreateAggregatedEvent和
EaSignalAggregatedEvent），借此实现中断那样的行为（WNF状态为True时启动回调，WNF状态为False时停止回调），并
能使用诸如AND、OR和NOT等运算符对条件进行组合。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">CEA的用户包括USB栈
以及Windows Driver Foundation（WDF），它为WNF状态名称的变化暴露了一种框架回调。此外，Power Delivery
 Coordinator（Pdc.sys）也会使用CEA构建类似本节开头提到的那种电源状态机。第9章将要介绍的统一后台进程管理器（Unified
 Background Process Manager，UBPM）也依赖CEA来实现一些功能，例如，根据低功耗或闲置等情况启动和停止服务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">WNF还是系统事件代理
（System Event 
Broker，SEB）服务的组成部分，该服务在SystemEventsBroker.dll中实现，其客户端库位于
SystemEventsBrokerClient.dll中。后者可导出诸如SebRegisterPrivateEvent、
SebQueryEventData以及SebSignalEvent等API，随后这些API可通过RPC接口传递给服务。在用户模式下，SEB是通用
Windows平台（Universal Windows 
Platform，UWP）、用于问询系统状态的各类API，以及根据WNF暴露的某些状态的变化自我触发的服务必不可少的基础。特别是在OneCore
衍生的各类系统，例如Windows 
Phone和Xbox（上文曾经提到，系统本身就用到了数百个众所周知的WNF状态名称）中，SEB已成为系统通知功能的核心驱动力，取代了窗口管理器
（window 
manager）通过诸如WM_DEVICEARRIVAL、WM_SESSIONENDCHANGE、WM_POWER等消息提供的遗留角色。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SEB可通过管道进入
UWP应用程序所使用的代理基础架构（Broker 
Infrastructure，BI），可供应用程序（即使运行在AppContainer中）访问映射至全系统状态的WNF事件。此外，对于WinRT
应用程序，Windows.ApplicationModel.Background命名空间暴露了一个SystemTrigger类，进而实现了
IBackgroundTrigger，借此可通过管道进入SEB的RPC服务和C++ 
API，对于某些众所周知的系统事件，最终还可转换为WNF_SEB_XXX这样的事件状态名称。这是一个非常完美的例子，证明了像WNF这样很少有公开
文档介绍的内部机制，最终也可以成为现代UWP应用程序开发过程中公开的高级API的核心。SEB只是UWP暴露的众多代理之一，本章末尾还将详细介绍后
台任务和代理基础架构。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter08_0010.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_59" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>1</b><b>0</b><b> </b><b>用</b><b>户</b><b>模</b><b>式</b><b>调</b><b>试</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统对用户模式调试的支持
工作可分为三个模块。第一个模块位于执行体中，使用Dbgk（代表调试框架，Debugging 
Framework）作为前缀。它为调试事件的注册和侦听提供了必要的内部函数，负责管理调试对象，并可将信息打包来供用户模式的对应部分直接使用。能与
Dbgk直接通信的用户模式组件位于原生系统库Ntdll.dll中，属于一组名称以DbgUi为前缀的API。这些API负责（以不透明方式）包装底层
调试对象的实现，通过将子系统应用程序围绕DbgUi实现对API进行包装，即可让所有子系统应用程序能够进行调试。最后，用户模式调试的第三个组件属于
子系统DLL，这是每个子系统为了对其他应用程序进行调试所暴露的公开的API（位于Windows子系统的KernelBase. dll中）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_60" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>1</b><b>0</b><b>.</b><b>1</b><b> </b><b>内</b><b>核</b><b>支</b><b>持</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">内核通过上文提到的调试对
象为用户模式的调试提供了支持。调试对象提供了一系列系统调用，其中大部分可直接映射至Windows调试API，而这些API通常可先通过DbgUi层
访问。调试对象本身的构造极为简单，包含一系列用于决定状态的标记、一个向任何等待方通知调试器事件已存在的事件、一个由等待处理的调试事件组成的双链
表，以及一个用于锁定对象的快速互斥。内核只需要这些信息即可成功地接收并发送调试器事件，而每个被调试进程都在自己的执行体进程结构中包含一个指向该调
试对象的调试端口号。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">一旦进程获得相关的调试端口，表8-32所列出的事件即可导致调试事件被插入事件列表中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-32 内核模式调试事件</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4b9a3029544347649bd842ca5a006e13.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了表8-32中提到的原
因，在调试器对象首次与进程建立关联后，除了上述常规情况外，还可能触发几种特殊情况。在连接调试器后，第一个Create 
process和Create thread消息将以手动方式发送，首先针对进程本身及其主线程发送；然后为进程中所有的其他线程发送Create 
thread消息；最后为被调试的可执行文件发送Load 
DLL事件，可从Ntdll.dll开始发送，再为被调试进程当前加载的每个DLL发送。类似地，如果调试器已经连接，但创建了克隆的进程（分叉），那么
还会为克隆进程中的第一个线程发送相同的事件（因为克隆的地址空间中不仅包含Ntdll.dll，也包含其他已加载的DLL）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，还可以为线程设置一
个特殊标记，该标记名为Hide from 
debugger（对调试器隐藏），可在线程创建时设置或动态地设置。开启该标记后，会导致TEB中的HideFromDebugger标记被设置，随后
即使连接了调试端口，当前线程执行的所有操作也不会引发调试器消息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">一旦调试器对象与进程相关
联，该进程就会进入深度冻结状态，这同样适用于UWP应用程序。需要注意的是，这会让所有线程暂停运行，并阻止创建任何新的远程线程。在这一点上，调试器
的责任是开始请求将调试事件发送过来。调试器通常会针对调试对象执行等待，借此请求将调试事件发送回用户模式。这样即可让该调用在调试事件列表中循环进
行。随着每个请求从列表中移除，其内容会从内部DBGK结构转换为下一层可以理解的原生结构。这种结构也不同于Win32结构，因此还需要进行另一层转
换。即使所有挂起的调试信息被调试器处理完毕后，内核也不会自动恢复进程的运行。此时需要由调试器负责调用ContinueDebugEvent函数以恢
复执行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了对某些多线程问题进行复杂处理外，该框架的基本模型其实非常简单：生成方+使用方，其中生成方会通过内核中的代码生成表8-32中所列出的调试事件，而使用方则是等待这些事件并在收到事件后加以确认的调试器。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_61" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>1</b><b>0</b><b>.</b><b>2</b><b> </b><b>原</b><b>生</b><b>支</b><b>持</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然用户模式调试的基本协
议非常简单，但并不能直接被Windows应用程序使用，而是需要由Ntdll.dll中的DbgUi函数包装起来。这种抽象是必要的，这样才能让原生应
用程序以及不同的子系统使用这些例程（因为Ntdll.dll中的代码没有依赖性）。该组件提供的大部分函数类似于Windows 
API函数以及相关系统调用。在内部，这些代码还提供了创建与线程相关联的调试对象所需的功能。所创建的调试对象的句柄永远不会被暴露，而是会存储在执行
连接操作的调试器线程的线程环境块（TEB）中（有关TEB的详情请参阅卷1第4章）。这个值会被保存在DbgSsReserved[1]字段中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在调试器连接到一个进程
后，会期待该进程被中断，也就是说，应该由注入该进程的线程引发int 
3（断点）操作。如果没有发生该操作，调试器将永远无法真正控制该进程，而只能看到调试器事件一闪而过。Ntdll.dll负责创建线程并将其注入目标进
程。请注意，该线程在创建时使用了一个特殊标记，内核会在TEB上设置该标记，进而导致SkipThreadAttach标记被设置，这避免了
DLL_THREAD_ATTACH通知以及TLS槽的使用，因为被避免的这两种情况会导致调试器每次中断进程时产生不必要的副作用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Ntdll.dll还提供了一些API，借此可将调试器事件的原生结构转换为Windows API所能理解的结构。这是通过表8-33中列出的转换来完成的。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表8-33 从原生到Win32的转换</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/5741c533df9d5eaa694ea1e931157084.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>调</b><b>试</b><b>器</b><b>对</b><b>象</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">虽然我们一直使用WinDbg进行内核模式调试，但其实也可以用它调试用户模式的程序。请试着通过下列步骤启动Notepad.exe并连接调试器：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">1）运行WinDbg，随后点击File→Open Executable。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">2）打开\Windows\System32\目录并选择Notepad.exe。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">3）因为我们无须真正进行调试，因此可忽略随后出现的所有提示信息。接着在命令行窗口中输入g即可让WinDbg继续执行记事本。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">运
行Process Explorer，确定已经启用了底部窗格，并将其配置为显示打开的句柄（选择View→Lower Pane 
View，随后选择Handles）。我们还需要查看未命名句柄，因此请选择View→Show Unnamed Handles And 
Mappings。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">点击Windbg.exe（如果使用WinDbg Preview，则点击EngHost.exe）进程，并查看句柄表。在这里应该可以看到一个指向调试器对象的打开的未命名句柄（按照Type排列表格可以更轻松地找到该句柄），类似下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/f9b9b7ccdb22b42444241141a1fcff7a.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">试着右键点击该句柄并将其关闭。记事本窗口会消失，WinDbg中会显示如下信息：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ERROR: WaitForEvent failed, NTSTATUS 0xC0000354 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">This usually indicates that the debuggee has been </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">killed out from underneath the debugger. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">You can use .tlist to see if the debuggee still exists. </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">实
际上，如果查看给出的NTSTATUS代码描述，就会找到类似“An attempt to do an operation on a debug 
port failed because the port is in the process of being 
deleted”（针对调试端口执行操作的企图失败了，因为该端口正在被删除）这样的文字，而这恰恰是我们关闭句柄所做的事情。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上所示，原生DbgUi接口除了抽象本身，并未对该框架提供其他支持。它所做的最复杂的工作就是原生和Win32调试器结构之间的转换。该转换涉及对结构进行的一些额外改变。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_62" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>1</b><b>0</b><b>.</b><b>3</b><b> </b><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>子</b><b>系</b><b>统</b><b>支</b><b>持</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">负责让诸如
Microsoft Visual 
Studio或WinDbg对用户模式应用程序进行调试的最后一个组件位于KernelBase.dll中，它提供了文档化的Windows 
API。除了将一个函数名转换为另一个函数名这种琐碎的工作外，调试基础架构中的这部分内容还负责另一个重要的管理工作：管理重复的文件和线程句柄。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上文曾经提过，每次发送
Load DLL事件时，内核都会复制一个映像文件的句柄并在事件结构中传递，这有些类似于Create 
process事件中对进程可执行文件句柄执行的操作。在每个等待调用中，KernelBase.dll会检查该事件是否会导致从内核复制一个新的进程或
线程句柄（两个Create事件）。如果会，则KernelBase.dll将分配一个结构用于存储进程ID、线程ID以及该事件关联的线程或进程句柄。
这个结构会被链接到TEB中的第一个DbgSsReserved数组索引。上文曾经提过，调试对象句柄也会存储在这里。同样，
KernelBase.dll还会检查退出事件。在检测到此类事件后，它会在数据结构中为句柄添加“标记”。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">一旦调试器用完句柄并执行Continue调用，KernelBase.dll会解析这些结构，查找任何已退出线程对应的句柄，并为调试器关闭这些句柄。否则，这些线程和进程将永远无法退出，因为只要调试器还在运行，就始终存在指向它们并且被打开的句柄。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter08_0011.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_63" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>1</b><b>1</b><b> </b><b>打</b><b>包</b><b>的</b><b>应</b><b>用</b><b>程</b><b>序</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">从Windows 
8开始，系统需要一些能在不同类型设备（例如手机、Xbox以及成熟的个人计算机）上运行的API。Windows也真正开始为这些全新的设备类型而设
计，这些设备使用了不同的平台和CPU架构（例如ARM）。而Windows 8还首次引入了一种全新的、与具体平台无关的应用程序架构：Windows
 
Runtime（也叫WinRT）。WinRT支持使用C++、JavaScript以及托管语言（C#、VB.NET等）进行开发，基于COM，可同时
为x86、AMD64以及ARM处理器提供原生支持。后来WinRT演变为通用Windows平台（Universal Windows 
Platform，UWP）。UWP在设计上克服了WinRT的一些困难，但也是在WinRT基础上构建的。UWP应用程序无须在清单中指定自己是为哪个
版本的操作系统开发的，而是能够以一个或多个设备家族为目标进行开发的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">UWP提供了保证所有设备
家族中均可用的Universal Device Family API（通用设备家族API），以及面向特定设备的Extension 
API（扩展API）。开发者能够以一种设备类型为目标，并在清单中添加扩展SDK，此外也可以在运行时有条件地测试API是否存在，并酌情调整应用程序
的行为。通过这种方式，如果有在智能手机上运行的UWP应用，在将手机连接到桌面计算机或适合的手机扩展坞后，该应用就可以表现出类似于直接在计算机上运
行时那样的行为。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">UWP为应用提供了多种服务。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·自适应控制和输入：图形元素可调整自己的布局和比例，以适应不同的大小和DPI的屏幕。此外，输入处理被抽象到底层应用中，这意味着UWP应用可以在不同的屏幕以及不同输入方式（如触控、触笔、鼠标、键盘或Xbox游戏手柄）的设备上良好运行。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·为每个UWP应用提供一个集中的商店，进而提供无缝的应用安装、卸载和升级体验。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·名为Fluent的统一设计系统（已集成在Visual Studio中）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一种名为AppContainer的沙盒环境。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">AppContainer最初是为WinRT设计的，UWP应用程序同样在使用。我们曾在卷1第7章介绍过有关AppContainer安全性的相关内容。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了正确地执行并管理
UWP应用程序，Windows内建了一种全新的应用程序模型，内部将其称为AppModel，代表现代应用程序模型（modern 
application model）。现代应用程序模型不断演化，在操作系统每次版本更新时已经经历了多次变化。本书将分析Windows 
10的现代应用程序模型。这种新模型包含多个组件，不同的组件相互配合，以能源效率更高的方式正确地管理着打包应用程序及其后台活动。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>主</b><b>机</b><b>活</b><b>动</b><b>管</b><b>理</b><b>器</b><b>（</b><b>H</b><b>o</b><b>s</b><b>t</b><b> </b><b>A</b><b>c</b><b>t</b><b>i</b><b>v</b><b>i</b><b>t</b><b>y</b><b> </b><b>M</b><b>a</b><b>n</b><b>a</b><b>g</b><b>e</b><b>r</b><b>，</b><b>H</b><b>A</b><b>M</b><b>）</b><b>：</b></span>主
机活动管理器是Windows 
10引入的新组件，取代并集成了控制UWP应用程序生命（及其状态）的很多老组件（进程生命周期管理器、前台管理器、资源策略、资源管理器）。主机活动管
理器位于后台任务基础架构服务（BrokerInfrastructure）中，但它与后台代理基础架构（Background Broker 
Infrastructure）组件并不是同一个概念。主机活动管理器的工作与进程状态管理器密切相关，它由两个库实现，这两个库分别代表客户端
（Rmclient.dll）和服务器（PsmServiceExtHost.dll）接口。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>进</b><b>程</b><b>状</b><b>态</b><b>管</b><b>理</b><b>器</b><b>（</b><b>P</b><b>r</b><b>o</b><b>c</b><b>e</b><b>s</b><b>s</b><b> </b><b>S</b><b>t</b><b>a</b><b>t</b><b>e</b><b> </b><b>M</b><b>a</b><b>n</b><b>a</b><b>g</b><b>e</b><b>r</b><b>，</b><b>P</b><b>S</b><b>M</b><b>）</b><b>：</b></span>PSM
已被HAM部分取代，并被认为是HAM的一部分（实际上PSM已经成为了HAM的一个客户端）。它维护并存储了打包应用程序的每个主机的状态。虽然它与
HAM在同一个服务（BrokerInfrastructure）中实现，但PSM位于不同的DLL（Psmsrv.dll）中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>应</b><b>用</b><b>程</b><b>序</b><b>激</b><b>活</b><b>管</b><b>理</b><b>器</b><b>（</b><b>A</b><b>p</b><b>p</b><b>l</b><b>i</b><b>c</b><b>a</b><b>t</b><b>i</b><b>o</b><b>n</b><b> </b><b>A</b><b>c</b><b>t</b><b>i</b><b>v</b><b>a</b><b>t</b><b>i</b><b>o</b><b>n</b><b> </b><b>M</b><b>a</b><b>n</b><b>a</b><b>g</b><b>e</b><b>r</b><b>，</b><b>A</b><b>A</b><b>M</b><b>）</b><b>：</b></span>AAM组件负责不同种类和类型打包应用程序的激活。它在ActivationManager.dll库中实现，而该库位于用户管理器服务中。AAM是HAM的客户端。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>视</b><b>图</b><b>管</b><b>理</b><b>器</b><b>（</b><b>V</b><b>i</b><b>e</b><b>w</b><b> </b><b>M</b><b>a</b><b>n</b><b>a</b><b>g</b><b>e</b><b>r</b><b>，</b><b>V</b><b>M</b><b>）</b><b>：</b></span>VM
检测并管理UWP用户界面事件与活动，并与HAM通信以保持UI应用程序处于前台以及非暂停状态。此外，VM还帮助HAM检测UWP应用程序何时进入后台
状态。视图管理器是在CoreUiComponents.dll这个.NET托管库中实现的，后者需要依赖Modern Execution 
Manager（现代执行管理器）客户端接口（ExecModelClient.dll）才能正确地向HAM注册。这些库都位于用户管理器服务中，而该服
务本身在Sihost进程中运行（该服务需要正确地管理UI事件）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>后</b><b>台</b><b>代</b><b>理</b><b>基</b><b>础</b><b>架</b><b>构</b><b>（</b><b>B</b><b>a</b><b>c</b><b>k</b><b>g</b><b>r</b><b>o</b><b>u</b><b>n</b><b>d</b><b> </b><b>B</b><b>r</b><b>o</b><b>k</b><b>e</b><b>r</b><b> </b><b>I</b><b>n</b><b>f</b><b>r</b><b>a</b><b>s</b><b>t</b><b>r</b><b>u</b><b>c</b><b>t</b><b>u</b><b>r</b><b>e</b><b>，</b><b>B</b><b>I</b><b>）</b></span>：
BI负责管理应用程序的后台任务、其执行策略以及事件。其核心服务器主要在bisrv.dll库中实现，负责管理代理生成的事件，并评估策略以决定是否运
行某个后台任务。后台代理基础架构位于BrokerInfrastructure服务中，撰写这部分内容时，已不再被Centennial应用程序所使
用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种全新应用程序模型还包含其他几个次要组件，因为已超出了本书范围，故不再详述。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了能够在Windows 10 S
	<sup><img width="10" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="S模式是Windows 10/11的一种特殊运行模式。该模式下，系统将只能运行来自Windows应用商店的应用，无法安装商店之外的应用。该模式未提供零售版系统，用户只能购买预装该模式系统的品牌机。S模式可无缝切换至普通模式，但该切换是单向的，无法从普通模式切换回S模式。——译者注" title="S模式是Windows 10/11的一种特殊运行模式。该模式下，系统将只能运行来自Windows应用商店的应用，无法安装商店之外的应用。该模式未提供零售版系统，用户只能购买预装该模式系统的品牌机。S模式可无缝切换至普通模式，但该切换是单向的，无法从普通模式切换回S模式。——译者注" class="epub-footnote"></sup>这
样的安全设备上运行应用程序（甚至标准的Win32应用程序），并为了帮助老应用程序转换为新模型，微软设计了Desktop 
Bridge（内部代号Centennial）。开发者可通过Visual Studio或Desktop App 
Converter来使用这种桥接技术。虽然技术上可以在AppContainer中运行Win32应用程序，但并不推荐这样做，因为标准Win32应用
程序在设计上需要访问更广泛的系统API表面，而AppContainer在这方面受到了较大限制。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_64" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>1</b><b>1</b><b>.</b><b>1</b><b> </b><b>U</b><b>W</b><b>P</b><b>应</b><b>用</b><b>程</b><b>序</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在卷1第7章，我们已经介绍了UWP应用程序及其安全环境。为了更好地理解本章涉及的概念，有必要对现代UWP应用程序的一些基本特性进行简要的介绍。Windows 8为进程引入了一些重要的新属性：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·程序包标识符。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·应用程序标识符。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·AppContainer。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Modern UI。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">我们已经全面介绍过
AppContainer（详见卷1第7章）。当用户下载一个现代UWP应用程序时，应用程序通常会封装在AppX程序包中。一个程序包可以包含同一个作
者所发布的不同应用程序，这些应用程序会相互链接在一起。程序包标识符是一种逻辑结构，能够以唯一的方式定义程序包，它包含名称、版本、架构、资源ID以
及发行商五个部分。程序包标识符可以用两种方式来表示：一是使用程序包全名（package full name，最初也叫package 
moniker），这是一种由程序包标识符的每部分内容通过下划线连接组合成的字符串；二是使用程序包家族名（package family 
name），这是由程序包和发行商名称组成的另一种字符串。在这两种情况下，发行商需要负责使用Base32对完整的发行商名称字符串进行编码。在UWP
的世界中，“程序包ID”和“程序包全名”这两个术语的含义是相同的。例如，Adobe Photoshop程序包就是通过下列全名分发的：</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">AdobeSystemsIncorporated.AdobePhotoshopExpress_2.6.235.0_neutral_split.scale-125_ynb6jyjzte8ga</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">其中：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·AdobeSystemsIncorporated.AdobePhotoshopExpress是程序包的名称。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·2.6.235.0是版本。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Neutral是目标架构。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Split_scale是资源ID。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·ynb6jyjzte8ga是发行商的Base32编码（采用了Crockford变体，为避免字母与数字混淆而不使用i、l、u和o这几个英文字母）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">而程序包家族名称则是更简单的AdobeSystemsIncorporated.AdobePhotoshopExpress_ynb6jyjzte8ga字符串。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">构成程序包的每个应用程序
都由一个应用程序标识符所代表。应用程序标识符能以唯一的方式来标识组成面向用户的程序所包含的全部窗口、进程、快捷方式、图标和功能的集合，但不会考虑
程序具体的实现方式（这意味着在UWP世界中，应用程序可以由不同的进程组成，但这些进程依然属于同一个应用程序标识符）。应用程序标识符通过一个简单的
字符串来表示（在UWP世界中这叫作程序包相关应用程序ID，即Package Relative Application 
ID，通常可缩写为PRAID）。后者总会与程序包家族名称组合在一起，构成应用程序用户模型ID（Application User Model 
ID，通常可缩写为AUMID）。例如，Windows现代开始菜单应用程序的AUMID是
Microsoft.Windows.ShellExperienceHost_cw5n1h2txyewy!App，其中的App部分就是它的
PRAID。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">程序包全名和应用程序标识符均位于描述现代应用程序安全上下文的令牌所包含的WIN://SYSAPPID安全特性中。有关UWP应用程序运行所需的安全环境的详细介绍，请参阅卷1第7章。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_65" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>1</b><b>1</b><b>.</b><b>2</b><b> </b><b>C</b><b>e</b><b>n</b><b>t</b><b>e</b><b>n</b><b>n</b><b>i</b><b>a</b><b>l</b><b>应</b><b>用</b><b>程</b><b>序</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">从Windows 
10开始，新的应用程序模型已可开始兼容标准Win32应用程序。开发者只需要使用一个名为Desktop App 
Converter的特殊微软工具运行应用程序的安装文件即可。Desktop App 
Converter会在沙盒服务器Silo（内部将其称为Argon 
Container）中启动安装程序，拦截创建应用程序的程序包所需的全部文件系统和注册表I/O，并将所有文件存储在一个VFS
（Virtualized File System，虚拟化文件系统）私有文件夹中。Desktop App 
Converter应用程序的全面介绍已超出了本书范围，有关Windows容器和Silo的详细信息请参阅卷1第3章。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与UWP应用程序不同，
Centennial运行时并不创建用于运行Centennial进程的沙盒，而是会在其基础上应用一种精简的虚拟化层。因此，相比标准Win32程序，
Centennial应用程序的安全性并不低，也不会以较低完整性级别的令牌来运行。Centennial应用程序甚至可以使用管理员账户启动。此类应用
程序运行在应用程序Silo（内部将其称为Helium 
Container）中，其目的在于保持兼通性的同时维持状态的分离，并提供两种形式的“监牢”：注册表重定向和虚拟文件系统（VFS）。图8-42展示
了一个Centennial应用程序（Kali Linux）的范例。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/cc3267521fbff5504701c1a84c3e8adc.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图8-42 Windows应用商店中的Kali Linux发行版就是一种典型的Centennial应用程序</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当程序包激活时，系统会对
应用程序应用注册表重定向，并将主System配置单元（Hive）合并到Centennial 
Application注册表配置单元。在安装到用户工作站后，每个Centennial应用程序可包含registry.dat、user.dat以及
（可选的）userclasses.dat三个注册表配置单元。Desktop 
Convert生成的注册表文件代表“不可变的”配置单元，会在安装时写入并且不应更改。当应用程序启动时，Centennial运行时会将不可变配置单
元合并到真正的System注册表配置单元（实际上，Centennial运行时还会执行“去标记化”过程，因为配置单元中存储的每个值都包含相应的
值）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">注册表合并与虚拟化服务是
由虚拟注册表命名空间过滤器驱动程序（WscVReg）提供的，该驱动程序已集成在NT内核（配置管理器）中。当程序包激活时，用户模式的AppInfo
服务会与VRegDriver设备通信，进而对Centennial应用程序的注册表活动进行合并与重定向。在这种模式下，如果应用程序试图读取的注册表
值位于虚拟化的配置单元中，I/O实际上会被重定向到程序包的配置单元。对这种值进行写入操作是禁止的。如果虚拟化配置单元中不存在所需值，则会直接在真
正的配置单元中创建，而不需要任何类型的重定向。整个HKEY_CURRENT_USER根键还会应用一种不同的重定向机制，在该键下，每个新子键或值都
只存储在下列路径的程序包配置单元中：C:\ProgramData\Packages\&lt;PackageName&gt;
\&lt;UserSid&gt;\SystemAppData\Helium\Cache。表8-34列出了应用于Centennial应用程序的注册
表虚拟化摘要。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">表8-34 应用于Centennial应用程序的注册表虚拟化</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/fb7be8a65736bb20a47530896a479ea6.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当Centennial运
行并设置Silo应用程序容器时，会遍历程序包VFS文件夹中的所有文件和目录。该过程也是程序包激活组件所提供的Centennial虚拟文件系统配置
的一部分。Centennial运行时包含一个列表，其中列出了VFS目录中每个文件夹的映射，如表8-35所示。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">表8-35 为Centennial应用虚拟化的系统文件夹列表</span></p><div style="display: block;text-align:center;">
	<img width="702" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/24ec8bcfe271da08ae5ce33540e7a57c.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">文件系统虚拟化是由三个不同的驱动程序提供的，Argon容器大量使用了这些驱动程序。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Windows<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>绑</b><b>定</b><b>微</b><b>过</b><b>滤</b><b>驱</b><b>动</b><b>程</b><b>序</b></span>（Windows
 Bind minifilter 
driver，BindFlt）：负责管理Centennial应用程序的文件重定向。这意味着如果Centennial应用需要读取或写入一个现有的虚
拟化文件，则I/O会被重定向至文件的原始位置。当应用程序试图在一个虚拟化文件夹（如C:\Windows）中创建文件，并且该文件尚不存在时，该操作
将被允许（前提是用户具备所需权限），此时将不进行重定向。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Windows<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>容</b><b>器</b><b>隔</b><b>离</b><b>微</b><b>过</b><b>滤</b><b>驱</b><b>动</b><b>程</b><b>序</b></span>（Windows
 Container Isolation minifilter 
driver，Wcifs）：负责合并不同虚拟化文件夹（也叫不同的“层”）的内容并创建一种唯一视图。Centennial应用程序使用该驱动程序将本
地用户的应用程序数据文件夹（通常为C:\Users\&lt;UserName&gt;\AppData）内容合并到应用的应用程序缓存文件夹（位于
C:\User\&lt;UserName&gt;\Appdata\Local\Packages\&lt;Package Full 
Name\LocalCache）。该驱动程序甚至可以管理多个程序包的合并，这意味着每个程序包都可以针对合并文件夹获得自己的私有视图并在此执行各种
操作。为了支持该功能，该驱动程序会在目标文件夹的重分析点中存储每个程序包的层ID（Layer 
ID）。借此即可在内存中构建层映射，并针对不同的私有区域（内部将其称为Scratch区域）执行操作。在撰写这部分内容时，这个高级功能只针对相关的
集进行了配置，下文将进一步介绍该功能。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Windows<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>容</b><b>器</b><b>名</b><b>称</b><b>虚</b><b>拟</b><b>化</b><b>微</b><b>过</b><b>滤</b><b>驱</b><b>动</b><b>程</b><b>序</b></span>（Windows
 Container Name Virtualization minifilter 
driver，Wcnfs）：当Wcifs驱动程序合并多个文件夹时，Centennial会使用Wcnfs来设置本地用户应用程序数据文件夹的名称重定
向。与上文提到的情况不同，当应用在虚拟化的应用程序数据文件夹中新建文件或文件夹时，无论该文件是否已经存在，文件都会被存储到应用程序缓存文件夹中，
而非真正的文件夹中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">有一个重要的概念需要注
意：BindFlt能对单个文件进行过滤操作，而Wcnfs和Wcifs驱动程序能对文件夹执行操作。Centennial会使用微过滤器的通信端口正确
设置虚拟化文件系统基础架构。该设置过程会使用一种基于消息的通信系统来完成（Centennial运行时向微过滤器发送消息并等待响应）。表8-36列
出了应用于Centennial应用程序的文件系统虚拟化概要。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">表8-36 应用于Centennial应用程序的文件系统虚拟化</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/182a0b536f58345d5b692398dad9bce5.jpg" alt="" title=""></div>
</div><div class="header2"><h3><span id="sigil_toc_id_66" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>1</b><b>1</b><b>.</b><b>3</b><b> </b><b>主</b><b>机</b><b>活</b><b>动</b><b>管</b><b>理</b><b>器</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统中原本有很多组件会以
不够协调的方式与打包的应用程序状态进行交互，但Windows 10对这些组件进行了统一。因此一个名为主机活动管理器（Host Activity 
Manager，HAM）的全新组件开始成为中心组件，独自负责管理打包应用程序的状态并向其所有客户端提供统一的API集。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与原先的方式不同，主机活
动管理器会向自己的客户端暴露基于活动的接口。“主机”是应用程序模型所认可的最小的隔离单元对象。而打包应用程序中代表Windows作业对象的资源状
态、暂停/恢复状态、冻结状态，以及优先级，都可以作为一种单元加以管理。对于简单的应用程序，作业对象可能只包含一个进程；但对于拥有多个后台任务的应
用程序（如多媒体播放器），其中也可能包含多个不同进程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在这种新的现代应用程序模型中，作业的类型分为三种。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Mixed：前台和后台活动的混合，但通常会与应用程序的前台部分相关联。包含后台任务的应用程序（例如音乐播放或打印）会使用这种类型的作业。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Pure：纯粹用于后台工作的主机。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·System：代表应用程序执行Windows代码的主机（例如后台下载）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">活动（Activity）
始终归属于主机，它代表了客户端某些概念（例如窗口、后台任务、任务完成等）的通用接口。如果主机的作业未处于冻结状态，并且有至少一个运行中的活动，那
么这样的主机会被视为“活跃的”。HAM客户端组件负责管理活动的交互并控制其寿命。很多组件都可以看成HAM客户端：视图管理器、代理基础架构、各种
Shell组件（例如Shell Experience Host）、AudioSrv、任务完成，甚至Windows服务控制管理器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">现代应用程序的生命周期由四种状态组成：运行中（Running）、暂停中（Suspending）、暂停完成（Suspend-complete）以及已暂停（Suspended）。这些状态及其相互之间的交互请参考图8-43。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>运</b><b>行</b><b>中</b></span>。该状态下的应用程序正在执行自己的部分代码，而并未暂停运行。不仅仅是处于前台的应用程序，运行后台任务（如播放音乐、打印，或执行其他任何后台任务）的应用程序也可以处于该状态下。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>暂</b><b>停</b><b>中</b></span>。
这是一种持续时间有限的过渡状态，当HAM要求应用程序暂停时会出现该状态。HAM可能会出于不同原因提出此要求，例如，应用程序失去了前台焦点，系统资
源不足或即将进入省电状态，或仅仅只是因为应用正在等待某些UI事件。出现这种情况后，应用程序需要在有限的时间（通常最多5秒）内进入已暂停状态，否则
将会被终止。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>暂</b><b>停</b><b>完</b><b>成</b></span>。该状态下的应用程序已完成暂停操作，并将情况告知系统。因此，其暂停过程会被视为已完成。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>已</b><b>暂</b><b>停</b></span>。一旦应用程序完成暂停过程并通知系统，系统将使用NtSetInformationJobObject API调用（通过JobObjectFreezeInformation信息类）冻结该应用程序的作业对象，随后该应用程序的任何代码均将无法运行。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/6956a711b47c60e2823fc90f1a5f4bab.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-43 打包应用程序的生命周期结构图</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">以维持系统效率并节约系统
资源为目标的主机活动管理器，默认情况下会始终要求应用程序暂停。HAM客户端需要向HAM发出请求才能让应用程序始终保持活跃。对于前台应用程序，由视
图管理器这个组件负责保持应用程序活跃状态。对于后台任务，则由代理基础架构负责判断要让承载后台活动的哪些进程保持活跃（同样要向HAM请求保持应用程
序活跃）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">打包的应用程序没有终止
（Terminated）状态。这意味着应用程序没有真正意义上的退出或终止状态这样的概念，并且应用程序也不应该试图终止自己。终止打包应用程序的实际
模式是：首先将其暂停，随后如果有必要，由HAM针对应用程序的作业对象调用NtTerminateJobObject 
API。HAM可以自动管理应用程序的寿命，并只在需要时销毁进程。但终止应用程序的决定并不是由HAM自己做出的，而是由客户端（例如视图管理器或应用
程序激活管理器）发出相关请求。打包的应用程序无法分辨出自己是被暂停还是被终止。这样Windows就可以自动还原应用程序原本的状态，哪怕应用程序已
经被终止或系统已经重启动。因此可以说，打包应用程序模型完全不同于标准的Win32应用程序模型。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了正确地暂停并恢复打包的应用程序，主机活动管理器会使用新增的PsFreezeProcess和PsThawProcess内核API。进程的冻结（Freeze）和解冻（Thaw）操作类似于暂停和恢复，但也存在如下两个重大差异。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·在深度冻结进程的上下文中注入或新建的线程将无法运行，哪怕在创建时并未使用CREATE_SUSPENDED标记或通过调用NtResumeProcess API来启动线程的情况下也是如此。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·在EPROCESS数据结构中实现了一个新的Freeze计数器。这意味着进程可以被多次冻结。为了让进程解冻，解冻请求的总数必须等于冻结请求的数量。只有在这种情况下，非暂停状态的线程才允许运行。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_67" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>1</b><b>1</b><b>.</b><b>4</b><b> </b><b>状</b><b>态</b><b>存</b><b>储</b><b>库</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">现代应用程序模型引入了一
种新方式来存储打包应用程序的设置、程序包依赖以及常规的应用程序数据。状态存储库（state 
repository）已成为一种全新的中心仓库，其中包含所有此类数据，并为所有现代应用程序的管理提供一条重要的中心原则，即每次从应用商店下载、安
装、激活或删除应用程序时，都需要通过该存储库读/写新数据。这方面有一个经典的使用范例：在用户点击开始菜单中的磁贴后，就会用到状态存储库。开始菜单
会解析应用程序激活文件（可以是EXE或DLL文件，详见卷1第7章）的完整路径，并从存储库中读取（该过程实际上已经进行了简化，因为
ShellExecutionHost进程已经在初始化时枚举了所有现代应用程序）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">状态存储库主要通过
Windows.StateRepository.dll和Windows.StateRepositoryCore.dll这两个库实现。状态存储库服
务运行了该存储库中与服务器有关的部分，而UWP应用程序需要通过Windows.StateRepositoryClient.dll库与存储库通信
（所有存储库API都是被完全信任的，因此WinRT客户端需要使用代理才能正确地与服务器通信，这是另一个DLL，即
Windows.StateRepositoryPs.dll所实现的规则）。状态存储库的根位置位于
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Appx\PackageRepositoryRoot
注册表值中，该值通常会指向C:\ProgramData\Microsoft\Windows\AppRepository路径。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">状态存储库是通过多个数据库（也叫“分区”）实现的。这些数据库中的表也被称为“实体”。不同的分区在访问和寿命方面存在不同的限制。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Machine：
该数据库包含程序包定义、应用程序的数据与标识符，以及主要和辅助磁贴（用于开始菜单），这是定义谁能访问哪些程序包的主注册表。相关数据会被不同组件
（例如TileDataRepository库，资源管理器和开始菜单会用它来管理不同磁贴）广泛读取，但它主要是由AppX部署来写入的（很少被其他次
要组件写入）。Machine分区通常会存储在状态存储库根文件夹下一个名为StateRepository- Machine.srd的文件中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Deployment：
存储了整个计算机的相关数据，通常只在新程序包向系统注册或移除时，被部署服务（AppxSvc）所使用。其中包含应用程序文件列表以及每个现代应用程序
清单文件的副本。Deployment分区通常存储在一个名为StateRepository- Deployment.srd的文件中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">所有分区都存储在
SQLite数据库内。Windows将自己版本的SQLite编译到StateRepository.Core.dll库中，该库可以暴露状态存储库数
据访问层（Data Access Layer，DAL）API，而这些API大多是内部数据库引擎的包装器，进而可由状态存储库服务加以调用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">有时，不同的组件需要知道状态存储库中的某些数据是何时被写入或修改的。在Windows 10的周年更新版本中，状态存储库通过更新已经可以支持变更和事件跟踪，进而应对各种场景。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·组件想要订阅某个实体的数据变更。该组件会在数据产生变化时收到回调并通过SQL事务来实现。一个部署操作可包含多个SQL事务，当每个数据库事务结束时，状态存储库会判断部署操作是否完成，如果完成，则会调用每个已注册的侦听器。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·进程被启动或从已暂停状态唤醒，需要了解自从自己上一次被通知或查看之后有哪些数据产生了变化。状态存储库可通过ChangeId字段满足这种请求，在支持该功能的表中，这个字段代表了一条记录的唯一时间标识符。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
进程从状态存储库检索数据，需要知道自从自己上一次检查后，数据是否产生了变化。数据的变化总是会通过一个名为Changelog的新表记录到兼容的实体
中。该表会始终记录时间以及创建该数据的事件变更ID的变化情况，并会在适用的情况下记录删除数据的事件变更ID的变化情况。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">现代开始菜单的正常工作离
不开状态存储库的变更和事件跟踪功能。每当ShellExperienceHost进程启动时，都会请求状态存储库在每次修改、创建或删除磁贴时通知自己
的控制器（NotificationController.dll）。当用户通过应用商店安装或删除现代应用程序时，应用程序部署服务器会执行数据库事务
来插入或删除磁贴。当该事务结束时，状态存储库会向事件发送信号以唤醒控制器。借此，开始菜单即可以近乎实时的方式改变自己的外观。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
现代开始菜单也可以通过类似方式，在每次新安装一个标准Win32应用程序后，自动添加或删除对应的项。应用程序的安装程序通常会在传统开始菜单文件夹位
置（系统级路径C:\ProgramData\Microsoft\Windows\Start 
Menu或每用户路径C:\Users\&lt;UserName&gt;
\AppData\Roaming\Microsoft\Windows\Start 
Menu）下创建一个或多个快捷方式。现代开始菜单会使用AppResolver库提供的服务为所有开始菜单文件夹注册文件系统通知（用到了
ReadDirectoryChangesW这个Win32 
API）。借此，当被监控的文件夹中添加了新的快捷方式后，该库即可获得回调并向开始菜单发出信号，使其重新绘制内容。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>见</b><b>证</b><b>状</b><b>态</b><b>存</b><b>储</b><b>库</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们可以使用自己惯用的SQLite浏览器应用程序轻松地打开并查看状态存储库的每个分区。在该实验中，我们需要下载并安装SQLite浏览器，例如，开源
的DB Browser for 
SQLite（下载地址：http://sqlitebrowser.org/）。标准用户无权访问状态存储库路径。此外，在尝试访问时，每个分区的文件
可能处于正被使用的状态。因此，我们需要将数据库文件复制到其他位置，随后再使用SQLite浏览器打开。请在以管理员身份运行（在搜索框中输入cmd，
右键点击“命令提示符”并选择“以管理员身份运行”）的命令提示符窗口中运行下列命令：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\WINDOWS\system32&gt;cd "C:\ProgramData\Microsoft\Windows\AppRepository" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\ProgramData\Microsoft\Windows\AppRepository&gt;copy StateRepository-Machine.srd</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">"%USERPROFILE%\Documents" </span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/89ededf586600bac6e003bada1a2d37e.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">这
样就可以将状态存储库的Machine分区复制到自己的“文档”文件夹中。随后需要打开它。使用开始菜单中创建的链接或搜索框中的搜索结果启动DB 
Browser for SQLite，随后点击Open Database按钮。打开“文档”文件夹，在File Type复选框中选择All 
Files 
(*)（状态存储库的数据库并未使用标准的SQLite文件扩展名），随后打开复制到这里的StateRepository-machine.srd文
件。DB Browser for SQLite的主视图显示了数据库结构。在这个实验中，我们需要选择Browse 
Data标签页，随后查看Package、Application、PackageLocation以及PrimaryTile这几个表。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">应用程序激活管理器和现代应用程序模型的很多其他组件会使用标准SQL查询从状态存储库中提取所需的数据。例如，要提取现代应用程序的程序包位置和可执行文件名称，可以使用类似下面这样的SQL查询：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">SELECT p.DisplayName, p.PackageFullName, pl.InstalledLocation, a.Executable, pm.Name</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">FROM Package AS p </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">INNER JOIN PackageLocation AS pl ON p._PackageID=pl.Package </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">INNER JOIN PackageFamily AS pm ON p.PackageFamily=pm._PackageFamilyID </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">INNER JOIN Application AS a ON a.Package=p._PackageID </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">WHERE pm.PackageFamilyName="&lt;Package Family Name&gt;" </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">DAL（数据访问层）也使用类似的查询为自己的客户端提供服务。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/278bcf0d3f48e15a6d425c188d8f8cd6.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们可以先记录表中的记录总数，随后从应用商店安装一个新应用程序。部署过程完毕后，再次复制该数据库文件并查看就会发现，记录的总数出现了变化。多个表中
的记录数量都会发生变化，尤其是当新安装的应用程序新建了磁贴时，甚至PrimaryTile表也会为开始菜单中新增加的磁贴添加一条新记录。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_68" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>1</b><b>1</b><b>.</b><b>5</b><b> </b><b>依</b><b>赖</b><b>项</b><b>小</b><b>型</b><b>存</b><b>储</b><b>库</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">打开SQLite数据库并
使用SQL查询提取所需信息的操作开销可能很高。此外，当前的架构还需要通过RPC完成一些进程间的通信。这两个局限有时会因限制性太大而难以满足。用户
通过命令行控制台启动新应用程序（例如通过执行别名来启动）就是一个典型的例子。每当系统产生一个进程时都检查状态存储库，这会造成巨大的性能问题。为了
解决这些问题，应用程序模型引入了依赖项小型存储库（Dependency Mini 
Repository，DMR），这是一种较小规模的存储，其中只包含现代应用程序的信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与状态存储库不同，依赖项
小型存储库不使用任何数据库，而是通过一种微软专有的二进制格式来存储数据，这些数据可被任何安全上下文中的文件系统所访问（甚至内核模式驱动程序也可以
解析DMR数据）。其中System 
Metadata（系统元数据）目录由状态存储库根路径中名为Packages的文件夹所表示，里面包含一个子文件夹列表，每个子文件夹对应一个已安装的
程序包。依赖项小型存储库由一个.pckgdep文件所代表，其名称与用户的SID相同。在为用户注册程序包时，部署服务会创建DMR文件（更多细节请参
阅下文“程序包注册”一节）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当系统为属于打包应用程序
的程序创建进程时，将大量使用依赖项小型存储库（位于AppX 
Pre-CreateProcess扩展中）。因此，依赖项小型存储库完全实现于Win32的kernelbase.dll中（但一些存根函数位于
kernel.appcore.dll中）。当创建进程并打开DMR文件时，会读取并解析其内容，并将结果映射至父进程的内存中。子进程创建完成后，加载
器代码甚至会在子进程中映射。DMR文件包含下列多种信息。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·程序包信息，如ID、完整名称、完整路径、发行商。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·应用程序信息：应用程序用户模型ID和相关ID、描述、显示名称以及徽标图像。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·安全上下文：AppContainer SID和能力。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·目标平台和程序包依赖性图（当一个程序包依赖一个或多个其他程序包时使用）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">按照设计，未来版本
Windows中的DMR文件还可以在需要时包含更多信息。在使用依赖项小型存储库的情况下，进程的创建速度将足够快，并且不需要查询状态存储库。需要注
意的是，DMR文件会在进程创建完毕后关闭。因此我们甚至可以在现代应用程序执行过程中重写入.pckgdep文件，向其中添加可选程序包。借此，用户可
在无须重启动的前提下为现代应用程序添加功能。程序包小型存储库的一小部分内容（主要是程序包的完整名称和路径）甚至可以作为缓存，复制到不同的注册表键
以便进一步提高访问速度。这种缓存通常会用于一些常用操作（如检查某个程序包是否存在）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_69" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>1</b><b>1</b><b>.</b><b>6</b><b> </b><b>后</b><b>台</b><b>任</b><b>务</b><b>和</b><b>代</b><b>理</b><b>基</b><b>础</b><b>架</b><b>构</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">UWP应用程序通常需要通
过某种方式在后台运行自己的部分代码，这些代码无须与前台主进程交互。UWP可支持后台任务，这样即可为主进程暂停或未运行的应用程序提供必需的功能。应
用程序可能会出于多种原因而需要使用后台任务：实时通信、邮件、即时信息、多媒体音乐、视频播放器等。后台任务可通过触发器和条件关联在一起。触发器是一
种全局系统异步事件，当它发生时，将发送信号启动对应的后台任务。取决于所适用的条件，此时后台任务可能已经启动了，或者还未启动。例如，即时信息应用程
序中使用的后台任务只会在用户已登录（这是一种系统事件触发器），并且具备可用互联网连接（这是一种条件）的情况下启动。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows 10中包含两种类型的后台任务。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>进</b><b>程</b><b>内</b><b>后</b><b>台</b><b>任</b><b>务</b></span>。应用程序代码及其后台任务在同一个进程中运行。从开发者的角度来看，此类后台任务更易于实现，但也存在一个很大的不足：如果代码中存在Bug，整个应用程序都可能崩溃。进程内后台任务支持的触发器比进程外后台任务少一些。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>进</b><b>程</b><b>外</b><b>后</b><b>台</b><b>任</b><b>务</b></span>。
应用程序代码及其后台任务通过不同的进程运行（这些进程也可以运行在不同的作业对象中）。此类后台任务更有弹性，会运行在
backgroundtaskhost.exe这个宿主进程中，可以使用所有的触发器和条件。如果后台任务的代码存在Bug，则不会危及整个应用程序。但
这种后台任务最主要的不足在于，不同进程之间的进程间通信完全需要通过执行RPC代码的方式实现，这会对性能造成一定的影响。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了向用户提供最佳体验，
所有后台任务都在执行时间上存在限制，总共可执行30秒。执行25秒后，后台代理基础架构（background broker 
infrastructure）服务会调用任务的取消句柄（在WinRT中，这叫作OnCanceled事件）。该事件发生后，后台任务依然有5秒时间完
成清理工作并退出。否则包含后台任务代码的进程（对于进程外任务，这是指BackgroundTaskHost.exe，进程内任务则是应用程序进程本
身）会被终止。个人或商用UWP应用程序的开发者可以移除该限制，但不包含该限制的应用程序将无法上架微软官方的应用商店。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">后台代理基础架构（BI）
是管理所有后台任务的中心组件。该组件主要在bisrv.dll（服务器端）实现，此文件位于代理基础架构服务中。有两类客户端可以使用后台代理基础架构
提供的服务：标准Win32应用程序与服务，它们可以导入bi.dll后台代理基础架构客户端库；此外还有WinRT应用程序，它们会始终链接到
biwinrt.dll，这个库为现代应用程序提供了WinRT 
API。后台代理基础架构无法在不使用代理的情况下存在。代理也是一种组件，主要用于产生被后台代理服务器使用的各类事件。代理分为多种类型，如下是最重
要的类型。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>系</b><b>统</b><b>事</b><b>件</b><b>代</b><b>理</b></span>（System Event Broker）：为诸如网络连接状态变化、用户登录和注销、系统电池状态变化等系统事件提供触发器。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>时</b><b>间</b><b>代</b><b>理</b></span>（Time Broker）：提供重复性或一次性的计时器支持。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>网</b><b>络</b><b>连</b><b>接</b><b>代</b><b>理</b></span>（Network Connection Broker）：为UWP应用程序提供了一种在某些端口上建立了网络连接后接收事件的方式。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>设</b><b>备</b><b>服</b><b>务</b><b>代</b><b>理</b></span>（Device Services Broker）：提供了设备抵达触发器（例如用户连接或断开某个设备），工作时需要侦听源自内核的PNP事件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>移</b><b>动</b><b>宽</b><b>带</b><b>体</b><b>验</b><b>代</b><b>理</b></span>（Mobile Broad Band Experience Broker）：为电话和SIM卡提供了所有关键的触发器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">代理的服务器部分通过
Windows服务的形式实现。每种代理的具体实现各异，但大部分都需要订阅Windows内核发布的WNF状态（详见“Windows通知设施”一
节），但也有一些基于标准Win32 
API构建（例如时间代理）。所有这些代理在实现方面的细节已经超出了本书的范围。代理可以简单地将其他某些地方（例如Windows内核）生成的事件进
行转发，或者也可以基于某些条件和状态生成新事件。代理可以转发自己通过WNF管理的事件：每个代理会创建一个WNF状态名称，并由后台基础架构进行订
阅。借此，当代理发布了新的状态数据后，一直在侦听的代理基础架构就可以被唤醒，并将事件转发给对应的客户端。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每个代理甚至还可以包含客户端基础架构：一个WinRT库和一个Win32库。后台代理基础架构及其代理可以向自己的客户端暴露三种类型的API。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>不</b><b>信</b><b>任</b><b>的</b></span>API：通常由运行在AppContainer或沙盒环境中的WinRT组件使用。此时会进行补充性的安全检查。此类API的调用方无法指定不同的程序包名称或以其他用户身份进行操作（即BiRtCreateEventForApp）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>部</b><b>分</b><b>信</b><b>任</b><b>的</b></span>API：由中等完整性级别环境中的Win32组件使用。此类API的调用方可以指定现代应用程序的程序包完整名称，但无法以其他用户身份进行操作（即BiRtCreateEventForApp）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>完</b><b>全</b><b>信</b><b>任</b><b>的</b></span>API：只能由具备高特权的系统性或管理性Win32服务使用。此类API的调用方能够以其他用户的身份执行操作，也可以使用不同的程序包（即BiCreateEventForPackageName）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这些代理的客户端可以决定是否直接订阅特定代理，或订阅后台代理基础架构提供的事件。WinRT始终会使用后一种方法。图8-44展示了一个现代应用程序后台任务对时间触发器进行初始化的范例。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/436259cff1fff277d344337ffe233358.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-44 时间代理的架构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">后台代理基础架构还为代理
及其客户端提供了另一个重要服务：后台任务的存储能力。这意味着当用户关闭随后重启动系统后，所有已注册的后台任务都可以还原并重新计划安排，一切都可恢
复至系统重启动之前的状态。为了准确实现这种能力，当系统引导并且服务控制管理器（详见第10章）启动代理基础架构服务时，后者会在初始化的过程中分配一
个根存储GUID，并使用NtLoadKeyEx这个原生API加载后台代理注册表配置单元的一个私有副本。该服务会让NT内核使用一个特殊标记
（REG_APP_HIVE）加载该配置单元的私有副本。BI配置单元位于C:\Windows\System32\Config\BBI文件中。该配置
单元的根键会被挂载为\Registry\A\&lt;Root Storage 
GUID&gt;，仅能由代理基础架构服务的进程（此时为svchost.exe，因为代理基础架构运行在一个共享的服务宿主内）访问。代理基础架构配置
单元包含一个由事件和工作项组成的列表，其中的内容会使用GUID进行排序和区分。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>事</b><b>件</b><b>代</b><b>表</b><b>后</b><b>台</b><b>任</b><b>务</b><b>的</b><b>触</b><b>发</b><b>器</b></span>。事件可关联代理ID（代表提供此事件类型的代理）、程序包完整名称、UWP应用程序所关联的用户及其他一些参数。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>工</b><b>作</b><b>项</b><b>代</b><b>表</b><b>已</b><b>计</b><b>划</b><b>的</b><b>后</b><b>台</b><b>任</b><b>务</b></span>。工作项可包含名称、条件列表、任务入口点，以及相关的触发器事件GUID。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">BI服务可枚举每个子键，随后还原所有触发器和后台任务。它还会清理无主事件（未与任何工作项关联的事件）。最后，它会发布一个WNF就绪状态名称。这样一来，所有代理就可以被唤醒并完成自己的初始化工作了。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">后台代理基础架构已被UWP应用程序深入使用。甚至普通的Win32应用程序和服务也可以通过自己的Win32客户端库使用BI和代理。例如，计划任务服务、后台智能传输服务、Windows推送通知服务以及AppReadiness服务都是这样做的。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_70" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>1</b><b>1</b><b>.</b><b>7</b><b> </b><b>打</b><b>包</b><b>应</b><b>用</b><b>程</b><b>序</b><b>的</b><b>安</b><b>装</b><b>和</b><b>启</b><b>动</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">打包应用程序的寿命与标准
Win32应用程序截然不同。在Win32世界中，应用程序的安装过程各不相同，最简单的只需要复制和粘贴所需的可执行文件，但复杂的则需要执行烦琐的安
装程序。尽管只需要执行一个可执行文件即可启动应用程序，但Windows加载器承担了所有复杂工作。对于主要通过Windows应用商店来安装的现代应
用程序，其安装过程则遵循一种明确定义的规程。在开发者模式下，管理员甚至可以使用外部的.Appx文件来安装现代应用程序，不过所用的程序包文件必须包
含数字签名。这种程序包注册过程较复杂，涉及多个组件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在深入介绍程序包注册之前，有必要了解与现代应用程序有关的另一个重要概念：程序包激活。程序包激活是指启动一个现代应用程序的过程，这一过程中可以向用户展示GUI，但也可以不展示。该过程因现代应用程序的不同类型而各异，涉及很多系统组件。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_71" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>1</b><b>1</b><b>.</b><b>8</b><b> </b><b>程</b><b>序</b><b>包</b><b>激</b><b>活</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">用户无法仅通过执
行.exe文件的方式启动UWP应用程序（专为此用途创建的AppExecution别名除外，本章下文将详细介绍AppExecution别名）。为了
正确地激活现代应用程序，用户需要点击现代菜单中的磁贴，使用资源管理器能够正确解析的特殊链接文件，或使用其他某些激活选项（双击应用程序的文档、调用
特殊URL等）。随后将由ShellExperienceHost进程根据应用程序类型决定执行哪种类型的激活操作。</span></p>
</div><div class="header2"><h3><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>U</b><b>W</b><b>P</b><b>应</b><b>用</b><b>程</b><b>序</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">激活管理器
（activation 
manager）是管理此类激活的主要组件，它在ActivationManager.dll中实现，由于需要与用户桌面交互，因此运行在一个
sihost.exe服务中。激活管理器会与视图管理器（View 
Manager）进行严格的合作。现代菜单会通过RPC调用到激活管理器中，随后激活管理器会启动激活过程，大致流程如图8-45所示。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·获取需要激活的用户的SID、程序包家族ID以及程序包的PRAID。这样即可验证程序包是否真的在系统中注册（会用到依赖项小型存储库及其注册表缓存）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
如果上述检查发现需要注册程序包，则会调用到AppX 
Deployment客户端并开始注册程序包。在“按需注册”的情况下，可能需要注册某些程序包，例如应用程序已下载但尚未安装（这样可以节约时间，尤其
是在企业环境中），或者应用程序可能需要更新。激活管理器可以通过状态存储库得知具体是上述哪种情况。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·使用HAM注册应用程序，并为新程序包及其初始活动创建HAM主机。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·激活管理器与视图管理器（通过RPC）通信，进而对新会话的GUI激活进行初始化（就算后台激活也需要这样做，视图管理器始终需要获得相关通知）。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/7dc2bdc64ca80324b3162db93fd5a0b8.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图8-45 现代UWP应用程序激活流程</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·激活过程在DcomLaunch服务中继续，因为激活管理器在这一阶段会使用WinRT类启动底层进程创建过程。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·DcomLaunch
服务负责启动COM、DCOM和WinRT服务器以响应对象激活请求，它是在rpcss.dll库中实现的。DcomLaunch会记录激活请求并准备调
用CreateProcessAsUser这个Win32 
API。但在此之前，它还需要设置正确的进程属性（如程序包完整名称），以确保用户具备启动该应用程序的正确许可，随后还需要复制用户令牌，设置新的低完
整性级别，并用必需的安全属性添加戳记（请注意，DcomLaunch服务使用System账户运行，具备TCB特权。这种类型的令牌操作必须具备TCB
特权。详见卷1第7章）。随后，DcomLaunch会调用CreateProcessAsUser，通过进程的某个属性解析传递来的程序包完整名称，并
创建出一个已暂停进程。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
后续激活过程继续在Kernelbase.dll中进行。DcomLaunch产生的令牌依然不是AppContainer，但其中包含了UWP安全属
性。CreateProcessInternal函数中的一段特殊代码会使用依赖项小型存储库的注册表缓存收集与打包应用程序有关的下列信息：根文件夹、
程序包状态、AppContainer程序包SID，以及应用程序能力列表。随后它会验证许可未被篡改（很多游戏会用到该功能）。接下来，依赖项小型存储
库文件会被映射至父进程，并开始解析UWP应用程序DLL的替代加载路径。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
使用BasepCreateLowBox函数创建AppContainer令牌、它的对象名称空间以及符号链接，这些工作大部分都在用户模式下进行，但实
际的AppContainer令牌创建工作是使用NtCreateLowBoxToken内核函数进行的。有关AppContainer令牌的详细信息请
参阅卷1第7章。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·使用NtCreateUserProcess内核API照常创建内核进程对象。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·CSRSS子系统接到通知后，BasepPostSuccessAppXExtension函数会将依赖项小型存储库映射至子进程的PEB中，并将子进程与父进程解除映射。随后即可恢复主线程，借此启动新进程了。</span></p>
</div><div class="header2"><h3><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>C</b><b>e</b><b>n</b><b>t</b><b>e</b><b>n</b><b>n</b><b>i</b><b>a</b><b>l</b><b>应</b><b>用</b><b>程</b><b>序</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Centennial应用
程序的激活过程与UWP激活类似，但实现方式完全不同。对于这类激活，始终会由现代菜单ShellExperienceHost调用
Explorer.exe。Centennial激活类型涉及多个库（如Daxexec.dll、Twinui.dll以及
Windows.Storage.dll），并会在Explorer中进行映射。当Explorer收到激活请求后，它会获取程序包完整名称和应用程序
ID，并通过RPC从状态存储库获取主应用程序可执行文件路径和程序包属性。随后它会执行与UWP激活相似的步骤（步骤2～4）。但主要差异在于，
Centennial激活在这一阶段的操作并未使用DcomLaunch服务，而是会使用Shell32库的ShellExecute 
API启动进程。更新后的ShellExecute代码已经可以识别Centennial应用程序，进而可以（通过COM）使用
Windows.Storage.dll中的特殊激活过程。Windows.Storage.dll库可通过RPC调用AppInfo服务中的
RAiLaunchProcessWithIdentity函数。AppInfo可使用状态存储库验证应用程序许可和应用程序所有文件的完整性，随后调用
进程令牌。接着它会使用必要的安全属性为令牌添加戳记，并最终创建处于已暂停状态的进程。AppInfo可使用
PROC_THREAD_ATTRIBUTE_PACKAGE_FULL_NAME这个进程属性将程序包完整名称传递给
CreateProcessAsUser API。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与UWP不同的是，
Centennial激活完全不会创建AppContainer，AppInfo会调用DaxExec.dll的
PostCreateProcessDesktopAppXActivation函数来实现Centennial应用程序（注册表和文件系统）虚拟化层的
初始化。更多信息请参阅上文“Centennial应用程序”一节。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>通</b><b>过</b><b>命</b><b>令</b><b>行</b><b>激</b><b>活</b><b>现</b><b>代</b><b>应</b><b>用</b><b>程</b><b>序</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">借
助这个实验，我们可以更好地理解UWP与Centennial的差异，并发现选择使用ShellExecute 
API激活Centennial应用程序这种决定背后的动机。在这个实验中，我们需要安装至少一个Centennial应用程序。在撰写这部分内容时，我
们可以在Windows应用商店中通过一个简单的办法找出这种类型的应用程序。在商店中打开目标应用程序的详情页后，向下滚动页面打开“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>其</b><b>他</b><b>信</b><b>息</b></span>”选项。如果在“支持的语言”之前看到“此应用可以：使用全部系统资源”字样，就意味着这是一个Centennial类型的应用程序。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在这个实验中我们将使用Notepad++。请在Windows应用商店中搜索并安装“(unofficial) Notepad++”应用程序。随后打开相机应用和Notepad++。以管理员身份打开一个命令提示符窗口（可在搜索框中输入cmd，右键点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>命</b><b>令</b><b>提</b><b>示</b><b>符</b></span>”并选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>以</b><b>管</b><b>理</b><b>员</b><b>身</b><b>份</b><b>运</b><b>行</b></span>”）。随后使用下列命令查找这两个正在运行的打包应用程序的完整路径：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">wmic process where "name='WindowsCamera.exe'" get ExecutablePath </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">wmic process where "name='notepad++.exe’" get ExecutablePath </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">接着使用下列命令创建两个指向应用程序可执行文件的链接：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">mklink "%USERPROFILE%\Desktop\notepad.exe" "&lt;Notepad++ executable Full Path&gt;" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">mklink "%USERPROFILE%\Desktop\camera.exe" "&lt;WindowsCamera executable full path&gt; </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">将“&lt;”和“&gt;”符号之间的内容替换为通过前两个命令找出的，真正的可执行文件路径。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后即可关闭命令提示符和这两个应用程序。此时桌面上应该已经出现了两个新建的链接。与Notepad.exe链接不同，如果试图从桌面启动相机应用，则激活操作将会失败，Windows会显示类似下图这样的错误对话框。</span></p><div style="display: block;text-align:center;">
	<img width="853" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a1362c52d86d65c750551ff480ac212a.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">这
是因为Windows资源管理器会使用Shell32库激活可执行文件的链接。对于UWP应用程序，Shell32库完全不知道自己要启动的可执行文件是
一个UWP应用程序，因此它会在不指定任何程序包标识符的情况下调用CreateProcessAsUser 
API。然而，Shell32可以识别Centennial应用，因此整个激活过程可顺利完成，应用程序也可以正常启动。如果试图在命令提示符窗口中启动
这两个链接，则它们都将无法正确启动应用程序。这是因为命令提示符完全没有使用Shell32，而是会通过自己的代码直接调用CreateProcess
 API。该实验展示了每种类型打包应用程序的不同激活方式。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 从Windows 10 Creators Update（RS2）开始，现代应用程序模型已经可以支持可选程序包（optional 
package，内部将其称为RelatedSet）的概念。可选程序包在游戏中有着广泛应用，借此即可让主游戏支持DLC（扩展包）。一些软件套件也能
受益于此，Microsoft 
Office就是一个很好的例子。用户可以下载并安装Word，其中包含的框架程序包里面包括了Office的所有通用代码。随后当用户需要安装
Excel时，部署操作即可跳过主框架程序包的下载过程，因为Word可选程序包已经包含于Office的主框架。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">可选程序包通过清单文件与主程序包建立关联。清单文件（使用AMUID）包含了对主程序包的依赖声明。可选程序包架构的深入介绍已超出了本书范围。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>A</b><b>p</b><b>p</b><b>E</b><b>x</b><b>e</b><b>c</b><b>u</b><b>t</b><b>i</b><b>o</b><b>n</b><b>别</b><b>名</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，打包应用程序
不能直接通过可执行文件来激活。这会受到很大的局限，对新的现代控制台应用程序来说尤为严重。为了能通过命令行启动现代应用（Centennial和
UWP应用），从Windows 10 Fall Creators 
Update（版本1709）开始，现代应用程序模型引入了AppExecution别名的概念。借助这项新功能，用户可以通过控制台命令行启动Edge
或任何其他现代应用程序。本质上，AppExecution别名是一种0字节长度的可执行文件，位于C:\Users\&lt;UserName&gt;
\AppData\Local\Microsoft\WindowsApps（如图8-46所示）。该位置会被加入系统可执行文件搜索路径列表（通过
PATH环境变量实现），因此，若要运行现代应用程序，用户只需指定位于该文件夹中的可执行文件的文件名，无须像在“运行”对话框或控制台命令行中那样指
定完整路径。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/0c261d25dfb0ed5c3adf2deaace9e0f7.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图8-46 AppExecution别名的主文件夹</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">0字节的文件该如何执行？
这要归功于文件系统中一个鲜为人知的功能：重分析点。重分析点通常可用于创建符号链接，但其中不仅可以存储符号链接信息，也可以存储任何其他数据。现代应
用程序模型使用该功能将打包应用程序的激活数据（程序包家族名称、应用程序用户模型ID、应用程序路径）直接存储在重分析点中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当用户启动
AppExecution别名可执行文件时，会照常使用CreateProcess 
API。但用于编排内核模式进程创建的NtCreateUserProcess系统调用（详见卷1第3章“CreateProcess流程”一节）会失
败，因为该文件的内容为空。作为常规进程创建工作的一部分，文件系统会（通过IoCreateFileEx 
API）打开目标文件并（在分析路径的最后一个节点时）遇到重分析点数据，随后向调用方返回STATUS_REPARSE代码。
NtCreateUserProcess会将该代码转换为STATUS_IO_REPARSE_TAG_NOT_HANDLED错误并退出。借此，
CreateProcess API可以知道进程创建因为无效的重分析点而失败，因此会调用到ApiSetHost. 
AppExecutionAlias.dll库，该库包含了解析现代应用程序重分析点所需的代码。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">该库的代码解析重分析点，
得到了打包应用程序的激活数据。随后，为了用必要的安全属性为令牌添加戳记，还会调用AppInfo服务。AppInfo验证用户具备运行该打包应用程序
所需的许可，再通过状态存储库检查文件的完整性。实际的进程创建是由调用方进程完成的。CreateProcess 
API检测到重分析错误并使用正确的软件包可执行文件路径（通常位于C:\Program 
Files\WindowsApps\）重启动自己的执行过程。这一次，它可以正确地创建进程以及AppContainer令牌，或为
Centennial应用正确完成虚拟化层的初始化工作（实际上，对于Centennial应用，需要再次为AppInfo使用另一个RPC）。此外，它
还会创建应用程序所需的HAM主机及活动。至此，激活完成。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>读</b><b>取</b><b>A</b><b>p</b><b>p</b><b>E</b><b>x</b><b>e</b><b>c</b><b>u</b><b>t</b><b>i</b><b>o</b><b>n</b><b>别</b><b>名</b><b>数</b><b>据</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">这个实验将从0字节的可执行文件中提取AppExecution别名数据。我们可以使用本书随附资源提供的FsReparser实用工具解析重分析点或NTFS文件系统的扩展特性。直接在命令提示符窗口中运行该工具并指定命令行参数READ即可：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\Users\Andrea\AppData\Local\Microsoft\WindowsApps&gt;fsreparser read MicrosoftEdge.exe</span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File System Reparse Point /Extended Attributes Parser 0.1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright 2018 by Andrea Allievi (AaLl86) </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Reading UWP attributes... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Source file: MicrosoftEdge.exe. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">The source file does not contain any Extended Attributes. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">The file contains a valid UWP Reparse point (version 3). </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Package family name: Microsoft.MicrosoftEdge_8wekyb3d8bbwe </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Application User Model Id: Microsoft.MicrosoftEdge_8wekyb3d8bbwe!MicrosoftEdge</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">UWP App Target full path: C:\Windows\System32\SystemUWPLauncher.exe </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Alias Type: UWP Single Instance </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">从上述输出结果中可以看到，CreateProcess API可以提取正确执行现代应用程序激活操作所需的全部信息。这也解释了为何可以在命令行下启动Edge浏览器。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_72" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>1</b><b>1</b><b>.</b><b>9</b><b> </b><b>程</b><b>序</b><b>包</b><b>注</b><b>册</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">当用户安装现代应用程序
时，通常会在Windows应用商店查找应用程序并点击“获取”按钮。随后开始下载一个包含一系列文件的打包文件，其中包含程序包清单文件、应用程序的数
字签名，以及代表数字签名中不同证书之间信任链的块图（block 
map）。这个打包文件最初会存储在C:\Windows\SoftwareDistribution\Download文件夹中。AppStore进程
（WinStore.App.exe）还会与管理下载请求的Windows Update服务（wuaueng.dll）通信。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">下载的文件属于一种清单
（manifest），其中包含现代应用程序所有文件的列表、应用程序依赖项、许可数据，以及正确注册程序包所需执行的步骤。Windows 
Update服务可以识别出这是一个现代应用程序的下载请求，随后会验证调用方进程的令牌（应该是一个AppContainer），并使用
AppXDeploymentClient.dll库提供的服务验证该程序包是否已安装到系统中。随后它会创建一个AppX部署请求，并通过RPC将其发
送给AppX部署服务器。AppX部署服务器以PPL服务的形式运行在共享的服务宿主进程中（宿主进程甚至承载了以相同受保护级别运行的客户端许可服
务）。部署请求会被放入一个异步管理的队列。在AppX部署服务器看到这样的请求后，会将请求取消排队并创建一个线程，真正开始现代应用程序部署过程。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 从Windows 
8.1开始，UWP部署栈开始支持捆绑包（bundle）的概念。捆绑包是一种包含多种资源（例如只针对特定区域提供的不同语言或功能）的程序包。部署栈
实现了一种适用性逻辑，可在检查用户配置和系统设置后，只从压缩的捆绑包中下载真正需要的那部分文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">现代应用程序部署过程需要进行一系列复杂的活动，我们可以将部署过程分为下列三个主要阶段。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>阶</b><b>段</b><b>1</b><b>：</b><b>程</b><b>序</b><b>包</b><b>暂</b><b>存</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当Windows 
Update下载完应用程序清单后，AppX部署服务器会验证程序包的所有依赖性是否均得到满足，随后检查应用程序的先决条件，例如可支持的目标设备（手
机、台式计算机、Xbox等），并检查目标卷的文件系统是否被支持。应用程序的所有先决条件会与每个依赖项一起罗列在清单文件中。如果所有检查都成功通
过，暂存过程会创建程序包根目录（通常位于C:\Program 
Files\WindowsApps\&lt;PackageFullName&gt;）及其子文件夹。此外，暂存过程还会对这些目录应用适当的ACL以
便加以必要保护。对于Centennial类型的现代应用程序，则会加载daxexec.dll库并创建Windows容器隔离微过滤驱动程序所需的
VFS重分析点（详见上文“Centennial应用程序”一节），这是为了对应用程序数据文件夹进行正确的虚拟化。最后，它会将程序包跟路径保存到
HKLM\SOFTWARE\Classes\LocalSettings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Packages\&lt;PackageFullName&gt;
注册表键下的Path注册表值中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后，暂存过程会在磁盘上预分配应用程序的文件，计算最终需要下载的数据量，提取包含所有程序包文件（压缩为AppX文件）的服务器URL，最后，再次使用Windows Update服务从远程服务器下载AppX。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>阶</b><b>段</b><b>2</b><b>：</b><b>用</b><b>户</b><b>数</b><b>据</b><b>暂</b><b>存</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">该阶段仅在用户更新应用程序时才会执行。这个阶段只是简单地还原上一个程序包中的用户数据，并将其存储到新应用程序路径中。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>阶</b><b>段</b><b>3</b><b>：</b><b>程</b><b>序</b><b>包</b><b>注</b><b>册</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">程序包注册是部署过程中最
重要的阶段。这个复杂的阶段用到了AppXDeploymentExtensions.onecore.dll库提供的服务（以及
AppXDeploymentExtensions.desktop.dll为台式计算机上的部署提供的有关服务）。我们将其称为Package 
Core 
Installation（程序包核心安装）。在该阶段，AppX部署服务器主要负责更新状态存储库。它会在这个存储库中为程序包、程序包中包含的一个或
多个应用程序、新磁贴、程序包能力、程序包许可等内容创建新的项。为此，AppX部署服务器会用到数据库事务，但只有在没有出现任何错误的情况下，才会最
终提交这些事务（如果出错，那么事务会被丢弃）。当组成状态存储库部署操作的所有数据库事务都正确提交后，状态存储库即可调用已注册的侦听方，借此向每个
请求通知的客户端发出通知（有关状态存储库变更和事件跟踪的详情，请参阅“状态存储库”一节）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">程序包注册的最后一个步骤是创建依赖项小型存储库文件，并更新计算机的注册表以体现状态存储库中存储的新数据。部署过程至此结束。新应用程序已经可以激活并运行了。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
为了提高可读性，上述部署过程已进行了大幅简化。在上文所述的暂存阶段，我们省略了初始过程中的一些子阶段，例如用于解析AppX清单文件的索引阶段、用
于创建工作方案并分析程序包依赖性的依赖项管理器阶段，以及与PLM通信并验证程序包尚未安装或未在使用中的程序包使用中（package in 
use）阶段。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">此外，如果某个操作失败，部署栈必须能够撤销所有改动。上文也没有详细介绍其他撤销阶段。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter08_0012.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_73" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>8</b><b>.</b><b>1</b><b>2</b><b> </b><b>总</b><b>结</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">本章介绍了组成Windows执行体的一些关键基础系统机制。第9章将介绍为改善整体系统安全性，并且为虚拟机、隔离的容器以及安全隔区提供快速执行环境、Windows所支持的虚拟化技术。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter09.xhtml">
</div><div class="header0"><h1><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';display: block;text-align:center;"><b>第</b><b>9</b><b>章</b></span></h1></div>
<div class="part">
</div><div class="header0"><h1><span id="sigil_toc_id_74" style="font-size:22px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';display: block;text-align:center;"><b>虚</b><b>拟</b><b>化</b><b>技</b><b>术</b></span></h1></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟化是一种在同一台物理
计算机上同时运行多个操作系统的重要技术。在撰写这部分内容时，不同的硬件供应商已经提供了多种类型的虚拟化技术，这些技术经历了多年的发展和完善。虚拟
化技术不仅可在一台物理计算机上同时运行多个操作系统，同时也成为虚拟安全模式（Virtual Secure 
Mode，VSM）、虚拟机监控程序实施的代码完整性（Hypervisor-Enforced Code 
Integrity，HVCI）等重要安全功能的基础，这一切都离不开虚拟机监控程序（Hypervisor）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">本章将概要介绍
Windows虚拟化解决方案：Hyper-V。Hyper-V由虚拟机监控程序（负责管理与平台相关的虚拟化硬件）和虚拟化栈组成。我们会介绍
Hyper-V内部架构，并简要介绍其组件（内存管理器、虚拟处理器、拦截器、调度器等）。虚拟化栈建立在虚拟机监控程序之上，为根分区和客户机分区提供
了不同的服务。我们将介绍虚拟化栈所包含的全部组件（虚拟机工作进程、虚拟机管理服务、VID驱动程序、VMBus等），以及可支持的各种硬件模拟。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在本章最后，我们还将介绍一些基于虚拟化的技术，例如VSM和HVCI，同时还会介绍这些技术为系统带来的各种安全服务。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter09_0001.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_75" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>1</b><b> </b><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>虚</b><b>拟</b><b>机</b><b>监</b><b>控</b><b>程</b><b>序</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Hyper-V虚拟机监控
程序（也叫Windows虚拟机监控程序）是一种“一类”（原生或裸机）虚拟机监控程序：一种直接在主机硬件上运行的小型操作系统，借此管理一个根分区和
一个或多个客户机操作系统。与“二类”（托管式）虚拟机监控程序需要像常规应用程序那样在传统操作系统基础上运行的做法不同，Windows虚拟机监控程
序可对根操作系统进行抽象，而根操作系统知道虚拟机监控程序的存在，并能与其通信进而执行一个或多个客户虚拟机。由于虚拟机监控程序已包含在操作系统中，
可以管理内部运行的客户机，并能与客户机进行交互，因此虚拟机监控程序可以通过标准的管理机制（如WMI以及相关服务）与操作系统实现全面集成。在这种情
况下，根操作系统即可包含一些“启发”（Enlightenment）。启发是内核以及某些设备驱动程序中包含的一种特殊优化措施，它们可以检测到代码是
在虚拟机监控程序的管理下虚拟化运行的，进而能够考虑到环境的特征，以不同的或更高效的方式运行某些任务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图9-1展示了Windows虚拟化栈的基本架构，下面还将详细介绍其中的各个组件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">该架构的最底部是虚拟机监
控程序，它会在系统启动非常早期的阶段启动，随后即可提供虚拟化栈（通过Hypercall接口）使用的服务。虚拟机监控程序早期初始化过程的详细介绍可
参阅第12章。虚拟机监控程序的启动是由Windows加载器（Windows 
loader）发起的，它会决定是否要启动虚拟机监控程序以及安全内核，如果虚拟机监控程序和安全内核均已启动，则虚拟机监控程序会使用
Hvloader.dll提供的服务来检测正确的硬件平台，随后加载并启动适当版本的虚拟机监控程序。由于Intel和AMD（以及ARM64）处理器对
硬件辅助虚拟化技术有着不同的实现，因此需要不同的虚拟机监控程序。系统启动时，通过CPUID指令查询处理器后，便会选择正确的虚拟机监控程序。
Intel系统将加载Hvix64.exe二进制文件，AMD系统将使用Hvax64.exe映像。截至Windows 
10于2019年5月的更新（19H1），ARM64版本的Windows也开始支持自己的虚拟机监控程序，这是通过Hvaa64.exe映像实现的。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/2c5757886ba84b1e27ff6230604da640.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-1 Hyper-V架构栈（虚拟机监控程序和虚拟化栈）</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">从较高层面来看，虚拟机监
控程序所使用的硬件虚拟化扩展是一种介于操作系统内核与处理器之间的薄层。该层负责以安全的方式拦截并模拟操作系统执行的敏感操作，并且运行在比操作系统
内核更高的特权级别下（Intel将该模式称为VMXROOT，大部分书籍和文献将VMXROOT安全域定义为“Ring 
1”）。当底层操作系统执行的操作被拦截后，处理器会停止运行操作系统代码，并将执行转移给更高特权级别的虚拟机监控程序。这种操作通常被称为
VMEXIT事件。同样，当虚拟机监控程序处理完被拦截的操作后，需要通过某种方式让物理CPU重新执行操作系统代码。硬件虚拟化扩展已经定义了新的操作
码，借此可让VMENTER事件顺利发生，并让CPU以原先的特权级别重新开始执行操作系统代码。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_76" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>1</b><b>.</b><b>1</b><b> </b><b>分</b><b>区</b><b>、</b><b>进</b><b>程</b><b>和</b><b>线</b><b>程</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows虚拟机监控
程序背后有一个关键的架构性组件：分区（partition）。本质上，分区代表一种主要的隔离单元，或者操作系统所安装的一个实例，也可以指传统意义所
说的主机或客户机。但是在Windows虚拟机监控程序模型中并未使用这两种称呼，而是分别将其称为根分区和子分区。分区由一些物理内存、一个或多个虚拟
处理器（Virtual 
Processor，VP）及其本地虚拟APIC和计时器组成（在全局范围内，分区还可以包含一块虚拟主板和多个虚拟外设。但这些都是虚拟化栈的概念，并
不属于虚拟机监控程序）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">一个Hyper-V系统至
少包含一个根分区（主操作系统在根分区中控制计算机的运行）、虚拟化栈，以及其他相关组件。虚拟化环境中运行的每个操作系统都代表一个子分区，其中还可能
包含某些额外的工具，借此可优化硬件访问或实现操作系统管理功能。分区能够以一定的层次结构进行组织。根分区可以控制每个子分区，并能在子分区中发生某些
类型的事件后收到通知（拦截）。根分区中发生的大部分物理硬件访问可由虚拟机监控程序进行透传（passed 
through），这意味着父分区可以直接与硬件通信（但有些例外）。相对来说，子分区通常无法直接与物理计算机的硬件通信（同样存在一些例外，详见“虚
拟化栈”一节）。每个I/O都会被虚拟机监控程序所拦截，并在需要时重定向至根分区。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows虚拟机监控
程序的主要设计目标是，尽可能小巧并模块化，甚至需要类似某种微内核（Microkernel），但无须支持任何虚拟机监控程序驱动程序或提供完整的单体
式模块。这意味着大部分虚拟化工作实际上是由单独的虚拟化栈（参考图9-1）完成的。这个虚拟机监控程序可以使用现有的Windows驱动程序架构并与实
际的Windows设备驱动程序进行通信。这种架构导致需要通过多个组件提供并管理相应的行为，而这一切被统称为虚拟化栈。虽然虚拟机监控程序需要先于根
操作系统（以及父分区）从启动磁盘读取并由Windows加载器执行，但依然需要由父分区负责提供整个虚拟化栈。由于这些都是微软的组件，因此，只有
Windows计算机可能成为根分区。根分区中的Windows操作系统需要为系统中的硬件提供设备驱动程序，同时还需要负责运行虚拟化栈。同时，根分区
也是所有子分区的管理点。根分区包含的主要组件如图9-2所示。</span></p><div style="display: block;text-align:center;">
	<img width="437" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/fa24b321a3d0ee94a17a6975e3f55a41.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图9-2 根分区包含的主要组件</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>子</b><b>分</b><b>区</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">子分区是一个与父分区并行
运行的实例，其中可以运行任意操作系统（可以保存子分区状态或将其暂停，子分区不一定始终处于运行状态）。父分区需要完整访问APIC、I/O端口及其物
理内存（但无法访问虚拟机监控程序以及安全内核的物理内存），子分区与其不同，出于安全和管理方面的原因，子分区只能对自己的地址空间视图（客户机物理地
址，即GPA空间，由虚拟机监控程序负责管理）获得有限的访问，并且子分区无法直接访问硬件（不过子分区可以直接访问某些类型的设备，详见“虚拟化栈”一
节）。在虚拟机监控程序的访问方面，子分区也只能对通知和状态变更实现有限的访问。例如，子分区无法控制其他分区（也无法新建分区）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">子分区的虚拟化组件数量比父分区的少很多，因为子分区并不需要负责运行虚拟化栈，只需要与虚拟化栈通信即可。另外，这些组件是可选的，因为虽然这些组件有助于改善环境性能，但并非子分区运行所必不可少的。图9-3展示了典型的Windows子分区所包含的组件。</span></p><div style="display: block;text-align:center;">
	<img width="431" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/66badb7a41262fe25135280a0017b44c.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图9-3 Windows子分区包含的组件</span></p>
</div><div class="header2"><h3><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>进</b><b>程</b><b>和</b><b>线</b><b>程</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows虚拟机监控
程序使用分区数据结构代表虚拟机。如上文所述，分区包含一些内存（客户机物理内存）以及一个或多个虚拟处理器（VP）。在虚拟机监控程序内部，每个虚拟处
理器都是一个可调度的实体，而虚拟机监控程序与标准NT内核类似，也包含一个调度器。这个调度器会将隶属于不同分区的虚拟处理器执行工作分发给每个物理
CPU（“Hyper-V调度器”一节将详细介绍不同类型的虚拟机监控程序调度器）。虚拟机监控程序的线程（TH_THREAD数据结构）充当了虚拟处理
器及其可调度单元之间的“黏合剂”。图9-4展示了这种数据结构，该结构也代表了当前的物理执行上下文。其中包含线程执行栈、调度数据、一个指向线程虚拟
处理器的指针、线程调度循环（详见下文）入口点，以及最重要的一个指向线程所属虚拟机监控程序进程的指针。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机监控程序会为自己创建的每个虚拟处理器构建一个线程，并将新构建的线程与虚拟处理器数据结构（VM_VP）关联在一起。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图9-5所示的虚拟机监控
程序的进程（TH_PROCESS数据结构）代表了一个分区，同时这也是其物理和虚拟地址空间的容器。其中包含线程（由虚拟处理器所支撑）列表、调度数据
（有关哪些进程可以运行的物理CPU亲和性），以及一个指向分区基本内存数据结构（内存隔间、保留页面、页面目录根等）的指针。进程通常是在虚拟机监控程
序构建分区（VM_PARTITION数据结构）时创建的，这个进程将用于代表新的虚拟机。</span></p><div style="display: block;text-align:center;">
	<img width="263" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/9c037e5cc50d3a2d4a7870feb89f1132.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">▲图9-4 虚拟机监控程序的线程数据结构</span></p><div style="display: block;text-align:center;">
	<img width="263" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/f3d8a99a7408cb296088f2d35784e3ee.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">▲图9-5 虚拟机监控程序的进程数据结构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">启发启发是Windows
虚拟化技术中一种关键的性能优化措施。它可以看作对标准Windows内核代码直接进行的修改，借此即可检测到操作系统正在子分区中运行，进而以不同的方
式执行工作。通常来说，这些优化都是与特定硬件高度相关的，并会导致向虚拟机监控程序发出虚拟化调用（Hypercall）通知。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">例如，借此通知虚拟机监控
程序出现了长时间忙于等待的旋转循环。虚拟机监控程序可以在旋转等待过程中保持某些状态，并决定在同一个物理处理器上调度另一个虚拟处理器，直到等待满足
要求。进入和退出中断状态以及访问APIC的工作可由虚拟机监控程序进行协调，进而避免对真正的访问进行捕获和虚拟化。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">另一个例子与内存管理有
关，尤其是转换旁视缓冲区（Translation Lookaside 
Buffer，TLB）刷新（有关这些概念的详细介绍请参阅卷1第5章）。通常，操作系统会执行一条CPU指令来刷新一个或多个陈旧的TLB项，这只会影
响处理器。但在多处理器系统中，通常必须从每个活跃处理器的缓存中刷新TLB项（为此，系统会向每个活跃处理器发送一个处理器间中断）。然而，因为子分区
可能会与多个其他子分区共享相同的物理CPU，而在发起TLB刷新时，其中一些子分区可能正在执行不同虚拟机的虚拟处理器，该操作也会刷新这些虚拟机的信
息。此外，虚拟处理器可能被重新调度以便只执行TLB刷新IPI，这会导致明显的性能下降。通过虚拟机监控程序运行的Windows将发出虚拟化调用，让
虚拟机监控程序只刷新属于某个子分区的特定信息。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>分</b><b>区</b><b>的</b><b>特</b><b>权</b><b>、</b><b>属</b><b>性</b><b>和</b><b>版</b><b>本</b><b>功</b><b>能</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最开始创建分区时（通常由VID驱动程序创建）并不会关联虚拟处理器（VP），此时VID驱动程序可以自由地添加或删除分区的某些特权。实际上，在最开始创建分区时，虚拟机监控程序会根据分区类型为其分配一些默认特权。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">分区的特权决定了分区中运
行的被启发的操作系统可以代表该分区执行的操作（通常使用虚拟化调用或综合MSR（Model Specific 
Register，模型特定寄存器）来表示）。例如，Access Root 
Scheduler（访问根调度器）特权允许子分区通知根分区某事件已发出信号并可重新调度客户机的虚拟处理器（这通常会提高客户机虚拟处理器所支撑的线
程的优先级）。而Access VSM（访问VSM）特权可以让分区启用VTL 
1并访问其属性和配置信息（通常以综合寄存器的方式暴露）。表9-1列出了虚拟机监控程序默认分配的所有特权。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表9-1 分区的特权</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/11aab73885b04f397821b0c7e3917080.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/587d3766fce7eb783da9b0e2ecc6635e.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">分区特权只能在创建分区并启动虚拟处理器之前设置，当分区中的虚拟处理器开始执行后，虚拟机监控程序将不允许请求设置特权。分区属性与特权类似，但不存在这个限制，任何时候都可以设置或查询分区属性。每个分区可以查询或设置不同的属性组。表9-2列出了这些属性组。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表9-2 分区的属性</span></p><div style="display: block;text-align:center;">
	<img width="746" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ebccaeefb48a1cee9035bd35ec4d0a09.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当创建分区时，VID基础
架构会向虚拟机监控程序提供兼容性级别（可在虚拟机的配置文件中指定）。根据兼容性级别，虚拟机监控程序可以启用或禁用由虚拟处理器暴露给底层操作系统的
特定虚拟硬件功能。很多功能可以根据虚拟机的兼容性级别调整虚拟处理器的行为方式，例如硬件页属性表（Page Attribute 
Table，PAT），这是一种可配置的虚拟内存缓存类型。在Windows 10 Anniversary 
Update（RS1）之前，客户虚拟机内部无法使用PAT，因此无论虚拟机的兼容性级别是否指定了Windows 10 
RS1，虚拟机监控程序都不会向底层客户机操作系统暴露PAT寄存器。但如果兼容性级别高于Windows 10 
RS1，则虚拟机监控程序会向客户虚拟机中运行的底层操作系统暴露对PAT的支持。当系统启动并开始创建根分区时，虚拟机监控程序会为系统启用最高兼容性
级别。因此，根操作系统就可以使用物理硬件所能支持的全部功能。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_77" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>1</b><b>.</b><b>2</b><b> </b><b>虚</b><b>拟</b><b>机</b><b>监</b><b>控</b><b>程</b><b>序</b><b>的</b><b>启</b><b>动</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">第12章将介绍UEFI工作站的启动方式，以及在加载和启动正确版本的虚拟机监控程序二进制文件过程中所涉及的全部组件。本节将简要讨论当HvLoader模块执行过程转移给虚拟机监控程序，并由它首次开始控制计算机之后，计算机内部所发生的事情。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">HvLoader负责（根
据CPU制造商信息）加载正确版本的虚拟机监控程序二进制映像，并创建虚拟机监控程序加载器块。它会记录一个最小化的处理器上下文，这是虚拟机监控程序启
动第一个虚拟处理器所必需的。随后，HvLoader会切换至一个刚创建的全新地址空间，并调用虚拟机监控程序映像入口点
KiSystemStartup，以此将执行转移给虚拟机监控程序映像，让处理器准备好运行虚拟机监控程序并初始化CPU_PLS数据结构。
CPU_PLS代表物理处理器，可充当NT内核的PRCB数据结构，虚拟机监控程序可以使用GS段对其进行快速寻址。但与NT内核不同的是，
KiSystemStartup只对启动处理器进行调用（应用程序处理器的启动顺序将在“应用程序处理器启动”中进行介绍），因此这会将真正的初始化工作
推给另一个函数：BmpInitBootProcessor。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">BmpInitBootProcessor
会启动复杂的初始化序列。该函数将检查系统并查询CPU可支持的所有虚拟化功能（如EPT和VPID，可查询的功能与平台密切相关，并会因Intel、
AMD或ARM版本的虚拟机监控程序而异）。随后，该函数会确定虚拟机监控程序调度器，由该调度器管理虚拟机监控程序调度虚拟处理器的方式。对于
Intel和AMD服务器系统，默认调度器为核心调度器，而所有客户端系统（包括ARM64）的默认调度器是根调度器。调度器类型可通过BCD的
hypervisorschedulertype选项手动调整（下文将详细介绍不同的虚拟机监控程序调度器）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后会初始化嵌套的启发。
嵌套的启发可以让虚拟机监控程序以嵌套的配置来执行，其中根虚拟机监控程序（也叫L0虚拟机监控程序）管理真实硬件，另一个虚拟机监控程序（也叫L1虚拟
机监控程序）负责在虚拟机中执行。这一阶段完成后，BmpInitBootProcessor例程将执行下列组件的初始化工作：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·内存管理器（初始化PFN数据库和根隔间）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·虚拟机监控程序的硬件抽象层（HAL）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·虚拟机监控程序的进程和线程子系统（取决于所选调度器的类型）。此时将创建系统进程及其初始线程。这是一个特殊进程，不会与任何分区绑定，其中承载了执行虚拟机监控程序代码的线程。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·VMX
虚拟化抽象层（VAL）。VAL的用途是对所有可支持的硬件虚拟化扩展（Intel、AMD以及ARM64）之间的差异进行抽象。其中包含的代码还负责实
现虚拟机监控程序中所使用的计算机虚拟化技术与特定平台有关的功能（例如在Intel平台上，VAL层负责管理对“不受限客户机”的支持，以及EPT、
SGX、MBEC等功能）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·综合中断控制器（Synthetic Interrupt Controller，SynIC）以及I/O内存管理单元（I/O Memory Management Unit，IOMMU）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
地址管理器（Address 
Manager，AM），这个组件负责管理分配给分区的物理内存（也叫作客户机物理内存，即GPA）以及这种内存与真实物理内存（也叫作系统物理内存）之
间的转换。虽然Hyper-V的第一代实现可支持影子页表（一种用于地址转换的软件技术），但自从Windows 
8.1开始，可由地址管理器使用与特定平台相关的代码配置硬件所提供的虚拟机监控程序地址转换机制（Intel平台中称“可扩展页表”，AMD平台中
称“嵌套页表”）。在虚拟机监控程序的语境中，分区的物理地址空间也称地址域（address 
domain）。与具体平台无关的物理地址空间转换通常也称二级地址转换（Second Layer Address 
Translation，SLAT）。该术语实际上是指Intel的EPT、AMD的NPT或ARM的二级地址转换机制。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">至此，虚拟机监控程序已经
可以通过分配初始的、依赖于特定硬件的虚拟机控制结构（Intel为VMCS，AMD为VMCB），并通过第一个VMXON操作启用虚拟化，成功完成与启
动处理器相关的CPU_PLS数据结构的构建。最终，还会对每个处理器的中断映射数据结构进行初始化。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>连</b><b>接</b><b>虚</b><b>拟</b><b>机</b><b>监</b><b>控</b><b>程</b><b>序</b><b>调</b><b>试</b><b>器</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
这个实验中，我们将连接到虚拟机监控程序调试器，进而分析上文介绍过的虚拟机监控程序启动序列。虚拟机监控程序调试器只支持串口或网络传输，只能使用物理
计算机调试虚拟机监控程序，或者在启用“嵌套虚拟化”（详见“嵌套虚拟化”一节）的情况下进行调试。如果使用嵌套虚拟化，将只能为L1虚拟化的虚拟机监控
程序启用串口调试。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
这个实验中，我们需要单独准备一台支持虚拟化扩展、安装并启用了Hyper-V角色的物理计算机。我们需要使用该计算机作为被调试的系统，将其连接到运行
了调试工具（充当调试器）的宿主机系统。或者通过另一种方式，如果不想使用另外一台物理计算机，也可以使用嵌套的虚拟机，具体做法详见下文的“在
Hyper-V上启用嵌套虚拟化”实验。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">首
先我们需要在宿主机系统中下载并安装Windows调试工具，该工具已包含在Windows 
SDK（或WDK）中，可在https://developer.microsoft.com/windows/downloads/
windows-10-sdk下载。或者也可以在本实验中使用WinDbgX。截至撰写这段内容时，可在Windows应用商店搜索“WinDbg 
Preview”安装该工具。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">本
次实验中被调试的系统必须禁用“安全启动”（secure 
boot）。虚拟机监控程序调试功能无法兼容安全启动。有关禁用安全启动功能的具体做法请参考计算机的说明书（通常需要在UEFI 
Bios中调整Secure Boot设置）。若要在被调试的系统中启用虚拟机监控程序调试器，首先需要以管理员身份启动命令提示符窗口（在搜索框中输入<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>c</b><b>m</b><b>d</b></span>，选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>以</b><b>管</b><b>理</b><b>员</b><b>身</b><b>份</b><b>运</b><b>行</b><b>”</b></span>）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如
果要通过网卡调试虚拟机监控程序，则需要输入下列命令，将&lt;HostIp&gt;替换为宿主机系统的IP地址，将&lt;HostPort&gt;
替换为宿主机上一个有效的端口（始于49152），将&lt;NetCardBusParams&gt;替换为被调试系统的网卡总线参数，该参数需要以
XX.YY.ZZ的格式指定（其中XX是总线编号，YY是设备编号，ZZ是功能编号）。我们可以使用设备管理器或Windows 
SDK中提供的KDNET.exe工具查看网卡的总线参数：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">bcdedit /hypervisorsettings net hostip:&lt;<span style="font-size:14px;font-style: oblique;color:rgb(0, 0, 0);font-family:'Source Code Pro';"><i>H</i><i>o</i><i>s</i><i>t</i><i>I</i><i>p</i></span>&gt; port:&lt;<span style="font-size:14px;font-style: oblique;color:rgb(0, 0, 0);font-family:'Source Code Pro';"><i>H</i><i>o</i><i>s</i><i>t</i><i>P</i><i>o</i><i>r</i><i>t</i></span>&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">bcdedit /set {hypervisorsettings} hypervisordebugpages 1000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">bcdedit /set {hypervisorsettings} hypervisorbusparams &lt;<span style="font-size:14px;font-style: oblique;color:rgb(0, 0, 0);font-family:'Source Code Pro';"><i>N</i><i>e</i><i>t</i><i>C</i><i>a</i><i>r</i><i>d</i><i>B</i><i>u</i><i>s</i><i>P</i><i>a</i><i>r</i><i>a</i><i>m</i><i>s</i></span>&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">bcdedit /set hypervisordebug on </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">下图展示了一个范例系统，其中用于对虚拟机监控程序进行调试的网络接口位于0.25.0总线参数，调试器的调试目标为IP地址192.168.0.56、端口58010的宿主机系统。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b81914e0887b9098c9147b2e4cd7e108.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请记录返回的调试键。在重启动被调试的系统后，需要在宿主机中使用下列命令运行Windbg：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">windbg.exe -d -k net:port=&lt;HostPort&gt;,key=&lt;DebuggingKey&gt; </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">这样即可对虚拟机监控程序进行调试并查看其启动序列，不过微软可能不会公开虚拟机监控程序主模块的符号。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4d5e2f80b218d37910600ff51efc8cef.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在启用嵌套虚拟化的虚拟机中，可使用下列命令在被调试的系统中启用L1虚拟机监控程序调试器的串口调试：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">bcdedit /hypervisorsettings SERIAL DEBUGPORT:1 BAUDRATE:115200 </span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>创</b><b>建</b><b>根</b><b>分</b><b>区</b><b>和</b><b>启</b><b>动</b><b>虚</b><b>拟</b><b>处</b><b>理</b><b>器</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机监控程序完整初始化过程的第一步需要创建根分区和用于启动系统的第一个虚拟处理器（也叫BSP VP）。根分区与子分区的创建几乎遵循完全相同的规则，如此循序渐进地对每一层分区进行初始化。尤其是：</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）虚拟机层初始化可允许的最大数量VTL级别，并根据分区类型设置分区特权（详情请参阅上一节）。此外，虚拟机层还将根据特定分区的兼容性级别确定分区可允许的功能。根分区可支持最多数量的可允许功能。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）虚拟处理器层初始化虚拟化的CPUID数据，当客户机操作系统请求CPUID时，分区的所有虚拟处理器都将使用此数据。虚拟处理器层还会创建虚拟机监控程序进程，以此为分区提供支撑。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）地址管理器（AM）使
用与计算机平台相关的代码构建分区的初始物理地址空间（Intel的EPT或AMD的NPT）。所构建的物理地址空间取决于分区类型。根分区会使用标识映
射，这意味着所有客户机物理内存都会与系统物理内存相对应（更多信息详见“分区的物理地址空间”一节）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在为分区正确配置了SynIC、IOMMU以及拦截器的共享页面后，虚拟机监控程序会为根分区创建并启动BSP虚拟处理器，这是用于重新执行启动过程的唯一虚拟处理器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机监控程序虚拟处理器
（VP）可由图9-6所示的大型数据结构（VM_VP）来表示。VM_VP数据结构维护了跟踪虚拟处理器状态所需的全部数据：平台相关寄存器状态（如常规
用途、调试、XSAVE区域、栈）及其数据、虚拟处理器的私有地址空间，以及VM_VPLC数据结构数组，该数组可用于跟踪虚拟处理器的每个虚拟信任级别
（Virtual Trust 
Level，VTL）状态。VM_VP还包含一个指向虚拟处理器支撑线程的指针，以及一个指向目前执行虚拟处理器的物理处理器的指针。</span></p><div style="display: block;text-align:center;">
	<img width="573" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4dea5514329032a7c1ef9badca340847.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-6 代表一个虚拟处理器的VM_VP数据结构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于分区，BSP虚拟处理
器的创建过程与普通虚拟处理器的过程类似。由VmAllocateVp函数负责从分区的隔间中分配并初始化所需内存，借此存储VM_VP数据结构和分区中
与平台相关的部分，并存储VM_VPLC数组（支持的每个VTL对应一个数组）。启动时，虚拟机监控程序会将HvLoader指定的初始处理器上下文复制
到VM_VP结构，随后创建虚拟处理器的私有地址空间并进行附加（只有在启用了地址空间隔离功能后才需要这样做）。最后，还需要创建虚拟处理器的支撑线
程。这是一个重要步骤：虚拟处理器的构建工作还会在自己的支撑线程的上下文中继续进行。在这一阶段，虚拟机监控程序的主系统线程还会继续等待，直到新的
BSP 
VP初始化完成。等待过程中，虚拟机监控程序调度器会选择新创建的线程并执行ObConstructVp例程，借此在新的支撑线程的上下文中构建虚拟处理
器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ObConstructVp会通过类似于分区的方式构建并初始化虚拟处理器的每一层，尤其会执行下列操作：</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）虚拟化管理器（VM）层将物理处理器数据结构（CPU_PLS）附加至虚拟处理器并将VTL 0设置为活跃。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）VAL层初始化虚拟处
理器中与平台相关的部分，如寄存器、XSAVE区域、栈以及调试数据。此外，对于可支持的每个VTL，还需要分配并初始化VMCS数据结构（AMD系统则
为VMCB），该数据结构将被硬件用于跟踪虚拟机状态以及VTL的SLAT页表，后者使得每个VTL可以相互隔离（有关VTL的详情请参阅下文“虚拟信任
级别（VTL）和虚拟安全模式（VSM）”一节）。最后，VAL层启用VTL 
0并将其设置为活跃。特定于平台的VMCS（或AMD系统的VMCB）将被完全编译，VTL 
0的SLAT表会被设置为活跃，实模式模拟器初始化完成。VMCS中与主机状态有关的部分会被设置为以虚拟机监控程序VAL分发循环为目标。该例程是虚拟
机监控程序中最重要的部分，它管理着每个客户机生成的所有VMEXIT事件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）虚拟处理器层分配虚拟处理器的虚拟化调用页，并为每个VTL分配辅助和拦截消息页。这些页面将被虚拟机监控程序用于与客户机操作系统共享代码或数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当
ObConstructVp完成自己的工作后，虚拟处理器的调度线程会激活该虚拟处理器及其综合中断控制器（SynIC）。如果这是根分区的第一个虚拟处
理器，则调度线程会还原存储在VM_VP数据结构中的初始虚拟处理器上下文，为此需要在与平台相关的VMCS（或VMCB）处理器区域中写入所捕获的每个
寄存器（该上下文已被HvLoader在启动过程的早期阶段指定）。调度线程最终会发出代表虚拟处理器初始化工作完成的信号（随后主系统线程将进入闲置循
环状态），并进入特定平台的VAL调度循环。VAL调度循环检测到这是一个新的虚拟处理器，开始为其首次执行做准备，随后将执行VMLAUNCH指令启动
新虚拟机。新虚拟机会在HvLoader将执行转移至虚拟机监控程序的那一刻重新启动。后续的启动过程将照常进行，不过是在新的虚拟机监控程序分区上下文
中进行。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_78" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>1</b><b>.</b><b>3</b><b> </b><b>虚</b><b>拟</b><b>机</b><b>监</b><b>控</b><b>程</b><b>序</b><b>内</b><b>存</b><b>管</b><b>理</b><b>器</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">相比NT或安全内核的内存
管理器，虚拟机监控程序内存管理器相对较简单。虚拟机监控程序以内存隔间（memory 
compartment）为单位管理一系列物理内存页面。在虚拟机监控程序启动前，虚拟机监控程序加载器（Hvloader.dll）会分配虚拟机监控程
序加载器块，并预计算虚拟机监控程序正确启动和创建根分区所需的物理页面数量最大值。该数值取决于初始化IOMMU以存储内存范围结构、系统PFN数据
库、SLAT页表还有HAL 
VA空间所需的页面数量。虚拟机监控程序加载器会预分配计算出的物理页面数量最大值，将其标记为保留，并将这个页面列表的数组附加到加载器块。随后，当虚
拟机监控程序启动时，会使用由虚拟机监控程序加载器分配的页表创建根隔间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内存隔间的数据结构布局如
图9-7所示。该数据结构可跟踪隔间中“存档”的物理页面总数，随后这些页面可分配到某些地方或直接释放。隔间会将物理页面存储在按照NUMA节点进行排
序的各种列表中，但只有每个列表的头部会存储在隔间内。每个物理页面的状态及其在NUMA列表中的链接是通过PFN数据库中的项维持的。隔间还会跟踪自己
与根的关系。新隔间可以使用属于父分区（或根分区）的物理页面来创建。类似地，当隔间被删除后，所有残留的物理页面也会返回给父分区。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b86bf024e1966869c42469876f8b9325.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-7 虚拟机监控程序的内存隔间。全局区域的虚拟地址空间会从隔间数据结构的末端开始保留</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当虚拟机监控程序需要一些物理内存来执行某些工作时，会从活跃隔间（取决于具体分区）进行分配。这意味着该分配有可能失败。如果失败，则可能会出现如下两种情况。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果是为虚拟机监控程序的内部服务发出的分配请求（通常这是代表根分区进行的），则不应失败，而是应该让系统直接崩溃（这也解释了为何最初计算的要分配给根隔间的页面总数必须精确）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
如果是代表子分区进行的分配（通常通过虚拟化调用进行），则虚拟机监控程序会让请求失败并返回INSUFFICIENT_MEMORY状态。根分区检测到
该错误并分配一些物理页面（更多详情请参阅下文“虚拟化栈”一节），这些页面将通过HvDepositMemory虚拟化调用存入子隔间。随后即可重新初
始化分配操作，并且通常将会成功。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">从隔间分配的物理页面通常会使用虚拟地址映射至虚拟机监控程序。在创建隔间时，会分配一个足以映射新隔间、隔间的PDE位图及其全局区域的虚拟地址范围（大小为4GB或8GB，取决于这是根隔间还是子隔间）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机监控程序的区域
（zone）中可封装一个私有VA范围，该范围不会与虚拟机监控程序的整个地址空间共享（详见下文“地址空间隔离”一节）。虚拟机监控程序会使用一个根页
表来执行（与NT内核使用KVA影子的方法完全不同）。根页表中有两个保留项，保留的目的是在每个区域和虚拟处理器的地址空间之间动态切换。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>分</b><b>区</b><b>的</b><b>物</b><b>理</b><b>地</b><b>址</b><b>空</b><b>间</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如上一节所述，在最初创
建分区时，虚拟机监控程序会为之分配物理地址空间。物理地址空间包含硬件将分区的客户机物理地址（GPA）转换为系统物理地址（SPA）所需的全部数据结
构。实现这种转换的硬件功能通常称为二级地址转换（Second Level Address 
Translation，SLAT）。SLAT这个术语无关于具体平台，硬件制造商使用不同的名称来称呼它：Intel称之为EPT，即扩展页表
（Extended Page Table）；AMD称之为NPT，即嵌套页表（Nested Page 
Table）；AMD直接将其称为第2阶地址转换（Stage 2 Address Translation）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SLAT的实现方式通常与
x64页表的实现方式类似，用到了四级转换（x64虚拟地址转换的详细介绍请参阅卷1第5章）。分区中运行的操作系统会像在裸机硬件上运行那样使用相同的
虚拟地址转换。然而，对于分区中运行的操作系统，物理处理器通常需要执行两级转换：一级适用于虚拟地址，另一级用于转换物理地址。图9-8展示了客户机分
区的SLAT设置。在客户机分区中，GPA通常会被转换为不同的SPA。但根分区并不会这样做。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/2310b9d5226b1fa916f9f81f798362ec.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图9-8 客户机分区的地址转换</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机监控程序创建根分区
时，会通过标识映射建立初始物理地址空间。在这种模型下，每个GPA都对应于相同的SPA（例如，根分区中的客户机帧0x1000会映射至裸机物理帧
0x1000）。虚拟机监控程序会预分配将计算机完整物理地址空间映射至所有允许的根分区虚拟信任级别（VTL）所需的内存（具体数量由Windows加
载器使用UEFI服务发现，详见第12章），根分区通常支持两个VTL。分区所属每个VTL的SLAT页表包含相同的GPA和SPA项，但通常会设置不同
的保护级别。应用给每个分区物理帧的保护级别可用于创建互相隔离的不同安全域（VTL）。VTL的详细介绍请参阅“安全内核”一节。虚拟机监控程序页会被
标记为硬件保留，不会映射至分区的SLAT表（实际上，它们是通过一个指向假PFN的无效入口点来映射的）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
出于性能方面的考虑，虚拟机监控程序在构建物理内存映射时，可以检测大块的连续物理内存，并且会使用类似于虚拟内存那样的做法，使用大页面来映射这些块。
如果由于某种原因，分区中运行的操作系统决定对物理页面应用更细化的保护，那么虚拟机监控程序将使用保留的内存打破SLAT表中的大页面。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">老版本虚拟机监控程序还支持通过另一种技术来映射分区的物理地址空间：影子页（shadow paging）。影子页主要被不支持SLAT的计算机使用。该技术会产生极高的性能开销，因此现在已不再支持（在不支持SLAT的计算机上，虚拟机监控程序将拒绝启动）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">根的SLAT表是在创建分
区时构建的，但区客户机分区来说情况略有不同。在创建子分区时，虚拟机监控程序会为其创建初始物理地址空间，但只为每个分区的VTL分配根页表
（PML4）。在新虚拟机启动前，VID驱动程序（虚拟化栈的一部分）会通过从根分区分配的方式保留该虚拟机所需的物理页面，页面的具体数量取决于虚拟机
内存大小（请注意，这里说的是物理内存，只有驱动程序可以分配物理页面）。VID驱动程序维护着一个物理页面列表，该列表会被分析并拆分成大页面，随后通
过HvMapGpaPages这个Rep虚拟化调用
	<sup><img width="11" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="虚拟化调用（Hypercall）可分为两类：简单（Simple）和重复（Rep，Repeat的缩写）。简单虚拟化调用只能执行一个操作，其输入和输出参数集的大小是固定的。重复虚拟化调用可执行一系列简单虚拟化调用。除了可以使用固定大小的输入和输出参数集外，重复虚拟化调用还可以调用固定大小的输入和输出元素列表。——译者注" title="虚拟化调用（Hypercall）可分为两类：简单（Simple）和重复（Rep，Repeat的缩写）。简单虚拟化调用只能执行一个操作，其输入和输出参数集的大小是固定的。重复虚拟化调用可执行一系列简单虚拟化调用。除了可以使用固定大小的输入和输出参数集外，重复虚拟化调用还可以调用固定大小的输入和输出元素列表。——译者注" class="epub-footnote"></sup>发送给虚拟机监控程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在发送映射请求前，VID
驱动程序会调用虚拟机监控程序来创建所需的SLAT页表以及内部物理内存空间的数据结构。分区中每个可用VTL还会被分配SLAT页表层次结构（该操作也
叫预提交）。这个操作有可能失败，例如，新分区的隔间未包含足够的物理页面时。在这种情况下，根据上一节的介绍，VID驱动程序会从根分区分配更多的内
存，并将其存入子分区的隔间。随后，VID驱动程序就可以自由地映射子分区的所有物理页面。虚拟机监控程序会构建并编译所需的全部SLAT页表，并根据
VTL级别分配不同的保护（大页面需要的间接级别数量会少一个）。至此，子分区的物理地址空间创建工作完成。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>地</b><b>址</b><b>空</b><b>间</b><b>隔</b><b>离</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">现代CPU中发现的预测执
行漏洞（Meltdown、Spectre或Foreshadow）可以让攻击者通过推测性方式读取CPU缓存中的陈旧数据，进而读取到更高执行特权上下
文中保存的机密数据。这意味机客户虚拟机中运行的软件有可能以推测性方式，读取隶属于虚拟机监控程序或更高特权根分区的私有内存。Spectre、
Meltdown以及所有此类侧信道漏洞的技术细节以及Windows的缓解措施详见第8章。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通过实施
HyperClear缓解措施，虚拟机监控程序也可以缓解大部分此类攻击。HyperClear缓解措施依赖这三个关键组件来保证虚拟机之间的强隔离：核
心调度器、虚拟处理器地址空间隔离以及敏感数据擦除。在现代多核心CPU中，通常会由不同的SMT线程共享同一个CPU缓存（有关核心调度器和对称多线程
的详细介绍请参阅“Hyper-V调度器”一节）。在虚拟化环境中，一个核心中的SMT线程可以根据自己的活动，独立地进入或退出虚拟机监控程序上下文。
例如，中断之类的事件可能导致SMT线程宾客户机虚拟处理器上下文的运行中切出，并开始在虚拟机监控程序的上下文中运行。每个SMT线程都可能独立执行这
种操作，因此，一个SMT线程可能正在虚拟机监控程序上下文中执行，但同时其同胞SMT线程依然在虚拟机宾客户机虚拟处理器上下文中运行。借此，攻击者通
过一个SMT线程在信任度较低的虚拟机的虚拟处理器上下文中运行的代码，就有可能通过侧信道漏洞窃取同胞SMT线程运行的虚拟机监控程序上下文中所包含的
敏感数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机监控程序通过为每宾
客户机SMT线程（这种线程支撑了虚拟处理器）维持相互独立的虚拟地址范围，提供了强大的数据隔离机制，借此防范有恶意机客户虚拟机。当虚拟机监控程序上
下文进入特定的SMT线程时，任何机密数据都是无法寻址的。此时唯一可以进入CPU缓存的数据是与当宾客户机虚拟处理器相关联的数据，或虚拟机监控程序共
享的数据。如图9-9所示，当SMT线程运行的虚拟处理器进入虚拟机监控程序时，根调度器会强制要求其他虚拟处理器上正在运行的同胞LP必须属于同一个虚
拟机。此外，共享的机密数据也不会映射至虚拟机监控程序。当虚拟机监控程序需要访问机密数据时，需要保证其他同胞SMT线程中没有别的已调度虚拟处理器。</span></p><div style="display: block;text-align:center;">
	<img width="782" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/25364a5506f251db3d83279ae09ae834.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图9-9 HyperClear缓解措施</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与NT内核不同，虚拟机监
控程序总是通过一个页表根来运行，这就形成一个全局虚拟地址空间。虚拟机监控程序定义了私有地址空间的概念，但其名称容易让人误解。实际上，为了映射私有
地址空间或取消其映射，虚拟机监控程序保留了两个全局根页表项（PML4项，可生成一个1TB的虚拟地址范围）。虚拟机监控程序在最开始构建虚拟处理器
时，会分配两个私有页表根项。这些项将用于映射虚拟处理器的机密数据，例如，它的栈以及包含私有数据的数据结构。切换地址空间意味着在全局页表根中写入这
两个项（这也解释了为何“私有地址空间”的名称这么有误导性，实际上，该名称代表的是私有地址“范围”）。虚拟机监控程序只会在两种情况下切换私有地址空
间：新建虚拟处理器时，以及切换线程时（别忘了，线程是由虚拟处理器支撑的，而核心调度器会保证同胞SMT线程不会在不同的分区中执行虚拟处理器）。运行
过程中，虚拟机监控程序线程只会映射自己虚拟处理器的私有数据，而无法访问其他机密数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">私有地址空间中机密数据的映射是借助由MM_ZONE数据结构所代表的内存区域实现的。内存区域可以封装私有地址空间的私有VA子范围，虚拟机监控程序通常会将每个虚拟处理器的机密存储在这里。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种内存区域的工作方式与
私有地址空间类似。内存区域并不会映射全局页表根中的根页表项，而是会映射私有地址空间所使用的两个根项中包含的私有页目录。内存区域维持了一个页目录数
组，该数组可映射至私有地址空间或解除映射，此外还包含一个用于跟踪已使用页表的位图。图9-10展示了私有地址空间和内存区域之间的关系。内存区域可以
按需映射至私有地址空间或解除映射，但通常只会在创建虚拟处理器时切换。实际上，虚拟机监控程序无须在切换线程时切换内存区域，私有地址空间封装了内存区
域所暴露的VA范围。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e538ac9c6182663310a2957549ae2e6a.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-10 虚拟机监控程序的私有地址空间和私有内存区域</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在图9-10中，页表中与
私有地址空间有关的结构填充了斜线，与内存区域有关的结构显示为灰色，隶属于虚拟机监控程序的共享结构使用了虚线外框。私有地址空间的切换是一种开销很低
的操作，只需要更改虚拟机监控程序页表根中的两个PML4项。从私有地址空间附加或分离内存区域则只需要修改区域的PDPTE（区域的VA大小是可变的，
而PDTPE总是会连续分配）。</span></p>
</div><div class="header2"><h3><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>动</b><b>态</b><b>内</b><b>存</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机可按照百分率使用为
自己分配物理内存。例如，一些虚拟机只使用了为自己分配宾客户机物理内存中的一小部分，导致大量已分配物理内存被释放或归零。而当内存压力较高时，其他虚
拟机的性能可能会受到一定影响，因为分配宾客户机物理内存不足，导致需要大量使用页面文件。为了防止出现这种情况，虚拟机监控程序和虚拟化栈支持了动态内
存这一概念。动态内存是指以动态的方式为虚拟机分配或移除物理内存的功能。该功能由多个组件提供。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·NT内核的内存管理器，为物理内存的热添加和热移除提供了支持（这也适用于裸机系统）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·虚拟机监控程序，通过SLAT提供支持（由地址管理器负责管理）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·虚拟机工作进程，可使用动态内存控制器模块（Vmdynmem.dll）与子分区中运行的VMBus动态内存VSC驱动程序（Dmvsc.sys）建立的连接。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了准确介绍动态内存，我
们应该首先简要看看NT内核是如何创建页面帧编号（Page Frame 
Number，PFN）数据库的。Windows会使用PFN数据库跟踪物理内存，详细介绍可参阅卷1第5章。为了创建PFN数据库，NT内核首先需要计
算映射物理地址可能的最大值所需的理论大小（标准64位系统为256TB），随后将映射所需的VA空间完全标记为保留空间，并将基址存储到
MmPfnDatabase全局变量中。请注意，这个保留的VA空间中目前尚未分配页表。NT内核会（使用UEFI服务）在启动管理器所发现的物理内存描
述符之间循环，将它们聚合在尽可能长的范围内，并使用大页面为每个范围映射底层的PFN数据库项。这会产生一个非常重要的含义：如图9-11所示，PFN
数据库拥有最大可能的物理内存数量，但只有其中很小的一个子集会被映射至真正的物理内存（这种技术也叫作稀疏内存）。</span></p><div style="display: block;text-align:center;">
	<img width="580" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/afa41e33f5b36f37e03c1061ebcfb474.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-11 部分物理内存被移除后的PFN数据库范例</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">物理内存热添加和热移除的
实现要归功于这一原则。将新的物理内存添加到系统后，即插即用内存驱动程序（Pnpmem.sys）检测到这一情况并调用NT内核导出的
MmAddPhysicalMemory例程。该例程会启动一个复杂的过程来计算新范围中确切的页数以及这些页面所属的NUMA节点，随后在保留的VA区
域中创建必要的页表，借此将新的PFN项映射至数据库。随后新增的物理页面会被加入空闲列表（详见卷1第5章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当一些物理内存被热移除
后，系统会执行一个相反的过程：首先检查这些页面所属的正确物理页面列表，更新内部内存计数器（例如物理页面的总数），最终释放对应的PFN项，意味着这
些项会被标记为“损坏”。随后，内存管理器将永远不再使用带有这种标记的物理页面。实际的虚拟空间不会从PFN数据库中解除映射，释放的PFN所描述的物
理内存还可以在未来重新添加。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">被启发的虚拟机启动后，动
态内存驱动程序（Dmvsc.sys）会检测这个子虚拟机是否支持热添加功能。如果支持，该驱动程序会创建一个工作线程来协商协议并连接到VSP的
VMBus通道（有关VSC和VSP的详情请参阅“虚拟化栈”一节）。VMBus连接通道可以将子分区中运行的动态内存驱动程序连接至动态内存控制器模块
（Vmdynmem.dll），该模块会在根分区的虚拟机工作进程中进行映射。随后将启动一个消息交换协议。在每一秒，子分区通过查询内存管理器暴露的各
种性能计数器（全局页面文件使用量、可用/已提交/脏页面数量、每秒页面错误数量、已释放和已归零页面列表中的页面数量）来获得一份内存压力报告，该报告
随后会发送给根分区。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">根分区中的虚拟机工作进程
会使用VMMS均衡器（VmCompute服务的一个组件）暴露出的服务进行必要的计算，借此判断需要执行热添加操作的概率。如果根分区的内存状态支持热
添加操作，则VMMS均衡器会计算需要存入子分区的页面数量，并通过COM回调虚拟机工作进程，由该进程在VID驱动程序的协助下开始执行热添加操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）在根分区中保留适当数量的物理内存。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）调用虚拟机监控程序，借此将根分区保留的系统物理页面映射至子虚拟机中映射的某些客户机物理页面，并设置必要的保护。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）向动态内存驱动程序发送一条消息，进而针对虚拟机监控程序先前映射的客户机物理页面执行热添加操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">子分区中的动态内存驱动程序会使用NT内核暴露出的MmAddPhysicalMemory API来执行热添加操作。该API可以映射PFN数据库中用于描述新增客户机物理内存的PFN项，并在需要时为该数据库添加新的支撑页面。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通过类似方式，当VMMS
均衡器检测到子虚拟机有大量的可用物理页面时，可能会要求子分区（依然通过虚拟机工作进程来要求）热移除某些物理页面。动态内存驱动程序会使用
MmRemovePhysicalMemory 
API执行热移除操作。NT内核会验证均衡器所指定范围内的每个页面已经处于归零或空闲列表中，或这些页面位于可以安全换出的栈中。如果所有条件都适用，
那么动态内存驱动程序会将“热移除”页面范围重新发送回虚拟机工作进程，该进程会使用VID驱动程序提供的服务从子分区中解除对这些物理页面的映射，并将
其释放回NT内核。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 启用嵌套虚拟化之后将无法支持动态内存功能。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_79" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>1</b><b>.</b><b>4</b><b> </b><b>H</b><b>y</b><b>p</b><b>e</b><b>r</b><b>-</b><b>V</b><b>调</b><b>度</b><b>器</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机监控程序是一种在根
分区的操作系统（Windows）中运行的微型操作系统。因此，它能决定哪个线程（支撑了虚拟处理器）应该由哪个物理处理器执行。如果系统中运行了多个虚
拟机，并且虚拟机所使用的虚拟处理器的总数已经超过物理处理器的数量，那么这个功能更为重要。虚拟机监控程序调度器的作用是：在当前分配的时间切片结束
后，选择在物理CPU上执行的下一个线程。Hyper-V 
可以使用三种调度器。为了正确管理所有这些调度器，虚拟机监控程序暴露了调度器API，以及一系列可以进入虚拟机监控程序调度器的例程。它们的唯一用途是
将API调用重定向至特定的调度器实现。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>控</b><b>制</b><b>虚</b><b>拟</b><b>机</b><b>监</b><b>控</b><b>程</b><b>序</b><b>的</b><b>调</b><b>度</b><b>器</b><b>类</b><b>型</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">客户端版本的Windows默认会使用根调度器启动，而Windows Server 2019默认使用核心调度器运行。在这个实验中，我们将查看自己系统所启用的虚拟机监控程序调度器，并了解如何在从下次重启动系统时切换至其他虚拟机监控程序调度器。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">Windows虚拟机监控程序会在确定要启用的调度器后记录一条系统事件。我们可以使用事件查看器工具搜索已记录的事件，为此请在搜索框中输入<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>e</b><b>v</b><b>e</b><b>n</b><b>t</b><b>v</b><b>w</b><b>r</b></span>。启动事件查看器后，请展开“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>日</b><b>志</b></span>”节点并点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>系</b><b>统</b><b>日</b><b>志</b></span>”。随后请搜索ID为2、事件来源为Hyper-V-Hypervisor的事件。请点击窗口右侧的“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>过</b><b>滤</b><b>当</b><b>前</b><b>日</b><b>志</b></span>”按钮，或点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>事</b><b>件</b></span>ID”列，随后即可用ID降序排列所有事件（该操作可能需要执行一段时间）。双击找到的事件，即可看到类似下图所示的窗口。</span></p><div style="display: block;text-align:center;">
	<img width="859" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/193b90108f18434ca474b6b30574d2b4.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">ID为2的事件揭示了所使用的虚拟机监控程序调度器类型，其中：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">1 = 经典调度器，SMT被禁用</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">2 = 经典调度器</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">3 = 核心调度器</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">4 = 根调度器</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">上述示例截图来自一台运行Windows Server的系统，该系统默认使用核心调度器运行。若要将调度器类型改为经典（或根）调度器，请以管理员身份打开命令提示符窗口（在搜索框中输入<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>c</b><b>m</b><b>d</b></span>，并选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>以</b><b>管</b><b>理</b><b>员</b><b>身</b><b>份</b><b>运</b><b>行</b></span>”），随后运行下列命令：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">bcdedit /set hypervisorschedulertype &lt;<span style="font-size:14px;font-style: oblique;color:rgb(0, 0, 0);font-family:'Source Code Pro';"><i>T</i><i>y</i><i>p</i><i>e</i></span>&gt; </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">其
中：&lt;Type&gt;设置为“Classic”可使用经典调度器，设置为“Core”可使用核心调度器，设置为“Root”可使用根调度器。设置
完毕后需要重启动系统并再次查看新生成的来自Hyper-V-Hypervisor、ID为2的事件。也可以在使用管理员身份运行的PowerShell
窗口中使用下列命令查看当前启用的虚拟机监控程序调度器：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Get-WinEvent -FilterHashTable @{ProviderName="Microsoft-Windows-Hyper-V-</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Hypervisor"; ID=2} -MaxEvents 1 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">上述命令可从系统事件日志中提取最新的ID为2的事件。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/6adc22ae8fe2d24d79f4966308b780cc.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>经</b><b>典</b><b>调</b><b>度</b><b>器</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">自Hyper-V发布以
来，所有版本的Hyper-V都默认使用经典调度器。经典调度器在默认配置中实现了一种简单的轮询策略，让当前执行状态（执行状态取决于系统中运行的虚拟
机总数）中的任何虚拟处理器都能获得相等的调度概率。经典调度器还支持为虚拟处理器设置相关性，并在考虑到物理处理器NUMA节点的情况下执行调度决策。
经典调度器不知道客户虚拟处理器当前在执行什么，唯一的例外由自旋锁启发来定义。当分区中运行的Windows内核要针对自旋锁执行主动等待时，会发出一
个虚拟化调用，借此通知虚拟机监控程序（高IRQL同步机制详见第8章）。经典调度器可以抢占当前执行的虚拟处理器（如果该虚拟处理器尚未用完分配给自己
的时间切片）并能调度另一个虚拟处理器。借此即可节省活跃CPU的旋转周期。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">经典调度器默认为每个虚拟
处理器分配相等的时间切片。这意味着在超额订阅了较高工作负载的系统中，因为有多个虚拟处理器会试图执行，而物理处理器已经非常繁忙，性能可能会快速降
低。为了解决这种问题，经典调度器支持多种调优选项（如图9-12所示），借此可修改其内部的调度决策。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>虚</b><b>拟</b><b>处</b><b>理</b><b>器</b><b>保</b><b>留</b></span>。用户可以代表客户机提前保留CPU容量。通过这种保留，可以指定当客户机被调度运行时，为该计算机预留的物理处理器的容量百分比。借此，Hyper-V只会在CPU可用容量最小值满足该比例时才会调度虚拟处理器运行（这意味着提供可保证的已分配时间切片）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>虚</b><b>拟</b><b>处</b><b>理</b><b>器</b><b>限</b><b>制</b></span>。与虚拟处理器保留类似，用户也可以限制虚拟处理器可以使用的物理CPU容量比例。这意味着在高负载情况下，会减少分配给特定虚拟处理器的可用时间切片。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>虚</b><b>拟</b><b>处</b><b>理</b><b>器</b><b>权</b><b>重</b></span>。
该选项控制了当保留条件被满足时，虚拟处理器能被调度的概率。在默认配置中，每个虚拟处理器具备相等的执行概率。当用户对某个虚拟机所属的虚拟处理器配置
了权重后，会根据用户选择的相对权重系数来决定调度决策。例如，假设一个包含四个CPU的系统需要同时运行三个虚拟机，第一个虚拟机的权重系数为100，
第二个为200，第三个为300。假设系统的所有物理处理器都分配了统一数量的虚拟处理器，那么第一个虚拟机的虚拟处理器被调度的概率就是17%，第二个
虚拟机的为33%，第三个虚拟机的为50%。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/874a81163979fca2cb6107177142bf94.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-12 经典调度器的调优设置属性页，该页面仅在启用经典调度器的情况下可用</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>核</b><b>心</b><b>调</b><b>度</b><b>器</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通常来说，传统CPU的核
心只有一条执行流水线，指令流会通过这条流水线一个接一个地执行。一个指令进入管道，通过包含多个环节的步骤（如加载数据、计算、存储数据）执行处理，随
后从管道中退出。不同类型的指令会用到CPU核心的不同部分。现代CPU的核心通常能以乱序（相对于进入管道的顺序而言属于“乱序”）的方式执行指令流中
的多个连续指令。支持乱序执行的现代CPU通常会实现一种名为对称多线程（Symmetric 
MultiThreading，SMT）的机制：CPU的一个核心有两个执行管线，会向系统提供一个以上的逻辑处理器，因此，可通过一个共享的执行引擎以
并排的方式执行两个指令流（如缓存等核心资源是共享使用的）。这两个执行流水线可作为一个独立处理器（CPU）暴露给软件。从现在开始，我们将使用逻辑处
理器（LP）这个术语来代表SMT核心暴露给Windows、可充当独立CPU使用的执行流水线（SMT详见卷1第2章和第4章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种硬件实现导致了很多安
全问题：由一个共享的逻辑CPU执行的指令可能干扰并影响其他同胞LP所执行的指令。此外，因为物理核心的缓存也是共享的，LP将能修改缓存内容，导致其
他同胞CPU有可能通过测量处理器访问同一个缓存行内存寻址所花费的时间来探测缓存中存储的数据，进而窥探其他逻辑处理器所访问的“机密数据”（详见第8
章中的“侧信道攻击”一节）。经典调度器通常可以选择属于不同虚拟机的两个线程，随后由同一个处理器核心的两个逻辑处理器执行。这显然是不可接受的，因为
在这种情况下，第一个虚拟机可能会读取到其他虚拟机的数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了解决这个问题，并且为
了以可预测的性能运行启用SMT的虚拟机，Windows Server 
2016引入了核心调度器。核心调度器可以利用SMT属性为客户机虚拟处理器提供隔离和更强的安全边界。启用核心调度器后，Hyper-V会将虚拟核心调
度到物理核心上，并能保证属于不同虚拟机的虚拟处理器永远不会调度到物理核心的同胞SMT线程上。核心调度器使得虚拟机能够更充分地使用SMT。暴露给虚
拟机的虚拟处理器可以是一个SMT集的组成部分，客户虚拟机中运行的操作系统和应用程序可以使用SMT行为和编程接口（API）控制SMT线程并实现跨线
程调度，一切与非虚拟化方式下的运行完全一样。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图9-13展示了在两个
CPU核心上分布了四个逻辑处理器的SMT系统范例。图中运行了三个虚拟机，第一个和第二个虚拟机各有四个虚拟处理器，这四个虚拟处理器各自组成两组，而
第三个虚拟机只有一个虚拟处理器。虚拟机中的虚拟处理器组分别标记为A、B、C、D和E。每个组中的闲置虚拟处理器（未执行代码）被填充为较深的颜色。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e449ec30a0dbf579cd63f528227faadf.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-13 包含两个处理器核心，运行了三个虚拟机的SMT系统范例</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每个核心有一个运行列表，
其中包含了准备执行的虚拟处理器组；此外还有一个延迟列表，其中包含了准备运行但尚未添加到核心运行列表的虚拟处理器组。虚拟处理器组会在物理核心上执
行。如果一个组中的所有虚拟处理器都处于闲置状态，该虚拟处理器组会被取消调度，不再出现在任何运行列表中（图9-13中的虚拟处理器组D就是这种情
况）。虚拟处理器组E刚刚脱离了闲置状态，其中的虚拟处理器被分配到CPU核心 
2。图9-13中还显示了一个假的同胞虚拟处理器，这是因为核心2的逻辑处理器从未调度过其他任何虚拟处理器，而该核心的同胞逻辑处理器正在执行隶属于虚
拟机3的虚拟处理器。同样，如果逻辑处理器组中的一个虚拟处理器变为闲置但其他虚拟处理器依然在执行（例如组A），其他虚拟处理器也不会调度到物理核心
上。每个核心会执行自己运行列表中处于首位的虚拟处理器组。如果没有可执行的虚拟处理器组，核心将变为闲置状态，开始等待虚拟处理器组被放入自己的延迟运
行列表。发生这种情况后，核心会从闲置状态唤醒并清空自己的延迟运行列表，将内容放入自己的运行列表中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">核心调度器是由不同组件实
现的（见图9-14），这些组件之间实现了严格的分层。核心调度器的中心是调度单元，它可代表一个虚拟核心或一组SMT虚拟处理器（对于非SMT虚拟机，
可代表一个虚拟处理器）。根据虚拟机的类型，调度单元可绑定一个或两个线程。虚拟机监控程序的进程拥有一个调度单元列表，该列表拥有为虚拟机的虚拟处理器
提供支撑的线程。调度单元是核心调度器进行调度的一种单位，运行期间，调度设置（如保留、权重以及上限）都将应用到调度单元这一层面上。在时间切片时段
内，调度单元始终维持活跃，可被阻断并解除阻断，可在不同的物理处理器核心之间迁移。这方面有个重要概念：调度单元类似于经典调度器中的线程，但不具备可
在其中运行的栈或虚拟处理器上下文。调度单元是与运行在物理处理器核心上的调度单元绑定的线程之一，线程组调度器则是每个调度单元的仲裁者。作为一种实
体，仲裁者决定了活跃调度单元中的哪个线程会被物理处理器核心中的哪个逻辑处理器执行，它会执行线程的相关性，应用线程调度策略，并更新每个线程的相关计
数器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">物理处理器核心的每个逻辑
处理器都包含一个与之相关的逻辑处理器调度程序实例。逻辑处理器调度程序负责切换线程、维持计时器并为当前线程刷新VMCS（或VMCB，取决于具体架
构）。逻辑处理器调度程序由核心调度程序所拥有，每个核心调度程序代表物理处理器上的一个核心，拥有两个SMT逻辑处理器。核心调度程序管理着当前活跃的
调度单元。单元调度器会被绑定给自己的核心调度程序，它决定了接下来将由哪个调度单元在单元调度器所属的物理处理器核心上运行。调度管理器是核心调度器的
最后一个重要组件，它拥有系统中所有的单元调度器，并对其状态有一个全局的视图。它可以为单元调度器提供负载均衡和理想核心分配服务。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>根</b><b>调</b><b>度</b><b>器</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">根调度器（也叫集成调度
器）最初在Windows 
10于2018年4月的更新（RS4）中引入，旨在让根分区能够调度隶属于客户机分区的虚拟处理器（VP）。根调度器的设计目标是为Windows 
Defender应用程序防护所使用的轻量级容器提供支持。此类容器（内部称之为Barcelona容器或Krypton容器）必须由根分区管理，并应尽
可能减少对内存和存储空间的用量（有关Krypton容器的详细介绍已超出了本书内容范围。有关服务器容器的详细介绍请参阅卷1第3章）。此外，根操作系
统调度器可以随时收集有关容器内部工作负载CPU利用率的指标，并将这些数据作为输入，应用于系统中所有其他工作负载的相同调度策略。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/8c34385044c2aaa8dbd230f77f327bee.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图9-14 核心调度器的组件</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">根分区操作系统实例中的
NT调度器管理着系统逻辑处理器调度工作的方方面面。为此，VID驱动程序内部的集成调度器根组件会在根分区内部（新VMMEM进程的上下文中）为每个客
户机虚拟处理器创建一个虚拟处理器调度线程（本章下文将详细介绍VA支持的虚拟机）。根分区中的NT调度器会将虚拟处理器调度线程作为常规线程对象那样进
行调度，但会遵守VM/VP特定调度策略和启发。每个VP调度线程会运行一个VP调度循环，直到VID驱动程序终止对应的虚拟处理器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当虚拟机工作线程
（VMWP，详见本章下文“虚拟化栈”一节）通过SETUP_PARTITION 
IOCTL请求创建了分区和虚拟处理器后，VID驱动程序将创建VP调度线程。VID驱动程序会与WinHvr驱动程序通信，后者将初始化虚拟机监控程序
的客户机分区创建工作（通过HvCreatePartition虚拟化调用）。如果所创建的分区代表由VA支持的虚拟机，或系统中的根调度器处于活跃状
态，VID驱动程序将通过一个内核扩展调用NT内核，借此创建与新建客户机分区关联的VMMEM最小进程。VID驱动程序还会为属于该分区的每个虚拟处理
器创建一个VP调度线程。该VP调度线程是在VID驱动程序以及WinHvr中实现的，会在内核模式下通过VMMEM进程的上下文执行（VMMEM中不包
含用户模式代码）。如图9-15所示，每个VP调度线程会运行一个VP调度循环，直到VID终止相应的虚拟处理器，或客户机分区产生了拦截。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/33a065fb714548767e76188befa16169.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-15 根调度器的VP调度线程以及负责处理虚拟机监控程序消息的相关VmWp工作线程</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在VP调度循环中，VP调度线程负责下列工作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）调用虚拟机监控程序新
增的HvDispatchVp虚拟化调用接口，以将VP调度到当前处理器。在每个HvDispatchVp虚拟化调用中，虚拟机监控程序会试图将上下文从
当前根VP切换至指定的客户机VP并让它运行客户机代码。这个虚拟化调用最重要的特征之一在于：它发出的代码应该以PASSIVE_LEVEL 
IRQL级别运行。虚拟机监控程序会让客户机VP持续运行，直到VP自愿阻塞、VP为根生成了一个拦截，或产生了一个以根VP为目标的中断。时钟中断依然
由根分区处理。当客户机VP耗尽分配给自己的所有时间切片后，该VP支撑的线程会被NT调度器抢占。发生上述三种事件中的任何一个后，虚拟机监控程序都会
重新切换回根VP并完成HvDispatchVp虚拟化调用，随后返回到根分区。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）如果虚拟机监控程序中
相应的VP被阻塞，则会阻塞VP调度事件。当客户机VP在任何时候自愿被阻塞时，VP调度线程都会在VP调度事件上阻塞自身，直到虚拟机监控程序解除对相
应客户机VP的阻塞并通知VID驱动程序。VID驱动程序会向VP调度事件发信号，随后NT调度器解除对VP调度线程的阻塞，从而可以进行另一个
HvDispatchVp虚拟化调用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）在从调度虚拟化调用返
回时，处理由虚拟机监控程序报告的所有拦截。如果客户机虚拟处理器为根生成了拦截，VP调度线程将在从HvDispatchVp虚拟化调用返回时处理该拦
截请求，并在VID处理完该拦截后发出另一个HvDispatchVp请求。每个拦截的管理方式各异。如果拦截需要由用户模式的VMWP进程处理，
WinHvr驱动程序会退出循环并返回到VID，VID可以为提供支撑的VMWP线程发送事件信号，并等待拦截消息被VMWP进程处理，随后才会重新启动
循环。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了正确地将发给VP调度
线程的信号从虚拟机监控程序交付给根，集成调度器提供了一种调度器消息交换机制。虚拟机监控程序会通过共享页面向根分区发送调度器消息。当新消息准备好交
付时，虚拟机监控程序会向根分区注入一个SINT中断，根分区会将其交付给WinHvr驱动程序中相应的ISR处理程序，由该处理程序将消息路由至VID
拦截回调（VidInterceptIsrCallback）。该拦截回调会试图直接处理来自VID驱动程序的拦截消息。如果无法直接处理，则会向一个同
步事件发送信号，借此让调度循环退出，进而让一个VmWp工作线程在用户模式下调度该拦截。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">相比虚拟机监控程序的其他
调度器实现，在启用根调度器的情况下，上下文切换会产生较高的开销。例如当系统在两个客户机虚拟处理器之间切换时，总是需要产生两个到根分区的出口。集成
调度器会以不同方式处理虚拟机监控程序的根VP线程和客户机VP线程（尽管在内部，它们由同一个TH_THREAD数据结构表示）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·只有根VP线程可以让客户机VP线程在自己的物理处理器上排队。根VP线程的优先级高于正在运行或已调度的任何客户机VP。如果根VP未被阻塞，集成调度器会尝试着尽快将上下文切换至根VP线程。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·客户机VP线程有两组状态：线程内部状态和线程根状态。线程根状态反映了虚拟机监控程序与根分区通信所用的VP调度线程的状态。集成调度器为每个客户机VP线程维持了这些状态，借此可以知道何时为相应的VP调度线程向根发送唤醒信号。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">只有根VP可以对自己处理
器上的客户机VP进行调度。这一点得以实现，可能是由于HvDispatchVp虚拟化调用的存在（这种情况下，我们可以说虚拟机监控程序正在处理“外部
工作”），或者其他虚拟化调用需要向目标客户机VP发送同步请求（这就是所谓的“内部工作”）。如果客户机VP最后一次运行于当前物理处理器上，调度器即
可立即调度客户机VP线程。否则调度器需要向客户机VP最后运行使用的处理器发送一个刷新请求，并等待远程处理器刷新VP上下文。后一种情况也叫作“迁
移”，这种情况需要由虚拟机监控程序（借助线程本地状态和根状态，这里不再详述）进行跟踪。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>操</b><b>作</b><b>根</b><b>调</b><b>度</b><b>器</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">NT
调度器决定何时选择并运行隶属于某个虚拟机的虚拟处理器，以及需要运行多久。该实验将演示上文讨论过的情况：所有VP调度线程都会在由VID驱动程序创建
的VMMEM进程上下文中执行。若要完成该实验，我们需要一台安装Windows 
10的2018年4月更新（RS4）或后续版本系统的计算机，在该计算机中安装Hyper-V角色，并创建一台安装了操作系统、可以正常运行的虚拟机。创
建虚拟机的详细过程请参阅https://docs.microsoft.com/virtualization/hyper-v-on-
windows/quick-start/quick-create-virtual-machine。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">首先我们需要确认根调度器已启用。本章“控制虚拟机监控程序的调度器类型”实验中介绍了具体做法。实验所用的虚拟机应处于关机状态。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">右击任务栏并选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>任</b><b>务</b><b>管</b><b>理</b><b>器</b></span>”以打开任务管理器窗口，随后点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>详</b><b>细</b><b>信</b><b>息</b></span>”</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">选
项卡，确认运行中的活跃VMMEM进程数量。如果没有虚拟机正在运行，那么应该不会出现该进程。如果安装了Windows 
Defender应用程序防护（WDAG）角色，那么应该有一个现有的VMMEM进程实例，该进程承载了预加载的WDAG容器（此类虚拟机会在下文“VA
支持的虚拟机”一节详细介绍）。如果VMMEM进程实例已存在，请留意它的进程ID（PID）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在搜索框中输入<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>H</b><b>y</b><b>p</b><b>e</b><b>r</b><b>-</b><b>V</b><b> </b><b>M</b><b>a</b><b>n</b><b>a</b><b>g</b><b>e</b><b>r</b></span>后打开Hyper-V管理器，并启动虚拟机。虚拟机和客户机操作系统成功启动后，重新切换到任务管理器并查找新出现的VMMEM进程。点击这个新增的VMMEM进程并展开“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>用</b><b>户</b><b>名</b></span>”一列，随后可以看到该进程已经关联给以该虚拟机GUID作为用户名的令牌。我们可以在管理员身份运行的PowerShell窗口中通过下列命令获取自己虚拟机的GUID（请将“&lt;VmName&gt;”替换为虚拟机的名称）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Get-VM -VmName "&lt;<span style="font-size:14px;font-style: oblique;color:rgb(0, 0, 0);font-family:'Source Code Pro';"><i>V</i><i>m</i><i>N</i><i>a</i><i>m</i><i>e</i></span>&gt;" | ft VMName, VmId</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">虚拟机ID与VMMEM进程的用户名应该相同，如下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/441a5b2fda578210b421b0420c502f98.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">安
装Process 
Explorer（可从https://docs.microsoft.com/sysinternals/downloads/process- 
explorer 下载）并以管理员身份运行。搜索上一步确定的正确VMMEM进程的PID（本例中为27312），右击并选择<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>S</b><b>u</b><b>s</b><b>p</b><b>e</b><b>n</b><b>d</b></span>。VMMEM进程的CPU选项卡随后会显示“Suspended”，而不再显示正确的CPU时间。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">重
新切换回该虚拟机会发现，虚拟机会无法响应并且彻底卡住。根源是我们刚才挂起的进程，它承载了该虚拟机所包含的所有虚拟处理器的调度线程。这会导致NT内
核无法调度这些线程，进而也就使得WinHvr驱动程序无法发出恢复VP执行所需的HvDispatchVp虚拟化调用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如果右键点击挂起的VMMEM并选择<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>R</b><b>e</b><b>s</b><b>u</b><b>m</b><b>e</b></span>，该虚拟机即可恢复执行并继续正常运行。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_80" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>1</b><b>.</b><b>5</b><b> </b><b>虚</b><b>拟</b><b>化</b><b>调</b><b>用</b><b>和</b><b>虚</b><b>拟</b><b>机</b><b>监</b><b>控</b><b>程</b><b>序</b><b>T</b><b>L</b><b>F</b><b>S</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟化调用为根分区或子分
区中运行的操作系统提供了一种从虚拟机监控程序中请求服务的机制。虚拟化调用有一套明确定义的输入和输出参数。虚拟机监控程序顶级功能规范（Top 
Level Functional 
Specification，TLFS）可在线获取（https://docs.microsoft.com/virtualization/
hyper-v-on-windows/reference/tlfs），该规范定义了在指定这些参数时不同的调用惯例。此外，它还列出了虚拟机监控程序
所有公开可用的功能、分区属性、虚拟机监控程序，以及VSM接口。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟化调用之所以可用，是
因为与平台无关的操作码（Opcode）的存在（Intel系统中叫作VMCALL，AMD系统中叫作VMMCALL，ARM64中叫作HVC），调用这
种操作码会导致虚拟机监控程序产生VM_EXIT。VM_EXIT是一个事件，会导致虚拟机监控程序重启动以在虚拟机监控程序特权级别下执行自己的代码，
这一特权级别高于系统中运行的任何其他软件（固件的SMM上下文除外），在这一过程中，虚拟处理器处于挂起状态。很多情况下会产生VM_EXIT事件。在
特定平台的VMCS（或VMCB）不透明数据结构中，可以通过硬件维护的一个索引记录VM_EXIT的退出原因。如果是因为虚拟化调用引起了退出，那么当
虚拟机监控程序得到该索引后，它会读取调用方（对于64位的Intel和AMD系统，通常来自于CPU的通用寄存器RCX）指定的虚拟化调用输入值。虚拟
化调用的输入值（请参考图9-16）是一个64位值，指定了虚拟化调用代码、属性，以及用于该虚拟化调用的调用约定。调用约定分为三类。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>标</b><b>准</b><b>虚</b><b>拟</b><b>化</b><b>调</b><b>用</b></span>。在8字节对齐的客户机物理地址（GPS）中存储输入和输出参数。操作系统会通过通用寄存器（Intel和AMD 64位平台上的RDX和R8）传递这两个地址。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>快</b><b>速</b><b>虚</b><b>拟</b><b>化</b><b>调</b><b>用</b></span>。通常不允许使用输出参数，而是使用标准虚拟化调用中所用的那两个通用寄存器，只将输入参数传递给虚拟机监控程序（最大16字节）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>可</b><b>扩</b><b>展</b><b>快</b><b>速</b><b>虚</b><b>拟</b><b>化</b><b>调</b><b>用</b></span>（或XMM快速虚拟化调用）。与快速虚拟化调用类似，但此类调用会使用额外的6个浮点寄存器，以便让调用方传输最大112字节的输入参数。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ebe07eebcd69dc39a47837f252fcfe77.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-16 虚拟化调用输入值（来自虚拟机监控程序TLFS）</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟化调用分为两类：简单
和重复。简单虚拟化调用只能执行一个操作，其输入和输出参数集的大小是固定的。重复虚拟化调用可以执行一系列简单虚拟化调用。当调用方使用重复虚拟化调用
时，可以通过Rep计数器代表输入或输出元素列表中包含的元素数量。调用方还可以指定Rep起始索引，借此代表要使用的下一个输入或输出参数。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">所有虚拟化调用都可以返回另一个名为虚拟化调用结果值的64位值（如图9-17所示）。一般来说，结果值描述了操作的结果，但重复虚拟化调用的结果值描述了已完成的总次数。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/f18cd90a68d95137f5eed2cb9daa18c1.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-17 虚拟化调用结果值（来自虚拟机监控程序TLFS）</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟化调用的完成需要花费
一些时间。对主机来说，保留一个不会接收中断的物理CPU是一种危险的做法。例如，Windows会通过一个机制检测CPU是否在超过16毫秒的时间里没
有接收其时钟周期中断。如果检测到这种情况，系统会停止运行并显示蓝屏死机（BSOD）错误。因此对于某些虚拟化调用（包括全部的重复虚拟化调用），虚拟
机监控程序会依赖一种虚拟化调用延续机制。如果一个虚拟化调用无法在规定时间（通常为50毫秒）内完成，控制权将（通过一种名为VM_ENTRY的操作）
返回给调用方，但指令指针不会越过调用该虚拟化调用的指令。借此，尚未完成的中断即可继续处理，并能继续调度其他虚拟处理器。当最初的调用方线程恢复执行
后，即可重新执行虚拟化调用指令，借此推动操作继续完成。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">驱动程序通常绝对不会直接通过平台相关的操作码发出虚拟化调用。相反，驱动程序会使用Windows虚拟机监控程序接口驱动程序所暴露的服务。该驱动程序分为两个版本。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>W</b><b>i</b><b>n</b><b>H</b><b>v</b><b>r</b><b>.</b><b>s</b><b>y</b><b>s</b></span>。如果操作系统在根分区中运行并且暴露了可供根分区和子分区使用的虚拟化调用，那么该驱动程序会在系统启动时加载。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>W</b><b>i</b><b>n</b><b>H</b><b>v</b><b>.</b><b>s</b><b>y</b><b>s</b></span>。只在操作系统在子分区中运行时加载，暴露了仅供子分区使用的虚拟化调用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟化栈广泛使用了Windows虚拟机监控程序接口驱动程序所导出的例程和数据结构，尤其是VID驱动程序，正如上文所述，它在整个Hyper-V平台中起到了关键作用。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_81" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>1</b><b>.</b><b>6</b><b> </b><b>拦</b><b>截</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">根分区应该能创建一种虚拟
环境，进而让未经修改的（为了在物理硬件上运行而开发的）客户机操作系统能够在虚拟机监控程序的客户机分区中顺利运行。这种传统客户机可能会试图访问虚拟
机监控程序分区中并不存在的物理设备（如访问某些I/O端口或写入特定MSR）。对于这种情况，虚拟机监控程序提供了主机拦截设施。当客户虚拟机的虚拟处
理器执行某些指令或生成某些异常时，获得授权的根分区可以拦截这些事件，并改变被拦截指令的效果，对子分区来说，这种行为反映了自己对于物理硬件预期想要
实现的行为。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">子分区发生拦截事件后，其
虚拟处理器会被暂停，综合中断控制器（Synthetic Interrupt 
Controller，SynIC，详见下文）会从虚拟机监控程序向根分区发送拦截消息。该消息的成功接收离不开虚拟机监控程序的综合ISR
（Interrupt Service 
Routine，中断服务例程），如果系统被启发并在虚拟机监控程序中运行，NT内核会在启动过程的阶段0安装该服务（详见第12章）。虚拟机监控程序的
综合ISR（KiHvInterrupt）通常会安装在向量0x30处，可将其执行转换为外部回调，而VID驱动程序在启动时已注册完毕（通过暴露的NT
内核API：HvlRegisterInterruptCallback）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">VID驱动程序也是一种拦
截驱动程序，这意味着它可以向虚拟机监控程序注册主机拦截，进而接收发生在子分区中的所有拦截事件。分区初始化完成后，虚拟机工作进程会为虚拟化栈的多种
组件注册拦截（例如为虚拟机的每个虚拟COM端口注册虚拟主板寄存器I/O拦截）。它会向VID驱动程序发送一个IOCTL，借此使用
HvInstallIntercept这个虚拟化调用为子分区安装拦截。当子分区产生拦截后，虚拟机监控程序会暂停虚拟处理器并向根分区注入一个综合中
断，该中断由KiHvInterrupt这个ISR负责管理。后者会将执行转移到已注册的VID中断回调，这个回调则会管理事件，并清除被暂停虚拟处理器
的中断暂停综合寄存器，借此重新启动虚拟处理器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机监控程序支持对子分区中的下列事件进行拦截。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·访问I/O端口（读取或写入）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·访问虚拟处理器的MSR（读取或写入）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·执行CPUID指令。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·异常。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·访问通用寄存器。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·虚拟化调用。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_82" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>1</b><b>.</b><b>7</b><b> </b><b>综</b><b>合</b><b>中</b><b>断</b><b>控</b><b>制</b><b>器</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机监控程序会通过综合
中断控制器（SynIC）对根分区和客户机分区的中断和异常进行虚拟化，而SynIC是本地APIC进行虚拟化后的扩展（有关APIC的详情，请参阅
Intel或AMD软件开发者手册）。SynIC负责将虚拟中断调度给虚拟处理器（VP）。调度到分区的中断可分为两类：外部中断与综合中断（综合中断也
可以叫作内部中断或直接称之为虚拟中断）。外部中断来自其他分区或设备；综合中断来自虚拟机监控程序本身，以分区的VP为目标。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在分区中创建VP后，虚拟
机监控程序会为可支持的每个VTL创建并初始化一个SynIC，随后会启动VTL 
0的SynIC，这意味着会在VMCS（或VMCB）硬件数据结构中对物理CPU的APIC启用虚拟化。在处理外部硬件中断时，虚拟机监控程序支持三类
APIC虚拟化。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
在标准配置下，APIC会通过事件注入硬件支持进行虚拟化。这意味着分区每次访问虚拟处理器的本地APIC寄存器、I/O端口或MSR（对于
x2APIC）时，都会产生一个VMEXIT，导致虚拟机监控程序代码通过SynIC调度中断，最终这会导致通过操作VMCS/VMCB不透明字段将事
件“注入”到正确的客户机虚拟处理器（这是在通过类似物理APIC的逻辑决定该中断是否可交付之后发生的）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·APIC
模拟模式的工作方式与标准配置类似。硬件发送的每个物理中断（通常通过IOAPIC发送）依然会导致VMEXIT，但虚拟机监控程序不会注入任何事件，而
是会操作处理器所使用的一个虚拟APIC页，以便对APIC寄存器的某些访问进行虚拟化。当虚拟机监控程序希望注入事件时，则会直接操作映射至该虚拟
APIC页的某些虚拟寄存器。当VMENTRY发生时，事件由硬件交付。与此同时，如果客户机VP操作了自己本地APIC的某些部分，则不会产生任何
VMEXIT，但相关改动会被存储在虚拟APIC页中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
发布的中断允许某些类型的外部中断直接交付给客户机分区，而无须产生任何VMEXIT。借此即可将直接访问设备直接映射到子分区，且不会由于VMEXIT
造成任何性能损失。物理处理器在处理虚拟中断时，会直接将它们记录为虚拟APIC页中的“挂起”（详见Intel或AMD的软件开发者手册）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当虚拟机监控程序启动一个
处理器时，通常会初始化物理处理器的综合中断控制器模块（由CPU_PLS数据结构表示）。物理处理器的SynIC模块是一个由中断描述符组成的数组，借
此可在物理中断和虚拟中断之间建立联系。如图9-18所示，虚拟机监控程序中断描述符（IDT项）包含了SynIC正确调度中断所需的数据，尤其是要将中
断交付给的实体（如分区、虚拟机监控程序、假中断）、目标VP（根、子、多VP或综合中断）、中断向量、目标VTL，以及其他与中断有关的特征。</span></p><div style="display: block;text-align:center;">
	<img width="263" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/731ac489a940fb2be28b9b50d5b27469.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图9-18 虚拟机监控程序物理中断描述符</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在默认配置中，所有中断都会交付给VTL 0的根分区或虚拟机监控程序本身（在第二种情况下，中断项将会是Hypervisor Reserved）。只有在直接访问设备被映射到子分区后，外部中断才能交付给客户机分区，例如NVMe设备就是一个很好的例子。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每次选择一个由线程支撑的
虚拟处理器来执行时，虚拟机监控程序都会检查是否需要交付一个（或多个）综合中断。如上文所述，综合中断不由任何硬件生成，通常由虚拟机监控程序自身产生
（需要满足某些条件），并且依然接受SynIC的管理，因此虚拟中断可以注入正确的虚拟处理器中。尽管它们被NT内核广泛使用（启发的时钟计时器就是一个
很好的例子），但综合中断已成为虚拟安全模式（Virtual Secure 
Mode，VSM）的基础。该功能的详细信息请参阅本章下文“安全内核”一节。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">根分区可以使用HvAssertVirtualInterrupt这个虚拟化调用（详见TLFS）向子分区发送自定义的虚拟中断。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>分</b><b>区</b><b>间</b><b>通</b><b>信</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">综合中断控制器还在为虚拟
机提供分区间通信设施方面发挥了重要作用。虚拟机监控程序为不同分区之间的通信提供了两种主要机制：消息和事件。这两者都可以使用综合中断将通知发送给目
标虚拟处理器。消息和事件可以通过预分配的连接从源分区发送到目标分区，而该连接有一个相互关联的目标端口。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">使用SynIC提供的分区
间通信服务的组件有很多，VMBus是其中最重要的组件之一（VMBus架构的详细介绍请参阅本章下文“虚拟化栈”一节）。根中的VMBus根驱动程序
（Vmbusr.sys）会分配一个端口ID（端口可由一个32位的ID识别），并通过WinHv驱动程序提供的服务发出HvCreatePort虚拟化
调用，借此在子分区中创建端口。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">端口是在虚拟机监控程序中
从接收方的内存池里分配的。创建端口时，虚拟机监控程序会从端口内存中分配16个消息缓冲区。在虚拟处理器的SynIC中，这些消息缓冲区通过一个与
SINT（Synthetic Interrupt 
Source，综合中断源）相关联的队列进行维护。虚拟机监控程序暴露了16个中断源，借此VMBus根驱动程序最多可以管理16个消息队列。一条综合消
息的大小为固定的256字节，但只能传输240字节的内容（其中16字节被用作消息头）。HvCreatePort虚拟化调用的调用方可以决定以哪些虚拟
处理器和SINT为目标。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了正确接收消息，
WinHv驱动程序会分配一个综合中断消息页（SIMP），并将其与虚拟机监控程序共享。当一条消息为目标分区排队时，虚拟机监控程序会将消息从其内部队
列复制到正确的SINT所对应的SIMP槽。随后，VMBus根驱动程序会创建一个连接，并通过HvConnectPort虚拟化调用将子虚拟机中打开的
端口关联给父虚拟机。当子虚拟机在正确的SINT槽中启用了对综合中断的接收后，即可开始通信，发送方可以指定目标端口ID并发出
HvPostMessage虚拟化调用，借此将消息发布给客户端。虚拟机监控程序会向目标虚拟处理器注入一个综合中断，进而可以从消息页（SIMP）中读
取消息内容。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机监控程序支持三种类型的端口和连接。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>消</b><b>息</b><b>端</b><b>口</b></span>。可以向分区或从分区传输240字节的消息。消息端口与父分区和子分区的一个SINT相关联，消息可通过一个端口消息队列依次传递。这一特性使得消息很适合用于VMBus通道的设置和拆除（详见本章下文“虚拟化栈”一节）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>事</b><b>件</b><b>端</b><b>口</b></span>。
可接收与一组标记相关的简单中断，这些标记由虚拟机监控程序在对端发出HvSignalEvent虚拟化调用时设置。此类端口通常被用作一种同步机制。例
如VMBus可以使用事件端口通知消息已被发布到某个特定通道所描述的唤醒缓冲区中。当事件中断传递到目标分区后，接收方可以确切得知该中断的目标通道是
什么，而这都要归功于与事件相关联的标记。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>监</b><b>视</b><b>器</b><b>端</b><b>口</b></span>。
这是对事件端口的进一步优化。为每个HvSignalEvent虚拟化调用产生VMEXIT并进行虚拟机上下文切换是一种开销很高的操作。监视器端口在设
置时可在虚拟机监控程序和分区之间分配一个共享页面，其中包含的数据结构可指出哪个事件端口与特定的被监视通知标记（页面中的一个“位”）相关联。这样，
当源分区希望发出同步中断时，只需在共享页面中设置对应的标记即可。虚拟机监控程序迟早会注意到共享页面中设置的这个“位”，并触发一个到该事件端口的中
断。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_83" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>1</b><b>.</b><b>8</b><b> </b><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>虚</b><b>拟</b><b>机</b><b>监</b><b>控</b><b>程</b><b>序</b><b>平</b><b>台</b><b>A</b><b>P</b><b>I</b><b>和</b><b>E</b><b>X</b><b>O</b><b>分</b><b>区</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows正在越来越
多地将Hyper-V虚拟机监控程序用在与传统的虚拟机运行无关的其他功能中。尤其是，正如本章第二部分将要讨论的那样，作为现代Windows版本中一
个重要的安全组件，VSM就可以利用虚拟机监控程序，为提供关键系统服务或处理密码等机密信息的功能实现更高程度的隔离。若要启用这些功能，计算机上必须
默认运行了虚拟机监控程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">外部的虚拟化产品（如
VMware、Qemu、VirtualBox、Android 
Emulator等）使用硬件提供的虚拟化扩展构建了自己的虚拟机监控程序，这也是此类产品正常运行所必需的。但这些虚拟机监控程序并不能兼容
Hyper-V，Hyper-V需要在根分区中的Windows内核启动前就启动自己的虚拟机监控程序（Windows虚拟机监控程序是一种原生的，
或“裸机”形式的虚拟机监控程序）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与Hyper-V类似，外部虚拟化解决方案也由虚拟机监控程序和虚拟化栈组成，其中虚拟机监控程序为处理器的执行和虚拟机的内存管理提供底层抽象，虚拟化栈则包含虚拟化解决方案为虚拟机提供模拟环境所需的组件（如虚拟机的主板、固件、存储控制器、设备等）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows虚拟机监控
程序平台API（详见https://docs.microsoft.com/virtualization/api/）的主要目标是在Windows虚
拟机监控程序上运行第三方虚拟化解决方案。具体来说，第三方虚拟化产品应当能创建、删除、启动和停止虚拟机，而相关特征（固件、模拟设备、存储控制器）则
由自己的虚拟化栈所定义。第三方虚拟化栈及其管理接口依然可以在根分区的Windows中运行，进而使其客户能照常使用自己的虚拟机。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如图9-19所示，Windows虚拟机监控程序平台的所有API都运行在用户模式下，并通过WinHvPlatform.dll和WinHvEmulation.dll这两个库在VID与WinHvr驱动程序的基础上实现（后者实现了MMIO的指令模拟器）。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/1f85f7176fc269e544dc12cbc1b8527a.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-19 Windows虚拟机监控程序平台API架构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">用户模式应用程序通常可按照下列流程创建虚拟机及相关的虚拟处理器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）使用WHvCreatePartition API在VID库（Vid.dll）中创建分区。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）使用WHvSetPartitionProperty API配置各种内部分区属性（如虚拟处理器数量、APIC仿真模式、请求的VMEXIT种类等）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）使用WHvSetupPartition API在VID驱动程序和虚拟机监控程序中创建分区（虚拟机监控程序中的此类分区也叫作EXO分区，下文很快将会介绍）。该API还可创建分区的虚拟处理器，创建的虚拟处理器将处于暂停状态。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）使用WHvCreateVirtualProcessor API在VID库中创建相应的虚拟处理器。这一步很重要，因为该API设置了一个消息缓冲区并将其映射到用户模式应用程序，借此才能在虚拟机监控程序与运行虚拟CPU的线程之间实现异步通信。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">5）通过经典的
VirtualAlloc函数（详见本书卷1第5章）预留一个大范围的虚拟内存，借此分配分区所需的地址空间，该空间还会通过
WHvMapGpaRange 
API在虚拟机监控程序中进行映射。在客户机虚拟地址空间中分配客户机物理内存时，可提交保留虚拟内存的不同范围，借此为客户机物理内存提供更细化的保
护。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">6）创建页表并复制已提交内存中的初始固件代码。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">7）使用WHvSetVirtualProcessorRegisters API设置初始虚拟处理器的寄存器内容。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">8）调用WHvRunVirtualProcessor阻止API来运行虚拟处理器。只有当客户机代码执行的操作需要在虚拟化栈中处理时（虚拟机监控程序中的VMEXIT明确要求由第三方虚拟化栈来管理），或者出现了外部请求时（如销毁虚拟处理器），该函数才会返回。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">只有当注册表中的
HKLM\System\CurrentControlSet\Services\Vid\Parameters\ExoDeviceEnabled值被
设置为1时，Windows虚拟机监控程序平台API通常才能向\Device\VidExo设备对象（由VID驱动程序在初始化时创建）发送不同
IOCTL，进而调用虚拟机监控程序的不同服务，否则系统不会启用对虚拟机监控程序API的支持。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">一些对性能敏感的虚拟机监
控程序平台API（如WHvRun 
VirtualProcessor）甚至可以直接从用户模式调用虚拟机监控程序，这要归功于Doorbell页，这是一种特殊但无效的客户机物理页，访问
这种页面时始终会导致VMEXIT。Windows虚拟机监控程序平台API可通过VID驱动程序获得Doorbell页的地址，并且每次从用户模式发起
虚拟化调用时，还会写入Doorbell页。由于Doorbell页的物理地址会在SLAT页表中标记为“特殊”，因此所产生的错误能被虚拟机监控程序识
别并准确处理。虚拟机监控程序可以像处理常规虚拟化调用那样，从虚拟处理器的寄存器中读取虚拟化调用的代码和参数，并最终将执行转移至虚拟化调用的处理例
程。当后者执行完毕后，虚拟机监控程序最终会执行VMENTRY，并落在产生错误的指令之后。这样可以为支撑客户机虚拟处理器的线程节约大量时钟周期，因
为不再需要进入内核来发出虚拟化调用。此外，VMCALL和类似的操作码始终需要内核特权才能执行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">新的第三方虚拟机的虚拟处
理器是通过根调度器调度的。如果根调度器被禁用，虚拟机监控程序平台API的任何功能都将无法运行。虚拟机监控程序中创建的分区属于EXO分区。EXO分
区是一种最小化分区，其中不包含任何综合功能，并且具备一些非常适合用于创建第三方虚拟机的特征。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·总是由VA进行支持（有关VA支持的虚拟机，即微型虚拟机的详情请参阅本章下文“虚拟化栈”一节）。分区的内存承载进程是一种用户模式应用程序，创建的是虚拟机，而非VMMEM进程的新实例。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
它们不具备任何分区特权，也不支持0级之外的其他VTL（Virtual Trust 
Level，虚拟信任级别）。所有传统分区的特权都需要引用综合函数，这些函数通常由虚拟机监控程序暴露给Hyper-V虚拟化栈。EXO分区是供第三方
虚拟化栈使用的，因此不需要传统分区特权所提供的任何函数。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·需要手动管理时间。虚拟机监控程序未向EXO分区提供任何虚拟时钟中断源，第三方虚拟化栈必须自行提供。这意味着每次试图读取虚拟处理器的时间戳计数器都会导致在虚拟机监控程序中产生VMEXIT，借此将拦截路由至运行该虚拟处理器的用户模式线程。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 与传统的虚拟机监控程序分区相比，EXO分区还包括一些细微差别。不过这些差别与我们讨论的内容无关，因此本书并未涉及。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_84" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>1</b><b>.</b><b>9</b><b> </b><b>嵌</b><b>套</b><b>虚</b><b>拟</b><b>化</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">大型服务器和云服务提供商
有时候需要在客户机分区内部运行容器或额外的虚拟机。如图9-20所示，虚拟机监控程序运行在裸机硬件之上，被视作L0虚拟机监控程序（L0代表
Level 
0，即0级），它使用硬件提供的虚拟化扩展创建了一个客户虚拟机。此外，该L0虚拟机监控程序还模拟了处理器的虚拟化扩展并将其暴露给客户虚拟机（这种暴
露虚拟化扩展的能力就叫作嵌套虚拟化）。客户虚拟机只需使用L0虚拟机监控程序暴露的模拟虚拟化扩展即可运行另一个虚拟机监控程序实例（此时该实例为L1
虚拟机监控程序，L1代表Level 
1，即1级）。L1虚拟机监控程序创建了嵌套的根分区并在其中启动了L2根操作系统。以同样的方式，L2根操作系统可以与L1虚拟机监控程序相互协调启动
嵌套的客户虚拟机。在这样的配置中，最终的客户虚拟机可以称为L2客户机。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/99e4563f221f0b96717148caf33113f5.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图9-20 嵌套虚拟化的结构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">嵌套虚拟化是一种软件构
造：虚拟机监控程序必须能模拟并管理虚拟化扩展。L1客户虚拟机执行的每条虚拟化指令都会导致L0虚拟机监控程序中产生一个VMEXIT，随后虚拟机监控
程序即可通过自己的模拟器重构该指令并执行模拟所需的工作。截至撰写这部分内容，仅Intel和AMD硬件可支持这种做法。嵌套虚拟化能力需要为L1虚拟
机明确启用，否则当客户机操作系统执行虚拟化指令时，L0虚拟机监控程序会为虚拟机注入常规保护异常。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在Intel硬件上，Hyper-V可通过下列两个主要概念实现嵌套虚拟化。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·VT-x虚拟化扩展模拟。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·嵌套地址转换。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如本节上文所讨论的那
样，对于Intel硬件，描述虚拟机基本数据结构的是虚拟机控制结构（Virtual Machine Control 
Structure，VMCS）。除了代表L1虚拟机的标准物理VMCS之外，当L0虚拟机监控程序创建的虚拟处理器属于支持嵌套虚拟化的分区时，此时将
分配一些嵌套的VMCS（这与虚拟VMCS是两个不同概念，请勿混淆）。嵌套VMCS是一种软件描述符，其中包含了L0虚拟机监控程序为L2分区启动并运
行嵌套的虚拟处理器所需的全部信息。正如“虚拟机监控程序的启动”一节简要介绍的那样，当L1虚拟机监控程序启动时，会检测自己是否运行在虚拟化环境中。
如果是，则会启用各种嵌套启发，如启发的VMCS或直接虚拟刷新（详见下文）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如图9-21所示，对于每
个嵌套VMCS，L0虚拟机监控程序还会创建一个虚拟VMCS和一个硬件物理VMCS，这两个类似的数据结构代表了运行L2虚拟机的虚拟处理器。虚拟
VMCS很重要，它在嵌套虚拟化数据的维持方面起到了重要作用。物理VMCS则会在L2虚拟机启动时被L0虚拟机监控程序加载，当L0虚拟机监控程序拦截
了L1虚拟机监控程序执行的VMLAUNCH指令时会发生该操作。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3bdaabdb9d1b412c828749ed0cd5ee81.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-21 一个使用虚拟处理器2运行L2虚拟机的L0虚拟机监控程序</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在图9-21中，L0虚拟机监控程序调度了通过VP2（使用嵌套的虚拟处理器1）运行的，由L1虚拟机监控程序所管理的L2虚拟机。L1虚拟机监控程序只能对复制到虚拟VMCS中的虚拟化数据进行操作。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>V</b><b>T</b><b>-</b><b>x</b><b>虚</b><b>拟</b><b>化</b><b>扩</b><b>展</b><b>模</b><b>拟</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在Intel硬件上，L0虚拟机监控程序可同时支持启发和未启发的L1虚拟机监控程序。不过唯一可以获得官方支持的做法是在Hyper-V的基础上运行另一个Hyper-V。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在未启发的虚拟机监控程序
中，所有在L1客户机中执行的VT-x指令都会产生VMEXIT。当L1虚拟机监控程序分配了用于描述全新L2虚拟机的客户机物理VMCS后，通常会将其
标记为活跃（在Intel硬件上是通过VMPTRLD指令实现的）。L0虚拟机监控程序会拦截该操作，并将已分配的嵌套VMCS与L1虚拟机监控程序指定
的客户机物理VMCS关联在一起。此外，它还会为VMCS填充初始值，并将当前虚拟处理器的嵌套VMCS设置为活跃状态（但并不会切换物理VMCS，执行
上下文还会保留在L1虚拟机监控程序中）。由L1虚拟机监控程序针对物理VMCS执行的每个后续读取或写入操作始终会被L0虚拟机监控程序拦截并重定向至
虚拟VMCS（请参阅图9-21）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当L1虚拟机监控程序启动
虚拟机（执行一种名为VMENTRY的操作）后，还会执行特定的硬件指令（Intel硬件上为VMLAUNCH指令），这些指令也会被L0虚拟机监控程序
拦截。对于未启发的情况，L0虚拟机监控程序会将虚拟VMCS的所有客户机字段复制到代表L2虚拟机的另一个物理VMCS中，并通过将其指向L0虚拟机监
控程序的入口点来写入主机字段，同时会将其设置为活跃状态（在Intel平台上这是通过硬件VMPTRLD指令实现的）。如果L1虚拟机监控程序使用了二
级地址转换（Intel硬件上这叫EPT），L0虚拟机监控程序将会映射当前活跃的L1扩展页表（详情请参阅下一节）。最后，它还会执行特定的硬件指令以
执行实际的VMENTRY。最终硬件开始执行L2虚拟机的代码。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在执行L2虚拟机过程中，
每个会导致VMEXIT的操作都会将执行上下文切回L0（而非L1）虚拟机监控程序。作为回应，L0虚拟机监控程序会在代表L1虚拟机监控程序上下文的原
始物理VMCS上执行另一个VMENTRY，并注入一个综合VMEXIT事件。L1虚拟机监控程序重新开始执行，并像常规非嵌套VMEXIT那样处理拦截
的事件。当L1完成对综合VMEXIT事件的内部处理后，它会执行VMRESUME操作，该操作会再次被L0虚拟机监控程序拦截，并使用与上文描述类似的
初始VMENTRY操作那样进行管理。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每次L1虚拟机监控程序执
行虚拟化指令后都执行一个VMEXIT，这是一种开销很高的操作，无疑会使L2虚拟机的运行速度普遍受到影响。为了解决此问题，Hyper-V虚拟机监控
程序为启发的VMCS提供了支持，这种优化措施在启用后，可以让L1虚拟机监控程序从L1与L0虚拟机监控程序共享的内存页（而非物理VMCS）加载、读
取并写入虚拟化数据。这个共享页也叫作启发的VMCS。当L1虚拟机监控程序操作属于L2虚拟机的虚拟化数据时，并不需要使用会导致L0虚拟机监控程序产
生VMEXIT的硬件指令，而是可以直接从启发的VMCS中读写。这种设计可显著提高L2虚拟机的性能。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在支持启发的情况下，L0
虚拟机监控程序只需要拦截VMENTRY和VMEXIT操作（以及其他一些与本讨论无关的操作）。L0虚拟机监控程序管理VMENTRY的方式与非启发场
景类似，但在执行上文描述的任何操作前，首先会将共享的启发VMCS内存页中包含的虚拟化数据复制到代表L2虚拟机的虚拟VMCS中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 值得一提的是，对于非启发场景，L0虚拟机监控程序还支持通过另一种技术防止产生VMEXIT同时管理嵌套的虚拟化数据，这种技术名为影子VMCS。影子VMCS是一种与启发VMCS较为类似的硬件优化技术。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>嵌</b><b>套</b><b>地</b><b>址</b><b>转</b><b>换</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如“分区的物理地址空
间”一节所述，虚拟机监控程序使用SLAT为虚拟机提供隔离的客户机物理地址空间，并将GPA转换为真正的SPA。而嵌套的虚拟机需要在现有这两层基础上
使用另一个额外的硬件转换层。为了向嵌套虚拟化提供支持，这个新层应当能将L2 GPA转换为L1 
GPA。由于建立一种支持三层转换的处理器MMU需要更复杂的电子器件，Hyper-V虚拟机监控程序采取了另一种策略来提供额外的地址转换层：影子嵌套
页表。影子嵌套页表使用了类似于影子页（可参阅上一节）的技术，可直接将L2 GPA转换为SPA。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在创建了支持嵌套虚拟化的分区后，L0虚拟机监控程序会分配并初始化一个嵌套页表影子域。这种数据结构可用于存储与分区中所创建的不同L2虚拟机相互关联的影子嵌套页表列表。此外，其中还存储了分区的活跃域世代编号（详见下一节的讨论）以及嵌套内存统计数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当L0虚拟机监控程序为了
启动L2虚拟机而执行初始VMENTRY时，它会分配与该虚拟机有关的影子嵌套页表，并用空值进行初始化（创建出空的物理地址空间）。当L2虚拟机开始执
行代码时，由于嵌套页故障（Intel硬件上这叫作EPT违规），L2虚拟机会立即生成VMEXIT。L0虚拟机监控程序此时并不会将故障注入L1，而会
遍历由L1虚拟机监控程序为客户机构建的嵌套页表。如果在其中找到了L2 GPA对应的有效条目，则会读取对应的L1 
GPA，将其转换为SPA，并创建所需的影子嵌套页表层次结构，以便将其映射至L2虚拟机。随后它会使用有效的SPA填充叶表项（虚拟机监控程序使用大页
面来映射影子嵌套页）并将描述用的嵌套VMCS设置为活跃状态，借此直接恢复L2虚拟机的执行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了让嵌套地址转换正常工
作，L0虚拟机监控程序需要获知对L1嵌套页表所做的所有改动，否则L2虚拟机可能会用陈旧的条目来运行。这种实现是特定于具体平台的，通常来说，虚拟机
监控程序会保护L2嵌套页表，只允许读取访问，这样即可在L1虚拟机监控程序修改了嵌套页表后获得通知。不过Hyper-V虚拟机监控程序采取了另一种更
聪明的策略，可以保证描述L2虚拟机的影子嵌套页表始终会得到更新，这是因为满足了如下两个前提条件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·当L1虚拟机监控程序在L2嵌套页表中添加新条目时，不会对嵌套虚拟机执行任何其他操作（L0虚拟机监控程序不会进行拦截）。只有当嵌套页表错误导致L0虚拟机监控程序产生VMEXIT时（上文讨论过这种情况），才会在影子嵌套页表中新增加一个条目。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
对于非嵌套虚拟机，当嵌套页表中有条目被更改或删除后，虚拟机监控程序始终会发出TLB刷新，以便让硬件TLB以正确的方式失效。对于嵌套虚拟化，当L1
虚拟机监控程序发出TLB刷新时，L0会拦截请求并让影子嵌套页表彻底失效。L0虚拟机监控程序还借助存储在影子VMCS和嵌套页表影子域中的世代ID维
持了一种名为虚拟TLB的概念（虚拟TLB架构的讨论已超出了本书的范围）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">因为一个地址的变化而让影
子嵌套页表彻底失效，这种做法看似有些多余，但这是由硬件支持决定的（Intel硬件的INVEPT指令不允许指定要从TLB中删除哪一个GPA）。在经
典虚拟机中这不算什么问题，因为很少会对物理地址空间进行改动。当经典虚拟机启动后，它的所有内存均已分配完成（详见“虚拟化栈”一节）。不过VA支持的
虚拟机和VSM并不属于这种情况。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了改善非经典嵌套虚拟机
和VSM的性能（详见下一节），虚拟机监控程序对“直接虚拟刷新”提供了支持，借此为L1虚拟机监控程序提供了两个能让TLB失效的虚拟化调用。尤其是
HvFlushGuestPhysicalAddressList这个虚拟化调用（详见TLFS文档记录）可以让L1虚拟机监控程序将影子嵌套页表中的某
一个具体条目失效，而无须为了刷新整个影子嵌套页表并通过多个VMEXIT重建而导致性能受到影响。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>在</b><b>H</b><b>y</b><b>p</b><b>e</b><b>r</b><b>-</b><b>V</b><b>中</b><b>启</b><b>用</b><b>嵌</b><b>套</b><b>虚</b><b>拟</b><b>化</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如
本节所述，为了在L1 
Hyper-V虚拟机中运行虚拟机，首先需要在宿主系统中启用嵌套虚拟化功能。为了完成本实验，我们需要一台搭载Intel或AMD 
CPU、安装了Windows 10或Windows Server 2019（版本不低于Anniversary Update 
RS1）的工作站。我们将使用Hyper-V管理器或Windows 
PowerShell创建一个内存不少于4GB的二类虚拟机。同时本实验还会在创建好的虚拟机中再创建一个嵌套的L2虚拟机，因此必须分配足够的内存。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">第一次启动虚拟机并完成初始配置后，需要关闭该虚拟机，随后以管理员身份打开PowerShell窗口（在搜索框中输入<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b> </b><b>P</b><b>o</b><b>w</b><b>e</b><b>r</b><b>S</b><b>h</b><b>e</b><b>l</b><b>l</b></span>，随后右击<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>P</b><b>o</b><b>w</b><b>e</b><b>r</b><b>S</b><b>h</b><b>e</b><b>l</b><b>l</b><b>图</b><b>标</b></span>并选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>以</b><b>管</b><b>理</b><b>员</b><b>身</b><b>份</b><b>运</b><b>行</b></span>”）。随后运行下列命令，其中“&lt;VmName&gt;”应替换为我们自己的虚拟机名称：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Set-VMProcessor -VMName "&lt;<span style="font-size:14px;font-style: oblique;color:rgb(0, 0, 0);font-family:'Source Code Pro';"><i>V</i><i>m</i><i>N</i><i>a</i><i>m</i><i>e</i></span>&gt;" -ExposeVirtualizationExtension $true </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">若要验证嵌套虚拟化功能是否已经成功启用，请运行：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">$(Get-VMProcessor -VMName "&lt;<span style="font-size:14px;font-style: oblique;color:rgb(0, 0, 0);font-family:'Source Code Pro';"><i>V</i><i>m</i><i>N</i><i>a</i><i>m</i><i>e</i></span>&gt;").ExposeVirtualizationExtensions </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">返回的结果应该是True。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">启用嵌套虚拟化功能后，即可重新启动虚拟机。在通过该虚拟机运行L1虚拟机监控程序前，首先需要通过控制面板添加必要的组件。在虚拟机的搜索框内输入“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>控</b><b>制</b><b>面</b><b>板</b></span>”，点击打开，随后点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>程</b><b>序</b></span>”，然后选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>打</b><b>开</b><b>或</b><b>关</b><b>闭</b><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>功</b><b>能</b></span>”。整个Hyper-V节点下的所有功能都必须选中，如下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="423" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3295e18335cca5e377c7494e698472c9.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>确</b><b>定</b></span>”。添加操作完成后，点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>重</b><b>启</b><b>动</b></span>”让虚拟机重新启动（这一步是必需操作）。虚拟机重启动后，即可通过系统信息应用程序（在搜索框中输入<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>m</b><b>s</b><b>i</b><b>n</b><b>f</b><b>o</b><b>3</b><b>2</b></span>。详见本章下文的“检测VBS及其提供的服务”实验）确认L1虚拟机监控程序的存在。如果因为某些原因该虚拟机监控程序未启动，可在虚拟机中打开一个管理员身份的命令提示符窗口（在搜索框中输入<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>c</b><b>m</b><b>d</b></span>并选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>以</b><b>管</b><b>理</b><b>员</b><b>身</b><b>份</b><b>运</b><b>行</b></span>”），运行下列命令强制启动：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">bcdedit /set {current} hypervisorlaunchtype Auto </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后即可用Hyper-V管理器或Windows PowerShell直接在虚拟机内部创建L2客户虚拟机。结果类似下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/2ebe4790a3146379712a50d2d162d5c8.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们还可以在L2根分区中启用L1虚拟机监控程序调试器，具体做法类似本章上文的“连接虚拟机监控程序调试器”实验。在撰写这部分内容时，这方面唯一的限制
是嵌套配置下无法使用网络调试，唯一能对L1虚拟机监控程序进行的调试方式是使用串口。这意味着在宿主机系统中，我们需要为L1虚拟机启用两个虚拟串口
（一个用于虚拟机监控程序，另一个用于L2根分区）并将其连接到命名管道。对于二类虚拟机，可以使用下列PowerShell命令在L1虚拟机中设置两个
串口（与上一条命令类似，需要将“&lt;VMName&gt;”替换为实际的虚拟机名称）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Set-VMComPort -VMName "&lt;<span style="font-size:14px;font-style: oblique;color:rgb(0, 0, 0);font-family:'Source Code Pro';"><i>V</i><i>M</i><i>N</i><i>a</i><i>m</i><i>e</i></span>&gt;" -Number 1 -Path \\.\pipe\HV_dbg </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Set-VMComPort -VMName "&lt;<span style="font-size:14px;font-style: oblique;color:rgb(0, 0, 0);font-family:'Source Code Pro';"><i>V</i><i>M</i><i>N</i><i>a</i><i>m</i><i>e</i></span>&gt;" -Number 2 -Path \\.\pipe\NT_dbg </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后即可配置虚拟机监控程序调试器连接到COM1串口，而NT内核调试器可连接至COM2（详见上一个实验）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_85" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>1</b><b>.</b><b>1</b><b>0</b><b> </b><b>A</b><b>R</b><b>M</b><b>6</b><b>4</b><b>上</b><b>的</b><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>虚</b><b>拟</b><b>机</b><b>监</b><b>控</b><b>程</b><b>序</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">x86和AMD64架构对
硬件虚拟化技术的支持是在最初的设计诞生很久之后才添加进来的，与之不同的是ARM64架构在最初的设计中就考虑了对硬件虚拟化的支持。尤其是，如图
9-22所示，ARM64执行环境已被分为三个安全域（Exception 
Level，异常级别）。EL决定了特权级别，EL越高，执行的代码就具备越多的特权。尽管所有用户模式应用程序都应在EL0中运行，NT内核以及内核模
式的驱动程序通常会在EL1中运行。一般来说，一个软件只能在一个异常级别中运行。EL2是专为虚拟机监控程序（在ARM64中也被叫作“虚拟机管理
器”）的运行而设的特权级别，这也是上述规则唯一的例外。虚拟机监控程序提供了虚拟化服务，它可以在EL2和EL1的“不安全世界”中运行（EL2不包
含“安全世界”，有关ARM TrustZone的讨论详见本节下文）。</span></p><div style="display: block;text-align:center;">
	<img width="783" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/fc6dfde0426b8e068a210e5c0a4b265a.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图9-22 ARM64执行环境</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">AMD64架构的CPU只
能在某些假定的情况下从内核上下文进入根模式（运行虚拟机监控程序的执行域），与之不同的是，当标准ARM64设备启动时，UEFI固件和启动管理器会在
EL2中开始自己的执行操作。在这些设备上，虚拟机监控程序加载器（取决于具体的启动流程）可以直接启动虚拟机监控程序，并在稍后把异常级别降至EL1
（为此需要发出一个异常返回指令，即ERET）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在异常级别之上，
TrustZone技术让系统在安全和非安全这两种执行安全状态之间进行划分。安全的软件一般可以同时访问安全和非安全的内存与资源，而普通软件只能访问
非安全的内存与资源。非安全状态通常也被称为常规世界（normal 
world）。这种设计使得操作系统能够在同一套硬件上与另一个受信任的操作系统并行运行，进而对某些软件和硬件攻击提供保护。安全状态也叫安全世界
（secure world），通常用于运行安全设备（它们的固件以及IOMMU范围），并且一般来说，所有需要处理器处理的东西都位于安全状态下。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了正确地与安全世界通
信，非安全操作系统会发出安全方法调用（Secure Method 
Call，SMC），这种调用提供了一种类似于标准操作系统Syscall的机制。SMC由TrustZone负责管理。TrustZone通常可以通过
一个内存保护薄层为常规世界和安全世界实现隔离，这种内存薄层由明确定义的硬件内存保护单元提供（高通将其称为XPU）。XPU由固件配置，只允许特定执
行环境访问特定内存位置（常规世界中的软件无法访问安全世界的内存）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在ARM64服务器计算机
上，Windows可以直接启动虚拟机监控程序。虽然可以启用TrustZone，但客户端计算机通常不具备XPU（大部分能运行Windows的客户端
ARM64设备都是由高通提供的）。在这类客户端设备中，安全世界和常规世界之间的隔离是由一种名为QHEE的专有虚拟机监控程序提供的，它可以通过二阶
内存转换提供内存隔离（这一层的作用与Windows虚拟机监控程序所用的SLAT层作用类似）。QHEE可以拦截运行中的操作系统发出的每个SMC，它
可将SMC直接转发给TrustZone（但首先需要验证是否具备必要权限），或代表TrustZone执行某些工作。在这些设备中，TrustZone
还有一个重要的职责：加载并验证设备固件的真实性，并通过与QHEE进行协调，正确地执行安全启动（secure launch）引导方法。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然Windows中一般
不使用安全世界（安全/非安全世界的界限已经由虚拟机监控程序通过VTL级别提供），但Hyper-V虚拟机监控程序依然运行在EL2下。这使其无法兼容
同样运行在EL2下的QHEE虚拟机监控程序。为了正确解决这个问题，Windows采用了一种特殊的启动策略：在QHEE的协助下对安全启动过程进行协
调。当安全启动终止时，QHEE虚拟机监控程序将被卸载并放弃执行Windows虚拟机监控程序，Windows虚拟机监控程序则会在安全启动的过程中加
载。在后续启动过程中，当安全内核成功启动并且SMSS创建了第一个用户模式会话时，还将新建一个特殊的Trustlet（高通将其称为QcExt）。这
个Trustlet充当了原始ARM64虚拟机监控程序，它可以拦截所有SMC请求，验证请求的完整性，通过安全内核暴露的服务提供必要的内存隔离，并发
送和接收来自EL3中安全监视器的命令。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SMC拦截架构在NT内核与ARM64 Trustlet中均有实现，但已超出了本书的范围。新引入的Trustlet可以让大部分客户端ARM64设备在启动时就默认启用安全启动和虚拟安全模式（VSM，详见下文）。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter09_0002.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_86" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>2</b><b> </b><b>虚</b><b>拟</b><b>化</b><b>栈</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">尽管虚拟机监控程序提供了
隔离能力以及用于管理虚拟硬件的底层服务，但虚拟机的所有上层实现都是由虚拟化栈提供的。虚拟化栈可管理虚拟机的状态，为虚拟机提供内存，通过提供虚拟主
板、系统固件以及多种类型的虚拟设备（模拟设备、合成设备、直接访问设备）来提供虚拟化的硬件。虚拟化栈还包含VMBus，这个重要的组件能在客户虚拟机
和根分区之间提供高速通信通道，并可由内核模式客户端库（KMCL）抽象层访问。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">本节将介绍虚拟化栈提供的一些重要服务，并分析组成虚拟化栈的组件。图9-23展示了虚拟化栈的主要组件。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4f114190ff431d805cfc01f228edb299.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图9-23 虚拟化栈的组件</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_87" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>2</b><b>.</b><b>1</b><b> </b><b>虚</b><b>拟</b><b>机</b><b>管</b><b>理</b><b>器</b><b>服</b><b>务</b><b>和</b><b>工</b><b>作</b><b>进</b><b>程</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机管理器服务
（Vmms.exe）负责为根分区提供Windows管理规范（Windows Management 
Instrumentation，WMI）接口，这样即可通过微软管理控制台（MMC）插件或PowerShell管理子分区。VMMS服务可以代表虚拟
机（在内部可通过GUID区分不同的虚拟机）管理通过WMI接口收到的请求，如启动、电源关闭、关机、暂停、恢复、重启动等。它还控制了一些设置，例如哪
些设备对子分区可见，为每个分区定义了怎样的内存和处理器分配情况。VMMS还管理着设备的添加与移除。当虚拟机启动时，VMMS服务还起到了一个关键作
用：创建对应的虚拟机工作进程（VMWP.exe）。VMMS还管理了虚拟机快照，会将运行中虚拟机的快照请求重定向至VMWP进程，或直接为非运行状态
的虚拟机创建快照。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">VMWP负责执行典型的单
体式虚拟机监控程序需要执行的大部分虚拟化工作（与基于软件的虚拟化解决方案所做的工作类似）。这意味着需要管理特定子分区的虚拟机状态（以便允许执行可
支持的功能，如快照和状态转换），响应来自虚拟机监控程序的各种通知，针对暴露给子分区的某些设备（即模拟设备）执行模拟，并要与虚拟机服务和配置组件进
行配合。工作进程的重要作用在于启动虚拟主板并维持虚拟机所包含的每个虚拟设备的状态。它还包含了一些负责虚拟化栈远程管理工作的组件，以及一个可供远程
桌面客户端连接到任意子分区并远程查看其用户界面、与其交互的RDP组件。虚拟机工作进程暴露的COM对象提供了VMMS以及VmCompute服务所需
的接口，借此可与代表特定虚拟机的VMWP实例通信。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机宿主机计算服务（通
过Vmcompute.exe和Vmcompute.dll库实现）则是另一个重要组件，承载了虚拟机管理器服务中未实现的大部分计算密集型操作，例如，
分析虚拟机的内存报告（针对动态内存）、管理VHD和VHDX文件，以及创建容器所需的基础层，这些操作都是在虚拟机宿主机计算服务中实现的。在所暴露的
COM对象帮助下，工作进程和VMMS可以与宿主机计算服务通信。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机管理器服务、工作进程、虚拟机计算服务都能打开并解析多种配置文件，这些文件揭示了系统中所创建的所有虚拟机列表，以及每个虚拟机的具体配置。尤其是：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·配置存储库，存储了系统中已安装虚拟机列表、名称、配置文件和GUID，位于data.vmcx文件中，存储在C:\ProgramData\Microsoft\Windows Hyper-V目录下。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·“虚拟机数据存储”存储库（虚拟机宿主机计算服务的一部分），借此可打开、读取、写入虚拟机的配置文件（通常使用.vmcx扩展名），其中包含虚拟设备列表和虚拟硬件的配置。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">“虚拟机数据存储”存储库
还可用于读/写虚拟机保存状态文件。虚拟机状态文件在虚拟机暂停过程中生成，其中包含了运行中虚拟机保存后的状态，可在稍后还原（可还原分区状态、虚拟机
的内存内容，以及每个虚拟设备的状态）。配置文件在格式上使用了XML形式的键值对。纯文本的XML数据会使用一种专有二进制格式压缩后存储，该格式还支
持写入操作日志逻辑，因此可以更好地应对电源故障。此二进制格式的详细介绍已超出了本书范围。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_88" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>2</b><b>.</b><b>2</b><b> </b><b>V</b><b>I</b><b>D</b><b>驱</b><b>动</b><b>程</b><b>序</b><b>和</b><b>虚</b><b>拟</b><b>化</b><b>栈</b><b>内</b><b>存</b><b>管</b><b>理</b><b>器</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟基础架构驱动程序
（VID.sys）也许是虚拟化栈最重要的组件之一。它为子分区中运行的虚拟机提供了分区、内存、进程管理服务，并将其暴露给根分区中的虚拟机工作进程。
虚拟机工作进程和VMMS服务使用VID驱动程序与虚拟机监控程序通信，而这主要是归功于Windows虚拟机监控程序接口驱动程序（WinHv.sys
和WinHvr.sys）实现的、并由VID驱动程序导入的那些接口。这些接口包含了为虚拟机监控程序的虚拟化调用管理提供支持所需的全部代码，可以让操
作系统或常规的内核模式驱动程序使用标准Windows API调用（而非虚拟化调用）访问虚拟机监控程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">VID驱动程序还包含了虚
拟化栈内存管理器。上一节我们曾介绍过虚拟机监控程序内存管理器，它负责管理虚拟机监控程序本身的物理和虚拟内存。而虚拟机的客户机物理内存是由虚拟化栈
内存管理器负责分配和管理的。当虚拟机启动时，所生成的虚拟机工作进程（VMWP.exe）会调用内存管理器的服务（由IMemoryManager 
COM接口定义）构建客户虚拟机的RAM。为虚拟机分配内存的操作分为以下两个步骤。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）虚拟机工作进程（使用
VMMS进程中内存平衡器提供的服务）获得全局系统内存状态报告，随后根据可用系统内存确定要向VID驱动程序请求多大的物理内存块（通过
VID_RESERVE 
IOCTL实现，可请求内存块大小各异，64MB～4GB）。随后VID驱动程序将使用MDL管理函数（尤其是
MmAllocatePartitionNodePagesForMdlEx）分配内存块。出于性能方面的考虑，以及为了避免内存碎片化，VID驱动程序
实现了一种“尽最大努力”的算法以尽可能分配巨型或大型物理页面（分别为1GB和2MB），如果无法满足才会考虑分配标准的小页面。内存块分配完成后，其
页面会被存入由VID驱动程序维持的一个内部“储备”桶。该桶包含一个按照服务质量（QoS）创建的数组进行排序的页面列表。这个QoS根据页面类型（巨
型、大型、小型）以及所属NUMA节点确定。该过程在VID的术语中叫作“保留物理内存”（请勿将其与NT内存管理器的“保留虚拟内存”混淆）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）从虚拟化栈角度来看，
物理内存承诺（commitment）是指清空桶中的保留页面，将其移入VID内存块（VSMM_MEMORY_BLOCK数据结构）的过程，该内存块是
由虚拟机工作进程使用VID驱动程序的服务创建并拥有的。在创建内存块过程中，VID驱动程序首先会在虚拟机监控程序中（通过Winhvr驱动程序和
HvDepositMemory虚拟化调用）存入额外的物理页面。这些额外页面是为虚拟机创建SLAT表页面层次结构所必需的。随后，VID驱动程序会请
求虚拟机监控程序对描述整个客户机分区RAM的物理页面进行映射。虚拟机监控程序在SLAT表中插入有效条目，并设置正确的权限，借此创建分区的客户机物
理地址空间。GPA范围会被插入一个属于VID分区的列表中。VID内存块由虚拟机工作进程所拥有，该内存块还被用于跟踪客户机内存，并会被用在DAX文
件支撑的内存块中（有关DAX卷和PMEM的详细信息，请参阅<span style="font-size:16px;font-weight: bold;font-family:'PingFang SC';"><b>第</b></span>11<span style="font-size:16px;font-weight: bold;font-family:'PingFang SC';"><b>章</b></span>）。随后，虚拟机工作进程即可将这些内存块用于多种用途，例如在管理模拟的设备时访问某些页面。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_89" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>2</b><b>.</b><b>3</b><b> </b><b>虚</b><b>拟</b><b>机</b><b>的</b><b>诞</b><b>生</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机的启动过程主要由
VMMS和VMWP进程管理。当虚拟机（在内部由GUID标识）启动请求（通过PowerShell或Hyper-V管理器GUI应用程序）被传递给
VMMS服务后，VMMS服务开始启动过程，从“数据存储”存储库中读取虚拟机的配置，这些配置包括虚拟机的GUID以及组成虚拟硬件的所有虚拟设备
（VDEV）列表。随后该服务会验证包含了虚拟机虚拟磁盘的VHD（或VHDX）文件路径是否具备正确的访问控制列表（ACL，下文将详细介绍）。如果虚
拟机配置所指定的ACL有误，VMMS服务（使用SYSTEM账户运行）会重写一个与新的VMWP进程实例兼容的新ACL。VMMS会使用COM服务与主
机计算服务通信，以生成新的VMWP进程实例。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">主机计算服务通过查询位于
Windows注册表（HKCU\CLSID\{f33463e0-7d59-11d9- 
9916-0008744f51f3}键）中的COM注册数据获得虚拟机工作进程的路径，随后会使用一个明确定义的访问令牌新建进程，该访问令牌是以虚拟
机的SID为所有者创建的。实际上，Windows安全模型的NT权威（NT 
Authority）定义了一个众所周知的子权威值（83），借此识别虚拟机（有关系统安全组件的详细信息请参阅卷1第7章）。主机计算服务会等待
VMWP进程完成初始化（这样所暴露的COM接口即可准备就绪）。随后执行会返回至VMMS服务，该服务最终可以向VMWP进程请求启动虚拟机（通过暴露
出的IVirtualMachine COM接口）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如图9-24所示，虚拟机
工作进程会为虚拟机执行“冷启动”状态转换。在虚拟机工作进程中，整个虚拟机是通过“虚拟主板”公开的服务进行管理的。对于第一代虚拟机，该虚拟主板模拟
了Intel 
i440BX主板；对于第二代虚拟机，则模拟了一种专有的主板。虚拟主板管理并维持了虚拟设备列表，并负责为每个虚拟设备执行状态转换。正如下一节即将介
绍的，每个虚拟设备都会作为DLL中的COM对象（公开IVirtualDevice接口）来实现。虚拟主板会从虚拟机的配置中枚举每个虚拟设备，并加载
代表每个设备的相关COM对象。</span></p><div style="display: block;text-align:center;">
	<img width="705" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ada7af5e15ba2d309dd1fd01e3ead0f3.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-24 虚拟机工作进程及其执行虚拟机“冷启动”的接口</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机工作进程通过预留每
个虚拟设备所需的资源来开始启动过程。然后它会通过VID驱动程序从根分区分配物理内存，借此构建虚拟机客户机物理地址空间（虚拟RAM）。这个阶段已经
可以给虚拟主板上电，并按顺序给每个VDEV上电。每个设备的上电过程是不同的，例如合成设备通常会与自己的虚拟化服务提供程序
（Virtualization Service Provider，VSP）通信以进行初始化配置。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟BIOS（在
Vmchipset.dll库中实现）是一个值得深入讨论的虚拟设备。它的上电方法允许虚拟机包含可在启动自举（Bootstrap）虚拟处理器时执行的
初始固件。BIOS 
VDEV会从支持自己的库所包含的资源部分为虚拟机提取正确的固件（第一代虚拟机使用传统的BIOS，其他虚拟机使用UEFI），构建固件中的易失性配置
部分（如ACPI和SRAT表），随后使用VID驱动程序提供的服务将其注入适当的客户机物理内存中。VID驱动程序则可以将VID内存块描述的内存范围
映射到用户模式内存中，供虚拟机工作进程访问（内部将该过程称为“内存孔隙创建”）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当所有虚拟设备已成功上电后，虚拟机工作进程将会向VID驱动程序发送一个适当的IOCTL，借此启动虚拟机的自举虚拟处理器，进而启动虚拟处理器及其消息泵（message pump，用于在VID驱动程序和虚拟机工作进程之间交换消息）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>理</b><b>解</b><b>虚</b><b>拟</b><b>机</b><b>工</b><b>作</b><b>进</b><b>程</b><b>以</b><b>及</b><b>虚</b><b>拟</b><b>磁</b><b>盘</b><b>文</b><b>件</b><b>的</b><b>安</b><b>全</b><b>性</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">上一节讨论了当虚拟机启动请求被（通过WMI）传递给VMMS进程后，主机计算服务（Vmcompute.exe）是如何启动虚拟机工作进程的。在与主机计算服务通信前，VMMS会为新的工作进程实例生成一个安全令牌。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">为向虚拟机提供正确的支持，Windows安全模型增加了三种新实体（Windows安全模型详见卷1第7章）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个“虚拟机”安全组，使用S-1-5-83-0作为安全标识符。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个根据虚拟机的唯一标识符（GUID）生成的虚拟机安全标识符（SID）。虚拟机SID将会是为虚拟机工作进程所生成的安全令牌的所有者。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一种虚拟机工作进程安全能力，可用于让AppContainer中运行的应用程序访问虚拟机工作进程所需的Hyper-V服务。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在这个实验中，我们将通过Hyper-V管理器，在一个只有当前用户和Administrators组的用户可以访问的位置新建一个虚拟机，随后我们将检查虚拟机文件和虚拟机工作进程的安全性会产生怎样的变化。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">首先以管理员身份打开命令提示符，并使用下列命令创建一个文件夹（本例为C:\TestVm）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">md c:\TestVm</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随
后需要剥离所有继承的ACE（访问控制项，详见卷1第7章），并为Administrators组和当前登录的用户添加完整访问的ACE。上述操作可通过
如下命令实现（请将C:\TestVm替换为实际的目录路径，而&lt;UserName&gt;是当前登录用户的用户名）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">icacls c:\TestVm /inheritance:r </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">icacls c:\TestVm /grant Administrators:(CI)(OI)F </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">icacls c:\TestVm /grant &lt;<span style="font-size:14px;font-style: oblique;color:rgb(0, 0, 0);font-family:'Source Code Pro';"><i>U</i><i>s</i><i>e</i><i>r</i><i>N</i><i>a</i><i>m</i><i>e</i></span>&gt;:(CI)(OI)F </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">若要验证该文件夹具备正确的ACL，请打开资源管理器（可使用Win+E组合键），右键点击该文件夹并选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>属</b><b>性</b></span>”，随后打开“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>安</b><b>全</b><b>性</b></span>”选项卡。此时应看到类似下图所示的界面。</span></p><div style="display: block;text-align:center;">
	<img width="493" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4df1ea9f70663f8f79dfc8bfc3d5a495.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">打
开Hyper-V管理器并新建一个虚拟机（及对应的磁盘文件），将其存储在新创建的文件夹中（完整操作过程可参阅https://
docs.microsoft.com/virtualization/hyper-v-on- 
windows/quick-start/create-virtual-machine）。对于这个实验，我们不需要为虚拟机安装操作系统。新建虚拟机
向导运行完毕后，即可启动虚拟机（本例中为VM1）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">以管理员身份打开Process Explorer并找到vmwp.exe进程。右键点击该进程，选择<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>“</b><b>属</b><b>性</b></span>”。毫无意外，我们可以看到其父进程为vmcompute.exe（主机计算服务）。打开<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>“</b><b>安</b><b>全</b><b>性</b></span>”选项卡可以看到，虚拟机的SID已被设置为该进程的所有者，并且该令牌属于Virtual Machines这个组。</span></p><div style="display: block;text-align:center;">
	<img width="607" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/84c3215dd28cd6797246ced3ad1ed63b.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">该
SID的构成方式可反映出虚拟机GUID。在本例中，虚拟机的GUID为{F156B42C- 
4AE6-4291-8AD6-EDFE0960A1CE}（我们也可以使用PowerShell来验证这一点，详细方法请参阅“操作根调度器”实验）。
GUID是一个16字节的序列，被组织成一个32位（4字节）整数、两个16位（2字节）整数，以及最后的8字节。上述例子中的GUID是按照如下方式组
织的。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·0xF156B42C是最开头的32位整数，用十进制表示则为4048991276。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·0x4AE6和0x4291是随后的两个16位整数，结合在一起组成了一个32位值，值的内容为0x42914AE6，即十进制的1116818150（注意：系统是小端序的，重要性不大的字节位于较低的地址上）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
最后的字节序列为0x8A、0xD6、0xED、0xFE、0x09、0x60、0xA1以及0xCE（人工易读的GUID中的第三部分：8AD6，这是
一个字节序列，而非一个16位的值），这些字节会合并为两个32位值：0xFEEDD68A和0xCEA16009，也就是十进制的4276999818
和3466682377。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如
果将计算出的所有十进制数字与NT权威发出的常规SID标识符（S-1-5）以及虚拟机基准RID（83）结合在一起，应该就能获得与Process 
Explorer中所示相同的SID（本例中为
S-1-5-83-4048991276-1116818150-4276999818-3466682377）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">正如在Process Explorer中看到的，VMWP进程的安全令牌不包含Administrators组，并且也不是代表当前登录的用户创建而来的。那么虚拟机工作进程又为何可以访问虚拟磁盘以及虚拟机配置文件？</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">答
案就藏在VMMS进程中，在创建虚拟机时，该进程会扫描虚拟机路径上的每个组件，并修改所需文件夹和文件的DACL。尤其是虚拟机根文件夹（根文件夹名称
与虚拟机名称相同，因此应该可以在所创建的目录下找到一个与虚拟机同名的子文件夹）的正确访问，这要归功于所添加的虚拟机安全组ACE。虚拟磁盘文件的正
常访问则要归功于为虚拟机SID提供的允许访问ACE。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以使用资源管理器验证这一点：打开虚拟机的虚拟磁盘文件夹（名为Virtual Hard Disks，位于虚拟机根文件夹中），右击VHDX（或VHD文件）并选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>属</b><b>性</b></span>”，随后打开“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>安</b><b>全</b><b>性</b></span>”选项卡。除了最初设置的ACE，我们应该可以看到两个新增的ACE（一个是虚拟机ACE，另一个是适用于AppContainer的VmWorker进程能力）。</span></p><div style="display: block;text-align:center;">
	<img width="387" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/aee1a925bf030a19d120ea5d3a21cc91.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如
果停止虚拟机并尝试从文件中删除虚拟机ACE，随后该虚拟机就无法再启动了。要将虚拟磁盘还原为正确的ACL，请运行这个PowerShell脚本：
https://gallery.technet.microsoft.com/Hyper-V-Restore-ACL-e64dee58。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_90" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>2</b><b>.</b><b>4</b><b> </b><b>V</b><b>M</b><b>B</b><b>u</b><b>s</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">VMBus是Hyper-V虚拟化堆栈提供的一种机制，可供虚拟机实现分区间通信。这是一种能在客户机和宿主机之间建立通道的虚拟总线设备，这些通道可用于在分区间共享数据并创建半虚拟化设备（也叫综合设备）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">承载虚拟化服务提供程序
（VSP）的根分区可通过VMBus通信，借此处理来自子分区的设备请求。在另一端，子分区（或客户机）可通过虚拟化服务使用程序
（Virtualization Service 
Consumer，VSC）借助VMBus将设备请求重定向至VSP。子分区需要借助VMBus和VSC驱动程序来使用半虚拟化的设备堆栈（有关虚拟硬件
支持的详细信息请参阅“虚拟硬件支持”一节）。VMBus通道主要通过“上游”和“下游”两个环形缓冲区让VSC和VSP传输数据。这些环形缓冲区会由虚
拟机监控程序映射至两端的分区中，如上一节所述，虚拟机监控程序还能通过SynIC提供分区间通信。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">工作进程在启动虚拟机时，
最先启动的虚拟设备（VDEV）之一就是VMBus 
VDEV（在Vmbusvdev.dll中实现）。在上电的过程中，它会向VMBus根设备（名为\Device\RootVmBus）发送
VMBUS_VDEV_SETUP 
IOCTL，借此可以将虚拟机工作进程连接至VMBus根驱动程序（Vmbusr.sys）。VMBus根驱动程序会协调与子虚拟机进行双向通信的父端
点。其初始设置例程还会在目标虚拟机暂未上电时调用，而它的一个重要作用是创建XPartition数据结构，该数据结构表示子虚拟机的VMBus实例，
可用于连接所需的SynIC综合中断源（也叫SINT，详见“综合中断控制器”一节）。在根分区中，VMBus使用了两个综合中断源：一个用于初始消息握
手（发生在通道创建前），另一个用于环形缓冲区发出的综合事件信号。不过子分区只使用了一个SINT。设置例程会在子虚拟机中分配主消息端口，并在根中分
配相应的连接，对于隶属于该虚拟机的每个虚拟处理器，还会分配事件端口及其连接（用于从子虚拟机接收综合事件）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这两个综合中断源会分别使
用名为KiVmbusInterrupt0和KiVmbusInterrupt1的ISR例程进行映射。在这两个例程的帮助下，根分区可以准备好接收来自
子虚拟机的综合中断和消息。当收到消息（或事件）后，ISR会将一个延迟过程调用（DPC）排队，借此检查消息是否有效。如果有效，会将一个工作项排队，
稍后该工作项将被运行在被动IRQL级别的系统处理（这会对消息队列产生进一步的影响）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">根分区中的VMBus就绪
后，根中的每个VSP驱动程序即可使用VMBus内核模式客户端库公开的服务为子虚拟机分配并提供VMBus通道。VMBus内核模式客户端库（缩写为
KMCL）可通过不透明的KMODE_CLIENT_CONTEXT数据结构代表VMBus通道，该数据结构也是在创建通道时（具体来说是VSP调用
VmbChannelAllocate API时）分配并初始化的。随后，根VSP通常会调用VmbChannelEnabled 
API（子分区中的该函数可打开通道，建立与根分区的实际连接）以便向子虚拟机提供通道。KMCL通过两个驱动程序实现：一个运行在根分区中
（Vmbkmclr.sys），一个会被载入子分区（Vmbkmcl.sys）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在根分区中提供通道是一种相对复杂的操作，涉及下列步骤。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）KMCL驱动程序通过VDEV上电例程中初始化的文件对象与VMBus根驱动程序进行通信，VMBus驱动程序获得表示子分区的XPartition数据结构，并启动通道提供过程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）VMBus驱动程序提
供的底层服务分配并初始化表示单个“通道”的LOCAL_OFFER数据结构，并预分配一些由SynIC预定义的消息。随后，VMBus会在根中创建综合
事件端口，随后子分区就可以在将数据写入环形缓冲区之后连接到信号事件。表示所提供通道的LOCAL_OFFER数据结构会被添加到一个内部服务器通道列
表中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）VMBus创建通道后，会尝试着向子分区发送OfferChannel消息，目的是通知子分区新通道已就绪。然而在这个阶段VMBus会失败，因为另一端（子虚拟机）尚未准备好，并且还没有开始初始消息握手。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在所有VSP完成了通道的供应操作，并且所有VDEV已经上电（详见上一节）后，虚拟机工作进程会启动虚拟机。为了让通道完全初始化并让相关连接启动，客户机分区应加载并启动VMBus子驱动程序（Vmbus.sys）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>初</b><b>始</b><b>V</b><b>M</b><b>B</b><b>u</b><b>s</b><b>消</b><b>息</b><b>握</b><b>手</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows中的
VMBus子驱动程序是一种由PNP管理器枚举并启动的WDF总线驱动程序，位于ACPI根枚举器中（Linux有另一个版本的VMBus子驱动程序，但
本书不会涉及该版本）。当子虚拟机的NT内核启动时，VMBus驱动程序会初始化自己的内部状态（意味着将会分配所需数据结构和工作项）并创建
\Device\VmBus根功能设备对象（Functional Device 
Object，FDO），借此开始执行。随后PNP管理器会调用VMBus的资源分配处理程序例程。后者将配置正确的SINT源（在WinHv驱动程序的
帮助下，对某一个HvRegisterSint寄存器发出HvSetVpRegisters虚拟化调用），并将其连接至
KiVmbusInterrupt2 
ISR。此外，它还会获取SIMP页，借此向根分区发送和接收综合消息（详见“综合中断控制器”一节），并创建代表父（根）分区的XPartition数
据结构。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当PNP管理器发出启动
VMBus的FDO的请求后，VMBus驱动程序会启动初始消息握手。在这个阶段，每个消息的发送都是通过发出HvPostMessage虚拟化调用实现
的（同时还需借助WinHv驱动程序），借此虚拟机监控程序即可将综合中断注入目标分区（本例中的目标是分区）。接收方只需读取SIMP页面即可收到消
息，接收方会将新的消息类型设置为MessageTypeNone，借此发出消息已读取的信号（详见虚拟机监控程序TLFS）。消息的读者可将图9-25
所示的初始消息握手过程看作分为两个阶段的过程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">第一阶段由初始联系
（Initiate 
Contact）消息所表示，该消息只会在虚拟机的生命周期中发送一次，由子虚拟机发给根分区，目的在于协商双方可支持的VMBus协议版本。截至撰写这
部分内容，VMBus协议主要分为五个版本，此外还有一些额外的变体。根分区会解析该消息，要求虚拟机监控程序映射客户端所分配的监视器页面（如果协议支
持的话），并发送可接受的协议版本作为回复。请注意，如果情况与此不符（例如根分区运行的Windows版本低于子虚拟机中运行的版本），子虚拟机会重启
动该过程并对VMBus协议版本进行降级，直到建立可兼容的版本。至此，子虚拟机已经准备好发送请求供应（Request 
Offers）消息，这会导致根分区发送已经由VSP提供的所有通道列表。这样，子分区即可在稍后的握手协议中打开通道。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/1d112e38d96b00d1b97e92be744c77f8.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图9-25 VMBus初始消息握手</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图9-25强调了在设置
VMBus通道时由虚拟机监控程序发出的各种综合消息。根分区会浏览服务器通道列表（LOCAL_OFFER数据结构，详见上文）提供的通道列表，并通过
每个通道为子虚拟机发送一条供应通道（Offer 
Channel）消息。该消息与上文“VMBus”一节所介绍的通道提供协议最后发送的消息完全相同，因此，尽管每个虚拟机的生命周期中初始消息握手的第
一阶段只会发生一次，但只要提供了通道，第二阶段就可以随时启动。供应通道消息包含的重要数据（例如通道类型和实例GUID）可用于区分每个通道。对于
VDEV通道，PNP管理器可以使用这两个GUID正确地识别相关虚拟设备。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了响应该消息，子分区会
分配表示通道的客户端LOCAL_OFFER数据结构以及相关XInterrupt对象，同时会判断该通道是否需要创建物理设备对象（PDO），VDEV
通道通常总是需要创建。这种情况下，VMBus驱动程序会创建代表新通道的PDO实例，所创建的设备可通过安全描述符获得必要保护，使其只能通过系统账户
和管理员账户访问。随后VMBus标准设备接口也会被附加至新建的PDO，借此在新的VMBus通道（由LOCAL_OFFER数据结构代表）和设备对象
之间维持关联。PDO创建完成后，PNP管理器即可通过供应通道消息包含的VDEV类型和实例GUID识别并加载正确的VSC驱动程序。这些接口会变为新
建PDO的一部分，可通过设备管理器查看。详细信息请参阅下面的实验。随后在VSC驱动程序加载完成后，通常即可调用VmbEnableChannel 
API（由KMCL暴露，详见上文）“打开”渠道并创建最终的环形缓冲区。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>通</b><b>过</b><b>V</b><b>M</b><b>B</b><b>u</b><b>s</b><b>暴</b><b>露</b><b>的</b><b>虚</b><b>拟</b><b>设</b><b>备</b><b>（</b><b>V</b><b>D</b><b>E</b><b>V</b><b>）</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">每
个VMBus通道均可通过类型和实例GUID来区分。对于属于VDEV的通道，其类型和实例GUID还可用于区分所公开的设备。当VMBus子驱动程序创
建实例PDO时，会将通道的类型和实例GUID包含在多个设备的属性中，例如实例路径、硬件ID、兼容ID。本实验将介绍如何枚举VMBus上构建的所有
VDEV。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">为完成该实验，需要通过Hyper-V管理器创建并启动一个Windows 10虚拟机。虚拟机启动并运行后，请打开设备管理器（在搜索框中输入“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>设</b><b>备</b><b>管</b><b>理</b><b>器</b></span>”）。随后在设备管理器窗口中点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>查</b><b>看</b></span>”菜单，并选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>按</b><b>连</b><b>接</b><b>列</b><b>出</b><b>设</b><b>备</b></span>”。VMBus总线驱动程序是通过ACPI枚举器枚举并启动的，因此我们需要展开ACPI x64-based PC根节点，随后展开Microsoft ACPI-Compliant System子节点下的“ACPI模块设备”，如下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ebc115e8dcd2faca2682422d15a2d61f.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">打开ACPI模块设备后会看见另一个名为Microsoft Hyper-V Virtual Machine Bus的节点，它代表根VMBus PDO。在该节点下，设备管理器会显示当根分区提供了相关VMBus通道后，由该VMBus FDO创建的所有实例设备。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后右击任何一个Hyper-V设备（如Microsoft Hyper-V Video设备）并选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>属</b><b>性</b></span>”。为了显示支持该虚拟设备的VMBus通道类型和实例GUID，请打开“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>属</b><b>性</b></span>”窗口的“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>详</b><b>细</b><b>信</b><b>息</b></span>”选
项卡。有三个设备属性中包含了通道的类型和实例GUID（以不同格式呈现）：设备实例路径、硬件ID以及兼容ID。虽然兼容ID仅包含VMBus通道类型
GUID（本例中为{da0a7802-e377-4aac-8e77-0558eb1073f8}），但硬件ID和设备实例路径同时包含了类型和实例
GUID。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>打</b><b>开</b><b>V</b><b>M</b><b>B</b><b>u</b><b>s</b><b>通</b><b>道</b><b>并</b><b>创</b><b>建</b><b>环</b><b>形</b><b>缓</b><b>冲</b><b>区</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了正确启动分区间通信并
创建环形缓冲区，必须首先打开一个通道。通常来说，在分配了通道的客户端（依然通过VmbChannel 
Allocate进行）后，VSC会调用从KMCL驱动程序导出的VmbChannelEnable 
API。正如上一节所述，子分区中的这个API可以打开一个已经由根提供的VMBus通道。KMCL驱动程序会与VMBus驱动程序通信，获取通道参数
（如通道类型、实例GUID、使用的MMIO空间），并为接收的数据包创建工作项。随后它会分配如图9-26所示的环形缓冲区。这个环形缓冲区的大小通常
是由VSC调用KMCL导出的VmbClientChannelInitSetRingBufferPageCount API来指定的。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/8f7dc000adf168a4912fd9e49a5cb904.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-26 子分区中分配的一个16页环形缓冲区范例</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">环形缓冲区是从子虚拟机的
非分页池中分配的，会使用一种名为双重映射（double 
mapping）的技术通过内存描述符列表（MDL）进行映射（MDL详见卷1第5章）。在这种技术中，所分配的MDL可描述缓冲区中双倍数量的传入（或
传出）物理页面。MDL的PFN数组通过包含缓冲区的物理页面内容进行两次填充：一次填充该数组的前半部分，另一次填充后半部分。借此即可创建出“环形缓
冲区”。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">例如在图9-26中，传入
和传出缓冲区分别为16个页面（0x10），传出缓冲区被映射至地址0xFFFFCA803D8C0000。如果发送方将一个1KB的VMBus数据包写
入接近缓冲区末尾的位置，假设写入偏移量0x9FF00处，写入将会成功（不会引发访问违规异常），但数据中的一部分会被写入缓冲区末尾，另一部分会写入
开头。在图9-26中，仅256（0x100）字节会被写入缓冲区末尾，而剩余768（0x300）字节会被写入开头。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">传入和传出缓冲区均被一个控制页所包围。该页面会在两个端点之间共享，并构成了虚拟机环形控制块。这种数据结构可用于跟踪写入环形缓冲区的最后一个数据包的位置。此外该数据结构还包含一些位，可用于控制当数据包需要交付时，是否发出一个中断。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">环形缓冲区创建完毕后，
KMCL驱动程序会向VMBus发送一个IOCTL，要求创建一个GPA描述符列表（GPADL）。GPADL是一种类似于MDL的数据结构，可用于描述
一大块物理内存。但与MDL的不同之处在于，GPADL包含一个由客户机物理地址（GPA，总是以64位数字表示，这一点与MDL中包含的PFN不同）组
成的数组。VMBus驱动程序向根分区发送不同消息，借此传输整个GPADL，描述传入和传出的环形缓冲区（综合消息最大可达240字节，详见上文）。根
分区会重建整个GPADL并将其存储在一个内部列表中。当子虚拟机发出最终的打开通道（Open 
Channel）消息后，GPADL会被映射至根分区中。根VMBus驱动程序解析收到的GPADL，并使用VID驱动程序提供的服务将其映射至自己的物
理地址空间（借此维持了组成虚拟机物理地址空间的内存块范围列表）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">至此通道已就绪：子分区和
根分区可以直接读写环形缓冲区中的数据进行通信了。当发送方完成自己的数据写入操作后，即可调用KMCL驱动程序公开的
VmbChannelSendSynchronousRequest 
API，该API可调用VMBus服务，在与该通道相关的Xinterrupt对象的监视器页面中发送信号（老版本VMBus协议使用了一个中断页，其中
包含一个与每个通道相对应的位），或者VMBus也可以直接向通道的事件端口发信号，这只取决于所需的延迟。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除VSC之外，其他组件也
使用VMBus实现了更高级别的接口。例如VMBus管道，它是在两个内核模式库（Vmbuspipe.dll和Vmbuspiper.dll）中实现
的，并且依赖VMBus驱动程序（通过IOCTL）公开的服务。Hyper-V套接字（也叫HvSocket）允许使用标准网络接口（套接字）实现分区间
高速通信。客户端通过指定目标虚拟机的GUID和Hyper-V套接字服务注册GUID（若要使用HvSocket，两端必须在注册表
HKLM\SOFTWARE\Microsoft\Windows 
NT\CurrentVersion\Virtualization\GuestCommunicationServices键下注册），即可在不使用目
标IP地址和端口的情况下连接至AF_HYPERV类型的套接字。Hyper-V套接字是通过多个驱动程序实现的：HvSocket.sys是传输驱动程
序，负责公开套接字基础架构使用的底层服务；HvSocketControl.sys是提供程序控制驱动程序，用于在系统中不存在VMBus接口时加载
HvSocket提供程序；HvSocket.dll是一个库，公开了补充的套接字接口（与Hyper-V套接字绑定），可从用户模式应用程序中调用。有
关Hyper-V套接字和VMBus管道内部基础架构的详细介绍已超出本书的范围，相关内容可参阅微软文档。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_91" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>2</b><b>.</b><b>5</b><b> </b><b>虚</b><b>拟</b><b>硬</b><b>件</b><b>支</b><b>持</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了正确运行虚拟机，虚拟
化堆栈需要为虚拟化设备提供支持。Hyper-V支持不同类型的虚拟设备，这些设备是通过虚拟化堆栈的多个组件实现的。发往以及来自虚拟设备的I/O主要
由根操作系统负责协调，I/O包括存储、网络、键盘、鼠标、串口以及GPU（图形处理单元）。虚拟化堆栈可以向客户虚拟机公开三类设备。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·模拟设备，（按照行业标准）也可称为完全虚拟化的设备。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·综合设备，也叫半虚拟化设备。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·硬件加速设备，也叫作直接访问设备。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了针对物理设备执行I/O操作，处理器通常会从设备所属的输入和输出端口（I/O端口）读取和写入数据。CPU可以通过两种方式访问I/O端口。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·通过一个独立的I/O地址空间，这是一种与物理内存地址空间不同的空间，在AMD64平台上，该空间可由6.4万个不同的可寻址I/O端口组成。这是一种较老的方法，通常只用于遗留的设备。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·通过内存映射的I/O访问。可以像内存组件那样响应的设备，能够通过处理器的物理内存地址空间访问，这意味着CPU可以通过标准指令访问内存：底层物理内存会被映射至设备。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图9-27展示了一个模拟设备范例（第一代虚拟机所用的虚拟IDE控制器），该设备使用内存映射的I/O与虚拟处理器传输数据。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/1915695e045b7dfbdb26c565be7f4c5c.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-27 虚拟IDE控制器，它使用模拟的I/O执行数据传输</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">该模式下，每次虚拟处理器
读写设备MMIO空间或发出指令以访问I/O端口时，都会向虚拟机监控成程序发出VMEXIT。虚拟机监控程序调用相应的拦截例程，将例程调度给VID驱
动程序。VID驱动程序会构建一条VID消息，并将其放入一个内部队列。该队列会由一个内部VMWP线程排空，这个线程会等待并调度从VID驱动程序收到
的虚拟处理器消息。这个线程叫作消息泵线程，隶属于一个在VMWP创建时初始化的内部线程池。虚拟机工作线程可识别导致VMEXIT的物理地址，将其与相
应虚拟设备（VDEV）关联，并调用一个VDEV回调（通常是读取或写入回调）。VDEV代码会使用指令模拟器提供的服务执行故障指令，并正确地模拟虚拟
设备（本例中的IDE控制器）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
虚拟机工作进程中的完整指令模拟器也可用于其他用途，例如加快子分区中拦截密集型代码的运行。此时，该模拟器可以让两次拦截期间的执行上下文保留在工作进
程中，因为VMEXIT会产生较大的性能开销。旧版本硬件虚拟化扩展禁止在虚拟机中执行实模式代码，对于这种情况，虚拟化堆栈会使用模拟器在虚拟机中执行
实模式代码。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>半</b><b>虚</b><b>拟</b><b>化</b><b>设</b><b>备</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然模拟设备总是会产生
VMEXIT并且相当慢，但图9-28展示了一种综合或半虚拟化设备范例：综合存储适配器。综合设备知道自己运行在虚拟化环境中，这样可以降低虚拟设备的
复杂性，使其实现更高性能。一些综合虚拟设备只以虚拟形式存在，不会模拟任何真正的物理硬件（如综合RDP）。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/00a0df19e73342049c588ff774b614cf.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图9-28 存储控制器半虚拟化设备</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">半虚拟化设备通常包含三个主要组件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个虚拟化服务提供程序（VSP）驱动程序，该组件运行在根分区中，可通过VMBus提供的服务（详见上文）将特定虚拟化接口公开给客户机。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
一个综合VDEV，会被映射至虚拟机工作进程，并且通常只在虚拟设备的驱动、拆除、保存和还原过程中提供协调作用。设备的常规工作过程中一般不会用到该组
件。综合VDEV会初始化并分配设备特定的资源（例如本例中的SynthStor 
VDEV会初始化虚拟存储适配器），但最重要的是，它可以让VSP为客户机VSC提供VMBus通信通道。该通道可用于与根分区通信，以及通过虚拟机监控
程序发出与设备有关的通知信号。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个虚拟化服务使用程序（VSC）驱动程序，该组件运行在子分区中，可理解VSP所公开的与虚拟化有关的接口，并使用VSP通过VMBus公开的共享内存读/写消息和通知，这样虚拟设备即可比模拟的设备更快速地在子虚拟机中运行。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>硬</b><b>件</b><b>加</b><b>速</b><b>设</b><b>备</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在服务器版系统中，硬件加
速设备（也叫直接访问设备）可供物理设备重映射至客户机分区，而这是通过VPCI基础架构公开的服务实现的。如果物理设备支持诸如单根输入/输出虚拟化
（Single-root Input/Output Virtualization，SR IOV）或离散设备分配（Discrete Device 
Assignment，DDA），即可映射至客户机分区。客户机分区可以直接访问与设备相关的MMIO空间，并在无须虚拟机监控程序进行任何拦截的情况
下，直接通过客户机内存执行DMA访问。IOMMU提供了所需的安全性，并保证了设备只能在属于虚拟机的物理内存中发起DMA传输。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图9-29展示了负责管理硬件加速设备的组件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·运行在虚拟机工作进程中的VPci VDEV（Vpcievdev.dll），它的作用是从虚拟机配置文件中提取硬件加速设备列表，设置VPCI虚拟总线，并将设备分配给VSP。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·PCI
代理驱动程序（Pcip.sys），负责从根分区卸载并安装DDA兼容的物理设备，此外它还在获取设备（通过SR-IOV协议）使用的资源（如MMIO空
间和中断）列表方面起到了关键的作用。该代理驱动程序提供了对设备物理配置空间的访问，并呈现了一个无法被宿主机操作系统访问的“未挂载”设备。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·VPCI虚拟服务提供程序（Vpcivsp.sys），创建并维护了关联给一个或多个硬件加速设备（在VPCI VSP中这叫作虚拟设备）的虚拟总线对象。虚拟设备可通过VSP创建的VMBus通道公开给客户虚拟机，并提供给客户机分区中的VSC使用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·VPCI
虚拟服务客户端（Vpci.sys），这是一种运行于客户虚拟机中的WDF总线驱动程序，可连接至VSP公开的VMBus通道，接收暴露给虚拟机的直接访
问设备列表及其资源，并为每个设备创建PDO（物理设备对象）。随后，设备驱动程序即可像在非虚拟化环境中那样创建PDO。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b2b449e86809b3b04d8a2c0b919a6b63.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图9-29 硬件加速设备</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当用户要将硬件加速设备映
射至虚拟机时，需要使用一些PowerShell命令（详见下面的实验），借此将设备从根分区“卸载”。该操作会迫使VMMS服务与标准PCI驱动程序
（通过公开的PciControl设备）通信。VMMS服务通过提供设备描述符（以总线、设备及功能ID形式）向PCI驱动程序发送
PCIDRIVE_ADD_VMPROXYPATH这个IOCTL。PCI驱动程序检查描述符，如果验证成功，会将其添加至
HKLM\System\CurrentControlSet\Control\PnP\Pci\VmProxy注册表值。随后VMMS使用PNP管理器
暴露的服务启动PNP设备（重新）枚举。在枚举阶段，PCI驱动程序可以找到新的代理设备并加载PCI代理驱动程序（Pcip.sys），将该设备标记为
虚拟化堆栈保留，使其对宿主机操作系统不可见。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">第二步需要将设备分配给虚
拟机。这种情况下，VMMS会将设备描述符写入虚拟机配置文件。当虚拟机启动时，VPCI 
VDEV（Vpcievdev.dll）从虚拟机配置中读取直接访问设备的描述符，并开始一个复杂的配置过程，这个过程主要由VPCI 
VSP（Vpcivsp.sys）负责协调。实际上，在“上电”回调中，VPCI VDEV会向VPCI 
VSP（运行在根分区中）发送不同的IOCTL，这是为了执行虚拟总线的创建操作并将硬件加速设备分配给客户虚拟机。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">“虚拟总线”是一种数据结
构，VPCI基础架构可将其用作“黏合剂”来维持根分区、客户虚拟机，以及所分配的直接访问设备之间的连接。VPCI 
VSP会分配并启动提供给客户虚拟机的VMBus通道，并将其封装在虚拟总线内。此外，虚拟总线还包含一些指向重要数据结构的指针，例如用于双向通信的已
分配VMBus数据包、客户机电源状态等。虚拟总线创建完毕后，VPCI VSP会执行设备分配工作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">硬件加速设备在内部是通过
LUID识别的，并由一种VPCI VSP分配的虚拟设备对象来表示。VPCI 
VSP可以根据设备的LUID定位适合的代理驱动程序（也叫作Mux驱动程序，通常为Pcip.sys）。VPCI 
VSP会从代理驱动程序查询SR-IOV或DDA接口，并借此获得直接访问设备的即插即用信息（硬件描述符），同时收集资源需求（MMIO空间、BAR寄
存器、DMA通道）。至此，设备就准备好可以附加至客户虚拟机：VPCI 
VSP会使用WinHvr驱动程序公开的服务向虚拟机监控程序发出HvAttachDevice虚拟化调用，借此重新配置系统的IOMMU，以便将设备的
地址空间映射至客户机分区。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于VPCI 
VSC（Vpci.sys）的存在，客户虚拟机可以知道所映射的设备。VPCI 
VSC是一种WDF总线驱动程序，由客户虚拟机中的VMBus总线驱动程序枚举并启动。它包含两个主要组件：一个在虚拟机启动时创建的FDO（功能设备对
象），以及一个或多个代表映射至客户虚拟机中的物理直接访问设备的PDO（物理设备对象）。当VPCI 
VSC总线驱动程序在客户虚拟机中运行时，它会创建并启动VMBus通道中用于与VSP交换消息的客户端部分。“发送总线关系”是VPCI 
VSC通过VMBus通道发送的第一条消息。根分区中的VSP对此的响应是发送一个列表，该列表中包含的硬件ID描述了目前连接到虚拟机的硬件加速设备。
当PNP管理器需要获得设备与VPCI 
VSC之间的新关系时，后者会为发现的每个直接访问设备新建一个PDO。VSC驱动程序还会向VSP发送其他消息，主要用途是请求PDO所需的资源。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">初始设置完成后，设备管理过程中将很少用到VSC和VSP。客户虚拟机中硬件加速设备的驱动程序会附加至相关PDO并管理外设，就好像这些设备是直接安装在物理计算机上的那样。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>将</b><b>硬</b><b>件</b><b>加</b><b>速</b><b>的</b><b>N</b><b>V</b><b>M</b><b>e</b><b>磁</b><b>盘</b><b>映</b><b>射</b><b>至</b><b>虚</b><b>拟</b><b>机</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如
上一节所述，在Windows Server 
2019宿主机上，支持SR-IOV和DDE技术的物理设备可以直接映射至客户虚拟机中。在这个实验中，我们要将通过PCI-Ex总线连接至系统，并且支
持DDE的NVMe磁盘链接给一个运行Windows 10的虚拟机（Windows Server 
2019还支持直接分配显卡，但这已超出了本实验的范围）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">正
如https://docs.microsoft.com/virtualization/community/team-
blog/2015/20151120- 
discrete-device-assignment-machines-and-devices中所述，为了能被重新分配，设备需要符合某些特征，例
如支持消息信号中断和内存映射I/O。此外，运行虚拟机监控程序的计算机还需要支持SR-IOV并具备适当的I/O 
MMU。在这个实验中，首先要确认系统BIOS中已经启用了SR-IOV标准（此处不再详述，具体操作请参阅计算机制造商文档）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随
后需要下载一个PowerShell脚本来验证自己的NVMe控制器是否兼容离散设备分配（discrete device 
assignment）。请访问https://github.com/MicrosoftDocs/Virtualization- 
Documentation/tree/master/hyperv-samples/benarm-powershell/DDA并下载名为
survey-dda.ps1的PowerShell脚本。随后以管理员身份打开一个PowerShell窗口（在搜索框中输入<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>P</b><b>o</b><b>w</b><b>e</b><b>r</b><b>S</b><b>h</b><b>e</b><b>l</b><b>l</b></span>并选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>以</b><b>管</b><b>理</b><b>员</b><b>身</b><b>份</b><b>运</b><b>行</b></span>”），并运行<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>G</b><b>e</b><b>t</b><b>-</b><b>E</b><b>x</b><b>e</b><b>c</b><b>u</b><b>t</b><b>i</b><b>o</b><b>n</b><b>P</b><b>o</b><b>l</b><b>i</b><b>c</b><b>y</b></span>命令检查PowerShell脚本执行策略是否被设置为Unrestricted（不受限）。如果该命令的输出结果为“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>U</b><b>n</b><b>r</b><b>e</b><b>s</b><b>t</b><b>r</b><b>i</b><b>c</b><b>t</b><b>e</b><b>d</b></span>”之外的其他情况，请输入<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>S</b><b>e</b><b>t</b><b>-</b><b>E</b><b>x</b><b>e</b><b>c</b><b>u</b><b>t</b><b>i</b><b>o</b><b>n</b><b>P</b><b>o</b><b>l</b><b>i</b><b>c</b><b>y</b><b> </b><b>-</b><b>S</b><b>c</b><b>o</b><b>p</b><b>e</b><b> </b><b>L</b><b>o</b><b>c</b><b>a</b><b>l</b><b>M</b><b>a</b><b>c</b><b>h</b><b>i</b><b>n</b><b>e</b><b> </b><b>-</b><b>E</b><b>x</b><b>e</b><b>c</b><b>u</b><b>t</b><b>i</b><b>o</b><b>n</b><b>P</b><b>o</b><b>l</b><b>i</b><b>c</b><b>y</b><b> </b><b>U</b><b>n</b><b>r</b><b>e</b><b>s</b><b>t</b><b>r</b><b>i</b><b>c</b><b>t</b><b>e</b><b>d</b></span>，按下回车键，然后输入<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>Y</b></span>以确认。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">执行下载的survey-dda.ps1脚本后，其输出结果会强调显示NVMe设备是否可以重新分配给客户虚拟机。输出结果范例如下：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Standard NVM Express Controller </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Express Endpoint -- more secure. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    And its interrupts are message-based, assignment can work. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PCIROOT(0)#PCI(0302)#PCI(0000) </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请
记录位置路径（本例中为PCIROOT(0)#PCI(0302)#PCI(0000)字符串）。接下来我们需要将目标虚拟机的自动停止操作设置为“关
闭”（DDA的必要步骤）并断开设备。本例中的虚拟机名为“Vibranium”，请在PowerShell窗口中输入下列命令（请将虚拟机名称和设备位
置替换为实际值）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Set-VM -Name "Vibranium" -AutomaticStopAction TurnOff </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Dismount-VMHostAssignableDevice -LocationPath "PCIROOT(0)#PCI(0302)#PCI(0000)"</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如果最后一个命令返回操作失败的错误，很可能是因为尚未禁用设备。请打开“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>设</b><b>备</b><b>管</b><b>理</b><b>器</b></span>”并找到NVMe控制器（本例中为Standard NVMe Express Controller），右击并选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>禁</b><b>用</b><b>设</b><b>备</b></span>”。随后即可再次运行最后一条命令，这次应该可以成功运行。随后运行下列命令将设备分配给虚拟机：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Add-VMAssignableDevice -LocationPath "PCIROOT(0)#PCI(0302)#PCI(0000)" -VMName "Vibranium" </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">上
一条命令可以将NVMe控制器从宿主机中彻底移除，我们可以在宿主机系统中使用设备管理器来验证这一点。随后需要启动虚拟机，为此可以使用Hyper-V
管理器工具或PowerShell。如果启动虚拟机后看到类似下图所示的错误信息，则可能意味着BIOS中尚未正确配置SR-IOV，或I/O 
MMU不符合必需的要求（很可能因为不支持I/O映射）。</span></p><div style="display: block;text-align:center;">
	<img width="543" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/de026a157d9f95b44713c5914cf77fcc.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">否
则虚拟机应该可以正常启动。在这种情况下，我们应该可以在子虚拟机的设备管理器中同时看到NVMe控制器和NVMe磁盘。我们可以在子虚拟机中使用磁盘管
理工具创建分区，具体做法与宿主机操作系统中的操作完全相同。NVMe磁盘可以全速运行，不会有性能损失（可以使用磁盘性能评测工具加以验证）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">若要正确地将设备从虚拟机中移除并重新挂载到宿主机操作系统，首先需要关闭虚拟机，随后运行下列命令（请注意，始终别忘了替换虚拟机名称和NVMe控制器位置）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Remove-VMAssignableDevice -LocationPath "PCIROOT(0)#PCI(0302)#PCI(0000)" -VMName</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">"Vibranium" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Mount-VMHostAssignableDevice -LocationPath "PCIROOT(0)#PCI(0302)#PCI(0000)" </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">最后一条命令运行完成后，NVMe控制器应当就可以重新出现在宿主机操作系统的设备管理器中。只需重新启用并重启动宿主机，即可在宿主机中使用这个NVMe磁盘了。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_92" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>2</b><b>.</b><b>6</b><b> </b><b>V</b><b>A</b><b>支</b><b>持</b><b>的</b><b>虚</b><b>拟</b><b>机</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机的用途有很多，其中
一种是在隔离的环境（容器）中正确运行传统软件（服务器Silo和应用程序Silo就是容器的两种类型，详见卷1第3章）。完整隔离的容器（内部命名为
Xenon和Krypton）需要能快速启动，开销低，并且尽可能减少内存占用。此类虚拟机的客户机物理内存通常会被多个容器共享。例如Windows 
Defender Application 
Guard就提供了一种容器，该功能可以通过容器提供完整隔离的浏览器或Windows沙盒，并借助容器获得完全隔离的虚拟化环境。通常来说，容器会共用
相同的虚拟机固件、操作系统，并且通常还会共用某些相同的应用程序（这些共享组件组成了容器的基础层）。在专用的客户机物理内存空间中运行每个容器，这种
做法并不可行，可能会极大地浪费物理内存。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了解决这个问题，虚拟化
堆栈为VA支持的虚拟机提供了支持。VA支持的虚拟机可以使用宿主机操作系统的内存管理器为客户机分区的物理内存提供高级功能，如内存去重、内存修剪、直
接映射、内存克隆，以及最重要的分页功能（所有这些概念均在卷1第5章进行了详细介绍）。对于传统的虚拟机来说，客户机内存是由VID驱动程序分配的，为
此需要静态分配来自宿主机的系统页面，并将其映射至虚拟机的GPA空间，随后才能让虚拟处理器有机会开始执行；但对于VA支持的虚拟机来说，GPA空间和
SPA空间之间添加了一个新的中间层，此时不再需要将SPA页面直接映射到GPA空间，VID可以创建一个初始为空的GPA空间，同时创建一个用户模式最
小化进程（名为VMMEM）来承载VA空间，并使用MicroVM设置GPA到VA的映射。MicroVM是NT内核的一个新组件，它与NT内存管理器紧
密集成，可负责GPA到VA的映射（由VID维护）以及VA到SPA的映射（由NT内存管理器维护），最终实现GPA到SPA的映射。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这个新增的中间层可以让
VA支持的虚拟机充分利用原本供Windows进程使用的大部分高级内存管理功能。正如上一节所述，虚拟机工作进程在启动虚拟机时，需要让VID驱动程序
创建分区的内存块。如果是VA支持的虚拟机，则会创建内存块范围GPA映射位图，借此跟踪为新虚拟机的RAM提供支持的已分配虚拟页面。随后虚拟机工作进
程还会创建分区的RAM内存，这是由一个大范围的VA空间支持的。VA空间通常会与虚拟机已分配的RAM内存容量一样大（但这并非必要条件：不同的VA范
围可映射为不同的GPA范围），并且会在VMMEM进程的上下文中使用原生的NtAllocateVirtualMemory API进行保留。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果“延迟提交”优化未启
用（详见下一节），VID驱动程序将再次调用NtAllocateVirtualMemory 
API，这是为了提交整个VA范围。正如卷1第5章所述，提交的内存会消耗系统的提交限制，但依然不会分配任何物理页面（所有描述整个范围的PTE项都是
无效的PTE）。VID驱动程序在这个阶段会使用Winhvr要求虚拟机监控程序将整个分区的GPA映射至一个特殊的无效SPA（为此需要使用与标准分区
一样的HvMapGpaPages虚拟化调用）。如果客户机分区访问的客户机物理内存是由这个特殊的无效SPA映射到SLAT表所产生的，此时会向虚拟机
监控程序发出一个VMEXIT，使其可以识别这个特殊值并向根分区注入内存拦截。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">VID驱动程序最后会调用
VmCreateMemoryRange例程向MicroVM告知VA支持的GPA的新范围（MicroVM服务由NT内核通过一个内核扩展公开给VID
驱动程序）。MicroVM将分配并初始化一个VM_PROCESS_CONTEXT数据结构，其中包含了两个重要的红黑树：一个描述虚拟机中分配的
GPA范围，一个描述根分区中对应的系统虚拟地址（SVA）范围。随后一个指向已分配数据结构的指针会被保存到VMMEM实例的EPROCESS中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当虚拟机工作进程希望写入
VA支持的虚拟机的内存时，或由于GPA到SPA的无效转换产生了内存拦截时，VID驱动程序会调用MicroVM页面错误处理程序
（VmAccessFault）。该处理程序会执行两个重要操作：首先，它会在描述出错虚拟页面的页表中插入一个有效PTE来解决错误（详见卷1第5
章），然后会更新子虚拟机的SLAT表（为此需要调用WinHvr驱动程序，由它发出另一个HvMapGpaPages虚拟化调用）。随后，虚拟机的客户
机物理页面即可直接换出，因为私有进程内存通常都是可分页的。这就产生了一个重要的影响：要求MicroVM的大部分函数都以被动IRQL级别来运行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NT内存管理器的多个服务
均可用于VA支持的虚拟机。尤其是克隆模板允许将VA支持的两个虚拟机的内存进行快速克隆，直接映射可以让共享的可执行映像或数据文件的节对象映射至
VMMEM进程以及指向VA区域的GPA范围。底层物理页面可在不同虚拟机和宿主机进程之间共享，进而可大幅提高内存密度。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>V</b><b>A</b><b>支</b><b>持</b><b>的</b><b>虚</b><b>拟</b><b>机</b><b>的</b><b>优</b><b>化</b><b>措</b><b>施</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上一节所述，如果客户机
访问缺乏支持的动态内存，或不具备所需权限，此时的访问成本将会相当高：如果客户机企图访问不可访问的内存，将发出VMEXIT，这需要虚拟机监控程序挂
起客户机虚拟处理器，调度根分区的虚拟处理器，并向其中注入一个内存拦截消息。VID的拦截回调处理程序需要在高IRQL级别下调用，但处理该请求并调用
MicroVM需要在PASSIVE_LEVEL级别下进行。因此需要将DPC放入队列。DPC例程通过设置事件来唤醒负责处理拦截的相应线程。当
MicroVM页面错误处理程序解决该错误并调用虚拟机监控程序以更新SLAT项（这要使用另一个虚拟化调用，并产生另一个VMEXIT）之后，才能恢复
客户机虚拟处理器的运行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">运行时产生大量内存拦截会导致性能受到巨大影响。为了避免这种问题，系统以客户机启发（或一些简单配置）的方式实现了很多优化措施。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·内存清零启发。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·内存访问提示。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·启发式页面错误。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·延迟提交和其他优化措施。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内存清零启发为避免将原本
由根分区或其他虚拟机使用的内存构件中包含的信息泄露给另一个虚拟机，内存支持的客户机RAM必须首先清零，然后才能通过映射供其他客户机访问。一般来
说，操作系统会在启动过程中将所有物理内存清零，因为在物理系统中，这些内容是非确定性（nondeterministic）的。对于虚拟机，这意味着内
存需要清零两次：一次由虚拟化宿主机清零，一次由客户机操作系统清零。对于以物理形式支持的虚拟机，这顶多浪费了CPU周期；但对于VA支持的虚拟机，客
户机操作系统进行的清零会产生代价高昂的内存拦截。为避免无谓的拦截，虚拟机监控程序提供了内存清零启发。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当Windows加载器加
载主操作系统时，会使用UEFI固件提供的服务得到计算机的物理内存图。当虚拟机监控程序启动VA支持的虚拟机时，会公开
HvGetBootZeroedMemory的虚拟化调用，Windows加载器可以借此查询实际上已经清零的物理内存范围列表。在将执行转向NT内核之
前，Windows加载器会将获得的已清零页面与通过EFI服务获得的物理内存描述符合并，并将结果存储到加载器块（有关启动机制的详情请参阅第12章）
中。NT内核通过跳过初始内存清零操作，即可将合并后的描述符直接插入已清零的页面列表中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机监控程序也通过类似
方式为热添加内存的清零启发提供了支持，这是通过一种简单的实现做到的：当动态内存VSC驱动程序（dmvsc.sys）向NT内核发起添加物理内存的请
求时，会指定MM_ADD_PHYSICAL_MEMORY_ALREADY_ZEROED标记，这会提示内存管理器（MM）直接将新页面添加到清零后的
页面列表。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>内</b><b>存</b><b>访</b><b>问</b><b>提</b><b>示</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于以物理形式支持的虚拟
机，根分区对于客户机内存管理器将如何使用物理页面所能提供的信息极为有限。对于这些虚拟机，这类信息大多都是不相关的，因为几乎所有的内存和GPA映射
都是在虚拟机启动时创建的，随后将保持静态映射。对于VA支持的虚拟机，这类信息则非常有用，因为宿主机内存管理器所管理的最小化进程的工作集中就包含了
虚拟机的内存（VMMEM）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这样的热提示可以让客户机
表明要将一组物理页面映射至客户机，因为这些页面很快就要访问，或者需要频繁访问。这也意味着页面会被添加到最小化进程的工作集中。VID处理这类提示的
方法是告诉MicroVM立即对物理页面进行错误处理，而不要将其从VMMEM进程的工作集中移除。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">冷提示也可以通过类似方式
让客户机表明一组物理页面应该从客户机中取消映射，因为很快就不再使用了。VID驱动程序处理此类提示的方法是将其转发给MicroVM，进而立即将页面
从工作集中移除。通常来说，客户机会为已经被后台清零页面线程清零的页面使用冷提示（详见卷1第5章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">VA支持的客户机分区可以使用HvMemoryHeatHint虚拟化调用为页面指定内存提示。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>启</b><b>发</b><b>式</b><b>页</b><b>面</b><b>错</b><b>误</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">启发式页面错误
（Enlightened Page 
Fault，EPF）处理是一种可以让VA支持的客户机分区重新调度虚拟处理器上线程的功能，该功能会导致VA支持的GPA页面产生内存拦截。通常来说，
此类页面的内存拦截处理方式为：以同步方式解决根分区的访问错误，并在访问错误完成后恢复虚拟处理器的运行。当启用了EPF并且VA支持的GPA页面发生
内存拦截后，根分区中的VID驱动程序会创建一个后台工作线程，由该线程调用MicroVM页面错误处理程序并向客户机虚拟处理器发出一个同步异常（不要
将它与异步中断混淆），这样就可以告知当前线程导致了内存拦截。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">客户机重新调度该线程，同时宿主机正在处理访问错误。访问错误完成后，VID驱动程序会将原先导致故障的GPA添加到一个完成队列中，并向客户机发出一个异步中断。该中断会导致客户机检查完成队列，并解除对正在等待EPF完成的任何线程所进行的封锁。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>延</b><b>迟</b><b>提</b><b>交</b><b>和</b><b>其</b><b>他</b><b>优</b><b>化</b><b>措</b><b>施</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">启用延迟提交这项优化措
施，会迫使VID驱动程序在首次访问前不要提交每一个支持页面。这有可能在无须增大页面文件的情况下同时运行更多虚拟机，但因为提供支持的VA空间只是保
留空间，并未提交，所以虚拟机在运行过程中可能因达到根分区的提交限额而崩溃。这种情况下已经没有更多可用内存了。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">我们还可以通过其他优化措施设置由MicroVM页面错误处理程序分配的页面大小（可分配“大”或“小”页面），并在首次访问时固定支持页面，这样可以防止老化和修剪，通常可实现更一致的性能，但代价是需要消耗更多的内存，并且会降低内存密度。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>V</b><b>M</b><b>M</b><b>E</b><b>M</b><b>进</b><b>程</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">VMMEM进程的存在主要出于以下两个原因。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·在启用根调度器的情况下承载虚拟处理器调度线程循环，并代表客户机虚拟处理器的调度单元。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·为VA支持的虚拟机承载VA空间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">VMMEM进程由VID驱
动程序在创建虚拟机分区时创建。与普通分区（详见上一节）一样，虚拟机工作进程会通过VID.dll库初始化虚拟机的设置，该库可通过IOCTL调用
VID。如果VID驱动程序检测到新分区由VA支持，则它会通过VsmmNtSlatMemoryProcessCreate函数调用MicroVM来创
建最小化进程。MicroVM使用的PsCreateMinimalProcess函数可分配进程，创建地址空间，并将该进程插入进程列表。随后它会保留
地址空间中底部的4GB，以确保直接映射的映像最终不会出现在这里（这会降低客户机的熵和安全性）。VID驱动程序会为新的VMMEM进程应用一个特定的
安全描述符，仅SYSTEM和虚拟机工作进程可以访问该进程（虚拟机工作进程会使用特定令牌启动，该令牌的所有者会被设置为使用虚拟机的唯一GUID生成
的SID）。这一点非常重要，如果不这样做，VMMEM进程的虚拟地址空间将会被所有人访问。通过读取进程虚拟内存，恶意用户有可能读取到虚拟机专用的客
户机物理内存。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter09_0003.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_93" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>3</b><b> </b><b>基</b><b>于</b><b>虚</b><b>拟</b><b>化</b><b>的</b><b>安</b><b>全</b><b>性</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如上一节所述，
Hyper-V提供了在Windows系统中管理和运行虚拟机所需的服务。虚拟机监控程序保证了分区之间可实现必要的隔离。这样，一个虚拟机就无法影响另
一个虚拟机的运行。本节将介绍Windows虚拟化基础架构的另一个重要组件：安全内核，它提供了基于虚拟化的安全性所需的基础服务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">首先，我们会介绍安全内核
提供的服务及其要求，随后将介绍架构和基本组件；此外，还会介绍一些基本的内部数据结构，并讨论安全内核和虚拟安全模块启动方法，以及它们对虚拟机监控程
序的高度依赖性；最后会介绍以安全内核为基础构建的各类组件，例如隔离用户模式、虚拟机监控程序实施的代码完整性、安全软件隔区、安全设备，以及
Windows内核热修补和微码服务。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_94" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>3</b><b>.</b><b>1</b><b> </b><b>虚</b><b>拟</b><b>信</b><b>任</b><b>级</b><b>别</b><b>和</b><b>虚</b><b>拟</b><b>安</b><b>全</b><b>模</b><b>式</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上一节所述，虚拟机监控
程序会使用SLAT将每个分区维持在自己的内存空间中。分区中运行的操作系统可以通过标准方式（借助页表将客户机虚拟地址转换为客户机物理地址）来访问内
存。在这一过程内部，硬件会将所有分区GPA转换为真正的SPA并执行实际的内存访问。这最后一个转换层由虚拟机监控程序维护，并且会为每个分区使用一个
单独的SLAT表。通过类似方式，虚拟机监控程序也可以使用SLAT在一个分区中创建多个安全域。微软正是基于这个功能设计了安全内核，并使其成为虚拟安
全模式（Virtual Secure Mode，VSM）的基础。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">传统上，操作系统只有一个
物理地址空间，在Ring 
0级别（即内核模式）运行的软件可以访问任何物理内存地址。因此，如果运行在这种管理者模式下的任何软件（内核、驱动程序等）被攻陷，整个系统也将被攻
陷。虚拟安全模式可以利用虚拟机监控程序为系统软件提供一种全新的信任边界。在VSM的帮助下，安全边界（由虚拟机监控程序通过SLAT描述）可以放置在
一个更合适的位置，并对管理者模式下资源的访问加以限制。因此，在使用VSM后，即使管理者模式下的代码被攻陷，整个系统也不会被波及。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">VSM通过虚拟信任级别
（Virtual Trust 
Level，VTL）的概念提供了这样的边界。究其核心，VTL实际上是对物理内存提供的一系列访问保护措施。每个VTL可以具备不同的访问保护措施，借
此VTL即可用于实现内存隔离。VTL的内存访问保护可配置为限制特定VTL所能访问的物理内存。在使用VSM的情况下，虚拟处理器将始终在特定VTL下
运行，只能访问通过虚拟机监控程序SLAT标记为可访问的物理内存。举例来说，如果某个处理器运行在VTL 0下，那么只能访问与VTL 
0相关的内存访问保护所控制的内存。这种对内存访问的限制发生在客户机物理内存转换的层面上，因此，无法被分区中以管理者模式运行的代码更改。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">VTL可以形成层次结构。
层级越高，特权越多，并且高层级可调整低层级的内存访问保护。因此，运行在VTL 1的软件可以调整VTL 0的内存访问保护，限制VTL 
0所能访问的内存。这使得VTL 1中的软件可以向VTL 
0隐藏（隔离）内存。这是一个很重要的概念，同时也是VSM的实现基础。目前，虚拟机监控程序只支持两个VTL：代表常规操作系统执行环境，用户可与之交
互的VTL 0；代表安全模式，负责运行安全内核与隔离用户模式（IUM）的VTL 1。由于VTL 
0中运行了标准操作系统和应用程序，因此通常也会被称为“常规模式”。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> VSM架构最初的设计最多可支持16个VTL。但截至撰写这部分内容，虚拟机监控程序只支持2个。未来微软有可能添加一个或多个新VTL。例如，Azure中运行的最新版Windows Server支持的机密虚拟机
	<sup><img width="11" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="机密虚拟机是一种特殊用途的Azure虚拟机，相比普通的Azure虚拟机，它可提供更强大的安全边界和隔离能力，同时还可提供更多安全功能，适合对安全性和机密性要求更高的用户。详细信息可参阅Azure官网。——译者注" title="机密虚拟机是一种特殊用途的Azure虚拟机，相比普通的Azure虚拟机，它可提供更强大的安全边界和隔离能力，同时还可提供更多安全功能，适合对安全性和机密性要求更高的用户。详细信息可参阅Azure官网。——译者注" class="epub-footnote"></sup>功能，其宿主机兼容层（Host Compatibility Layer，HCL）就运行在VTL 2中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每个VTL都具备下列相关特征。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>内</b><b>存</b><b>访</b><b>问</b><b>保</b><b>护</b></span>。如上文所述，每个VTL都有一组客户机物理内存访问保护措施，用于决定软件如何访问内存。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>虚</b><b>拟</b><b>处</b><b>理</b><b>器</b><b>状</b><b>态</b></span>。虚拟机监控程序中的每个虚拟处理器都与每个VTL共享某些寄存器，但也有一些寄存器是每个VTL私有的。VTL的私有虚拟处理器状态无法被更低级别VTL下运行的软件所访问。这样即可在VTL之间对处理器的状态实现隔离。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>中</b><b>断</b><b>子</b><b>系</b><b>统</b></span>。每个VTL都有一个唯一的中断子系统（由虚拟机监控程序综合中断控制器负责管理）。VTL的中断子系统无法被更低级别VTL下运行的软件所访问。这样即可在特定VTL下安全地管理中断，不会造成低VTL生成非预期中断或屏蔽中断的风险。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图9-30展示了虚拟机监
控程序为虚拟安全模式（VSM）提供的内存保护架构方案。虚拟机监控程序会通过不同的VMCS数据结构（详见上一节）代表虚拟处理器的每个VTL，其中还
包括一个特定的SLAT表。这样，运行在某个特定VTL下的软件就只能访问分配给自己所在级别的物理内存页。这里的重点在于：SLAT保护会应用于物理页
面，而非虚拟页面，虚拟页面是由标准页表负责保护的。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/1a73354f1ae6786f3fcca54f5f69b9e9.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-30 虚拟机监控程序为VSM提供的内存保护架构方案</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_95" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>3</b><b>.</b><b>2</b><b> </b><b>V</b><b>S</b><b>M</b><b>提</b><b>供</b><b>的</b><b>服</b><b>务</b><b>及</b><b>其</b><b>要</b><b>求</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">基于虚拟机监控程序构建的虚拟安全模式（VSM）为Windows生态提供了下列服务。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>隔</b><b>离</b></span>。
IUM为每个在VTL 1下运行的软件提供了基于硬件的隔离环境。安全内核所管理的安全设备会与系统的其他部分隔离，并运行在VTL 
1用户模式下。运行在VTL 1下的软件通常会将不能被截取或泄露的机密数据存储在VTL 0下。凭据保护（credential 
guard）功能就大量使用了该服务，该功能可以将所有系统凭据存储在运行于VTL 1用户模式下的LsaIso Trustlet内存地址空间中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>对</b><b>V</b><b>T</b><b>L</b><b> </b><b>0</b><b>的</b><b>控</b><b>制</b></span>。
虚拟机监控程序实施的代码完整性（Hypervisor Enforced Code 
Integrity，HVCI）可检查常规操作系统加载并运行的每个模块的完整性和签名。完整性检查完全在VTL 1下进行（可访问所有的VTL 
0物理内存），任何VTL 
0软件都无法干扰签名检查。此外，HVCI保证了包含可执行代码的所有常规模式内存页都会被标记为不可写（该功能也叫W^X，HVCI和W^X详见卷1第
7章）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>安</b><b>全</b><b>拦</b><b>截</b></span>。VSM提供的机制可以让较高的VTL锁定某些关键系统资源，防止其被较低的VTL访问。HyperGuard大量使用了安全拦截，该功能可阻止对操作系统的关键组件进行恶意修改，以此为VTL 0内核提供一层额外的保护。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>基</b><b>于</b><b>V</b><b>B</b><b>S</b><b>的</b><b>隔</b><b>区</b></span>。安全隔区（security enclave）是用户模式进程地址空间中一块隔离的内存区域。这种内存隔区甚至无法被更高的特权级别访问。该技术最初的实现需要使用硬件组件对属于进程的内存加密，而基于VBS的隔区，则可以由VSM对隔区的隔离性提供保证。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>内</b><b>核</b><b>控</b><b>制</b><b>流</b><b>防</b><b>护</b></span>。
在启用HVCI的情况下，VSM可以为常规世界中的每个内存模块（以及NT内核本身）提供控制流防护（Control Flow 
Guard，CFG）。运行在常规世界中的内核模式软件可以对位图获得只读访问的权限，因此，攻击措施将无法修改这些内容。也正因如此，Windows中
的内核CFG也被称为安全内核CFG（SKCFG）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> CFG是微软对控制流完整性的实现结果，这种技术可以防止各类恶意攻击对程序的执行流进行重定向。用户模式和内核模式CFG的详情可参阅卷1第7章。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>安</b><b>全</b><b>设</b><b>备</b></span>。安全设备是一种全新类型的设备，其映射和管理工作完全由VTL 1下的安全内核负责。此类设备的驱动程序完全在VTL 1用户模式下运行，会使用安全内核提供的服务映射设备I/O空间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了正确启用并正常运行，
VSM对硬件有一些要求。宿主机系统必须支持虚拟化扩展（Intel VT-x、AMD SVM或ARM 
TrustZone）和SLAT。如果系统处理器不具备上述一种硬件功能，那么VSM将无法运行。虽然其他一些硬件功能并不严格要求，但如果不支持，
VSM的某些安全权限可能将无法保证。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·为防范物理设备的DMA攻击，必须具备IOMMU。如果系统处理器不具备IOMMU，那么VSM依然可以运行，但容易受到此类物理设备的攻击。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
为保护启动虚拟机监控程序和安全内核所需的引导链，必须具备启用安全启动（secure boot）功能的UEFI 
BIOS。如果不启用安全启动，那么系统的启动过程将容易受到攻击，这种攻击可能修改虚拟机监控程序和安全内核的完整性，甚至在这些功能开始执行前进行篡
改。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">其他组件是可选的，但如果
有这些组件，将大幅改善系统的整体安全性和响应性。TPM就是一个很好的例子。安全内核会使用TPM存储主加密密钥并执行安全运行（也叫DRTM，详见第
12章）。还有一个硬件组件可以改善VSM的响应性，那就是处理器对基于模式的执行控制（Mode-Based Execute 
Control，MBEC）提供的硬件支持：当启用HVCI以保护内核模式中用户模式页的执行状态时，就会用到MBEC。通过使用硬件MBEC，虚拟机监
控程序可以根据特定VTL的CPL（内核或用户）域设置物理内存页的可执行状态。这样，属于用户模式应用程序的内存将以物理的方式标记为只能由用户模式下
的代码执行（内核漏洞将不再执行自己位于用户模式应用程序内存中的代码）。如果不支持硬件MBEC，则虚拟机监控程序需要模拟MBEC，为此需要为VTL
 
0使用两个不同的SLAT表，并在代码执行改变了CPL安全域时进行切换（从用户模式切换至内核模式，或反之，这种情况下都会产生VMEXIT）。有关
HVCI的详情请参阅卷1第7章。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>检</b><b>测</b><b>V</b><b>B</b><b>S</b><b>及</b><b>其</b><b>提</b><b>供</b><b>的</b><b>服</b><b>务</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们将在第12章讨论VSM启动策略并介绍如何手动启用或禁用基于虚拟化的安全性。在这个实验中，我们将检查虚拟机监控程序和安全内核所提供各类功能的状
态。VBS是一种不对用户直接可见的技术，默认安装的Windows中提供的系统信息工具可显示有关安全内核及其相关技术的详细信息。我们可以在搜索框中
输入<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>m</b><b>s</b><b>i</b><b>n</b><b>f</b><b>o</b><b>3</b><b>2</b></span>运行该工具。请以管理员身份运行该工具，某些信息仅供具备完整特权的用户账户查看。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">从
下图可知，VBS已启用，并且包含HVCI（显示为“虚拟机监控程序实施的代码完整性”）、UEFI运行时虚拟化（显示为“UEFI只读”）、MBEC
（显示为“基于模式的执行控制”）。然而，下图所示的系统未启用安全启动，也不包含可用的IOMMU（在“基于虚拟化的安全性可用安全属性”这一行下显示
为“DMA保护”）。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/48393b6fa9065a7f6422b7faa6ee7aa4.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">有关如何启用、禁用、锁定VBS配置的详细信息请参阅第12章的“理解VSM策略”实验。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter09_0004.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_96" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>4</b><b> </b><b>安</b><b>全</b><b>内</b><b>核</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全内核主要在
securekernel.exe文件中实现，由Windows加载器在虚拟机监控程序成功运行后启动。如图9-31所示，安全内核是一种最小化的操作系
统，会与运行在VTL 0下的常规内核紧密合作。与任何常规操作系统类似，安全内核运行在VTL 1的CPL 0（也称Ring 
0或内核模式）模式下，它为VTL 1的CPL 3（也称Ring 3或用户模式）下的隔离用户模式（Isolated User 
Mode，IUM）提供所需服务（大部分通过系统调用提供）。为了尽可能地减小攻击面，安全内核在设计上尽可能的小巧。它不像常规内核那样可以通过外部设
备驱动程序进行扩展，唯一可以扩展其功能的内核模块是由Windows加载器在VSM启动前加载并从securekernel.exe中导入的。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>S</b><b>k</b><b>c</b><b>i</b><b>.</b><b>d</b><b>l</b><b>l</b></span>：实现安全内核中与虚拟机监控程序实施的代码完整性有关的部分。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>C</b><b>n</b><b>g</b><b>.</b><b>s</b><b>y</b><b>s</b></span>：提供安全内核所需的密码学引擎。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>V</b><b>m</b><b>s</b><b>v</b><b>c</b><b>e</b><b>x</b><b>t</b><b>.</b><b>d</b><b>l</b><b>l</b></span>：为安全内核组件在Intel TXT（Trusted Boot）环境中的认证提供支持（有关Trusted Boot的详情请参阅第12章）。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/db95cbbb5174959c1d75b2d3bbe7f4b1.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-31 基于虚拟机监控程序构建的虚拟安全模式架构方案</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然安全内核不可扩展，但
隔离用户模式提供了一种名为Trustlet的专用进程。Trustlet相互之间会被隔离，并且在数字签名方面有一些特殊要求。它们能通过
Syscall与安全内核通信，并能通过邮件槽和ALPC与常规世界通信。隔离用户模式的详细信息请参阅下文。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_97" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>4</b><b>.</b><b>1</b><b> </b><b>虚</b><b>拟</b><b>中</b><b>断</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">当虚拟机监控程序配置底层
虚拟分区时，在CPU的物理APIC（Advanced Programmable Interrupt 
Controller，高级可编程中断控制器）引发一个外部中断后，它都要求物理处理器产生一个VMEXIT。硬件的虚拟机扩展允许虚拟机监控程序向客户
机分区注入虚拟中断（详见Intel、AMD以及ARM的用户手册）。在这两个因素的作用下，虚拟机监控程序实现了综合中断控制器（SynIC）的概念。
SynIC可以管理两种中断。虚拟中断是指传递给客户机分区虚拟APIC的中断，虚拟中断可以表示并与由真实硬件生成的物理硬件中断相关联。此外，虚拟中
断也可以表示综合中断，这种中断由虚拟机监控程序为响应某些类型的事件生成。SynIC可将物理中断映射至虚拟中断。VTL中所运行的每个虚拟处理器都会
有一个相关联的SynIC。截至撰写这部分内容，虚拟机监控程序在设计上已经可以支持16种不同的综合中断向量（但目前只用到了其中的两种）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当系统启动时（NT内核初
始化的阶段1），ACPI驱动程序会借助HAL提供的服务将每个中断映射给相应的向量。NT 
HAL已经得到启发，知道自己是否运行在VSM下。这种情况下，它调用虚拟机监控程序将每个物理中断映射给自己的VTL，甚至安全内核也会这样做。不过截
至撰写这部分内容，安全内核还不具备相关的物理中断（这种情况以后可能发生变化，虚拟机监控程序已经可以支持这样的功能）。目前，安全内核会要求虚拟机监
控程序只接收下列虚拟中断：安全计时器、虚拟中断通知辅助（Virtual Interrupt Notification 
Assist，VINA）以及安全拦截。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
必须了解这样一种情况：在管理只属于外部类型的中断时，虚拟机监控程序会要求底层硬件产生一个VMEXIT。异常依然会在执行处理器的同一个VTL中进行
管理（不会产生VMEXIT）。如果有指令导致异常，依然需要由当前VTL下的结构化异常处理（SEH）代码进行管理。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了理解这三种虚拟中断，首先必须看看虚拟机监控程序是如何管理中断的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在虚拟机监控程序中，每个
VTL在设计上都能安全地接收与自己的VTL相关设备发出的中断。这样即可获得一个不会被低安全性的VTL干扰的安全计时器设施，并确保在较高VTL下执
行代码时防止中断发给较低的VTL。此外，VTL应当向其他处理器发出IPI中断。这种设计产生了下列几种情况。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·在特定的VTL下运行时，接收以当前VTL为目标的中断会导致进行标准的中断处理机制（由虚拟处理器的虚拟APIC控制器决定）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
如果收到以更高的VTL为目标的中断，并且更高的VTL的IRQL值允许提交中断，那么接收这样的中断会导致切换至更高的VTL（也就是该中断原本的目标
VTL）。如果更高的VTL的IRQL值不允许接收中断，那么将不切换当前的VTL，直接将该中断加入队列。这种行为使得较高的VTL可以在返回较低的
VTL时选择性地屏蔽中断。如果较高的VTL正在运行中断服务例程并且需要返回较低的VTL以协助处理中断，这样的设计就会比较有用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果收到的中断以较低的VTL为目标（低于虚拟处理器当前执行的VTL），那么中断会被放入队列，等待将来交付给较低的VTL。以较低的VTL为目标的中断永远不会抢占当前的VTL的执行。相反，只有在虚拟处理器下一次转换到目标VTL时，这样的中断才会出现。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">防止向较低的VTL发出中
断，并不总是一种好的解决方案。在很多情况下，这可能导致常规操作系统的执行速度减慢（尤其是在一些关键任务或游戏环境中）。为了更好地应对这些情况，系
统引入了VINA。作为常规事件调度循环的一部分，虚拟机监控程序会检查是否有排队等待传递到较低的VTL的中断。如果有，虚拟机监控程序就会向当前执行
的VTL注入一个VINA中断。安全内核也在自己的虚拟IDT中为VINA向量注册一个处理程序。该处理程序（ShvlVinaHandler函数）可向
VTL 0执行常规调用（NORMALKERNEL_VINA，常规调用和安全调用详见下文）。该调用会迫使虚拟机监控程序切换至常规内核（VTL 
0）。一旦VTL被切换，所有排队的中断就会被正确调度。常规内核会通过发出一个SECUREKERNEL_RESUMETHREAD安全调用重新进入
VTL 1。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>安</b><b>全</b><b>I</b><b>R</b><b>Q</b><b>L</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">VINA处理程序并不总在
VTL 
1下执行。与NT内核类似，这也取决于代码实际执行时所在的IRQL。当前执行代码的IRQL会屏蔽所有小于或等于自己的IRQL所关联的中断。中断向量
与IRQL之间的映射由虚拟APIC的任务优先级寄存器（Task Priority 
Register，TPR）维护，这一点与真实的物理APIC无异（详见Intel架构手册）。如图9-32所示，相比常规内核，安全内核可支持不同级别
的IRQL。这些IRQL就叫安全IRQL。</span></p><div style="display: block;text-align:center;">
	<img width="737" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/12d49b98c6e4920648317d22fe59f42b.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-32 安全内核中断请求级别（IRQL）</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">前三个安全IRQL由安全
内核管理，具体方法与常规世界中的类似。常规APC和DPC（以VTL 0为目标）依然无法通过虚拟机监控程序抢占VTL 
1中执行的代码，但VINA中断却可以传送给安全内核（操作系统通过写入目标处理器的APIC任务优先级寄存器来管理这三个软件中断，该操作会导致向虚拟
机监控程序发出VMEXIT。有关APIC 
TPR的详情请参阅Intel、AMD或ARM手册）。这意味着，如果常规模式DPC被选择以一个正在执行VTL 
1代码的处理器为目标（处于可兼容的安全IRQL级别下，该级别至少应该为Dispatch），VINA中断将被传递出去，并且会将执行上下文切换至
VTL 
0。实际上，这会导致在常规世界中执行DPC，并会在短时间内将常规内核的IRQL提升至Dispatch级别。DPC队列排空后，常规内核的IRQL也
将降低。在位于VslpEnterIumSecureMode例程中的VSM通信循环代码帮助下，执行流将返回至安全内核。该循环可以处理来自安全内核的
每个常规调用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全内核会将前三个安全
IRQL映射至常规世界中的相同IRQL。当从常规世界的特定IRQL（依然小于或等于Dispatch）下执行的代码发出安全调用后，安全内核会将自己
的安全IRQL切换至相同的级别。反之亦然，即当安全内核执行常规调用进入NT内核时，也会将常规内核的IRQL切换至与自己相同的级别。但这只适用于前
三个级别。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当NT内核以高于DPC级
别的IRQL进入安全世界时，就会使用正常提升后的级别。在这种情况下，安全内核会将所有高于DPC的常规世界IRQL映射至正常提升后的安全级别。该级
别下执行的安全内核代码无法为常规内核中任何类型的软件IRQL接收任何VINA（但依然可以为硬件中断接收VINA）。每次NT内核以高于DPC的常规
IRQL进入安全世界时，安全内核都会将自己的安全IRQL提升至常规提升级别。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">等于或高于VINA的安全
IRQL永远不会被常规世界运行的代码抢占。这也解释了安全内核为什么可以支持安全的、不可抢占的计时器和安全拦截这样的概念。安全计时器由虚拟机监控程
序的时钟中断服务例程（ISR）生成。该ISR在将综合时钟中断注入NT内核前，会检查是否有一个或多个安全计时器已经过期。如果有，则它会向VTL 
1注入一个综合安全计时器中断，随后继续将时钟周期中断转发给常规VTL。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_98" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>4</b><b>.</b><b>2</b><b> </b><b>安</b><b>全</b><b>拦</b><b>截</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在有些情况下，安全内核可
能需要阻止以较低的VTL运行的NT内核访问某些关键系统资源。例如，对某些处理器的MSR进行写入的功能可能会被用来发起攻击，进而使虚拟机监控程序失
效或破坏它的一些保护措施。VSM提供了一种机制，可以让较高的VTL锁定关键系统资源，阻止较低的VTL的访问。该机制称为安全拦截。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全拦截是通过在安全内核
中注册综合中断来实现的，该中断由虚拟机监控程序提供（会在安全内核中重映射至向量0xF0）。随后，在某些事件导致VMEXIT后，虚拟机监控程序会向
触发该拦截的虚拟处理器上较高的VTL注入一个综合中断。截至撰写这部分内容，安全内核会为下列类型的拦截事件向虚拟机监控程序进行注册。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·写入某些重要的处理器MSR（Star、Lstar、Cstar、Efer、Sysenter、Ia32Misc以及AMD64架构中的APIC）和特殊寄存器（GDT、IDT、LDT）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·写入某些控制寄存器（CR0、CR4以及XCR0）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·写入某些I/O端口（例如端口0xCF8和0xCFC，这种拦截还管理着PCI设备的重配置）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·对受保护客户机物理内存的无效访问。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当VTL 
0软件引发一个会提升至VTL 
1的拦截时，安全内核需要从自己的中断服务例程中识别出拦截的类型。为此，安全内核会使用SynIC为“拦截”综合中断源而分配的消息队列（有关
SynIC和SINT的详情，请参阅上文“分区间通信”一节）。安全内核可以通过检查由虚拟机监控程序虚拟化的SIMP综合MSR来发现并映射物理内存页
面。物理页面的映射是在VTL 1中的安全内核初始化时执行的。安全内核的启动过程详见下文。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了保护常规NT内核中的
敏感部分，HyperGuard大量使用了拦截功能。如果NT内核中安装的恶意Rootkit程序试图通过将特定值写入受保护寄存器（如Syscall处
理程序、CSTAR和LSTAR，或特定模型的寄存器）而篡改系统，安全内核拦截处理程序（ShvlpInterceptHandler）会过滤寄存器的
新值，如果发现这些值不可接受，就会向VTL 0的NT内核注入一个常规保护错误（General Protection 
Fault，GPF）不可屏蔽异常。这会导致立即出现Bug检查操作，进而让系统停止运行。如果写入的值可接受，安全内核会使用虚拟机监控程序，通过
HvSetVpRegisters虚拟化调用写入新的值（此时安全内核是将对寄存器的访问充当代理）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>对</b><b>虚</b><b>拟</b><b>化</b><b>调</b><b>用</b><b>的</b><b>控</b><b>制</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全内核与虚拟机监控程序
注册的最后一种拦截类型为虚拟化调用拦截。虚拟化调用拦截的处理程序会检查VTL 
0代码向虚拟机监控程序发出的虚拟化调用是否合法，是否源自操作系统本身，而非某些外部模块。当任何一个VTL发出虚拟化调用时，都会导致虚拟机监控程序
产生VMEXIT（设计特性）。虚拟化调用是每个VTL的内核组件相互之间（以及虚拟机监控程序本身）请求服务时使用的基础服务。只有在使用虚拟化调用向
虚拟机监控程序直接请求服务时，虚拟机监控程序才会向较高的VTL注入综合拦截中断，并会跳过与安全内核之间进行安全调用和常规调用的所有虚拟化调用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果虚拟化调用未被识别为有效，则完全不会被执行：此时，安全内核会更新较低的VTL的寄存器，以便发出虚拟化调用错误的信号。系统不会崩溃（不过这种行为在未来可能产生变化），发出调用的代码可以决定如何处理该错误。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_99" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>4</b><b>.</b><b>3</b><b> </b><b>V</b><b>S</b><b>M</b><b>系</b><b>统</b><b>调</b><b>用</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上一节所述，VSM使用虚拟化调用向安全内核请求服务。虚拟化调用最初设计用于向虚拟机监控程序请求服务，但在VSM中，该模型通过扩展已经可以支持新类型的系统调用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·VTL 0中的常规NT内核可发出安全调用，向安全内核请求服务。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果需要由VTL 0中运行的NT内核提供服务，则VTL 1中的安全内核可以请求常规调用。此外，一些调用还可被隔离用户模式（IUM）下运行的安全进程（Trustlet）用于向安全内核或常规NT内核请求服务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此类系统调用在虚拟机监控程序、安全内核及常规NT内核中实现。为了在不同的VTL之间切换，虚拟机监控程序定义了两个虚拟化调用：HvVtlCall和HvVtlReturn。安全内核和NT内核也为安全调用和常规调用的调度定义了调度循环。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，安全内核还实现了另一种系统调用：安全系统调用。这种系统调用只为运行在IUM下的安全进程（Trustlet）提供服务，不会暴露至常规NT内核。虚拟机监控程序完全不参与安全系统调用的处理。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>虚</b><b>拟</b><b>处</b><b>理</b><b>器</b><b>状</b><b>态</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在深入介绍安全调用和常规
调用的架构前，有必要分析虚拟处理器是如何管理VTL转换的。安全VTL总是在长模式（AMD64处理器的执行模式，CPU只访问64位的指令和寄存器）
下运行，并会启用分页。不支持任何其他执行模式。这可以简化安全VTL的启动和管理，也为安全模式下运行的代码提供了一层额外保护（下文将讨论该模式的一
些其他影响）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了提高效率，虚拟处理器
的一些寄存器是在VTL之间共享的，而另外一些寄存器则是每个VTL私有的。在VTL之间切换时，共享寄存器的状态不会改变，这就可以在VTL之间快速传
递少量信息，同时降低切换VTL时的上下文切换开销。每个VTL都有自己的私有寄存器实例，这些实例仅供该VTL访问。当在VTL之间切换时，虚拟机监控
程序可以保存并还原私有寄存器的内容，因此，当在一个虚拟处理器上进入某个VTL后，私有寄存器的状态将包含与虚拟处理器之前在该VTL下最后一次运行时
相同的值。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟处理器的大部分寄存器
是在VTL之间共享的。尤其是常规用途寄存器、向量寄存器以及浮点寄存器会在所有VTL间共享，但也有少量例外，例如RIP和RSP寄存器。私有寄存器包
含一些控制寄存器、架构寄存器以及虚拟机监控程序虚拟MSR。安全拦截机制（详见上一节）可以让安全环境控制哪些MSR可被常规模式环境所访问。表9-3
总结了VTL间共享的寄存器以及每个VTL私有的寄存器。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表9-3 VTL的虚拟处理器寄存器状态</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/5ce35fc99aca42789a11771014ee57b2.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>安</b><b>全</b><b>调</b><b>用</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当NT内核需要安全内核提
供服务时，会使用一个特殊函数VslpEnterIumSecureMode。该例程可接收一个104字节的数据结构（名为SKCALL），借此可描述操
作类型（调用服务、刷新TB、恢复线程、调用隔区）、安全调用编号，以及最多12个8字节的参数。如果有必要，该函数会提升处理器的IRQL，并确定安全
线程Cookie的值。该值可以告知安全内核由哪个安全线程处理该请求，随后会重新启动安全调用调度循环。每个VTL的可执行状态是一个依赖其他VTL的
状态机。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由
VslpEnterIumSecureMode函数描述的循环管理如图9-33左侧列出的所有运行在VTL 
0下的操作（安全中断除外）。NT内核可决定进入安全内核，安全内核可决定进入常规NT内核。循环开始时将通过HvlSwitchToVsmVtl1例程
进入安全内核（指定调用者要求的操作）。后续的函数只有在安全内核请求VTL切换时才会返回，还会保存所有共享寄存器，并将完整的SKCALL数据结构存
储在一些明确定义的CPU寄存器中，即RBX和SSE寄存器的XMM10到XMM15。最后，它会向虚拟机监控程序发出一个HvVtlCall虚拟化调
用。虚拟机监控程序切换到目标VTL（通过加载保存的每VTL 
VMCS）并将VTL安全调用进入原因写入VTL控制页。实际上，为了确定进入安全VTL的原因，虚拟机监控程序维护着一个被每个安全VTL共享的记录信
息的内存页面。该页面可供虚拟机监控程序和虚拟处理器中安全VTL内运行的代码进行双向通信。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/687bf75b9b1e81263983904cb9038249.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图9-33 VSM调度循环</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟处理器在VTL 
1上下文中通过安全内核的SkCallNormalMode函数重新开始执行。代码会读取VTL进入原因，如果原因不是安全中断，那么会加载当前处理器的
SKPRCB（安全内核处理器控制块），选择要运行的线程（从安全线程Cookie开始），并将SKCALL数据结构的内容从CPU共享寄存器复制到内存
缓冲区中。最后，它会调用IumInvokeSecureService这个调度程序例程，由该例程处理所请求的安全调用，将调用调度给正确的函数并实现
VTL 1中的部分调度循环。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这方面有一个重要的概念需要理解：安全内核可以映射并访问VTL 0内存，因此，无须将任何最终数据结构封送并复制，然后通过一个或多个参数指向VTL 1内存。但这个概念并不适用于下一节要讨论的常规调用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上一节所述，安全中断和
拦截是由虚拟机监控程序调度的，可抢占VTL 0中执行的任何代码。这种情况下，当VTL 
1代码开始执行时，会将中断调度给正确的ISR。当ISR运行完毕后，安全内核会立即发出一个HvVtlReturn虚拟化调用。因此，VTL 
0中的代码可以在之前被中断的地方重新开始执行，但这个位置并不处于安全调用调度循环中。所以，即使依然会产生VTL切换，但安全中断并非调度循环的一部
分。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>常</b><b>规</b><b>调</b><b>用</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">常规调用的管理方式与安全调用的类似（在VTL 1中使用一个名为“常规调用循环”的类似调度循环），但也有些重要区别，如下所示。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·在向虚拟机监控程序发出HvVtlReturn以切换VTL之前，所有共享的VTL寄存器会以安全的方式清空。这可以防止将安全数据泄露到常规模式。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
常规NT内核无法读取安全VTL 
1内存。为了正确传递常规调用所需的Syscall参数和数据结构，这需要一个能被安全内核和常规内核共享的内存缓冲区。安全内核会使用
ALLOCATE_VM常规调用（无须以参数形式传递任何指针）分配该共享缓冲区。该常规调用会被调度到NT常规内核的
MmAllocateVirtualMemory函数。所分配的内存会重新映射至安全内核中相同的虚拟地址，并成为安全进程共享内存池的一部分。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
正如将在下文讨论的那样，隔离用户模式（IUM）最初被设计为可以执行特殊的Win32可执行文件，这些文件应当能在常规世界和安全世界中无差别地运行。
即使在IUM中，也会映射未经修改的标准Ntdll.dll库和KernelBase.dll库，这产生了一个重要后果：几乎所有原生的NT 
API（被Kernel32.dll和很多其他用户模式库所依赖）都需要由安全内核来代理。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了正确处理上述问题，安全内核包含了一个封送处理程序（marshaler），它可以识别并正确复制共享缓冲区中NT API参数所指向的数据结构。该封送处理程序还能确定从安全进程内存池中分配的共享缓冲区大小。安全内核定义了以下三种类型的常规调用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>禁</b><b>用</b><b>的</b><b>常</b><b>规</b><b>调</b><b>用</b></span>。并未在安全内核中实现，如果从IUM调用，则将会直接失败并返回退出代码STATUS_INVALID_SYSTEM_SERVICE。此类调用无法直接由安全内核本身发出。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>启</b><b>用</b><b>的</b><b>常</b><b>规</b><b>调</b><b>用</b></span>。
仅由NT内核实现，可从IUM的原始Nt或Zw版本中（通过Ntdll.dll）调用。不过安全内核可以请求“启用的常规调用”（需要通过一个小型的存根
代码加载常规调用编号），设置编号的最高位，并调用常规调用的调度程序（IumGenericSyscall例程）。最高位可确定常规调用是由安全内核本
身发出的，而不是由ITM中加载的Ntdll.dll模块发出的。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>特</b><b>殊</b><b>的</b><b>常</b><b>规</b><b>调</b><b>用</b></span>。在安全内核（VTL 1）中部分或全部实现，可用于过滤原始函数的结果或完全重新设计其代码。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">启用的和特殊的常规调用可
标记为KernelOnly（仅内核）。在后一种情况下，常规调用只能由安全内核本身（而不是由安全进程）所请求。我们已经在卷1第3
章“Trustlet可访问的系统调用”一节列出了启用的和特殊的常规调用（它们可从VSM中运行的软件内调用）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图9-34展示了一个特殊
的常规调用的例子。在本例中，LsaIso这个Trustlet调用NtQueryInformationProcess原生API来请求特定进程的信
息。IUM中映射的Ntdll.dll准备好Syscall编号并执行SYSCALL指令，该指令将执行流转移到位于安全内核（VTL 
1）中的KiSystemServiceStart这个全局系统调用调度程序。全局系统调用调度程序识别出该系统调用编号属于常规调用，因此，使用该编号
访问IumSyscallDispatchTable数组，该数组代表了常规调用的调度表。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">常规调用的调度表包含一个
由压缩后的项组成的数组，该数组在安全内核启动过程（详见下文）的阶段0生成。其中每一项都包含一个到目标函数的偏移量（根据与表本身的相对关系计算而
来）以及自己参数（和某些标记）的数量。表中所有这些偏移量最初都被计算为指向常规调度的调度程序例程（IumGenericSyscall）。在第一个
初始化周期结束后，安全内核启动例程会对代表特殊调用的每一项进行修补。新的偏移量会指向安全内核中实现常规调用的代码。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/18abe30b9981dcd9c32ad16957ec1e3c.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-34 Trustlet针对NtQueryInformationProcess API执行特殊的常规调用</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">因此在图9-34中，全局
系统调用的调度程序会将执行转移到在安全内核中实现的NtQueryInformationProcess函数部分。后者会检查所请求的信息类是否为安全
内核公开的小规模子集之一，如果是，则将使用一个小型存根代码调用常规调用的调度程序例程（IumGenericSyscall）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图9-35展示了
NtQueryInformationProcess 
API的Syscall选择器编号。请注意，存根设置了Syscall编号的最高位（N位），代表该常规调用是由安全内核请求的。常规调用的调度程序会检
查参数并调用封送处理程序，封送处理程序可以封送每个参数，并将其复制到共享缓冲区中正确的偏移量位置。选择器中还有一位可以进一步区分常规调用或安全系
统调用，下文将详细讨论这个位。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/1952867b4e7ecb2af5ac6c5363c3e36c.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-35 安全内核的Syscall选择器编号</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">封送处理程序的正常工作离不开用于描述每个常规调用的两个重要的数组：描述符数组（如图9-34右侧所示）和参数描述符数组。封送处理程序可以借助这些数组获取自己需要的所有信息，即常规调用类型、封送函数索引、参数类型、大小及指向的数据类型（如果参数是指针的话）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">共享缓冲区被封送处理程序
正确填充后，安全内核会编译SKCALL数据结构并进入常规调用的调度程序循环（SkCallNormalMode）。循环的这一部分会保存并清空所有共
享的虚拟CPU寄存器，禁用中断，并将线程上下文转移至PRCB线程（有关线程调度的详情请参阅下文）。随后它会将SKCALL数据结构的内容复制到一些
共享寄存器中。最后，它会通过HvVtlReturn虚拟化调用来调用虚拟机监控程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后VTL 
0中安全调用调度循环中的代码恢复执行。如果队列中还有未处理的中断，则这些中断将会被照常处理（前提是IRQL允许）。循环可以识别出常规调用的操作请
求，并调用VTL 
0中实现的NtQueryInformationProcess函数。后一个函数完成处理工作后，循环会重启动并再次进入安全内核（与安全调用一样），此
时依然是通过HvlSwitchToVsmVtl1例程实现的，但使用了不同的操作请求：线程恢复。顾名思义，这使得安全内核可以切换到原先的安全线程，
并继续执行之前被抢占的常规调用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">启用常规调用的实现与此相同，但有一个例外：这些调用会将自己的项保存在常规调用调度表中，并直接指向常规调用的调度程序例程IumGenericSyscall。这样，代码即可直接转移到处理程序，跳过了安全内核中的所有API实现代码。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>安</b><b>全</b><b>系</b><b>统</b><b>调</b><b>用</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全内核中最后一类系统调用类似于NT内核为VTL 0用户模式软件提供的标准系统调用。安全系统调用只能用于为安全进程（Trustlet）提供服务。VTL 0软件无法以任何方式发出安全系统调用。正如我们将在下文“<span style="font-size:16px;font-weight: bold;font-family:'PingFang SC';"><b>隔</b><b>离</b><b>用</b><b>户</b><b>模</b><b>式</b></span>”一
节中讨论的那样，每个Trustlet都会将IUM Native Layer 
Dll（Iumdll.dll）映射到自己的地址空间。Iumdll.dll的作用与它在VTL 
0中对应的Ntdll.dll作用相同，都是为了给用户模式应用程序实现原生Syscall存根函数。该存根可将Syscall编号复制到寄存器，并发出
SYSCALL指令（该指令会根据具体平台使用不同的操作码）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全系统调用编号总会将第
28位设置为1（这是AMD64架构的做法，ARM64会设置第16位）。这样一来，全局系统调用调度程序（KiSystemServiceStart）
即可识别出属于安全系统调用（而非常规调用）的Syscall编号，并切换至表示安全系统调用调度表的SkiSecureServiceTable。对于
常规系统调用，全局调度程序会验证调用编号是否位于限制范围内，为参数分配堆栈空间（如果需要），计算系统调用的最终地址，然后转移至执行代码。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">总的来说，代码的执行依然停留在VTL 1下，但虚拟处理器的当前特权级别会从3（用户模式）提升至0（内核模式）。在安全内核启动的阶段0过程中，安全系统调用的调度表会被压缩（常规调用调度表也会被压缩）。不过该表中的项都是有效的，并会指向安全内核中实现的函数。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_100" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>4</b><b>.</b><b>4</b><b> </b><b>安</b><b>全</b><b>线</b><b>程</b><b>和</b><b>调</b><b>度</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如我们将在下文“隔离用户模式”中讨论的那样，VSM的执行单位是安全线程，安全线程位于安全进程所描述的地址空间中。安全线程可以是内核模式或用户模式的线程。VSM会在每个用户模式安全线程和VTL 0中的常规线程之间维持严格的对应关系。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">实际上，安全内核线程调度
完全依赖于常规的NT内核，安全内核不包含任何专有的调度器（按照设计，安全内核的表面需要尽可能小）。在卷1第3章中，我们介绍了NT内核创建进程和相
关初始线程的方式，在描述阶段4“创建初始线程及其堆栈和上下文”一节，我们解释过线程的创建过程分为两个步骤。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·创建执行体线程对象，分配内核和用户堆栈。需要调用KeInitThread例程为用户模式线程设置初始线程上下文。KiStartUserThread将会是新线程上下文中执行的第一个例程，它可以降低线程的IRQL并调用PspUserThreadStartup。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·将执行控制返回给NtCreateUserProcess，由它在后续阶段调用PspInsertThread完成线程的初始化工作，并将其插入对象管理器命名空间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">作为工作的一部分，当
PspInsertThread检测到线程属于安全进程后，它会调用VslCreateSecureThread，顾名思义，借此可使用Create 
Thread安全服务调用来要求安全内核创建相关的安全线程。安全内核会验证参数并获取进程的安全映像数据结构（详见下文）。随后它会分配安全线程对象及
其TEB，创建初始线程的上下文（运行的第一个例程为SkpUserThreadStartup），并最终让该线程可以被调度。此外，在将该线程标记为已
就绪可运行后，VTL 1中的安全服务处理程序会返回一个特定的线程Cookie，并将其存储在ETHREAD数据结构中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">新的安全线程依然在VTL
 
0中启动。正如卷1第3章的“阶段7”一节所述，PspUserThreadStartup会在新的上下文中执行用户线程的最终初始化工作。如果它判断线
程的拥有者进程是一个Trustlet，则PspUserThreadStartup将调用VslStartSecureThread函数，并由后者通过
VTL 0中的VslpEnterIumSecureMode例程调用安全调用调度循环（传递由Create 
Thread安全服务处理程序返回的安全线程Cookie）。调度循环向安全内核请求的第一个操作将会是恢复安全线程的执行（这依然是通过
HvVtlCall虚拟化调用做到的）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在切换到VTL 
0之前，安全内核会在常规调用调度程序循环（SkCallNormalMode）中执行代码。由常规内核执行的虚拟化调用会重启动在同一个循环例程中的执
行。VTL 
1调度程序循环会识别出新线程的恢复请求，随后它会将自己的执行上下文切换至新的安全线程，附加到该线程的地址空间，并使该线程可以运行。在上下文切换过
程中，还会选择一个新的栈（该栈在此之前由Create 
Thread安全调用完成初始化）。这个新的栈包含第一个安全线程系统函数（SkpUserThreadStartup）的地址，与常规NT线程的情况类
似，这个函数可以设置运行映像加载器初始化例程（Ntdll.dll中的LdrInitializeThunk）所需的初始形式转换（Thunk）上下
文。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">启动之后，新的安全线程即可返回到常规模式，这主要出于两个原因：发出了需要在VTL 0下处理的常规调用请求，或VINA中断抢占了代码的执行。虽然这两种情况的处理方式略有差异，但都会导致执行常规调用调度程序循环（SkCallNormalMode）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如我们在卷1第4章
的“线程”一节讨论的那样，NT调度器的正常运行离不开处理器时钟，当系统时钟触发（通常每15.6毫秒一次）时，处理器时钟会产生一个中断。时钟中断服
务例程会更新处理器计时器并计算线程的量程是否已过期。该中断以VTL 0为目标，因此，当虚拟处理器在VTL 
1下执行代码时，虚拟机监控程序会向安全内核注入一个VINA中断，如图9-36所示。该VINA中断可以抢占当前正在执行的代码，将IRQL降低到之前
被抢占代码的IRQL值，并发出进入VTL 0所需的VINA常规调用请求。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">作为常规调用调度的标准过
程，在安全内核发出HvVtlReturn虚拟化调用之前，它会从虚拟处理器的PRCB中选择当前的执行线程。这一点很重要：VTL 
1中的虚拟处理器不再与任何线程上下文绑定，在下一个循环周期里，安全内核可以切换到不同的线程，或决定重新调度当前线程的执行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">VTL切换后，NT内核会
恢复在安全调用调度循环中的执行，此时依然会在新线程的上下文中执行。在有机会执行任何代码前，代码会被时钟中断服务例程抢占，该例程会计算新的量程值，
如果量程值已过期，则会切换执行另一个线程。当发生上下文切换，并且另一个线程进入VTL 
1时，根据安全线程Cookie的值，常规调用调度循环会调度另一个安全线程。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果常规NT内核为了调度安全调用已进入VTL 1，则从安全线程池中选择一个安全线程（此时安全线程Cookie为0）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果线程的执行已重新调度，则选择一个新创建的安全线程（安全线程Cookie为有效值）。如图9-36所示，这个新线程也可以被其他虚拟处理器（本例中为VP3）重新调度。</span></p><div style="display: block;text-align:center;">
	<img width="779" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/29e897236d1cb4e18c6e6c801e33c84c.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图9-36 安全线程调度结构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">按照上述方案，所有调度决
策都只在VTL 0下进行。安全调用循环和常规调用循环会相互配合，以便将安全线程上下文正确地切换到VTL 
1中。所有安全线程都在常规内核中有一个相关线程，但反之未必如此。如果VTL 
0下的一个常规线程决定发出安全调用请求，安全内核会使用来自线程池的任意线程上下文来调度该请求。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_101" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>4</b><b>.</b><b>5</b><b> </b><b>虚</b><b>拟</b><b>机</b><b>监</b><b>控</b><b>程</b><b>序</b><b>实</b><b>施</b><b>的</b><b>代</b><b>码</b><b>完</b><b>整</b><b>性</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机监控程序实施的代码
完整性（HVCI）是Device Guard功能的基础，同时还为VTL 
0的内核内存提供了W^X特征。如果没有安全内核的帮助，NT内核将无法在内核模式下映射并执行任何类型的可执行内存。安全内核只允许带有数字签名的特定
驱动程序在计算机内核中运行。正如下一节将要讨论的那样，安全内核会跟踪常规NT内核中分配的每个虚拟页面，在NT内核中标记为可执行的内存页面会被视为
特权页面。仅安全内核可以在SKCI模块正确验证了内容之后写入这些页面。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">有关HVCI的详细信息请参阅卷1第7章的“Device Guard”和“凭据保护”相关章节。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_102" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>4</b><b>.</b><b>6</b><b> </b><b>U</b><b>E</b><b>F</b><b>I</b><b>运</b><b>行</b><b>时</b><b>虚</b><b>拟</b><b>化</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在启用HVCI的情况下，
安全内核提供的另一项服务是为UEFI运行时服务提供虚拟化和保护。正如将在第12章介绍的那样，UEFI固件服务主要是通过一个大型函数指针表实现的。
当操作系统拿到控制权并调用ExitBootServices函数时，该表的部分内容将从内存中删除，但表中的另一部分代表了运行时服务，会始终维持映射
状态，甚至在操作系统全面控制计算机后也会保持这种状态。这是必要的，因为有时候操作系统需要与UEFI配置和服务进行交互。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每个硬件供应商都实现了自
己的UEFI固件。在HVCI的帮助下，固件可以相互配合为自己的每个可执行内存页面提供不可写的状态（任何固件页面都不能在VTL 
0中映射为读取、写入和执行状态）。UEFI固件驻留的内存范围由多个MEMORY_DESCRIPTOR数据结构描述，这些数据结构位于EFI内存图
中。Windows加载器会解析这些数据，借此为UEFI固件的内存提供适当保护。然而，在UEFI的原始实现中，代码和数据会混合存储在同一个（或多
个）节中，并由相应的内存描述符来描述。此外，一些设备驱动程序会直接通过UEFI的内存区域读/写配置数据，这明显与HVCI的要求不符。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了解决这些问题，安全内核采取了下列两种策略。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
由新版UEFI固件（遵守UEFI 2.6和后续版本的规范）维持了一个名为内存属性表（Memory Attribute 
Table，MAT）的全新配置表（链接到启动服务表）。MAT非常细化地定义了UEFI内存区域中的不同节，这些节均为EFI内存图所定义的内存描述符
的子节。每个节永远不可能同时获得可执行和可写入的保护特性。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·对于旧的固件，安全内核会在VTL 0中使用只读访问权限映射整个UEFI固件区域的物理内存。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于第一种策略，在启动
时，Windows加载器会将EFI内存图和MAT中找到的信息合并在一起形成一个内存描述符数组，该数组精确描述了整个固件区域。随后加载器会将其复制
到VTL 
1中一个保留的缓冲区中（用于休眠路径），并验证每个固件的节是否违反W^X做出的假设。如果不违反，那么当安全内核启动时，会对属于底层UEFI固件区
域的每个内存页应用适当的SLAT保护。物理页面会受到SLAT保护，但其在VTL 
0中的虚拟地址空间依然会被完全标记为RWX。确保虚拟内存获得RWX保护，这一点很重要，因为当应用给MAT项的保护可能被更改的情况下，安全内核依然
要能为从休眠中恢复的场景提供支持。此外，这样也可以与需要直接读/写UEFI内存区域的旧版本驱动程序保持兼容性，确保这类驱动程序能直接对相应的节执
行写操作（此外，UEFI代码应该还能写入映射至VTL 0的自己的内存）。该策略可以让安全内核避免将任何固件代码映射至VTL 1，而VTL 
1中唯一存留的固件代码仅仅只是运行时函数表本身。将该表留在VTL 1，可让从休眠状态恢复使用的代码直接更新UEFI运行时服务的函数指针。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">第二种策略并非最佳策略，
只会用于确保旧系统在启用HVCI后可以正常运行。如果安全内核在固件中未找到任何MAT，此时将别无选择，只能将整个UEFI运行时服务代码映射至
VTL 1。历史上，UEFI固件代码（尤其是SMM中）曾被检测到包含很多Bug，将固件映射至VTL 
1可能是一种危险的做法，但这是此时唯一能兼容HVCI的解决方案（如上文所述，新系统绝不会将任何UEFI固件代码映射至VTL 1）。启动时，NT 
Hal检测到HVCI已启用，并且固件被完全映射至VTL 1。此时它会将自己内部EFI服务表的指针切换到一个名为UEFI包装表（UEFI 
wrapper table）的新表。该包装表中的项所包含的存根例程可以使用INVOKE_EFI_RUNTIME_SERVICE安全调用进入VTL
 1。安全内核会对参数进行封送，执行固件调用，并将结果输出到VTL 
0。这种情况下，描述整个UEFI固件的全部物理内存依然会以只读模式映射至VTL 
0。这是为了让驱动程序能够正确地从UEFI固件内存区域读取信息（如ACPI表）。这种情况下，需要直接写入UEFI内存区域的旧驱动程序将无法兼容
HVCI。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当安全内核从休眠状态恢复时，会更新内存中的UEFI服务表，以指向新服务的位置。此外，对于具备新版UEFI固件的系统，安全内核会对映射至VTL 0的每个内存区域应用SLAT保护（Windows加载器可在需要时更改区域的虚拟地址）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_103" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>4</b><b>.</b><b>7</b><b> </b><b>V</b><b>S</b><b>M</b><b>启</b><b>动</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">我们会在第12章完整介绍
Windows的启动和关闭机制，本节将介绍安全内核与整个VSM基础架构的启动方式。安全内核的正常启动离不开虚拟机监控程序、Windows加载器以
及NT内核。我们会在第12章介绍Windows加载器和虚拟机监控程序加载器，以及这两个模块在VTL 
0中对安全内核进行初始化的前期阶段。本节将重点介绍securekernel.exe二进制文件中所实现的VSM启动方法。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">securekernel.exe二进制文件执行的第一段代码依然运行在VTL 0下，此时虚拟机监控程序已经启动，VTL 1所用的页表也已创建完成。安全内核会在VTL 0中初始化下列组件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·内存管理器的初始化函数存储了VTL 0根级页级结构的PFN，保存代码完整性数据，并启用HVCI、MBEC（基于模块的执行控制）、内核CFG以及热修补。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·共享特定架构的CPU组件，如GDT和IDT。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·常规调用和安全系统调用调度表（初始化并压缩）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
启动处理器。启动处理器的启动过程需要安全内核分配自己的内核与中断堆栈，初始化与架构有关并且无法在不同组件之间共享的组件（如TSS），并最终分配处
理器的SKPRCB。后者是一个重要的数据结构，与VTL 0的PRCB数据结构类似，可用于存储与每个CPU有关的重要信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全内核初始化代码已经准
备好首次进入VTL 
1。虚拟机监控程序子系统初始化函数（ShvlInitSystem例程）连接到虚拟机监控程序（通过虚拟机监控程序CPUID类，详见上一节）并检查可
支持的启发。随后它会保存VTL 
1的页表（之前由Windows加载器创建）以及已分配的虚拟化调用页面（用于保存虚拟化调用参数）。最终它会以下列方式初始化并进入VTL 1。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）通过HvEnablePartitionVtl虚拟化调用为当前虚拟机监控程序分区启用VTL 1。虚拟机监控程序会将常规VTL中的现有SLAT表复制到VTL 1，并为该分区启用MBEC和新的VTL 1。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）通过HvEnableVpVtl虚拟化调用为启动处理器启用VTL 1。虚拟化监控程序会初始化一个新的每级别VMCS数据结构，编译该数据结构，并设置SLAT表。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）要求虚拟机监控程序提
供平台相关的VtlCall和VtlReturn虚拟化调用代码的位置。执行VSM调用所需的CPU操作码会隐藏安全内核的实现，这样安全内核的大部分代
码均可与平台无关。最后，安全内核执行HvVtlCall虚拟化调用转换至VTL 
1。虚拟机监控程序为新的VTL加载VMCS并进行切换（将其激活）。至此，新的VTL就已经可以运行了。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全内核会在VTL 1中进行复杂的初始化过程，但依然需要依赖Windows加载器以及NT内核。需要注意，在这个阶段，VTL 1内存依然需要映射至VTL 0，安全内核及其附属模块依然可以被常规世界所访问。在切换至VTL 1后，安全内核会开始初始化启动过程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）获取综合中断控制器共享页、TSC以及虚拟处理器辅助页的虚拟地址，这些地址均由虚拟机监控程序提供，可用于在虚拟机监控程序和VTL 1代码之间共享数据。虚拟化调用页面会被映射至VTL 1。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）阻断其他系统虚拟处理器被较低VTL启动的可能性，请求内存在重启动时被虚拟机监控程序清零。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）初始化并填充启动过程中断描述符表（IDT）。配置IPI、回调以及安全计时器中断处理程序，并将当前安全线程设置为默认的SKPRCB线程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）启动VTL 
1安全内存管理器，由它创建启动表映射并在VTL 
1中映射启动加载器的内存，创建安全PFN数据库和系统超空间（Hyperspace），初始化对安全内存池的支持，读取VTL 
0加载器块以复制安全内核导入映像（Skci.dll、Cnf.sys、Vmsvcext.sys）的模块描述符。最后，还需要查看NT已加载模块列表以
建立每个驱动程序的状态，为每个驱动程序创建NAR（Normal Address 
Range，常规地址范围）数据结构，并为组成启动驱动程序的节的每个页面编译常规表项（Normal Table 
Entry，NTE）。另外，安全内存管理器初始化函数还会为每个驱动程序的节应用适当的VTL 0 SLAT保护。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">5）初始化HAL、安全线程池、进程子系统、综合APIC、安全PNP以及安全PCI。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">6）为安全内核页面应用只读的VTL 0 SLAT保护，配置MBEC，为启动处理器启用VINA虚拟中断。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这部分初始化工作结束后，
安全内核会解除对启动加载内存的映射。正如上一节所述，安全内存管理器依赖VTL 0内存管理器分配并释放VTL 1内存。VTL 
1不拥有任何物理内存。在这个阶段，VTL 
1依赖之前（由Windows加载器）分配的物理页面来满足内存分配请求。当NT内核稍后启动后，安全内核会执行常规调用以向VTL 
0内存管理器请求内存服务。因此，安全内核一些部分的初始化必须延迟到NT内核启动后进行。执行流会返回至VTL 
0下的Windows加载器，由Windows加载器负责加载并启动NT内核。安全内核初始化的最后一部分工作发生在NT内核初始化的阶段0和阶段1中
（详见第12章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NT内核初始化的阶段0中
依然没有可用的内存服务，此时也是安全内核依旧完全信任常规世界的最后一刻。启动时加载的驱动程序依然未初始化，而初始启动过程应该已经受到安全启动功能
的保护。PHASE3_INIT这个安全调用处理程序会修改属于安全内核及其附属模块的所有物理页面的SLAT保护，使其无法在VTL 
0下访问。此外，它还会为内核CFG位图应用只读保护。在这个阶段，安全内核将启用对页面文件完整性的支持，创建初始系统进程及其地址空间，保存共享的
CPU寄存器（如IDT、GDT、Syscall 
MSR等）的所有“可信任”的值。共享的寄存器所指向的数据结构会被（通过NTE数据库）验证。最后，安全线程池启动，对象管理器、安全代码完整性模块
（Skci.dll）以及HyperGuard均被初始化（有关HyperGuard的详细信息请参阅卷1第7章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当执行流返回到VTL 0后，NT内核即可启动所有其他应用程序处理器（Application Processor，AP）。安全内核被启用后，将以略微有变的方式进行AP的初始化（下一节将讨论AP的初始化）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">作为NT内核初始化阶段1
工作的一部分，系统会启动I/O管理器。如卷1第6章所述，I/O管理器是I/O系统的核心，定义了将I/O请求以何种模型传递给设备驱动程序。I/O管
理器的职责之一是初始化并启动引导加载的驱动程序以及ELAM驱动程序。在创建用于映射用户模式系统DLL所需的特殊节之前，I/O管理器初始化函数会发
出PHASE4_INIT安全调用以启动安全内核的初始化的最后阶段。在这个阶段，安全内核已经不再信任VTL 
0，但依然可以使用NT内存管理器提供的服务。安全内核会初始化安全用户共享（Secure User 
Shared）数据页的内容（这些页面会同时映射到VTL 
1用户模式和内核模式）并完成执行体子系统初始化工作。它还会回收启动过程中保留的所有资源，调用自己依赖的每个模块（尤其是先于其他常规启动驱动程序启
动的cng.sys和vmsvcext.sys）的入口点。它会为休眠文件、崩溃转储文件以及分页文件的加密以及内存页面完整性分配必要的资源，最后，它
还会读取并映射VTL 1内存中的API集Schema文件。至此，VSM的初始化全部完成。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>应</b><b>用</b><b>程</b><b>序</b><b>处</b><b>理</b><b>器</b><b>启</b><b>动</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全内核提供的安全功能之
一是应用程序处理器（AP）的启动。AP是指不用于启动系统的处理器。当系统启动时，Intel和AMD的x86与AMD64架构规范定义了一种精确的算
法，用于在多处理器系统中选择启动处理器（Boot Strap 
Processor，BSP）。启动处理器始终以16位实模式（只能访问1MB物理内存）启动，通常还要负责执行计算机的固件代码（大部分情况下为
UEFI），而这些代码需要位于特定的物理内存位置（这个位置也叫复位向量）。启动处理器执行了几乎全部的操作系统、虚拟机监控程序以及安全内核初始化工
作。为了启动“启动处理器”外的其他处理器，系统需要向属于每个处理器的本地APIC发送一个特殊的IPI（Inter-Processor 
Interrupt，处理器间中断）。启动IPI（SIPI）向量包含处理器启动块的物理内存地址，这种代码块包含执行下列基本操作的指令。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）加载GDT并从16位实模式切换至32位受保护模式（不启用分页）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）设置一个基础页表，启用分页，进入64位长模式。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）加载64位IDT和GDT，设置适当的处理器寄存器，跳转至操作系统启动函数（KiSystemStartup）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这个过程很容易受到恶意攻
击。处理器启动代码在AP处理器上执行时，可能会被外部实体修改（NT内核此时还无法施加控制）。在这种情况下，VSM所带来的各种安全承诺都可能被轻松
绕过。在启用虚拟机监控程序和安全内核后，应用程序处理器依然由NT内核启动，但会使用虚拟机监控程序来启动。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NT内核初始化的阶段1
（详见第12章）会调用KeStartAllProcessors函数，借此可以启动所有AP，构建一个共享的IDT，并查询多APIC描述表
（Multiple APIC Description 
Table，MADT）这个ACPI表，借此枚举所有可用处理器。对于被检测到的每个处理器，还会为PRCB和内核与DPC栈的所有私有CPU数据结构分
配内存。如果VSM已启用，随后则会向安全内核发出START_PROCESSOR安全调用以启动AP。安全内核会验证为新处理器分配和填充的所有数据结
构是否有效，包括处理器寄存器的初始值和启动例程（KiSystemStartup），确保AP可以按顺序启动，并且每次只启动一个处理器。随后，它会初
始化新的应用程序处理器需要的VTL 
1数据结构（尤其是SKPRCB），并使用PRCB线程将安全调用调度给新处理器的上下文，同时使用SLAT保护VTL 0 
CPU数据结构。最后，安全内核会为新应用程序处理器启用VTL 
1，并使用HvStartVirtualProcessor虚拟化调用启动这些AP。虚拟机监控程序会使用与本节开头介绍的类似方式启动AP（发送启动
IPI）。不过这种情况下，AP会在虚拟机监控程序上下文中开始执行，随后切换至64位长模式执行，并返回到VTL 1。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">应用程序处理器执行的第一
个函数位于VTL 
1中。安全内核的CPU初始化例程会映射每处理器VP辅助页面和SynIC控制页面，配置MBEC，并启用VINA。随后它会通过HvVtlReturn
虚拟化调用返回VTL 0。VTL 
0中执行的第一个例程是KiSystemStartup，该例程可以初始化NT内核管理AP所需的数据结构，初始化HAL，并跳转至空闲循环（详见第12
章）。第一个安全调用执行完成后，将由常规NT内核初始化安全调用调度循环。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种情况下，攻击者无法修改处理器的启动块或CPU寄存器和数据结构的任何初始值。在上述安全AP启动过程的帮助下，任何修改都会被安全内核检测到，随后系统将进入Bug检查模式，进而挫败任何可能的攻击企图。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_104" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>4</b><b>.</b><b>8</b><b> </b><b>安</b><b>全</b><b>内</b><b>核</b><b>内</b><b>存</b><b>管</b><b>理</b><b>器</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全内核内存管理器严重依赖NT内存管理器以及Windows Loader内存管理器的启动代码。安全内核内存管理器的完整介绍已超出了本书的范围。此处我们只讨论安全内核中最重要的概念和数据结构。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上一节所述，安全内核内存管理器初始化过程可分为三个阶段。在最重要的阶段1，内存管理器会执行下列操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）映射VTL 
1中的启动加载器固件内存描述符列表，扫描该列表，确定可用于分配初始启动过程所需内存的第一个物理页面（此类内存也叫SLAB）。将VTL 
0的页表映射至VTL 1页表前恰好512GB处的虚拟地址中。这样安全内核即可在NT虚拟地址和安全内核的虚拟地址之间进行快速转换。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）初始化PTE范围数据结构。PTE范围包含了一个位图，该位图描述了已分配的虚拟地址范围块，可以帮助安全内核为自己的地址空间分配PTE。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）创建安全PFN数据库并初始化内存池。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）初始化稀疏NT地址
表。对于每个引导加载的驱动程序，还会创建并填充一个NAR，验证二进制文件的完整性，填充热修补信息。如果启用了HVCI，还会使用SLAT保护驱动程
序的每个可执行节。随后会在内存映像的每个PTE以之间进行循环，并在NT地址表中写入一个NT地址表项（Address Table 
Entry，NTE）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">5）初始化页面捆绑（page bundle）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全内核会跟踪常规NT内
核使用的内存。安全内核内存管理器使用NAR数据结构描述包含可执行代码的内核虚拟地址范围。NAR包含有关该范围的一些信息（如范围的基址和大小）以及
一个指向SECURE_IMAGE数据结构的指针，该数据结构被用于描述载入VTL 
0的运行时驱动程序（一般来说，会使用安全HVCI验证映像，包括Trustlet使用的用户模式的映像）。引导加载的驱动程序并不使用
SECURE_IMAGE数据结构，因为NT内存管理器会将其视作包含可执行代码的私有页面。后一种数据结构包含与NT内核中所加载映像有关的信息（由
SKCI进行验证），例如入口点的地址、重定位表的副本（用于处理Retpoline和导入优化）、指向其共享原型PTE的指针、热修补信息，以及一个指
定了内存页面授权用途的数据结构。SECURE_IMAGE数据结构非常重要，因为安全内核要借此来跟踪并验证运行时驱动程序使用的共享内存页面。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全内核会使用NTE数据
结构跟踪VTL 0内核私有页面。在VTL 0地址空间中，每个需要安全内核监管的虚拟页面都有一个NTE，它通常会被用于私有页面。NTE可跟踪VTL
 
0虚拟页面的PTE并存储页面状态和保护措施。启用HVCI的情况下，NTE表会将所有虚拟页面划分为特权页和非特权页。特权页表示NT内核无法自行碰触
的内存页（因为这类页面受到SLAT保护，通常对应于一个可执行页或内核CFG只读页）；非特权页表示NT内核可以完整控制的所有其他类型内存页。安全内
核会使用无效的NTE来代表非特权页。在禁用HVCI的情况下，所有私有页都是非特权页（NT内核可以对所有页面具备完整控制权）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在启用HVCI的系统中，
NT内存管理器无法修改任何受保护的页面。否则虚拟机监控程序会产生EPT违规异常并导致系统崩溃。当这样的系统完成引导阶段后，安全内核已经处理完所有
不可执行的物理页面，即使用SLAT保护它们只能进行读取或写入访问。这种情况下，只有当目标代码已被安全HVCI验证之后，才能分配新的可执行页面。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当系统、应用程序或即插即用管理器需要加载新的运行时驱动程序时，将启动一个复杂的过程来调用NT和安全内核的内存管理器，全过程概括如下。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）NT内存管理器创建一个节对象，分配并填充一个新的控制区域（有关NT内存管理器的详情请参阅卷1第5章），读取二进制文件的第一个页面，并调用安全内核以创建相应的安全映像，该映像描述了新加载的模块。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）安全内核创建SECURE_IMAGE数据结构，解析二进制文件的所有节，并填充安全原型PTE数组。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）NT内核将整个二进制文件读取到不可执行的共享内存（由控制区域的原型PTE指向），调用安全内核，安全内核将使用安全HVCI在二进制映像的每个节之间循环，并计算最终的映像哈希。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）如果计算出的文件哈希
与数字签名中存储的哈希相符，则NT内存管理器将查看整个映像，并为每个页面调用安全内核，由安全内核验证页面（每个页面哈希已经在上一个阶段计算出来
了），应用所需的隔离（ASLR、Retpoline以及导入优化），并应用新的SLAT保护，让页面可以执行但不再可以写入。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">5）节对象已创建。NT内
存管理器需要将驱动程序映射到自己的地址空间。它会调用安全内核来分配所需的特权PTE，借此描述驱动程序的虚拟地址范围。安全内核会创建NAR数据结
构，随后映射驱动程序的物理页面，这些页面之前已经使用MiMapSystemImage例程验证过了。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 在为运行时驱动程序初始化NAR时，为描述新驱动程序的地址空间，NTE表的一部分会被填充。NTE并不用于跟踪运行时驱动程序的虚拟地址范围（其虚拟页面是共享的、非私有的），因此，NT地址表中的相应部分会使用无效的“保留”NTE来填充。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当VTL 
0内核虚拟地址范围使用NAR数据结构来表示时，安全内核会使用安全VAD（Virtual Address 
Descriptor，虚拟地址描述符）来跟踪VTL 
1中的用户模式的虚拟地址。每次进行新的私有虚拟分配，将二进制映像映射至Trustlet（安全进程）的地址空间，以及创建VBS隔区或模块被映射至地
址空间时，都会创建安全VAD。安全VAD类似于NT内核VAD，其中包含一个VA范围描述符、一个引用计数器、一些标记，以及一个指向（由SKCI创建
的）安全节的指针（如果安全VAD描述了私有虚拟分配，该安全节指针会被设置为0）。有关Trustlet和VBS隔区的详细信息请参阅下文。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>页</b><b>面</b><b>完</b><b>整</b><b>性</b><b>和</b><b>安</b><b>全</b><b>P</b><b>F</b><b>N</b><b>数</b><b>据</b><b>库</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当驱动程序被加载并正确映
射至VTL 
0内存后，NT内存管理器需要能管理它的内存页面（出于多种原因，例如将可分页驱动程序的节换出，创建私有页面，为应用程序进行私有修复等，详见卷1第5
章）。每当NT内存管理器针对受保护的内存进行操作时，都需要安全内核的配合。为了让NT内存管理器可以操作特权内存，安全内核主要提供了两项安全服务：
受保护页面的复制和受保护页面的移除。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">PAGE_IDENTITY
数据结构可以充当“胶水”，让安全内核持续跟踪所有不同类型的页面。该数据结构包含两个字段：一个地址上下文（address 
context）和一个虚拟地址（virtual 
address）。每当NT内核调用安全内核来操作特权页面时，它需要指定物理页面编号以及一个描述物理页面用途的有效PAGE_IDENTITY数据结
构）。通过这种数据结构，安全内核可以验证所请求的页面用途并决定是否允许该请求。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">表9-4展示了PAGE_IDENTITY数据结构（第二列和第三列），以及安全内核对不同内存页面进行的所有验证类型。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
如果安全内核收到一个需要复制或释放运行时驱动程序共享可执行页面的请求，它会验证安全映像句柄（由调用方指定）并获取其相对数据结构
（SECURE_IMAGE）。随后它会使用相对虚拟地址（Relative Virtual 
Address，RVA）作为安全原型数组的索引来获取驱动程序共享页面的物理页帧（Physical Page 
Frame，PFN）。如果找到的PFN等于调用方指定的那个，安全内核将允许该请求；否则请求会被阻止。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·按照类似方式，如果NT内核请求对Trustlet或隔区页面（有关Trustlet或安全隔区的详细信息请参阅本章下文）进行操作，安全内核将使用调用方指定的虚拟地址来验证安全进程页表中的安全PTE是否包含正确的PFN。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如上文“安全内核内存管理器”一节所述，对于私有内核页面，安全内核会从调用方指定的虚拟地址开始定位NTE，并验证它是否包含有效的PFN，该PFN必须与调用方指定的一致。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·占位页（placeholder page）是一种受SLAT保护的空闲页面，安全内核会使用PFN数据库验证占位页的状态。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表9-4 安全内核管理的不同页面标识</span></p><div style="display: block;text-align:center;">
	<img width="655" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/d5ca1f266339e9bfe0af7a1965e92709.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全内核内存管理器维护的PFN数据库可代表每个物理页面的状态。安全内核中的PFN项远小于NT内核中的等效项，基本上只包含页面状态和共享计数器。从安全内核的角度来看，物理页面可处于下列一种状态：无效、空闲、共享、I/O、安全或映像（安全的NT私有）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上述“安全”状态可用于对安全内核来说属于私有的物理页面（NT内核永远不能申领），或用于已经被NT内核分配随后又被安全内核使用SLAT保护，以存储经由安全HVCI验证的可执行代码的物理页面。仅安全的非私有物理页面具备页面标识。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当NT内核要将受保护页面
换出时，它会要求安全内核执行页面移除操作。安全内核会分析指定的页面标识并（按照上文介绍的过程）进行验证。如果页面标识代表隔区或安全页面，安全内核
首先加密页面内容，随后将其释放给NT内核，并由NT内核将其存储在分页文件中。这样，NT内核依然无法获取私有内存中的真正内容。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>安</b><b>全</b><b>内</b><b>存</b><b>分</b><b>配</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，安全内核最初
启动时，它会解析固件的内存描述符列表，这样才能分配供自己使用的物理内存。在初始化的阶段1中，安全内核无法使用NT内核提供的内存服务（此时NT内核
还未初始化），因此它会使用固件内存描述符列表中的空闲项保留2MB的SLAB。SLAB是一种2MB的连续物理内存，可由虚拟机监控程序中的一个嵌套页
表目录项映射而来。所有SLAB页面都可获得相同的SLAT保护。SLAB在设计上充分考虑了性能问题。通过使用虚拟机监控程序中的单个嵌套页表项映射一
个2MB的物理内存块，可以加快其他硬件内存地址转换的速度，并降低SLAT表缓存未命中的概率。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">第一个安全内核页面捆绑会
使用已分配的1MB 
SLAB内存来填充。页面捆绑是一种数据结构，如图9-37所示，其中包含了连续可用的物理页帧编号（PFN）列表。当安全内核自己需要内存时，它会从捆
绑的PFN数组尾部移除一个或多个空闲页帧，借此从页面捆绑中分配物理页面。这种情况下，安全内核无须检查固件内存描述符列表，除非页面捆绑已彻底耗尽。
当安全内核初始化的阶段3完成后，NT内核的内存服务已经可用，因此安全内核会释放所有启动内存描述符列表，并保留之前位于页面捆绑中的物理内存页面。</span></p><div style="display: block;text-align:center;">
	<img width="648" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ea86592e3628818daa9b3b1f37c4908f.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-37 包含80个可用页面的安全页面捆绑。页面捆绑由一个头部和一个空闲PFN数组组成</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">后续的安全内存分配将通过
NT内核提供的常规调用来进行。页面捆绑在设计上可最大限度地减少内存分配所需的常规调用的次数。在一个捆绑被全部分配后，其中将不包含任何页面（所有页
面已被分配出去），此时可以向NT内核申请1MB的连续物理页面（通过常规调用ALLOC_PHYSICAL_PAGES）新建一个捆绑。NT内核将从适
当的SLAB中分配物理内存。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">以同样的方式，每当安全内
核释放自己的私有内存时，都会将相应的物理页面存储到对应的捆绑中，为此会将PFN数组增大，直到达到256个空闲页面的上限。当该数组被完全填满后，页
面捆绑将变为空闲状态，一个新的工作项会被加入队列中。该工作项会清零所有的页面并发出一个FREE_PHYSICAL_PAGES常规调用，最终这会导
致执行NT内存管理器的MmFreePagesFromMdl函数。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每当有足够的页面被移入或移出页面捆绑时，这些页面都会受到VTL 0使用SLAT提供的全面保护（这个过程也叫“捆绑保护”）。安全内核支持三类捆绑，它们会从不同的SLAB（不可访问、只读、读取执行）分配内存。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_105" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>4</b><b>.</b><b>9</b><b> </b><b>热</b><b>修</b><b>补</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">多年前，32位版本的
Windows支持对操作系统组件进行热修补（hot 
patch）。可修补的函数会在自己的序言（prolog）中包含一个冗余的2字节操作码，并在函数本身之前放置一些填充字节（padding 
byte）。这样，NT内核即可使用间接跳转动态替换初始操作码，并使用填充字节提供的可用空间将代码转移至另一个模块中修补后的函数。Windows 
Update大量使用了该功能，借此让系统无须立即重启动即可安装更新。但在转移到64位架构后，因为各种问题的存在，该技术已不再可行。内核修补防护
（kernel patch 
protection）就是一个很好的例子。此时已经无法通过可靠的方式修改受保护的内核模式二进制文件，并让PatchGuard在不公开自己的一些私
有接口的前提下进行更新，毕竟公开的PatchGuard接口很容易被攻击者利用并让这种保护措施失效。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全内核解决了与64位架构有关的所有这些问题，让操作系统再次获得了对内核二进制文件进行热修补的能力。在启用安全内核的情况下，可对下列类型的可执行映像进行热修补。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·VTL 0用户模式模块（可执行文件和二进制文件）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·内核模式驱动程序、HAL、NT内核二进制文件，无论是否受到PatchGuard的保护。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·运行在VTL 1内核模式下的安全内核二进制文件及其依赖模块。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·虚拟机监控程序（Intel、AMD以及ARM版本）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">修补VTL 0下运行的软件二进制文件的补丁叫作常规修补，修补其他内容的补丁叫作安全修补。如果安全内核未启用，则只有用户模式应用程序可以修补。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">热修补映像是一种标准的可
移植可执行的（PE）二进制文件，其中包含热修补表，以及用于跟踪修补函数的数据结构。热修补表会通过映像加载配置数据目录与二进制文件链接，其中包含的
一个或多个描述符描述了每个可修补的基础映像，映像可通过其校验值和时间日期戳加以识别（这保证了热修补只能兼容正确的基础映像，系统无法将修补应用给错
误的映像）。热修补表还包含一个列表，其中列出了基础映像或修补映像中需要更新的函数或全局数据块。下文很快将介绍修补引擎。该列表中的每一项都包含函数
在基础映像和修补映像中的偏移量，以及所要替换的基础函数最初的字节位置。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">一个基础映像可应用多个修
补，但修补的效果是幂等的：同一个修补可应用多次，不同修补可依次应用，但无论如何最后应用的修补都将是基础映像的活跃修补。当系统需要应用热修补时，会
通过NtManageHotPatch系统调用来安装、移除、管理热修补（该系统调用支持使用不同的“修补信息”类来描述各种可能的操作）。热修补可针对
整个系统进行全局安装，如果是适用于用户模式代码（VTL 0）的修补，则会安装给特定用户会话所属的全部进程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当系统请求应用修补时，
NT内核会在补丁的二进制文件中定位并验证热修补表，随后使用DETERMINE_HOT_PATCH_TYPE安全调用，安全地确定修补类型。安全修补
只能由安全内核应用，此时将使用APPLY_HOT_PATCH安全调用，NT内核无须执行其他处理。其他情况下，则由NT内核首先尝试着将修补应用给内
核驱动程序，它会在每个已加载内核模块之间循环，搜索校验值与补丁映像的热修补描述符匹配的基础映像。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">仅当
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session 
Manager\Memory 
Management\HotPatchTableSize注册表值是标准内存页大小（4096）的倍数时，才能启用热修补。实际上，在热修补被启用后，
每个映射到虚拟地址空间的映像都需要在映像本身之后近邻的位置保留一定量的虚拟地址空间。该保留空间用于保存映像的热修补地址表（HPAT，不要将其与热
修补表混淆）。HPAT用于存储被修补映像中新函数的地址，借此最大限度地减小每个映像需要填充的数量。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当修补一个函数时，将使用HPAT位置执行从基础映像中原始函数到修补映像中被修补函数的间接跳转（请注意，为了兼容Retpoline，会使用另一种类型的Retpoline例程代替间接跳转）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NT内核找到适合修补的内
核模式驱动程序后，会在内核地址空间中加载并映射补丁的二进制文件并创建相关的加载器数据表项（详见第12章）。随后它会扫描基础映像和补丁映像的每个内
存页面，并在内存中锁定与热修补有关的页面（这很重要，保证了页面不会在修补进行过程中被换出到磁盘）。最后它会发出APPLY_HOT_PATCH安全
调用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">真正的修补应用过程是在安
全内核中开始的。安全内核会捕获并验证补丁映像的热修补表（通过将补丁映像重映射至VTL 
1），并定位基础映像的NAR（NAR的详细信息请参阅上文“安全内核内存管理器”一节），借此安全内核还能知道映像是否受到PatchGuard的保
护。随后，安全内核会验证映像HPAT是否有足够的保留空间。如果有，则它会分配一个或多个空闲的物理页面（可从安全页面捆绑中获取，或使用
ALLOC_PHYSICAL_PAGES常规调用）并将其映射至保留空间。随后，如果基础映像受到保护，则安全内核会开始执行一个复杂的过程来为修补后
的新映像更新PatchGuard的内部状态，并最终调用修补引擎。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内核的修补引擎会执行下列操作，这些操作均由热修补表中不同类型的项来描述。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）修补补丁映像中所有被
修补函数的调用，借此跳转至基础映像中对应的函数。这保证了所有未修补代码始终在原始基础映像中执行。举例来说，如果函数A调用基础映像中的函数B，补丁
更改了函数A但未更改函数B，那么修补引擎将更新补丁中的函数B，以跳转至基础映像中的函数B。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）在被修补函数中修补对全局变量的必要引用，以便在基础映像中指向相应的全局变量。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）从基础映像复制相应的IAT项，借此在修补映像中修补必要的导入地址表（Import Address Table，IAT）引用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）以原子化的方式修补基础映像中的必要函数，以便跳转至补丁映像中对应的函数。在对基础映像中的特定函数完成该操作后，对该函数的所有新调用将会用补丁映像中修补后的新函数代码来执行。当修补后的函数返回时，将返回到基础映像中原始函数的调用方。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于新函数的指针宽度为
64位（8字节），修补引擎会将每个指针放入HPAT，使其位于二进制文件的末尾。这样，只需要5字节就能将间接跳转放在位于每个函数开头处的填充空间内
（该过程已被简化。Retpoline兼容的热修补需要可兼容的Retpoline，此外HPAT会被分为代码页和数据页）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如图9-38所示，修补引擎可兼容不同类型的二进制文件。如果NT内核未找到任何可修补的内核模式模块，则它会对所有用户模式进程进行重新搜索，并通过类似的过程对可兼容的用户模式可执行文件或二进制文件进行正确的修补。</span></p><div style="display: block;text-align:center;">
	<img width="885" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a9b3720a98df72ca8c8f785e0ec2f3d1.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-38 热修补引擎针对不同类型二进制文件的执行方案</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter09_0005.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_106" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>5</b><b> </b><b>隔</b><b>离</b><b>用</b><b>户</b><b>模</b><b>式</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">隔离用户模式（Isolated User Mode，IUM）是一种由安全内核为自己的安全进程（Trustlet）提供的服务。Trustlet的常规架构请参阅卷1第3章，本节将继续介绍隔离用户模式所提供的一些服务，例如安全设备以及VBS隔区。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如卷1第3章所述，在VTL 1中创建一个Trustlet后，它通常会在自己的地址空间中映射下列库。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>I</b><b>u</b><b>m</b><b>d</b><b>l</b><b>l</b><b>.</b><b>d</b><b>l</b><b>l</b><b>：</b></span>IUM原生层DLL实现了安全系统调用存根，它相当于VTL 0下的Ntdll.dll。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>I</b><b>u</b><b>m</b><b>b</b><b>a</b><b>s</b><b>e</b><b>.</b><b>d</b><b>l</b><b>l</b><b>：</b></span>IUM
基础层DLL这个库实现了仅供VTL 
1软件使用的大部分安全API。它为每个安全进程提供了各种服务，如安全识别、通信、密码学运算以及安全内存管理。Trustlet通常并不直接调用安全
系统调用，但会通过Iumbase.dll（相当于VTL 0下的kernelbase.dll）进行这些操作。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>I</b><b>u</b><b>m</b><b>C</b><b>r</b><b>y</b><b>p</b><b>t</b><b>.</b><b>d</b><b>l</b><b>l</b><b>：</b></span>公开了用于签名和完整性验证的公钥/私钥加密函数。VTL 1中公开的大部分加密函数都在Iumbase.dll中实现，仅少数专用加密例程在IumCrypt中实现。IumCrypt公开的服务主要由LsaIso使用，但很多其他Trustlet并不加载LsaIso。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>N</b><b>t</b><b>d</b><b>l</b><b>l</b><b>.</b><b>d</b><b>l</b><b>l</b><b>、</b><b>K</b><b>e</b><b>r</b><b>n</b><b>e</b><b>l</b><b>b</b><b>a</b><b>s</b><b>e</b><b>.</b><b>d</b><b>l</b><b>l</b><b>和</b><b>K</b><b>e</b><b>r</b><b>n</b><b>e</b><b>l</b><b>3</b><b>2</b><b>.</b><b>d</b><b>l</b><b>l</b><b>：</b></span>Trustlet
在设计上可同时运行于VTL 1和VTL 0。这种情况下，它应该只能使用标准VTL 0 API表面所实现的例程。VTL 
0下可用的服务并不全在VTL 
1中实现。例如，一个Trustlet可以永远不执行与注册表和文件有关的I/O操作，但依然可以使用同步例程、ALPC、线程API以及结构化异常处
理，并能管理虚拟内存和节对象。由Kernelbase和Kernel32库提供的几乎所有服务都通过Ntdll.dll执行系统调用。在VTL 
1中，此类系统调用可“转换为”常规调用并重定向至VTL 
0内核（常规调用详见上文）。常规调用通常会被IUM函数和安全内核本身所使用。这也解释了为何ntdll.dll始终会映射到每个Trustlet中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>V</b><b>e</b><b>r</b><b>t</b><b>d</b><b>l</b><b>l</b><b>.</b><b>d</b><b>l</b><b>l</b><b>：</b></span>VSM隔区运行时DLL负责管理VBS隔区的生命周期。安全隔区中执行的软件只能提供非常有限的服务，该库实现了公开给隔区软件的所有隔区服务，通常并不为标准的VTL 1进程加载。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">了解这些信息后，我们一起来看看Trustlet创建过程中涉及的内容，首先是VTL 0中的CreateProcess API，有关它的执行流程详情请参阅卷1第3章。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_107" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>5</b><b>.</b><b>1</b><b> </b><b>T</b><b>r</b><b>u</b><b>s</b><b>t</b><b>l</b><b>e</b><b>t</b><b>的</b><b>创</b><b>建</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">上文曾多次提到，安全内核
依赖NT内核执行多种操作，Trustlet的创建也是如此：这是一种由安全内核与NT内核共同管理的操作。在卷1第3章，我们介绍了Trustlet的
结构及其签名要求，并介绍了重要的策略元数据。此外，我们还详细介绍了CreateProcess 
API的运行流程，Trustlet的创建也是从这里为起点开始的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了正确创建
Trustlet，应用程序在调用CreateProcess 
API时应指定CREATE_SECURE_PROCESS创建标记。在内部，该标记会被转换为PS_CP_SECURE_PROCESS这个NT属性并
传递给NtCreateUserProcess这个原生API。当NtCreateUserProcess成功打开要执行的映像后，会指定一个特殊的标记
来创建映像的节对象，借此让内存管理器使用安全HVCI验证其内容。这样，安全内核即可创建SECURE_IMAGE数据结构，该数据结构可用于描述通过
安全HVCI进行验证的PE映像。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NT内核会像对待常规进程
那样创建所需的进程数据结构和初始的VTL 
0地址空间（页面目录、超空间、工作集），如果新进程是一个Trustlet，NT内核会发出CREATE_PROCESS安全调用。这个安全调用将由安
全内核来管理，为此，安全内核会创建安全进程对象和相关数据结构（名为EPROCESS）。随后，安全内核将常规进程对象（EPROCESS）与新建的安
全进程对象链接在一起，并创建初始的安全地址空间，为此需要分配安全页表，并在安全页表的上半部分复制用于描述安全地址空间中内核部分的根项。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NT内核完成空进程地址空
间的设置，并将Ntdll库映射到其中（详见卷1第3章的“阶段3D”）。在为安全进程执行该操作时，NT内核会调用
INITIALIZE_PROCESS安全调用以完成VTL 
1中的设置。安全内核会将创建进程时指定的Trustlet标识和属性复制到新的安全进程，创建安全句柄表，并将安全共享页映射到地址空间中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全进程创建工作的最后一
步需要创建安全线程。初始线程对象的创建过程与NT内核中的常规进程类似：当NtCreateUserProcess调用PspInsertThread
时，它已经分配了线程内核堆栈并插入了必要数据，这样既可从KiStartUserThread内核函数启动（详见卷1第3章的“阶段4”）。如果进程是
一个Trustlet，NT内核会发出CREATE_THREAD安全调用以执行最终的安全线程创建工作。安全内核会附加到新安全进程的地址空间，分配并
初始化安全线程数据结构、线程的安全TEB以及内核堆栈。安全内核会填充线程的内核堆栈，为此需要插入线程优先的初始内核例程
SkpUserThreadStart。随后，安全内核会为安全线程初始化与计算机相关的硬件上下文，该上下文指定了实际的映像启动地址以及第一个用户模
式例程的地址。最后，安全内核会将常规线程对象与新创建的安全线程对象联系起来，将线程插入安全线程列表，并将该线程标记为可运行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当NT内核调度器选择运行
常规线程对象时，执行过程依然始于VTL 
0下的KiStartUserThread函数。该函数可降低线程的IRQL并调用系统初始线程例程（PspUserThreadStartup）。在
NT内核设置初始形式转换上下文之前，执行过程与常规线程无异。但在设置形式转换上下文之后，会调用VslpEnterIumSecureMode例程启
动安全内核调度循环并指定RESUMETHREAD安全调用。该循环只有在线程被终止后才会退出。这个初始安全调用将由VTL 
1下的常规调用调度程序循环来处理，借此确定“恢复线程”进入VTL 
1的原因，附加到新进程的地址空间，并切换至新的安全线程堆栈。在这种情况下，安全内核并不调用IumInvokeSecureService调度程序函
数，因为它知道初始线程函数已经位于堆栈中，因此只需要返回到堆栈中的地址，该地址指向了VTL 1安全初始例程SkpUserThreadStart。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与标准VTL 
0线程类似，SkpUserThreadStart会设置初始形式转换上下文，以运行映像加载器初始化例程（Ntdll.dll中的
LdrInitializeThunk）以及整个系统范围内的线程启动存根（Ntdll.dll中的RtlUserThreadStart）。这些步骤是
通过在原地编辑线程上下文并发出从系统服务中退出的操作来完成的，借此即可加载特制的用户上下文并返回到用户模式。新生的安全线程会像常规VTL 
0线程那样进行初始化，由LdrInitializeThunk例程初始化加载器及所需的数据结构。该函数返回后，NtContinue会还原新的用户上
下文。至此线程才真正开始执行：RtlUserThreadStart会使用实际映像入口点的地址和启动参数，并调用应用程序的入口点。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 细心的读者可能已经注意到，安全内核并未采取任何措施来保护新Trustlet的二进制映像。这是因为按照设计，描述Trustlet基础二进制映像的共享内存依然可被VTL 0访问。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">假
设一个Trustlet想要向映像的全局数据中写入私有数据。在映像全局数据中，映射可写数据节的PTE会被标记为“写入时复制”。因此处理器会生成访问
故障。该故障属于用户模式的地址范围（别忘了，系统并不使用NAR来跟踪共享页）。安全内核页面故障处理程序（使用一个常规调用）将执行转向NT内核，借
此分配一个新页面并将旧页面的内容复制进去，随后通过SLAT进行保护（使用受保护的复制操作，详见上文“安全内核内存管理器”一节）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>调</b><b>试</b><b>T</b><b>r</b><b>u</b><b>s</b><b>t</b><b>l</b><b>e</b><b>t</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">只
有在Trustlet通过其元数据策略（存储在.tPolicy节下）明确允许的情况下，我们才可以通过用户模式调试器调试Trustlet。在这个实验
中，我们将通过内核调试器调试一个Trustlet。我们需要将内核调试器连接至启用VBS的测试系统（也可以使用本地内核调试器），不过严格来说并不需
要HVCI。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">首先，找到LsaIso.exe这个Trustlet：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; !process 0 0 lsaiso.exe </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PROCESS ffff8904dfdaa080 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    SessionId: 0 Cid: 02e8    Peb: 8074164000 ParentCid: 0250 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    DirBase: 3e590002 ObjectTable: ffffb00d0f4dab00 HandleCount: 42. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Image: LsaIso.exe </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">分析该进程的PEB可以发现，一些信息被设置为“0”或不可读：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; .process /P ffff8904dfdaa080 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; !peb 8074164000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PEB at 0000008074164000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    InheritedAddressSpace:    No </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ReadImageFileExecOptions: No </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    BeingDebugged:            No </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ImageBaseAddress:         00007ff708750000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    NtGlobalflag:             0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    NtGlobalflag2:            0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Ldr                       0000000000000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    *** unable to read Ldr table at 0000000000000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    SubSystemData:     0000000000000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ProcessHeap:       0000000000000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ProcessParameters: 0000026b55a10000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    CurrentDirectory: 'C:\Windows\system32\' </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    WindowTitle:  '&lt; Name not readable &gt;' </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ImageFile:    '\??\C:\Windows\system32\lsaiso.exe' </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    CommandLine:  '\??\C:\Windows\system32\lsaiso.exe' </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    DllPath:      '&lt; Name not readable &gt;'lkd </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">读取进程映像基址的操作可能会成功，但这取决于映射到VTL 0地址空间的LsaIso映像是否已经被访问。第一个页面通常都会是这样的情况（毕竟主映像的共享内存依然可在VTL 0下访问）。在我们的系统中，第一个页面已映射且有效，但第三个页面是无效的：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; db 0x7ff708750000 l20 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">00007ff7`08750000 4d 5a 90 00 03 00 00 00-04 00 00 00 ff 00 00 MZ.............</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">00007ff7`08750010 b8 00 00 00 00 00 00 00-40 00 00 00 00 00 00 00 ......@.....</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; db (0x7ff708750000 + 2000) l20 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">00007ff7`08752000 ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ?? ????????????????</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">00007ff7`08752010 ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ?? ????????????????</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; !pte (0x7ff708750000 + 2000) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">1: kd&gt; !pte (0x7ff708750000 + 2000) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                          VA 00007ff708752000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PXE at FFFFD5EAF57AB7F8   PPE at FFFFD5EAF56FFEE0   PDE at FFFFD5EADFFDC218 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">contains 0A0000003E58D867 contains 0A0000003E58E867 contains 0A0000003E58F867 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">pfn 3e58d     ---DA--UWEV pfn 3e58e     ---DA--UWEV pfn 3e58f     ---DA--UWEV </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PTE at FFFFD5BFFB843A90 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">contains 00000000000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">not valid </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">转储进程的线程可以发现一些重要信息，借此确认了我们上一节所讨论的内容：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">!process ffff8904dfdaa080 2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PROCESS ffff8904dfdaa080 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    SessionId: 0 Cid: 02e8    Peb: 8074164000 ParentCid: 0250 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    DirBase: 3e590002 ObjectTable: ffffb00d0f4dab00 HandleCount: 42. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Image: LsaIso.exe </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        THREAD ffff8904dfdd9080 Cid 02e8.02f8 Teb: 0000008074165000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">            ffff8904dfdc5ca0 NotificationEvent </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        THREAD ffff8904e12ac040 Cid 02e8.0b84 Teb: 0000008074167000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Win32Thread: 0000000000000000 WAIT: (WrQueue) UserMode Alertable </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">            ffff8904dfdd7440 QueueObject </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; .thread /p ffff8904e12ac040 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Implicit thread is now ffff8904`e12ac040 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Implicit process is now ffff8904`dfdaa080 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">.cache forcedecodeuser done </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">lkd&gt; k </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  *** Stack trace for last set context - .thread/.cxr resets it </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> # Child-SP          RetAddr           Call Site </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">00 ffffe009`1216c140 fffff801`27564e17 nt!KiSwapContext+0x76 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">01 ffffe009`1216c280 fffff801`27564989 nt!KiSwapThread+0x297 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">02 ffffe009`1216c340 fffff801`275681f9 nt!KiCommitThreadWait+0x549 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">03 ffffe009`1216c3e0 fffff801`27567369 nt!KeRemoveQueueEx+0xb59 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">04 ffffe009`1216c480 fffff801`27568e2a nt!IoRemoveIoCompletion+0x99 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">05 ffffe009`1216c5b0 fffff801`2764d504 nt!NtWaitForWorkViaWorkerFactory+0x99a </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">06 ffffe009`1216c7e0 fffff801`276db75f nt!VslpDispatchIumSyscall+0x34 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">07 ffffe009`1216c860 fffff801`27bab7e4 nt!VslpEnterIumSecureMode+0x12098b </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">08 ffffe009`1216c8d0 fffff801`276586cc nt!PspUserThreadStartup+0x178704 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">09 ffffe009`1216c9c0 fffff801`27658640 nt!KiStartUserThread+0x1c </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0a ffffe009`1216cb00 00007fff`d06f7ab0 nt!KiStartUserThreadReturn </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0b 00000080`7427fe18 00000000`00000000 ntdll!RtlUserThreadStart </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">通
过这个堆栈我们可以清晰地看到：执行始于VTL 
0下的KiStartUserThread例程。PspUserThreadStartup调用了安全调用调度循环，该循环永远不会结束，但被一个等待操
作打断了。内核调试器无法显示安全内核的任何数据结构或Trustlet的私有数据。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_108" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>5</b><b>.</b><b>2</b><b> </b><b>安</b><b>全</b><b>设</b><b>备</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">VBS为驱动程序提供了在安全环境中运行自己部分代码的能力。安全内核本身无法通过扩展支持内核驱动程序，这样会导致它的攻击面过大。此外，微软也不允许外部企业在主要承担安全作用的组件中引入可能的Bug。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">用户模式驱动程序框架
（User-Mode Driver Framework，UMDF）通过引入驱动程序辅助组件的概念解决了这个问题，这种辅助组件可同时在VTL 
0和VTL 
1下运行。在这种情况下，甚至可将其称为安全辅助组件。安全辅助组件包含驱动程序中需要在不同模式（本例中为IUM）下运行的代码子集，可作为主KMDF
驱动程序的扩展或辅助组件加载。不过标准WDM驱动程序也可以被支持。主驱动程序依然运行在VTL 
0内核模式下，并继续负责管理设备的PnP和电源状态，但它需要能够联系到自己的辅助组件，才能执行必须在IUM下完成的任务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">卷1第3章提到的安全驱动
程序框架（Secure Driver 
Framework，SDF）已被弃用，图9-39展示了全新UMDF安全辅助组件模型的架构，该架构依然建立在相同的，可在VTL 
0用户模式下使用的UMDF核心框架（Wudfx02000.dll）基础上。UMDF核心框架利用UMDF安全辅助组件主机
（WUDFCompanionHost.exe）提供的服务加载并管理以DLL形式调度的驱动程序辅助组件。UMDF安全辅助组件主机管理了安全辅助组件
的生命周期，并封装了很多专门处理IUM环境中特定问题所需的UMDF函数。</span></p><div style="display: block;text-align:center;">
	<img width="756" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/182752cbfe762644420999ca213b3a8a.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-39 WDF驱动程序的安全辅助组件架构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全辅助组件通常与VTL
 0内核中运行的主驱动程序相关联。它必须包含正确的数字签名（与每个Trustlet一样，需要在签名中包含IUM 
EKU），并且必须在元数据节中声明自己的能力。安全辅助组件会对自己管理的设备拥有完整的所有权（这也解释了为何此类设备通常被称为安全设备）。安全辅
助组件的安全设备控制器支持下列功能。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>安</b><b>全</b><b>D</b><b>M</b><b>A</b><b>：</b></span>驱
动程序可以指示设备直接在受保护的VTL 1内存中执行DMA传输，而VTL 
0是无法访问的。安全辅助组件可以处理通过DMA接口收发的数据，随后通过标准KMDF通信接口（ALPC）将部分数据传输给VTL 
0驱动程序。通过Iumbase.dll公开的IumGetDmaEnabler和IumDmaMapMemory安全系统调用，可以让安全辅助组件在
VTL 1用户模式下直接映射物理DMA内存范围。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>内</b><b>存</b><b>映</b><b>射</b><b>的</b><b>I</b><b>O</b><b>（</b><b>M</b><b>M</b><b>I</b><b>O</b><b>）</b><b>：</b></span>安全辅助组件可以请求设备在VTL 1（用户模式）下映射自己可访问的MMIO范围。随后即可在IUM中直接访问内存映射设备的寄存器。该功能由MapSecureIo和ProtectSecureIo API公开。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>安</b><b>全</b><b>节</b><b>：</b></span>辅
助组件可以通过CreateSecureSection API创建并映射安全节，安全节代表可以在Trustlet和VTL 
0下运行的主驱动程序之间共享的内存。此外，安全辅助组件还可以指定不同类型的SLAT保护，以便让内存能够通过安全设备（使用DMA或MMIO）访问。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全辅助组件无法直接响应
设备中断，设备中断需要通过VTL 
0下运行的相关内核模式驱动程序来映射和管理。按照同样的方式，内核模式驱动程序依然需要管理收到的所有IOCTL，借此充当系统和用户模式应用程序的高
级接口。主驱动程序通过使用UMDF任务队列对象发送WDF任务的方式与自己的安全辅助组件通信，在内部，这会用到WDF框架公开的ALPC设施。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">典型的KMDF驱动程序会
通过INF指令注册自己的辅助组件。WDF会在驱动程序调用WdfDeviceCreate的上下文中自动启动驱动程序的辅助组件（对即插即用驱动程序来
说这通常发生在AddDevice回调中），为此要向UMDF驱动程序管理器服务发送一条ALPC消息，通过调用NtCreateUserProcess
原生API生成一个新的WUDFCompanionHost.exe 
Trustlet。随后，UMDF安全辅助组件主机会在自己的地址空间中加载安全辅助组件DLL。为了真正启动安全辅助组件，UMDF驱动程序管理器还会
向WUDFCompanionHost发送另一条ALPC消息。辅助组件的DriverEntry例程会执行驱动程序的安全初始化工作，并通过经典的
WdfDriverCreate API创建WDFDRIVER对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后框架会调用VTL 
1下辅助组件的AddDevice回调例程，通常这会通过新的WdfDeviceCompanionCreate这个UMDF 
API创建辅助组件的设备。后者会通过IumCreateSecureDevice安全系统调用将执行转移至安全内核，并由安全内核创建新的安全设备。至
此，安全辅助组件对自己管理的设备拥有了完整的所有权。通常来说，在创建了安全设备后，辅助组件要做的第一个工作是创建任务队列对象
（WDFTASKQUEUE），该对象可用于处理由相关VTL 
0驱动程序传入的任务。执行控制会返回给内核模式驱动程序，并由它向自己的安全辅助组件发送新任务消息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">WDM驱动程序也支持这种
模式。WDM驱动程序可以使用KMDF的微型端口（miniport）模式与一个特殊的过滤器驱动程序WdmCompanionFilter.sys交
互，该驱动程序被附加到设备堆栈中一个较低级别的位置。WDM辅助组件过滤器可以让WDM驱动程序使用任务队列对象向安全辅助组件发送任务消息。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_109" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>5</b><b>.</b><b>3</b><b> </b><b>基</b><b>于</b><b>V</b><b>B</b><b>S</b><b>的</b><b>隔</b><b>区</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在卷1第5章，我们介绍了
软件防护扩展（Software Guard 
Extension，SGX），这项硬件技术创建受保护的内存隔区（enclave），这种进程地址空间中的安全区域可以通过硬件为代码和数据提供保护
（加密），防止受到隔区外部代码的影响。这项技术最早出现在第6代Intel酷睿处理器（Skylake）上，但当时存在一些问题而无法被广泛采用
（AMD也提供了一种名为安全加密虚拟化的类似技术，但该技术无法兼容SGX）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了解决这些问题，微软发布了基于VBS的隔区，这种安全隔区的隔离能力由VSM基础架构来保证。基于VBS的隔区中的代码和数据仅限隔区自己和VSM安全内核查看，NT内核、VTL 0进程以及系统中运行的安全Trustlet均无法访问。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">基于VBS的安全隔区是通
过在常规进程中建立虚拟地址范围的方式创建的。在代码和数据载入隔区后，系统会通过安全内核将控制转移至隔区的入口点，借此即可首次进入该隔区。随后，安
全内核首先会为隔区映像使用映像签名的验证机制来验证所有代码和数据是否都是真实的，并获得可在隔区中运行的授权。如果签名检查通过，随后的执行控制会被
转移给隔区的入口点，该入口点可以访问隔区中的所有代码和数据。默认情况下，系统只支持执行带有正确签名的隔区。这样排除了未签名恶意软件在反恶意软件无
法监控的系统中执行的可能性，毕竟反恶意软件是无法访问任何隔区中的内容的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">执行过程中，控制权可在隔
区及包含隔区的进程间来回转移。隔区内部执行的代码可访问隔区虚拟地址范围内的所有数据，此外，它还可以读取并写入包含隔区的不安全进程地址空间。包含隔
区的进程无法访问隔区虚拟地址范围内的所有内存。如果一个托管进程包含多个隔区，那么每个隔区都将只能访问自己的内存以及托管进程所能访问的内存。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于硬件隔区，当代码在隔
区中运行时，将获得一份隔区密封报告，第三方实体可以使用该报告来验证代码确保是在VBS隔区的隔离保障之下运行的。该报告还可用于验证所运行代码的具体
版本。该报告包含了与宿主系统、隔区本身，以及隔区中可能已加载的所有DLL有关的信息。此外，还能通过相关信息了解隔区是否在启用调试功能的情况下运
行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">基于VBS的隔区以符合下列特征的DLL形式发布。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
通过Authenticode签名方式添加签名，其叶证书（leaf 
certificate）包含有效EKU，这样的映像才能作为隔区运行。发出数字证书的根信任机构应该是微软，或是由微软副署
（countersigned）的证书清单所涵盖的第三方签名机构。这意味着第三方公司可以签名并运行自己的隔区。在有效的数字签名EKU方面，
Windows内部签名隔区为IUM EKU (1.3.6.1.4.1.311.10.3.37)，所有第三方隔区为Enclave EKU 
(1.3.6.1.4.1.311.10.3.42)。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·包含一个隔区配置节（由IMAGE_ENCLAVE_CONFIG数据结构表示），该节描述了有关隔区的信息，会链接到隔区映像的加载配置数据目录中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·包含正确的控制流防护（CFG）检测。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">隔区的配置节很重要，其中
包含正确运行和密封隔区所需的重要信息：具备唯一性的族ID和映像ID，它们由隔区的创建者指定，用于识别隔区的二进制文件、安全版本号以及隔区的策略信
息（例如预期虚拟大小、可运行的线程数量最大值、隔区的可调试性）。此外，隔区的配置节还包含隔区可导入的映像列表及其标识信息。隔区的导入模块可通过族
ID和映像ID的组合来识别，或可通过所生成的唯一ID（从二进制文件的哈希值开始计算而来）以及作者ID（通过为隔区签名所用的证书派生而来）的组合来
识别（这个组合可以代表创建该隔区的人的身份）。导入模块的标识符还必须包含最小的安全版本号。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全内核通过VBS隔区运
行时DLL（Vertdll.dll）为隔区提供了一些基础的系统服务，该DLL会映射至隔区的地址空间。这些服务包括标准C运行时库的有限子集、在隔区
地址范围内分配或释放安全内存的能力、同步服务、结构化异常处理支持、基础的密码学加密函数，以及密封数据的能力。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>转</b><b>储</b><b>隔</b><b>区</b><b>配</b><b>置</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
这个实验中，我们将使用Windows SDK和WDK中提供的Microsoft Incremental 
linker（link.exe）工具转储软件隔区配置数据。这些软件包均可从网上下载。此外，我们也可以使用EWDK，其中已经包含所有必要的工具，并
且无须安装。EWDK的下载地址：https://docs.microsoft.com/windows-hardware/drivers/
download-the-wdk。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请通过搜索框打开Visual Studio Developer Command Prompt，或执行EWDK的ISO映像中包含的LaunchBuildEnv.cmd脚本文件。我们将使用<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>l</b><b>i</b><b>n</b><b>k</b><b>.</b><b>e</b><b>x</b><b>e</b><b> </b><b>/</b><b>d</b><b>u</b><b>m</b><b>p</b><b>/</b><b>l</b><b>o</b><b>a</b><b>d</b><b>c</b><b>o</b><b>n</b><b>f</b><b>i</b><b>g</b></span>命令分析System Guard Routine Attestation这个隔区的配置数据，如图9-40所示。下文还将详细介绍这些配置数据。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/daf7ef885df9b93ae6deb4d5b20a17b9.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">上述命令的输出结果很长，因此在如图所示的范例中，我们已将输出结果重定向到SgrmEnclave_secure_loadconfig.txt文件中。打开新创建的输出文件后，可以看到该二进制映像包含一个CFG表以及一个有效的隔区配置指针，该指针指向了下列数据。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Enclave Configuration </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">             00000050 size </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">             0000004C minimum required config size </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">             00000000 policy flags </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">             00000003 number of enclave import descriptors </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">             0004FA04 RVA to enclave import descriptors </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">             00000050 size of an enclave import descriptor </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">             00000001 image version </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">             00000001 security version </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     0000000010000000 enclave size </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">             00000008 number of threads </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">             00000001 enclave flags </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">             family ID : B1 35 7C 2B 69 9F 47 F9 BB C9 4F 44 F2 54 DB 9D </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">              image ID : 24 56 46 36 CD 4A D8 86 A2 F4 EC 25 A9 72 02 </span></p>
</div><div class="header0"><h1><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h1></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ucrtbase_enclave.dll </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">              0 minimum security version </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">              0 reserved </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                match type : image ID </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                 family ID : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                  image ID : F0 3C CD A7 E8 7B 46 EB AA E7 1F 13 D5 CD DE 5D </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">          unique/author ID : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                             00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">bcrypt.dll </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                0 minimum security version </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                0 reserved </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                  match type : image ID </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                   family ID : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                    image ID : 20 27 BD 68 75 59 49 B7 BE 06 34 50 E2 16 D7 ED</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">            unique/author ID : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                               00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     ... </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">配
置节包含了二进制映像的隔区数据（如族ID、映像ID以及安全版本号）和导入描述符数组，借此可向安全内核告知主隔区的二进制文件可以安全地依赖哪些库。
我们可以对Vertdll.dll库以及从System Guard Routine Attestation隔区导入的所有二进制文件重做该实验。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>隔</b><b>区</b><b>生</b><b>命</b><b>周</b><b>期</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">我们在卷1第5章讨论了硬件隔区（基于SGX）的生命周期。VBS隔区的生命周期与其类似，微软进一步增强了原有的隔区API，借此为基于VBS的新隔区类型提供支持。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';"><span style="font-size:16px;font-weight: bold;font-family:'PingFang SC';"><b>步</b><b>骤</b></span>1：
创建。应用程序通过向CreateEnclave 
API指定ENCLAVE_TYPE_VBS标记来创建基于VBS的隔区。调用方应当指定一个所有者ID以识别隔区所有者。隔区会像硬件隔区那样创建代
码，最终调用内核中的NtCreateEnclave。后者会检查参数，复制传入的结构，并附加到目标进程（以防隔区被创建到不同于调用方的另一个进程
中）。MiCreateEnclave函数分配一个隔区类型的VAD，借此描述隔区的虚拟内存范围并选择一个基准虚拟地址（如果调用方未指定）。内核分配
内存管理器的VBS隔区数据结构和每处理器隔区哈希表，这些信息将用于快速查找以特定编号开始的隔区。如果这是进程中创建的第一个隔区，系统还会使用
CREATE_PROCESS安全调用在VTL 1下创建一个充当隔区容器的空的安全进程（详见上文“Trustlet的创建”一节）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">VTL 
1中的CREATE_ENCLAVE安全调用处理程序将执行隔区创建的实际工作：分配安全隔区密钥数据结构（SKMI_ENCLAVE），设置对容器安全
进程（之前由NT内核创建）的引用，并创建描述整个隔区虚拟地址空间的安全VAD（安全VAD包含与VTL 
0中的等效项类似的信息）。该VAD会被插入包含进程的VAD树（而非隔区本身）。另外，还会像对待包含进程那样为隔区创建一个空的虚拟地址空间：页表根
仅由系统项填充。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';"><span style="font-size:16px;font-weight: bold;font-family:'PingFang SC';"><b>步</b><b>骤</b></span>2：
将模块载入隔区。基于硬件的隔区中，父进程只能将模块（而非任意数据）载入隔区。这会导致映像的每个页面被复制到VTL 1中的地址空间。VTL 
1隔区中每个映像的页面都是一个私有副本。隔区中需要加载至少一个模块（充当模块主映像），否则隔区将无法初始化。而VBS隔区创建完毕后，应用程序将调
用LoadEnclaveImage 
API，指定隔区基址和必须载入隔区的模块名称。位于Ntdll.dll中的Windows加载器代码将搜索指定的DLL名称，打开并验证其二进制文件，
创建一个在调用过程中以只读访问权限映射的节对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">加载器映射该节后，会解析
映像的导入地址表，这是为了创建依赖模块（导入、延迟加载以及转发的模块）列表。对于找到的每个模块，加载器会检查隔区中是否有足够的空间来映射，并会计
算正确的映像基址。如图9-40所示，该图展示了SGRA（System Guard Runtime 
Attestation）安全隔区，该隔区中的模块使用自上而下的策略进行映射。这意味着主映像会映射至尽可能高的虚拟地址上，所有依赖的模块会映射至彼
此相邻的低位地址上。在这个阶段，Windows加载器还会为每个模块调用NtLoadEnclaveData内核API。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了在VBS隔区中加载特
定映像，内核会执行一个复杂的过程，以便让节对象的共享页面可以复制到VTL 
1中隔区的私有页面里。MiMapImageForEnclaveUse函数可以获得节对象的控制区域，并通过SKCI进行验证。如果验证失败，则过程会
被中断并向调用方返回一个错误信息（如上文所述，隔区的所有模块都必须包含正确的签名）。如果成功，则系统会附加至安全系统进程，并将映像的节对象映射至
VTL 
0中的地址空间。此时，模块的共享页面可能是有效的，也可能是无效的，详见卷1第5章。随后会在包含进程中提交模块的虚拟地址空间，这样即可为需要零的
PTE创建私有VTL 0分页数据结构，随后当映像载入VTL 1后，安全内核会填充该数据结构。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/2e4c1a3b503010911c7dd01f107adc31.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-40 SGRA安全隔区（请注意隔区底部为空的空间）</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">VTL 
1中的LOAD_ENCLAVE_MODULE安全调用处理程序获得新模块（由SKCI创建）的SECURE_IMAGE，并验证该映像是否适合在VBS
隔区中使用（通过验证数字签名特征）。随后它会附加到VTL 
1中的安全系统进程，并将安全映像映射至与之前NT内核映射时相同的虚拟地址。这样即可共享来自VTL 
0的原型PTE。随后，安全内核创建描述模块的安全VAD并将其插入隔区在VTL 
1中的地址空间。最后，它会在每个模块的节原型PTE之间循环。对于每个不存在的原型PTE，它会附加在安全系统进程上，并使用
GET_PHYSICAL_PAGE常规调用来调用NT页面错误处理程序（MmAccessFault），借此将共享页面带入内存。安全内核会对私有隔区
页面执行类似的过程，这些页面之前已经由VTL 
0中的NT内核为demand-zero的PTE提交过了。在这种情况下，NT页面错误处理程序会分配归零的页面。安全内核将每个共享物理页面的内容复制
到每个新的私有页面，并在需要时应用必要的私有重定位。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">至此，VBS隔区中的模块加载工作已完成。安全内核会对隔区的私有页面应用SLAT保护（NT内核无法访问隔区中的映像代码和数据），从安全系统进程中解除对共享节的映射，并将执行交给NT内核。加载器可以继续处理下一个模块了。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';"><span style="font-size:16px;font-weight: bold;font-family:'PingFang SC';"><b>步</b><b>骤</b></span>3：
隔区初始化。所有模块被载入隔区后，应用程序将使用InitializeEnclave 
API来初始化隔区，并指定该隔区支持的线程数量最大值（这些线程将被绑定到能在包含进程中执行隔区调用的线程）。安全内核的
INITIALIZE_ENCLAVE安全调用处理程序验证创建隔区过程中指定的策略可兼容主映像配置信息中表达的策略，验证隔区的平台库
（Vertdll.dll）已加载，计算隔区最终的256位哈希值（用于生成隔区密封报告），并创建所有安全隔区线程。当执行控制权返回VTL 
0中的Windows加载器代码后，系统会执行第一个隔区调用，由该调用执行平台DLL的初始化代码。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';"><span style="font-size:16px;font-weight: bold;font-family:'PingFang SC';"><b>步</b><b>骤</b></span>4：
隔区调用（入站和出站）。隔区成功初始化后，应用程序即可针对该隔区进行任意数量的调用。隔区中所有可调用的函数都需要被导出。应用程序可以调用标准的
GetProcAddress 
API来获取隔区函数的地址，随后使用CallEnclave例程将执行控制权转移给安全隔区。这种入站调用的情况下，NtCallEnclave内核例
程将执行线程选择算法，根据下列规则将发出调用的VTL 0线程绑定到隔区线程：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果常规线程之前未被隔区调用过（隔区支持嵌套调用），则将选择执行任意一个空闲隔区线程。如果没有可用的空闲隔区线程，则调用将被阻塞，直到有隔区线程变为可用（前提是调用方指定，未指定的调用会直接失败）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果隔区曾经调用过一个常规线程，那么对隔区的调用将在之前对宿主机发出调用的同一个隔区线程上进行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NT内核与安全内核一起维护了一个隔区线程描述符列表。当常规线程被绑定到隔区线程后，该隔区线程会被插入一个名为绑定线程列表（bound threads list）的列表。被该列表跟踪的隔区线程处于正在运行的状态，不再可用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">线程选择算法成功后，NT
内核会发出CALLENCLAVE安全调用。安全内核会为隔区新建一个堆栈帧并返回到用户模式。隔区上下文中执行的第一个用户模式函数是
RtlEnclaveCallDispatcher。如果隔区调用是发出的第一个调用，那么该函数会将执行转移给VSM隔区运行时DLL
（Vertdll.dll）的初始化例程，借此对CRT、加载器及提供给隔区的所有服务进行初始化。该例程最终会调用隔区主模块以及所有依赖映像的
DllMain函数（会指定DLL_PROCESS_ATTACH作为原因）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">正常情况下，如果隔区平台
DLL已被初始化，隔区调度程序会通过指定DLL_THREAD_ATTACH原因调用每个模块的DllMain，验证目标隔区函数的特定地址是否有效，
如果有效，则会最终调用目标函数。当目标隔区的例程执行完毕时，会回调包含进程借此返回VTL 
0。为此依然需要依赖隔区平台DLL，平台DLL会再次调用NtCallEnclave内核例程。尽管后者在安全内核中的实现略为不同，但依然会采用类似
的策略来返回VTL 
0。隔区本身可以发出隔区调用，借此在不安全的包含进程上下文中执行某些函数。在这种情况（也叫出站调用）下，隔区代码会使用CallEnclave例程
并指定包含进程主模块中导出函数的地址。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';"><span style="font-size:16px;font-weight: bold;font-family:'PingFang SC';"><b>步</b><b>骤</b></span>5：
终止和销毁。当通过TerminateEnclave API请求终止整个隔区时，隔区中的所有线程都会被迫返回VTL 
0。一旦请求终止隔区，所有到隔区的后续调用都将失败。随着线程被终止，它们的VTL 
1线程状态（包括线程堆栈）会被销毁。所有线程都停止执行后，隔区即可被销毁。在隔区被销毁后，依然与隔区关联的其余VTL 
1状态也会被销毁（包括隔区的整个地址空间），所有页面会被释放回VTL 
0。最后，隔区VAD会被删除，所有已提交隔区内存会被释放。当包含进程用隔区的基准地址范围调用VirtualFree时，便会触发销毁。除非隔区已终
止或从未被初始化，否则无法进行销毁。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 如上文所述，映射到隔区地址空间的所有内存页都是私有的。这表示包含很多种含义。不过属于VTL 0中包含进程的任何内存页都不会映射到隔区地址空间（并且不存在描述包含进程分配情况的VAD），那么隔区如何访问包含进程的所有内存页？</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">答
案是安全内核页面错误处理程序（SkmmAccessFault）。在它的代码中，默认处理程序会检查出现错误的进程是否为隔区。如果是，则默认处理程序
会检查错误的发生是否是由于隔区试图执行自己区域外的代码而导致的。这种情况下，处理程序会发出一个访问违规错误。如果产生错误是因为对隔区地址空间之外
进行了读或写访问，那么安全页面错误处理程序会发出GET_PHYSICAL_PAGE常规服务，进而导致VTL 0访问错误处理程序被取消。VTL 
0处理程序会检查包含进程的VAD树，通过PTE获得页面的PFN（为此在必要时将其带入内存），并将其返回给VTL 
1。在这个阶段，安全内核可以创建必要的分页结构，以便将物理页面映射到相同虚拟地址（由于隔区本身属性的缘故，所以该地址是可用的）并恢复执行。至此，
该页面在安全隔区上下文中已处于有效状态。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>密</b><b>封</b><b>和</b><b>认</b><b>证</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">VBS隔区与基于硬件的隔
区类似，都支持数据的密封（seal）和认证（attestation）。“密封”是指使用一个或多个对隔区代码不可见，而由安全内核管理并绑定到计算机
和隔区标识的加密密钥对任意数据进行的加密。隔区永远无法访问这些密钥，安全内核通过使用隔区指定的适当密钥，以及借助EnclaveSealData和
EnclaveUnsealData 
API，提供了密封和解封任意内容的服务。在数据被密封后，将提供一组参数来控制哪些隔区可以解封数据。该机制支持下列策略。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>安</b><b>全</b><b>内</b><b>核</b><b>和</b><b>主</b><b>映</b><b>像</b><b>的</b><b>安</b><b>全</b><b>版</b><b>本</b><b>号</b><b>（</b><b>S</b><b>V</b><b>N</b><b>）</b></span>。任何隔区都不能解封被后续版本隔区或安全内核密封的数据。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>准</b><b>确</b><b>代</b><b>码</b></span>。如果数据被映射了某个模块的隔区密封，那么随后只能被映射了完全相同模块的隔区解封。安全内核会验证隔区中映射的每个映像的唯一ID的哈希值，以便让正确的隔区解封数据。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>相</b><b>同</b><b>映</b><b>像</b><b>、</b><b>族</b><b>或</b><b>作</b><b>者</b></span>。数据只能被具有相同作者ID、族ID或映像ID的隔区解封。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>运</b><b>行</b><b>时</b><b>策</b><b>略</b></span>。只有在解封隔区与密封隔区具备相同调试策略（可调试或不可调试）的情况下，数据才可以解封。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每个隔区都可以向任意第三方证明自己以VBS隔区的形式运行，并且具备VBS隔区架构所提供的全部保护。隔区认证报告提供了特定隔区在安全内核的控制下运行的认证。认证报告包含隔区中所加载全部代码的标识，以及控制隔区执行方式的策略。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">有关密封和认证操作的内部
细节介绍已超出了本书范围。隔区可通过EnclaveGetAttestationReport 
API生成认证报告。由该API返回的内存缓冲区可传送给另一个隔区，借此通过EnclaveVerifyAttestationReport函数生成的
报告“证明”源隔区运行环境的完整性。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_110" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>5</b><b>.</b><b>4</b><b> </b><b>系</b><b>统</b><b>防</b><b>护</b><b>运</b><b>行</b><b>时</b><b>认</b><b>证</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统防护运行时认证
（System Guard Runtime 
Attestation，SGRA）是一种操作系统完整性组件，可将上文介绍的VBS隔区与远程认证服务组件配合使用，为执行环境提供强有力的保障。该环
境可用于在运行时认证敏感的系统属性，并让依赖方了解系统提供的安全承诺是否存在违反情况。这项新技术的首个实现是由Windows 
10于2018年4月的更新（RS4）引入的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SGRA允许应用程序查看有关设备安全态势的声明。该声明包含以下三部分内容。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个会话报告，其中包含的安全级别描述了设备启动时可认证的属性。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个运行时报告，描述了设备的运行时状态。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个签名会话证书，可用于验证报告的真伪。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SGRA服务
（SgrmBroker.exe）承载了一个组件（SgrmEnclave_secure.dll），该组件以VBS隔区的形式运行在VTL 
1中，可持续认证系统在运行过程中出现的安全功能违背情况。这些认证会包含在运行时报告中，而该报告可由依赖方在后端进行验证。由于这个认证过程在一个单
独的信任域中进行，因此很难直接对运行时报告内容发起攻击。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>S</b><b>G</b><b>R</b><b>A</b><b>内</b><b>部</b><b>原</b><b>理</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图9-41从较高的角度展示了Windows Defender System Guard运行时认证的架构概况，其中包含下列客户端组件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·VTL-1认证引擎：SgrmEnclave_secure.dll。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个VTL-0内核模式代理：SgrmAgent.sys。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个承载了认证引擎的VTL-0 WinTCB受保护代理进程：SgrmBroker.exe。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个供WinTCBPP代理进程与网络堆栈交互的VTL-0 LPAC进程：SgrmLpac.exe。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b3fb928e7f4a85e588ff061ed022a913.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图9-41 Windows Defender System Guard运行时认证机制的架构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了快速应对威胁，SGRA通过一种动态脚本引擎（Lua）构建了核心认证机制，该引擎在VTL 1隔区中运行，这样即可频繁地更新认证逻辑。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于VBS隔区提供了隔离能力，所以VTL 1中执行的线程在访问VTL 0 NT API时会遇到各种限制。因此为了让SGRA的运行时组件能执行更有意义的工作，还需要通过某种方式应对VBS隔区给API带来的限制。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统实现了一种基于代理的
方法，可将VTL 0设施公开给运行在VTL 1下的逻辑，这些设施称为辅助（assist），由SgrmBroker用户模式组件或运行在VTL 
0内核模式下的代理驱动程序（SgrmAgent.sys）提供服务。隔区中运行的VTL 1逻辑可调用这些VTL 
0组件，借此请求辅助提供一系列设施，包括NT内核同步基元、页面映射能力等。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">举例来说，该机制的工作原
理如下：SGRA允许VTL 1认证引擎直接读取VTL 
0拥有的物理页面。隔区可通过辅助请求对任意的页进行映射，随后该页会被锁定并映射至SgrmBroker的VTL 
0地址空间（并常驻）。由于VBS隔区可以直接访问宿主进程的地址空间，所以安全逻辑可以直接从映射的虚拟地址读取。这些读取操作必须与VTL 
0内核本身同步。VTL 0常驻代理（SgrmAgent.sys启动程序）也经常用于执行同步。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>认</b><b>证</b><b>逻</b><b>辑</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，SGRA可认证系统运行时的安全属性。这些认证是在VBS隔区所承载的认证引擎中进行的。系统启动期间，会向认证引擎提供描述认证逻辑的带签名Lua字节码。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">认证会定期进行。当发现违背所认证属性的情况（即认证“失败”）时，“失败”会被记录并存储到隔区中。该“失败”会通过运行时报告公开给依赖方，这个报告同样会在隔区中生成并使用会话证书签名。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">例如，SGRA提供的一种认证能力可以认证与执行体进程对象有关的各种属性，如运行中进程的定期枚举，以及进程保护位（负责管理受保护进程策略）的状态认证。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">认证引擎执行检查的流程可概括总结为下列几个步骤。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）VTL 1下运行的认证引擎调用自己的VTL 0托管进程（SgrmBroker），请求内核引用一个执行体进程对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）Broker进程将该请求转发给内核模式代理（SgrmAgent），后者获取请求执行体进程对象的引用来提供服务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）内核模式代理（Agent）向Broker发出通知，告知请求已获得服务，并将必要的元数据传递给Broker。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）Broker将响应转发给发出请求的VTL 1认证逻辑。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">5）随后该逻辑可以选择将支持引用执行体进程对象的物理页面锁定，并映射至自己可访问的地址空间，这是通过类似上述步骤1～4的流程调用隔区实现的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">6）页面被映射后，VTL 1引擎可直接读取并根据内部持有的上下文检查执行体进程对象的保护位。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">7）VTL 1逻辑再次调用到VTL 0，解除页面映射和内核对象的引用。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>报</b><b>告</b><b>和</b><b>信</b><b>任</b><b>的</b><b>建</b><b>立</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了让依赖方获取SGRA
会话证书并为会话和运行时报告签名，系统暴露了一个基于WinRT的API。该API并未公开，仅供参与Microsoft Virus 
Initiative计划的供应商在签署保密协议后索取（请注意，目前只有Microsoft Defender Advanced Threat 
Protection可通过该API与SGRA直接交互）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通过SGRA获取信任声明的流程如下。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）依赖方和SGRA之间
建立一个会话。该会话的建立需要具备网络连接。SgrmEnclave认证引擎（运行在VTL 
1下）生成一个公私密钥对，受保护进程SgrmBroker检索TCG日志和VBS认证报告，将其与上一步生成的密钥的公开部分一起发送给微软的
System Guard认证服务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）认证服务验证TCG日志（来自TPM）和VBS认证报告（认证了该逻辑运行在VBS隔区中），并生成一个会话报告，通过该报告描述被认证设备在启动时的属性。该服务会使用SGRA认证服务中间密钥对公钥签名，借此创建出验证运行时报告所需的证书。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）会话报告和证书返回给依赖方。随后，依赖方即可验证会话报告和运行时证书的有效性。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）依赖方可以借助已建立的会话定期从SGRA请求运行时报告：SgrmEnclave认证引擎会生成一份运行时报告，借此描述已运行认证的状态。该报告会使用会话创建过程中生成的配对私钥进行签名并返回给依赖方（私钥永远不会离开隔区）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">5）依赖方可通过先前获得的运行时证书验证运行时报告，并根据会话报告内容（启动时认证的状态）以及运行时报告（认证的状态）做出策略决定。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">依赖方可以使用SGRA提
供的一些API来认证设备在某个时间点时的状态。该API会返回一份运行时报告，其中详细列出了Windows Defender System 
Guard在运行时针对系统整体安全态势给出的意见。这些意见也包括认证，即对系统运行过程中某些敏感属性测量得到的结果。例如，应用程序可以要求
Windows Defender System 
Guard从硬件支持的隔区测量系统安全性并提供报告，随后该应用即可使用报告提供的详细信息来决定是否可以执行敏感的金融交易或展示个人信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，VBS隔区也
可以提供使用VBS特定签名密钥签名的隔区认证报告。如果Windows Defender System 
Guard可以获得证据，认证主机系统是在启用了VSM的情况下运行的，那么即可使用该证据和带签名的会话报告保证特定隔区正在运行。因此，为了建立必要
的信任，以保证运行时报告的真实性，必须做到以下几点。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）认证计算机的启动状态：操作系统、虚拟机监控程序、安全内核（SK）二进制文件必须具备微软数字签名，并根据安全策略进行必要的配置。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）要在TPM和虚拟机监控程序的运行状况之间建立信任关系，从而信任测量启动日志（measured boot log）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）从测量启动日志中提取所需密钥（VSM IDK），用这些密钥验证VBS隔区签名（详见第12章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）使用受信任的证书颁发机构对隔区中生成的临时密钥对的公共部分进行签名，以便颁发会话证书。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">5）使用临时私钥对运行时报告签名。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">隔区和Windows Defender System Guard认证服务之间的网络调用是在VTL 0下进行的，不过认证协议的设计保证了即使使用不可信任的传输机制，也可以有效防范篡改。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在充分建立上述信任链之
前，还需要具备很多底层技术。为了让依赖方了解能对特定配置下的运行时报告产生的信任程度，Windows Defender System 
Guard认证服务所签署的每一份会话报告都会被分配一个安全级别。这个安全级别体现了平台上启用的底层技术，以及根据平台能力分配的可信度级别。微软正
在将各种安全技术的启用与否映射为不同的安全级别，并会在将相关的API发布给第三方使用时公布相关信息。最高级别的可信度很可能至少需要具备下列功能。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·硬件和OEM配置均可支持VBS。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·启动时的动态信任根测量。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·通过安全启动验证虚拟机监控程序、NT以及安全内核映像。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·通过安全策略保证虚拟机监控程序实施的代码完整性（HVCI）和内核模式代码完整性（KMCI）均已启用，测试签名被禁用，并且内核调试被禁用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·具备ELAM驱动程序。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter09_0006.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_111" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>9</b><b>.</b><b>6</b><b> </b><b>总</b><b>结</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在Hyper-V虚拟机监
控程序及其虚拟化堆栈的帮助下，Windows可以管理并运行多个虚拟机，并能在虚拟机中运行不同的操作系统。多年来，这两个组件通过不断完善，为虚拟机
提供了越来越多的优化和高级功能，例如嵌套虚拟化、虚拟处理器的多种调度器、对不同类型虚拟硬件的支持、VMBus、VA支持的虚拟机等。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">基于虚拟化的安全性为根操
作系统防范恶意软件和隐蔽的Rootkit提供了全新保护，从而确保恶意威胁无法从根操作系统的内存中窃取私密和机密信息。安全内核使用Windows虚
拟机监控程序提供的服务创建了一种全新的执行环境（VTL 
1），该环境受到额外保护，使之无法通过主操作系统中运行的软件访问。此外，安全内核还为Windows生态系统提供了多种服务，以此维护一个更安全的环
境。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全内核还定义了隔离用户模式，可供用户模式代码通过Trustlet、安全设备以及隔区在一种全新的受保护环境中执行。本章最后还介绍了系统防护运行时认证，该组件可以使用安全内核公开的服务测量工作站的执行环境，并针对工作站的完整性提供强有力的保障。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">第10章将介绍Windows的管理和诊断组件，并讨论与这些组件的基础架构有关的重要机制：注册表、服务、任务计划程序、Windows管理规范（WMI）、内核事件跟踪等。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter10.xhtml">
</div><div class="header0"><h1><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';display: block;text-align:center;"><b>第</b><b>1</b><b>0</b><b>章</b></span></h1></div>
<div class="part">
</div><div class="header0"><h1><span id="sigil_toc_id_112" style="font-size:22px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';display: block;text-align:center;"><b>管</b><b>理</b><b>、</b><b>诊</b><b>断</b><b>和</b><b>跟</b><b>踪</b></span></h1></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">本章介绍了微软
Windows操作系统中一些对管理和配置至关重要的基本机制。具体来说，本章将分别介绍Windows注册表、服务、统一后台进程管理器，以及
Windows管理规范（Windows Management 
Instrumentation，WMI）。本章还将介绍用于诊断和跟踪的重要组件，例如Windows事件跟踪（Event Tracing for 
Windows，ETW）、Windows通知设施（Windows Notification 
Facility、WNF）以及Windows错误报告（Windows Error 
Reporting，WER）。本章最后将讨论Windows全局标记，并简要介绍内核以及用户填充码引擎。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter10_0001.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_113" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>1</b><b> </b><b>注</b><b>册</b><b>表</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">注册表在Windows系
统的配置和控制中起着关键作用。注册表是一个用于存储系统和每个用户的设置的存储库，尽管大多数人认为注册表是一种存储在硬盘上的静态数据，但通过本节的
介绍将会知道，注册表还可以作为一个窗口，帮助我们了解Windows执行体和内核在内存中维护的各种结构。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">本节首先会概括介绍注册表
结构，讨论注册表可支持的数据类型，并简要介绍Windows在注册表中维护的关键信息。随后将介绍配置管理器的内部原理，以及负责实现注册表数据库的执
行体组件。此外还将介绍注册表在磁盘上的内部结构、Windows按照应用程序的需求检索配置信息的方法，以及为保护这个重要的系统数据库所采取的安全保
护措施。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_114" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>1</b><b>.</b><b>1</b><b> </b><b>查</b><b>看</b><b>和</b><b>更</b><b>改</b><b>注</b><b>册</b><b>表</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">总的来说，我们不应该直接
修改注册表。如果需要修改应用程序和系统存储在注册表中的设置，应该通过相应的用户界面来进行改动。然而，正如本书之前多次提到的那样，一些高级设置和调
试设置并未提供可编辑的用户界面。因此Windows还提供了很多图形用户界面（GUI）工具和命令行工具，供我们查看并修改注册表设置。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows提供的最主
要的注册表编辑图形用户界面工具为注册表编辑器（Regedit.exe），此外还提供了很多命令行下的注册表编辑工具，如Reg.exe，这些工具可以
导入、导出、备份并还原注册表键，同时可以对比、修改并删除键和值。此外这些工具还可以设置或查询UAC虚拟化所用的标记。另外，我们也可以通过
Regini.exe将包含ASCII或Unicode配置数据的文本文件导入注册表数据中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows驱动包
（WDK）提供了一个可以再分发的组件Offregs.dll，该组件托管脱机注册表库（Offline Registry 
Library）。该库可用于加载二进制格式的注册表配置单元文件（详见下面“配置单元”一节），并对文件本身应用操作，借此绕过Windows对注册表
操作所需的加载和映射等常规逻辑。它的用途主要是协助对注册表进行脱机访问，例如进行完整性检查和验证。如果底层数据不打算被系统可见，还可以借助该工具
获得性能收益，因为这种访问是通过本地文件I/O（而非注册表系统调用）实现的。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_115" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>1</b><b>.</b><b>2</b><b> </b><b>注</b><b>册</b><b>表</b><b>的</b><b>使</b><b>用</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">配置数据的读取主要发生在下列四个时间内。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
初始启动过程中，启动加载器读取配置数据和启动设备驱动程序列表，在内核初始化之前将其载入内存。由于启动配置数据库（Boot 
Configuration 
Database，BCD）实际上也存储在注册表配置单元中，因此完全可以说注册表的访问甚至发生在比这更早的时候，即启动管理器显示操作系统列表时就开
始访问了。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·内核启动过程中，内核读取设置，这些设置决定了要加载哪些设备驱动程序，以及各种系统元素（如内存管理器和进程管理器）如何配置自己并调整系统行为。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·登录过程中，资源管理器和其他Windows组件从注册表读取每用户的首选项，包括网络驱动器盘符映射、桌面壁纸、屏幕保护程序、菜单行为、图标的布局，以及最重要的：要自动运行的程序以及最近访问过的文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·启动过程中，应用程序需要读取系统端设置数据，例如可选安装的组件列表和许可数据，以及每用户设置（可能还包含菜单与工具栏的布局）与最近访问的文档列表。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">其他时候也可以读取注册
表，例如要对注册表值或键的改动做出响应时。虽然注册表提供了异步回调，这也是接收变更通知的首选方式，但一些应用程序也会通过轮询持续监视自己在注册表
中的配置，并自动应用更新后的设置。不过总的来说，空闲的系统中应该不会出现注册表活动，因为这样的应用程序实际上违反了最佳实践
（Sysinternals提供的Process Monitor工具即可跟踪此类活动并找出“不规矩”的应用程序）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">注册表通常会在下列情况下被修改。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·虽然不属于一种“修改”，但注册表的初始结构和很多默认设置都是由原型版本的注册表定义的，该原型包含在Windows的安装介质中，会被复制到每一个新安装的系统内。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·应用程序设置工具创建默认应用程序设置，以及反映了安装过程中选择的配置的设置。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·安装设备驱动程序过程中，即插即用系统在注册表中创建设置，借此告诉I/O管理器该如何启动驱动程序，并创建其他设置来配置驱动程序操作（有关设备驱动程序安装方式的详细信息，请参阅本书卷1第6章“I/O系统”）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·通过用户界面更改应用程序或系统设置后，这些更改通常也会保存在注册表中。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_116" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>1</b><b>.</b><b>3</b><b> </b><b>注</b><b>册</b><b>表</b><b>数</b><b>据</b><b>类</b><b>型</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">注册表是一种数据库，其结构类似于磁盘卷。注册表中包含键（Key，类似于磁盘上的目录）和值（Value，类似于磁盘中的文件）。键是一种容器，可包含其他键（子键）或值，而值可用于存储数据。顶级键是根键。在本节中，我们会交替使用“子键”和“键”这两个词。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">键和值都借鉴了文件系统的
命名约定，因此可以通过名称标记（name 
mark）以唯一的方式识别一个值，而这种名称标记以“Trade\Mark”形式存储在一个名为Trade的键中。每个键的未命名值是这种命名方案唯一
的例外，注册表编辑器会将未命名的值显示为“(Default)”。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">值可存储不同类型的数据，
数据类型共有12种，如表10-1所示。大部分注册表值的类型为REG_DWORD、REG_BINARY或REG_SZ。REG_DWORD值类型可以
存储数字或布尔逻辑值（true/false），REG_BINARY值类型可存储大于32位的数字或加密后的密码等原始数据，REG_SZ值类型可存储
代表名称、文件名、路径、类型等元素的字符串（当然，仅限Unicode编码方式）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表10-1 注册表值的类型</span></p><div style="display: block;text-align:center;">
	<img width="793" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/d9121eec78880e299d71b42cd4d32967.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">REG_LINK值类型特
别有趣，它可以让一个键以透明的方式指向另外一个键。当通过链接遍历注册表时，路径搜索工作还会在链接的目标位置处继续。举例来说，如果
\Root1\Link有一个REG_LINK值为\Root2\RegKey，而RegKey包含值RegValue，那么可以通过两个路径来识别
RegValue，即\Root1\Link\RegValue和\Root2\RegKey\RegValue。下一节将会介绍，Windows大量使
用了注册表链接：六个注册表根键中有三个实际上链接到了另外三个非链接根键下的子键上。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_117" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>1</b><b>.</b><b>4</b><b> </b><b>注</b><b>册</b><b>表</b><b>的</b><b>逻</b><b>辑</b><b>结</b><b>构</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">我们可以通过存储在注册表中的数据来描绘注册表的组织结构。如表10-2所示，用来存储信息的根键共有九个（无法添加根键或删除现有的根键）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表10-2 九个根键</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/5f53f7395215d62771bcb8569c6df276.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为何根键名称的首字母
是“H”？因为根键名称表示Windows对键（KEY）的处理（Handle，H）。正如本书卷1第1章所述，HKEY_LOCAL_MACHINE可
以缩写为HKLM。表10-3列出了所有根键及其缩写。下面还将详细介绍每个根键包含的内容和用途。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表10-3 注册表根键</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/c0248fb151e6338b1227b7c165ba93ba.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>H</b><b>K</b><b>E</b><b>Y</b><b>_</b><b>C</b><b>U</b><b>R</b><b>R</b><b>E</b><b>N</b><b>T</b><b>_</b><b>U</b><b>S</b><b>E</b><b>R</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">HKCU根键包含与本地已
登录用户的偏好和软件配置有关的数据。它会指向当前登录用户的用户配置文件，配置文件位于硬盘\Users\&lt;username&gt;
\Ntuser.dat处（有关根键如何映射到硬盘文件的详情，请参阅下文“注册表的内部原理”一节）。在加载用户配置文件时（例如用户登录或服务进程以
特定用户的身份运行），将自动创建HKCU来映射该用户在HKEY_USERS下的键（这样，如果多个用户登录到同一个系统，则每个用户可看到不同的
HKCU）。表10-4列出了HKCU下的一些子键。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">表10-4 HKEY_CURRENT_USER</span></p><div style="display: block;text-align:center;">
	<img width="849" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/0c39ae0bfa23c403600fc3a262fcda58.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>H</b><b>K</b><b>E</b><b>Y</b><b>_</b><b>U</b><b>S</b><b>E</b><b>R</b><b>S</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于每个已加载的用户配置
文件和系统中的每个用户类注册数据库，HKCU都会包含一个对应的子键。它还包含一个名为HKU\.DEFAULT的子键，会链接到系统配置文件（供通过
Local 
System账户运行的进程使用，详见下文“Windows服务”一节）。例如Winlogon就会使用该配置文件，因此对该配置文件桌面背景设置进行的
改动会体现在登录界面上。当用户首次登录系统并且用户账户不依赖漫游的域配置文件时（漫游配置文件可通过域控制器指定的中央网络位置获取），系统会根据存
储在%SystemDrive%\Users\Default下的配置文件为这个用户的账户创建配置文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统存储配置文件的位置是
通过注册表值HKLM\Software\Microsoft\Windows 
NT\CurrentVersion\ProfileList\ProfilesDirectory定义的，其默认设置为%SystemDrive%
\Users。ProfileList键还存储了系统中现存配置文件列表。有关每个配置文件的信息位于一个子键中，该子键的名称可体现对应账户的安全描述
符（security 
identifier，SID，有关SID的详细信息请参阅卷1第7章）。存储在配置文件对应键中的数据包括该配置文件最后一次加载的时间
（LocalProfileLoadTimeLow值）、账户SID的二进制表示（Sid值），以及该配置文件在硬盘上配置单元（Ntuser.dat文
件，详见本章下文“配置单元”一节）的目录路径（ProfileImagePath值）。Windows会在图10-1所示的用户配置文件管理对话框中显
示系统中存储的配置文件，我们可以在控制面板的用户账户下点击“配置高级用户配置文件属性”来打开该对话框。</span></p><div style="display: block;text-align:center;">
	<img width="591" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/fbd36bb5b7c4ffb0f61eefec2f969576.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-1 用户配置文件管理对话框</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>观</b><b>察</b><b>配</b><b>置</b><b>文</b><b>件</b><b>的</b><b>加</b><b>载</b><b>和</b><b>卸</b><b>载</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们可以使用Runas命令，以当前未登录到本机的用户账户身份启动一个进程，以此观察配置文件如何载入注册表，随后又从注册表中卸载。新进程运行过程中，
运行Regedit并记录HKEY_USERS下已加载的配置文件键。随后终止该进程，在Regedit中按下F5进行刷新，会看到该配置文件已消失。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/bca3be72ed0b70a655fbdeed53640b55.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>H</b><b>K</b><b>E</b><b>Y</b><b>_</b><b>C</b><b>L</b><b>A</b><b>S</b><b>S</b><b>E</b><b>S</b><b>_</b><b>R</b><b>O</b><b>O</b><b>T</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">HKCR包含三类信息：文
件扩展关联、COM类注册，以及用于用户账户控制（UAC）的虚拟化后的注册表根（有关UAC的详细信息请参阅卷1第7章）。每个已注册的文件名扩展都有
一个对应的键，大多数键包含一个REG_SZ值，该值指向HKCR中的另一个键，这个被指向的键包含对应扩展所表示的文件类的关联信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">例如，HKCR\.xls
指向有关Microsoft Office Excel文件的信息。举例来说，其默认值包含“Excel.Sheet.8”，可用于对Excel 
COM对象进行实例化。其他键包含系统中所有已注册COM对象的详细的配置信息。UAC虚拟化注册表位于VirtualStore键下，该键与HKCR下
存储的其他类型的数据并无关联。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">HKEY_CLASSES_ROOT下的数据有两个来源。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·每用户类注册数据，位于HKCU\SOFTWARE\Classes下（会映射至磁盘文件\Users\&lt;username&gt;\AppData\Local\Microsoft\Windows\Usrclass.dat）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·系统级类注册数据，位于HKLM\SOFTWARE\Classes下。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每用户注册数据与系统级注
册数据会被分开，这样可以使漫游配置文件包含自定义的内容。非特权用户和应用程序可以读取系统级数据，可以为系统级数据添加新的键和值（添加的内容会被镜
像到自己的每用户数据），但只能修改自己私有数据中的现有的键和值。这种设计弥补了一个安全漏洞：非特权用户无法更改或删除
HKEY_CLASSES_ROOT的系统级版本，因此无法影响系统中应用程序的运行。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>H</b><b>K</b><b>E</b><b>Y</b><b>_</b><b>L</b><b>O</b><b>C</b><b>A</b><b>L</b><b>_</b><b>M</b><b>A</b><b>C</b><b>H</b><b>I</b><b>N</b><b>E</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">HKLM这个根键包含所有系统级的配置子键：BCD00000000、COMPONENTS（按需动态加载）、HARDWARE、SAM、SECURITY、SOFTWARE以及SYSTEM。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">HKLM\BCD00000000
子键包含以注册表配置单元形式加载的启动配置数据库（Boot Configuration 
DataBase，BCD）信息。该数据库取代了Windows 
Vista之前系统所用的Boot.ini文件，并为所安装的每个系统的启动配置数据带来了更高的灵活性和隔离能力。BCD00000000子键由隐藏的
BCD文件支持，在UEFI系统中，该文件位于\EFI\Microsoft\Boot目录下（有关BCD的详细信息，请参阅第12章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">BCD中的每一项（如
Windows安装，或者该安装的命令行设置）都存储在Objects子键中，这些内容可以作为对象被GUID引用（对于启动项），或者作为数字子键来调
用某个元素。这些原始元素大部分都在Microsoft 
Docs网站的BCD参考文档中给出了相关说明，它们定义了各种命令行设置或启动参数。与每个元素子键关联的值对应了相关命令行标记或启动参数的值。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">命令行工具BCDEdit
可供我们使用元素和对象的符号名称修改BCD，它还为所有可用的启动选项提供了帮助。注册表配置单元可以远程打开，并能从配置单元文件导入，因此可以通过
注册表编辑器修改或读取远程计算机的BCD。下列实验将介绍如何通过注册表编辑器启用内核调试。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>远</b><b>程</b><b>编</b><b>辑</b><b>B</b><b>C</b><b>D</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">虽
然可以使用bcdedit 
/store命令修改脱机的BCD存储，但在这个实验中，我们将通过在注册表中编辑BCD存储的方式启用调试。在这个例子中，我们需要编辑BCD的本地副
本，但这项技术的重点在于可用于任何计算机的BCD配置单元。请通过如下操作添加/DEBUG命令行标记。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">1）打开注册表编辑器进入HKLM\BCD00000000键。展开每个子键，让每个Elements键的数值标识符完全可见。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">2）
找到Type值为0x10200003的Description，以此确定当前Windows系统的启动项，随后选择Elements树中的
12000004键。在该子键的Element值中，应该可以看到当前版本Windows的名称，例如Windows 
10。在较新的系统中，可能会看到多个Windows安装或多个启动应用程序，例如Windows Recovery 
Environment（Windows恢复环境）或Windows Resume 
Application（Windows恢复应用程序）。在这种情况下，我们可能需要检查22000002这个Elements的子键，其中包含路径信
息，例如\Windows。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">3）
这样即可找到当前Windows系统的正确GUID，请在该GUID的Elements子键下新建一个子键，将其名称设置为0x260000a0。如果该
子键已存在，则直接点击进入。找到的GUID应该与bcdedit /v命令输出结果中Windows Boot 
Loader节的identifier值一致（可以使用命令行选项/store检查脱机的文件存储）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">4）如果需要创建子键，随后请在其中创建一个名为Element的二进制值。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">5）修改该值，将其设置为1。这样即可启用内核模式调试。这些更改看起来应该类似下图。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/1c87fe7e753c52c794065184824a691c.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
0x12000004这个ID对应BcdLibraryString_ApplicationPath，而0x22000002这个ID对应
BcdOSLoaderString_SystemRoot。最后，我们添加的0x260000a0这个ID对应
BcdOSLoaderBoolean_KernelDebuggerEnabled。这些值均记录在Microsoft 
Docs网站上的BCD参考文档中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">HKLM\COMPONENTS子键包含与基于组件的服务
	<sup><img width="11" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="此处的“服务”是指针对已安装好的系统进行的维护性操作，如安装更新。虽然本书沿袭微软产品和官方文档中的称呼将其直译为“服务”，但它与我们熟知的Windows后台服务（Service）并非同一个概念，请注意不要混淆。——译者注" title="此处的“服务”是指针对已安装好的系统进行的维护性操作，如安装更新。虽然本书沿袭微软产品和官方文档中的称呼将其直译为“服务”，但它与我们熟知的Windows后台服务（Service）并非同一个概念，请注意不要混淆。——译者注" class="epub-footnote"></sup>（Component
 Based 
Servicing，CBS）堆栈有关的信息。该堆栈包含的多种文件和资源同时也是Windows安装映像（可供自动安装包或OEM预装包使用）或活跃安
装的一部分。CBS 
API主要是为了提供各类维护服务，可以使用这个注册表键中包含的信息识别系统里已安装的组件及其配置信息。在安装、更新或删除个别组件（叫作“单位”）
或一组组件（叫作“包”）时，都会用到这些信息。由于这个键可能变得相当大，为优化系统资源，只有当CBS堆栈为请求提供服务时，才会根据需要动态地加载
和卸载这个键。该键由位于\Windows\system32\config目录下的COMPONENTS配置单元文件提供支持。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">HKLM\HARDWARE
子键存储了有关系统遗留硬件的描述和某些硬件在设备之间的映射关系。在现代操作系统中，此处可能只包含少量外设（如键盘、鼠标以及ACPI 
BIOS数据）。我们可以通过设备管理器工具查看注册表中的硬件信息。为获取这些信息，设备管理器会直接读取HARDWARE键中包含的数据（主要涉及
HKLM\SYSTEM\CurrentControlSet\Enum树下的信息）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">HKLM\SAM存储了与
本地账户和组有关的信息，例如用户密码、组定义以及与域的关联。作为域控制器的Windows 
Server操作系统会将域账户和组的信息存储在活动目录（active 
directory）中，这是一种数据库，其中保存了域级的设置和信息（本书不会介绍活动目录）。SAM键默认配置了安全描述符，因此即使是管理员账户也
无法访问。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">HKLM\SECURITY
子键存储了系统级的安全策略和用户权限分配。HKLM\SAM会链接至HKLM\SECURITY\SAM之下的SECURITY子键。默认情况下，我们
无法查看HKLM\SECURITY或HKLM\SAM的内容，因为这些子键的安全设置只允许System账户访问（System账户的详细介绍请参阅下
面内容）。我们可以更改安全描述符让管理员账户获得读取访问的权限，或者使用PsExec以Local 
System账户身份运行Regedit，即可进一步查看其中的内容。然而，这种“窥视”并不能获得太多有用的信息，因为相关数据是不公开的，并且密码也
通过单向映射的方式进行了加密，也就是说，我们无法从加密后的密码推导出真实密码。SAM和SECURITY子键由启动分区
\Windows\system32\config路径下的SAM和SECURITY配置单元文件提供支持。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">HKLM\SOFTWARE子键存储了系统启动过程中用到的Windows系统级配置信息。此外，第三方应用程序也可以在这里存储自己的系统级设置，例如，应用程序文件和目录的路径，或者许可和过期日期等信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">HKLM\SYSTEM子
键包含系统启动过程中会用到的系统级配置信息，例如要加载的设备驱动程序以及要启动的服务。该子键由\Windows\system32\config目
录下的SYSTEM配置单元文件提供支持。Windows加载器会使用启动库（boot 
library）提供的注册表服务读取并查阅SYSTEM配置单元文件中的数据。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>H</b><b>K</b><b>E</b><b>Y</b><b>_</b><b>C</b><b>U</b><b>R</b><b>R</b><b>E</b><b>N</b><b>T</b><b>_</b><b>C</b><b>O</b><b>N</b><b>F</b><b>I</b><b>G</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">HKEY_CURRENT_CONFIG
实际上是指向当前硬件配置文件（存储于HKLM\SYSTEM\CurrentControlSet\Hardware 
Profiles\Current）的链接。Windows已不再支持硬件配置文件，但这些键依然被保留下来，主要是为了向需要该键的遗留应用程序提供向
后兼容性。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>H</b><b>K</b><b>E</b><b>Y</b><b>_</b><b>P</b><b>E</b><b>R</b><b>F</b><b>O</b><b>R</b><b>M</b><b>A</b><b>N</b><b>C</b><b>E</b><b>_</b><b>D</b><b>A</b><b>T</b><b>A</b><b>和</b><b>H</b><b>K</b><b>E</b><b>Y</b><b>_</b><b>P</b><b>E</b><b>R</b><b>F</b><b>O</b><b>R</b><b>M</b><b>A</b><b>N</b><b>C</b><b>E</b><b>_</b><b>T</b><b>E</b><b>X</b><b>T</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">注册表也可以作为访问Windows性能计数器（这些性能计数器可以来自操作系统组件或服务器应用程序）的机制。通过注册表访问性能计数器，这种做法带来的附带好处是：可以实现“免费的”远程性能监控，因为我们可以通过常规的注册表API轻松实现注册表的远程访问。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">只需打开名为
HKEY_PERFORMANCE_DATA的特殊键并查询其中的值，即可直接访问注册表性能计数器信息。但直接使用注册表编辑器是找不到该键的，该键只
能以编程方式通过Windows注册表函数（如RegQueryValueEx）查看。性能信息实际上并未存储在注册表中，注册表函数会将对该键的访问重
定向至通过性能数据提供程序获得的实时性能信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">HKEY_PERFORMANCE_TEXT
也是一个可用于获取性能计数器信息（通常为名称和描述）的特殊键。我们可以查询Counter这个特殊注册表值的数据来获取任何性能计数器的名称。另一个
特殊注册表值Help提供了所有计数器的描述信息。这些特殊键返回的信息都使用了美式英语，HKEY_PERFORMANCE_NLSTEXT则能提供与
操作系统运行所用语言一致的性能计数器名称和描述。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">我们还可以通过性能数据助手API（Pdh.dll）提供的性能数据助手（Performance Data Helper，PDH）函数获取性能计数器信息。图10-2展示了访问性能计数器信息所涉及的组件。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/282aa20c1582d0b8039b6a32f4a3daee.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-2 注册表性能计数器架构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如图10-2所示，注册表键由静态链接至Advapi32.dll的性能库（Perflib）进行抽象。Windows内核对HKEY_PERFORMANCE_DATA注册表键一无所知，这也解释了为何这些信息无法显示在注册表编辑器中的原因。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_118" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>1</b><b>.</b><b>5</b><b> </b><b>应</b><b>用</b><b>程</b><b>序</b><b>配</b><b>置</b><b>单</b><b>元</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">应用程序通常能从全局注册
表读/写数据。当应用程序打开一个注册表键时，Windows内核会针对特定键所包含的ACL，对进程（或线程，如果在进行线程模拟的话，详见本书卷1第
7章）的访问令牌执行访问检查验证。应用程序也可以使用RegSaveKeyEx和RegLoadKeyEx 
API加载并保存注册表配置单元。在这些情况下，应用程序所操作的数据，可能会被运行在相同或更高特权级别下的其他进程所干扰。此外，为了加载和保存配置
单元，应用程序需要启用备份和还原特权，这两个特权只会提供给以管理员身份运行的进程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">显然，对于大部分需要访问
私有存储库来存储自己设置的应用程序来说，这受到了一定的限制。Windows 
7引入了应用程序配置单元的概念。应用程序配置单元是一种标准的配置单元文件（会链接至相应的日志文件），在挂载后，这样的配置单元只对请求该配置单元的
应用程序可见。开发者可以使用RegSaveKeyEx 
API（可导出配置单元文件中的常规注册表键内容）来创建基础配置单元文件。随后，该应用程序即可使用RegLoadAppKey函数以私密的方式挂载配
置单元（指定REG_PROCESS_APPKEY标记可防止其他应用程序访问同一个配置单元）。在内部，该函数将执行以下操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）以“\Registry\A\&lt;随机Guid&gt;”的形式创建一个随机GUID并将其分配给私有命名空间（\Registry组成NT内核注册表命名空间，详见下文“注册表的命名空间和操作”一节）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）将指定的配置单元文件名称的DOS路径转换为NT格式，并通过适当的参数集调用NtLoadKeyEx原生API。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NtLoadKeyEx函
数会调用常规注册表回调。然而，当检测到这是一个应用程序配置单元时，它会使用CmLoadAppKey将配置单元和相关日志文件加载到私有命名空间中，
这种命名空间无法被其他任何应用程序枚举，并会与调用方进程的生命周期直接绑定（不过配置单元和日志文件依然会被映射至“注册表进程”，注册表进程的详细
信息请参阅下文）。应用程序可以使用标准注册表API读/写自己存储在应用程序配置单元中的私有设置。当应用程序退出或键的最后一个句柄关闭后，配置单元
会自动卸载。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">很多Windows组件都
使用了应用程序配置单元，例如，应用程序兼容性遥测代理（CompatTelRunner.exe）以及现代应用程序模型。通用Windows平台
（UWP）应用程序使用应用程序配置单元存储WinRT类的相关信息，这些信息可被实例化并被应用程序以私有的方式使用。这种配置单元存储在一个名为
ActivationStore.dat的文件中，主要在应用程序启动（更准确地说应该是“激活”）时被激活管理器（activation 
manager）所使用。现代应用程序模型的后台基础架构组件也会通过配置单元中存储的数据保存后台任务信息。这样，当一个后台任务的计时器到时间后，就
可以精确得知该任务的代码位于哪个应用程序库（以及激活类型和线程模型）中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，现代应用程序栈还为
UWP开发者提供了应用程序数据容器的概念，这种容器也可用于存储本地设备上运行应用程序的对应的设置信息（此时这种容器叫作本地容器），或者还可在用户
安装了同一个应用程序的所有设备上共享设置信息。这两类容器都是通过Windows.Storage.ApplicationData.dll这个
WinRT库实现的，该库使用了对应用程序而言属于“本地”的应用程序配置单元（支持文件名为settings.dat）来存储UWP应用程序创建的设
置。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Settings.dat
和ActivationStore.dat配置单元文件都由现代应用程序模型的部署过程（在安装应用时）创建，相关内容已在第8章中进行了详细介绍（并概
括讨论了打包的应用程序）。应用程序数据容器的详细信息可参阅：https://docs.microsoft.com/windows/uwp/
get-started/settings-learning-track。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_119" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>1</b><b>.</b><b>6</b><b> </b><b>事</b><b>务</b><b>型</b><b>注</b><b>册</b><b>表</b><b>（</b><b>T</b><b>x</b><b>R</b><b>）</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在内核事务管理器（Kernel Transaction Manager，KTM，详见第8章）的帮助下，开发者可以通过一套简洁的API在执行注册表操作时实现强大的错误恢复功能，这些操作还能与非注册表操作（如文件或数据库操作）关联起来。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">我们可以通过三个API对
注册表进行事务型的修改：RegCreateKeyTransacted、RegOpenKeyTransacted以及
RegDeleteKeyTransacted。这些新例程除了增加一个新的事务句柄参数外，其他参数与非事务型操作中的参数完全相同。开发者可在调用
KTM的CreateTransaction函数后传入该句柄。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在执行事务型的创建或打开
操作后，所有后续的注册表操作（如创建、删除或修改键中的值）也会自动变成事务型的。不过对已执行事务型操作的子键进行的操作将不会自动继续以事务型的方
式进行，因此诞生了第三个API：RegDeleteKeyTransacted。它可以实现以事务型的方式删除子键，而这是
RegDeleteKeyEx通常无法完成的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与其他的KTM操作类似，
这些事务型操作涉及的数据会使用通用日志文件系统（Common Logging File 
System，CLFS）服务写入日志文件。在事务最终提交或回滚（取决于事务状态，这两种情况都能通过编程发生，或由于断电或系统崩溃而发生）之前，
键、值以及通过事务句柄对注册表进行的其他修改都不会被外部应用程序使用的非事务型API看到。此外，事务是相互隔离的，在最终提交之前，一个事务中进行
的修改对其他事务或事务外部不可见。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 在发生冲突的情况下，非事务型写入方会终止事务。举例来说，如果在一个事务中创建了某个值，但随后在该事务依然活跃的情况下，一个非事务型写入方试图在同一个键下创建一个值，那么非事务型操作将会成功，发生冲突的事务中的所有操作都会被忽略。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">TxR资源管理器实现的隔离级别（ACID
	<sup><img width="11" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="ACID是指数据库事务能够正确执行所要满足的四个要素：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。——译者注" title="ACID是指数据库事务能够正确执行所要满足的四个要素：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。——译者注" class="epub-footnote"></sup>中
的“I”）为“读取-提交”，这意味着一旦提交，之后的改动会立即对其他读取方（无论是事务型或非事务型）可见。对熟悉数据库事务的人来说，这种机制很重
要，因为数据库的隔离级别为“可预测-读取”（或按照数据库领域的称呼为“游标-稳定性”）。对于“可预测-读取”隔离级别，如果读取了事务中的一个值，
则后续的读取将返回相同的数据。“读取-提交”无法提供这样的保证，而这造成的影响是：注册表事务不能用于对注册表值进行“原子性”的增减操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了对注册表进行永久性更
改，使用事务句柄的应用程序必须调用KTM的CommitTransaction函数（如果应用程序需要撤销改动，例如处于失败路径时，此时可调用
RollbackTransaction API）。随后这些改动就可以通过常规的注册表API变得可见。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 如果用CreateTransaction创建的事务句柄在事务提交之前被关闭（并且没有其他句柄打开这个事务），则系统将回滚该事务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了借助KTM对CLFS
的支持，TxR还会将自己的内部日志文件存储在%SystemRoot%\System32\Config\Txr文件夹中，这些文件的扩展名
为.regtrans-ms，默认会被隐藏。有一个全局注册表资源管理器（RM）为启动时挂载的配置单元提供服务。每个显式挂载的配置单元都会创建一个
RM。对于使用注册表事务的应用程序，RM的创建过程是透明的，因为KTM保证了参与同一事务的所有RM会通过一个两阶段的提交/忽略协议进行协调。对于
全局注册表RM，CLFS日志文件会被存储到System32\Config\Txr目录下；其他配置单元的日志文件会与配置单元存储在一起（同一个目录
下）。这些文件都是隐藏的，并遵循相同的命名约定，都使用了.regtrans-ms扩展名。日志文件的名称会使用对应的配置单元的名称作为前缀。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_120" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>1</b><b>.</b><b>7</b><b> </b><b>监</b><b>控</b><b>注</b><b>册</b><b>表</b><b>活</b><b>动</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于系统和应用程序在很大
程度上依赖配置设置来指导自己的行为，系统和应用程序的故障有时由注册表数据或安全设置的变化导致。当系统或应用程序无法读取自己假定总能访问的设置时，
可能就无法正常运行，显示出难以判断根本原因的错误信息，甚至直接崩溃。如果不了解出现故障的系统或应用程序是如何访问注册表的，那么基本就无法确定到底
是哪些注册表键或值存在错误配置。在这种情况下，Windows 
Sysinternals（https://docs.microsoft.com/sysinternals/）的进程监视器（Process 
Monitor）工具也许可以告诉我们答案。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">进程监视器可以帮助我们在
有注册表活动时对其进行实时监控。对于每个注册表的访问，进程监视器会显示执行访问的进程、时间、类型以及访问结果，此外，还会显示访问时的线程堆栈。借
助这些信息，我们可以了解应用程序和系统到底是如何依赖注册表的，了解应用程序和系统会将配置设置存储在哪里，并对因丢失注册表键或值造成的应用程序故障
进行排错。进程监视器还包含高级过滤和强调显示功能，借此我们可以更细致地查看与特定的键或值，或者与特定进程有关的活动。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_121" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>1</b><b>.</b><b>8</b><b> </b><b>进</b><b>程</b><b>监</b><b>视</b><b>器</b><b>的</b><b>内</b><b>部</b><b>原</b><b>理</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">进程监视器依赖一个设备驱动程序，这个驱动程序是在它运行时从自己的可执行映像中提取并启动的。因此，首次执行该工具时要求账户具备加载驱动程序和调试特权，同一个启动会话中的后续执行只需要调试特权，因为一旦加载后，该驱动程序就会驻留。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>闲</b><b>置</b><b>系</b><b>统</b><b>的</b><b>注</b><b>册</b><b>表</b><b>活</b><b>动</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">由
于应用程序可以由注册表实现的RegNotifyChangeKey函数来请求在注册表发生变化后接收通知，而不需要进行轮询，因此，在闲置系统上启动进
程监视器后，应该不会看到对同一个注册表键或值进行的重复性访问。如果遇到这样的活动，往往意味着应用程序的质量不高，这也会对系统的整体性能产生负面影
响。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请运行进程监视器，确保工具栏中只启用了“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>显</b><b>示</b><b>注</b><b>册</b><b>表</b><b>活</b><b>动</b></span>”选项（这是为了消除文件系统、网络以及进程或线程产生的噪音），随后等待几秒钟并查看输出的日志，看看能否找到轮询行为。用鼠标右击轮询行为对应的输出项，随后从右键菜单中选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>进</b><b>程</b><b>属</b><b>性</b></span>”即可查看执行该活动进程的详细信息。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>使</b><b>用</b><b>进</b><b>程</b><b>监</b><b>视</b><b>器</b><b>定</b><b>位</b><b>应</b><b>用</b><b>程</b><b>序</b><b>的</b><b>注</b><b>册</b><b>表</b><b>设</b><b>置</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
某些排错场景中，我们可能需要判断系统或应用程序将特定设置保存在注册表中的哪个位置。本实验将使用进程监视器来找出记事本设置的保存位置。与大部分
Windows应用程序类似，记事本执行过程中会存储用户首选项（如自动换行模式、字体和字号、窗口位置）。通过使用进程监视器在记事本读/写设置时进行
实时监视，即可找出存储这些设置的注册表键。请根据下列步骤执行操作。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">1）让记事本保存一个我们可以在进程监视器记录中轻松搜索的设置。例如可以运行记事本，将字体设置为Times New Roman，然后退出记事本。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">2）运行进程监视器。打开过滤器对话框和Process Name过滤器，随后输入notepad.exe作为要匹配的字符串。点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>添</b><b>加</b></span>”按钮加以确认。该操作会让进程监视器记录notepad.exe进程的活动。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">3）再次运行记事本，启动完成后停止进程监视器的事件捕获，为此请在进程监视器的“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>文</b><b>件</b></span>”菜单中点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>捕</b><b>获</b><b>事</b><b>件</b></span>”以将其关闭。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">4）滚动至结果日志的第一行并将其选中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">5）按下Ctrl+F，打开“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>查</b><b>找</b></span>”对话框，搜索times new。进程监视器会强调显示类似下图所示的一行内容，这表示记事本在从注册表读取字体值。这一行上下的其他操作则与记事本的其他设置有关。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/c0f01d0eb4a2f4adbea287a940af1eea.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">6）右击突出显示的行并点击Jump To。进程监视器会启动注册表编辑器（如果尚未启动的话）并直接打开，然后选中记事本引用的这个注册表值。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_122" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>1</b><b>.</b><b>9</b><b> </b><b>注</b><b>册</b><b>表</b><b>的</b><b>内</b><b>部</b><b>原</b><b>理</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">本节介绍了配置管理器（实
现注册表的执行体子系统）用磁盘上的文件组织注册表的方法。下面我们将讨论配置管理器是如何在应用程序和操作系统的其他组件读取和更改注册表键与值的过程
中管理注册表的。此外，我们还将讨论配置管理器通过怎样的机制尽可能地确保注册表始终处于可恢复状态（即便在修改注册表的过程中系统已崩溃）。</span></p>
</div><div class="header2"><h3><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>配</b><b>置</b><b>单</b><b>元</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">注册表在磁盘上并不是一个
巨大的文件，而是一系列称为配置单元（hive）的离散文件。每个配置单元包含一个注册表树，有一个键作为根，即树的起点。子键及其值位于根的下方。很多
人会认为注册表编辑器中显示的每个根键可以看成相应配置单元的根键，但事实并非如此。表10-5列出了注册表配置单元及其在磁盘上对应的文件名称。除了用
户配置文件外，所有配置单元的路径名都被编码在配置管理器中。配置管理器加载配置单元（包括系统配置文件）时，会将每个配置单元的路径记录到
HKLM\SYSTEM\CurrentControlSet\Control\Hivelist子键的值中，如果卸载了一个配置单元，则会删除对应的路
径。它还会创建根键，将配置单元链接在一起构建出我们熟悉的注册表编辑器所显示的注册表结构。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表10-5 与注册表中路径对应的磁盘文件</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/96e90942c1430ae62290eb32eba761c1.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/9d8c596d8965cd69a2b99d2b8594897b.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">大家可能注意到，表
10-5中列出的一些配置单元是易失的，没有相关的文件。系统完全在内存中创建并管理这些配置单元，因此这些配置单元是临时性的。系统会在自己每次启动时
创建易失性配置单元。例如HKLM\HARDWARE配置单元就是易失的，其中存储了与物理设备有关的信息以及为设备分配的资源。系统每次启动时都会检测
硬件并分配资源，因此不将这些信息存储到磁盘上也是一种合理的做法。另外还请注意，表10-5中的最后三项是虚拟化的配置单元。从Windows 
10周年更新开始，NT内核已经支持虚拟化注册表（Virtualized 
Registry，VReg），这是为了对Helium容器中运行的Centennial打包应用程序提供支持。每当用户运行Centennial应用程
序（例如现代版的Skype）时，系统都会挂载所需的包配置文件。Centennial应用程序和现代应用程序模型的详细信息请参阅第8章。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>手</b><b>动</b><b>加</b><b>载</b><b>和</b><b>卸</b><b>载</b><b>配</b><b>置</b><b>单</b><b>元</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">Regedit
可以加载我们通过注册表编辑器的“文件”菜单访问的配置单元。这种功能在排错时会非常有用，我们可以借此查看或编辑无法启动的系统或备份介质中的配置单
元。在这个实验中，我们将使用Regedit加载Windows安装程序在系统安装过程中创建的HKLM\SYSTEM配置单元。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">1）仅HKLM或HKU下的配置单元可以这样加载，因此请打开Regedit，选择HKLM，随后从注册表编辑器的“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>文</b><b>件</b></span>”菜单中选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>加</b><b>载</b><b>配</b><b>置</b><b>单</b><b>元</b></span>”。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">2）在加载配置单元对话框中打开%SystemRoot%\System32\Config\RegBack目录，选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>系</b><b>统</b></span>”并打开。一些较新的系统可能在RegBack文件夹中未存储任何文件，在这种情况下，可以尝试着打开Config文件夹下的ELAM配置单元来进行后续实验。被询问时，输入Test作为要加载到的键的名称。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">3）打开新建的HKLM\Test键，并浏览该配置单元的内容。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">4）打开HKLM\SYSTEM\CurrentControlSet\Control\Hivelist并找到\Registry\Machine\Test这个项，这证明了配置管理器是如何在Hivelistkey中列出已加载的配置单元的。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">5）选择HKLM\Test并从注册表编辑器的“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>文</b><b>件</b></span>”菜单中选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>卸</b><b>载</b><b>配</b><b>置</b><b>单</b><b>元</b></span>”，将该配置单元卸载。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>配</b><b>置</b><b>单</b><b>元</b><b>的</b><b>大</b><b>小</b><b>限</b><b>制</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在一些情况下，配置单元的
大小是有限的。例如，Windows会对HKLM\SYSTEM配置单元的大小进行一些限制。这是因为，如果未启用虚拟内存分页，Winload会在启动
过程即将开始时将整个HKLM\SYSTEM配置单元读入物理内存。Winload还会将Ntoskrnl和启动设备驱动程序载入物理内存，因此必须限制
分配给HKLM\SYSTEM的物理内存数量（有关Winload在系统启动过程中所起作用的详细信息请参阅第12章）。在32位系统中，Winload
允许的配置单元最大为400MB，或系统中物理内存总量的一半，以较小者为准。64位系统中的大小下限为2GB。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>启</b><b>动</b><b>过</b><b>程</b><b>和</b><b>R</b><b>e</b><b>g</b><b>i</b><b>s</b><b>t</b><b>r</b><b>y</b><b>进</b><b>程</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在Windows 
8.1之前，NT内核使用分页池来存储每个已加载配置单元文件的内容。在系统关机前，大部分已载入系统的配置单元都会留在内存中（例如SOFTWARE配
置单元，它由会话管理器在系统启动的阶段1完成后加载，有时候大小可能达到数百MB）。如果在一定时间内未被访问，分页池内存可能会被内存管理器的平衡集
管理器换出（详见卷1第5章）。这意味着配置文件中未使用的部分无法长时间保留在工作集中。已提交的虚拟内存由页面文件支持，并且需要增加系统提交量，从
而减少可用于其他目的的虚拟内存总量。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了解决这个问题，
Windows 10的2018年4月更新（RS4）引入了对节支持的注册表（section-backed 
registry）。在NT内核初始化的阶段1，配置管理器启动例程会初始化注册表的多个组件：缓存、工作线程、事务、回调支持等。随后它会创建Key对
象类型，并且在加载所需配置单元前还会创建Registry进程。Registry进程是一种完全受保护（受到与SYSTEM进程相同程度的保护：
WinSystem级别）的最小化进程，配置管理器用它来执行打开的注册表配置单元上的大部分I/O操作。在初始化时，配置管理器会将预加载的配置单元映
射至Registry进程，不过这些预加载的配置单元（SYSTEM和ELAM）会继续留在非分页内存中（使用内核地址进行映射）。在启动过程的后续阶
段，会话管理器会调用NtInitializeRegistry系统调用来加载SOFTWARE配置单元。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这将创建一个由
SOFTWARE配置单元文件支持的节对象：配置管理器会将该文件分为2MB大小的块，并在Registry进程的用户模式地址空间中为每个块创建一个保
留映射（使用NtMapViewOfSection原生API。保留映射可通过有效的VAD进行跟踪，但并不分配实际页面。详见卷1第5章）。每个2MB
的视图都受到只读保护。当配置管理器需要从配置单元读取某些数据时，会访问该视图的页面并产生一个访问障碍，这会导致内存管理器将共享页面带入内存。这
时，系统工作集的计费会增加，但提交计费不会增加（页面由配置单元文件本身支持，而非由页面文件支持）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在初始化时，配置管理器会
将Registry进程的工作集限制设置为64MB。这意味着在内存压力高的情况下，可以保证注册表使用的工作集大小不会超过64MB。每当应用程序或系
统使用API访问注册表时，配置管理器都会附加至Registry进程地址空间，执行所需工作，随后返回结果。配置管理器并不总是需要切换地址空间：当应
用程序想要访问的注册表键已经位于缓存中（存在Key控制块）时，配置管理器会跳过附加进程，直接返回缓存的数据。Registry进程主要用于针对底层
配置单元文件执行I/O操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当系统写入或修改配置单元
中存储的注册表键和值时，需要执行“写入时复制”操作（首先将2MB视图的内存保护改为PAGE_WRITECOPY）。对标记为“写入时复制”的内存进
行写操作，这会创建新的私有页面并增加系统的提交计费。在请求进行注册表更新后，系统会立即将新项写入配置单元的日志，但对实际页面所属的主要配置单元文
件执行的写入操作会被延迟进行。与每个常规页面一样，配置文件的“脏”页面可以换出到磁盘上。这些页面会在配置文件卸载时写入主配置单元文件中，或由
Reconciler写入：这是配置管理器的一个延迟写入线程，默认每小时运行一次（该时间可通过
HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Configuration 
Manager\RegistryLazyReconcileInterval注册表值进行修改）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">重组和增量日志的详情请参阅“增量日志”一节。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>注</b><b>册</b><b>表</b><b>符</b><b>号</b><b>链</b><b>接</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">一种名为注册表符号链接的
特殊类型键使得配置管理器可以将键链接在一起来组织注册表。符号链接这种键可以将配置管理器重定向到另一个键。HKLM\SAM就是一个符号链接键，可指
向SAM配置单元根下的某个键。要创建符号链接，可为RegCreateKey或RegCreateKeyEx指定REG_CREATE_LINK参数。
在内部，配置管理器会创建一个名为SymbolicLinkValue的REG_LINK值，其中包含了到目标键的路径。由于该值是REG_LINK而非
REG_SZ，因此在注册表编辑器中是不可见的，不过会包含在磁盘上的注册表配置单元文件中。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>配</b><b>置</b><b>单</b><b>元</b><b>的</b><b>句</b><b>柄</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">配
置管理器会使用内核句柄表（详见第8章）来打开配置单元，这样即可从任意进程上下文访问配置单元了。相比使用驱动程序或执行体组件从System进程访问
必须从用户进程保护的句柄，使用内核句柄表是一种高效的替代方式。我们可以用管理员身份启动Process 
Explorer来查看配置单元句柄，它们会显示为已在System进程中打开。选中System进程，随后从View菜单的Lower Pane 
View菜单项中选择Handles，按照句柄类型排序，并滚动显示的内容，直到看到配置单元文件，如下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/032414d62a74e971bd0b99eaeef0d53f.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>配</b><b>置</b><b>单</b><b>元</b><b>的</b><b>结</b><b>构</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">配置管理器在逻辑上将配置单元划分为名为“块”的分配单元，具体方式与文件系统将磁盘划分为簇的方式类似。按照定义，注册表块的大小为4096字节（4KB）。当新数据扩展到配置单元时，配置单元总是会以块为单位逐渐增大。配置单元的第一个块也称为基块。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">基块包含有关该配置单元的
全局信息：一个将文件识别为配置单元所需的签名（regf）、两个更新序列号、一个代表配置单元最后一次执行写操作时间的时间戳、与Winload执行注
册表修复或恢复操作有关的信息、配置单元格式版本号、校验值以及配置单元文件内部文件名（如
\Device\HarddiskVolume1\WINDOWS\SYSTEM32\CONFIG\SAM）。下文介绍向配置单元中写入数据的方法时，
还将进一步介绍这两个更新序列号和时间戳的重要性。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">配置单元格式版本号决定了
配置单元中的数据格式。配置管理器使用的配置单元格式为1.5版，该版本支持大数值（超过1MB的值）和改进的搜索功能（不再需要缓存名称的前四个字符，
可以使用完整名称的哈希值来减少碰撞）。此外，为支持容器，配置管理器还增加了对差异化配置单元（differencing 
hive）的支持。差异化配置单元使用的配置单元格式为1.6版。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows会将配置单
元中存储的注册表数据组织到一种名为单元格（cell）的容器中。单元格可以包含一个键、一个值、一个安全描述符、一个子键列表或一个键值列表。单元格数
据开头处的一个4字节的字符标记描述了作为签名的数据类型。表10-6详细介绍了每个单元格的数据类型。单元格的头部是一种字段，以“1”的补集
（complement）指定了单元格的大小（在CM_结构中不存在）。当一个单元格联结（join）到配置单元，而配置单元必须扩展才能包含该单元格
时，系统会创建一种名为Bin的分配单位。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表10-6 单元格的数据类型</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/6b5010d8598ae7bfbbdaf9ac23af0f03.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Bin是新单元格的大小，会取整到下一个块或页的边界（以较高者为准）。系统认为，在单元格末端和Bin末端之间的任何空间都是可用空间，可以分配给其他单元格。Bin也有头部，其中包含了签名、hbin，以及一个记录Bin的配置单元文件偏移量和Bin大小的字段。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通过用Bin代替单元格来
跟踪注册表的活动部分，Windows可最大限度地减少一些管理工作。例如，系统分配和解除分配Bin的频率就远低于针对单元格执行的此类操作，这样配置
管理器可以更高效地管理内存。当配置管理器将一个注册表配置单元读入内存时，会读取整个配置单元（包括空的Bin），但随后配置管理器可以选择丢弃空
Bin。当系统在配置单元中添加或删除单元格时，配置单元可以包含散布在活跃Bin中的空Bin。这种情况与系统在磁盘上创建和删除文件后产生的磁盘碎片
较为类似。当一个Bin成为空Bin后，配置管理器会将连续的空Bin连接在一起，尽可能形成一个足够大的连续空Bin。配置管理器还会将连续的已删除单
元格连接在一起形成一个更大的可用单元格（配置管理器只有在配置单元末端的Bin空闲后才会收缩配置单元。我们可以使用Windows的
RegSaveKey和RegReplaceKey函数备份并还原注册表，借此压缩注册表，Windows备份工具也用到了这些函数。此外，系统会在配置
单元初始化时使用下文介绍的重组算法压缩Bin）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">用于创建配置单元结构的链
接也称单元格索引。单元格索引等于一个单元格在配置文件中的偏移量减去基块大小后获得的值。因此单元格索引类似于从一个单元格到另一个单元格的指针，配置
管理器会将其理解为相对于配置单元起始位置的相对位置。例如，如表10-6所示，描述键的单元格中包含了一个指定其父键单元格索引的字段，子键的单元格索
引指定了描述从属于特定子键的子键单元格，子键列表单元格包含的单元格索引列表引用了子键的键单元格。因此，举例来说，如果希望定位子键A的键单元格，其
父键为键B，必须首先使用B键单元格中的子键列表单元格索引来定位包含B键的子键列表单元格，随后使用子键列表单元格中的单元格索引列表来定位B键的每个
子键单元格。对于每个子键单元格，我们可以检查键单元格中存储的子键名称是否与自己希望找到的键（本例中为子键A）相匹配。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">单元格、Bin、块之间的
差异可能会让人困惑，那么我们通过一个简单的注册表配置单元布局来更好地了解它们之间的差异吧。图10-3所示的注册表配置单元的内部结构包含一个基块和
两个Bin。第一个Bin是空的，第二个Bin包含多个单元格。从逻辑上来说，该配置单元只包含两个键：根键Root和Root的一个子键Sub 
Key。Root有两个值，即Val 1和Val 
2。子键列表单元格可用于定位根键的子键，而值列表单元格可以定位根键的值。第二个Bin中的可用空间是空单元格。图10-3并未展示这两个键的安全单元
格，但它在配置单元中是实际存在的。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e829b306fd45290cc6e83ccab59c1a32.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-3 注册表配置单元的内部结构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了优化值和子键的搜索工
作，配置管理器会按照字母表顺序对子键列表单元格进行排序。随后配置管理器即可执行二叉搜索（binary 
search），查找子键列表中的特定子键。配置管理器会检查列表中间位置的子键，如果所查找的子键名称按字母表顺序位于子键列表中间位置之前，那么配置
管理器就会知道目标子键应该在子键列表的前半部分，否则就在子键列表的后半部分。这种拆分过程会持续进行，直到配置管理器最终找到目标子键或没有任何收
获。不过值列表单元格并未排序，因此新值总是会被加入列表的末尾。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>单</b><b>元</b><b>格</b><b>映</b><b>射</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果配置单元永不增大，配
置管理器就可以完全在内存中的配置单元里执行所有注册表管理工作，就像处理普通文件那样。只要提供一个单元格索引，配置管理器就可以将单元格索引（也就是
配置单元文件的偏移量）与内存中配置单元映像的基址相加，得到任何一个单元格在内存中的位置。在系统启动的早期阶段，Winload就是通过这样的方式处
理SYSTEM配置单元的：Winload将整个SYSTEM配置单元以只读配置单元的形式读入内存，并将内存中的配置单元映像基址与单元格索引相加，确
定不同单元格的位置。然而，随着存入新的键和值，配置单元的大小会增长，这意味着系统必须分配新的保留视图并扩展配置单元文件，这样才能存储新增加的键和
值所对应的新Bin。在内存中保存注册表数据的这种保留视图未必是连续的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了解决在不连续内存地址
空间中引用内存中配置单元文件数据的问题，配置管理器采取了类似于Windows内存管理器将虚拟地址空间映射至物理内存地址的策略。虽然单元格索引只是
配置单元文件的偏移量，但配置管理器采用了一种如图10-4所示的两级方案，借此通过Registry进程中的映射视图来表示配置单元。该方案使用单元格
索引（即配置单元文件偏移量）作为输入，可输出单元格索引所在块在内存中的地址，以及单元格所在块在内存中的地址。一个Bin可以包含一个或多个块，而配
置单元是在Bin中增大的，所以Windows总是用一个连续的内存区域表示Bin。因此，一个Bin中的所有块都会在同一个2MB的配置单元映射视图
中。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a38a8ba2c0e0d010f5cdb0ed39e3b63b.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-4 单元格索引的结构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了实现这种映射，配置管
理器在逻辑上将一个单元格索引划分为多个字段，具体方法与内存管理器将一个虚拟地址划分为多个字段的方式类似。Windows将单元格索引的第一个字段理
解为指向配置单元的单元格映射目录索引。单元格映射目录中包含1024项，每个项都指向一个包含512个映射项的单元格映射表。单元格映射表中的每个项都
由单元格索引中的第二个字段指定，而这第二个项可用于定位单元格的Bin和块的内存地址。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在这个转换过程的最后一步，配置管理器会将单元格索引的最后一个字段理解为已确定块的偏移量，这样即可精准定位内存中的单元格。当初始化配置单元时，配置管理器会动态创建映射表，为配置单元中的每个块指定一个映射项，并根据配置单元的大小变化向单元格目录中添加或删除表。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_123" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>1</b><b>.</b><b>1</b><b>0</b><b> </b><b>配</b><b>置</b><b>单</b><b>元</b><b>重</b><b>组</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">与真正的文件系统类似，注
册表配置单元也会遭遇碎片化问题：当Bin中的单元格被释放，但无法继续以连续方式将多个闲置单元格合并到一起时，会导致多个Bin中出现碎片化的小块可
用空间。如果没有足够多的连续可用空间来保存新单元格，就需要在配置单元文件的末尾附加新的Bin，而之前遗留的碎片化Bin将无法重复利用。为了解决这
个问题，从Windows 
8.1开始，每当配置管理器挂载一个配置单元文件时，都会检查是否需要对该配置单元执行重组操作。配置管理器还会在配置单元的基块中记录上次重组的时间。
如果配置单元具备有效的日志文件（即非易失性配置单元），并且距离上次重组已经超过7天，那么将立即开始重组操作。重组的目的有两个：缩减配置单元的文件
大小和优化配置单元。重组时，首先会新建一个与原配置单元文件完全一致，但不包含任何单元格的空配置单元，随后用新建的“克隆”配置单元复制原始配置单元
的根键以及根键的所有值（但不复制子键）。接下来会通过复杂的算法分析所有子键，实际上，在常规活动中，配置管理器会记录特定键是否被访问过，如果被访
问，则会在它的键单元格中存储一个代表操作系统当前运行时阶段（“启动”或“常规”）的索引。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">重组算法首先会复制操作系
统常规执行阶段访问过的键，随后复制启动阶段访问过的键，最后复制（自上次重组后）完全未被访问过的键。该操作会将所有不同的键分组到配置单元文件中连续
的Bin内。按照定义，复制操作会产生一个未碎片化的配置单元文件（每个单元格都在Bin中以连续方式存储，新Bin始终附加到文件末尾）。此外，新配置
单元还有一个特点：用足够大的连续块分别存储“热的”和“冷的”键。这也使得操作系统在启动和正常运行期间可以更快速地从注册表中读取数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">重组算法会重置所有新复制
单元格的访问状态。这样就可以从一个中性状态重新开始跟踪配置单元中每个键的使用情况。7天后的下一次重组将使用新获得的使用情况统计信息。如图10-5
所示，配置管理器会将重组周期的结果保存到HKLM\SYSTEM\CurrentControlSet\Control\Session 
Manager\Configuration 
Manager\Defrag注册表键中。在截图范例中，上次重组进行于2019年4月10日，节省了10MB的碎片化配置文件空间。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/fadfe9c1a7816f9759a914d3f74fbc15.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-5 注册表重组数据</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_124" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>1</b><b>.</b><b>1</b><b>1</b><b> </b><b>注</b><b>册</b><b>表</b><b>的</b><b>命</b><b>名</b><b>空</b><b>间</b><b>和</b><b>操</b><b>作</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">为将注册表的命名空间与内
核的常规命名空间集成，配置管理器定义了一个键对象类型。配置管理器在Windows命名空间的根部插入了一个名为Registry的键对象，以此作为注
册表的入口点。Regedit会将键的名称显示为HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet的形式，但
Windows子系统会将这样的名称转换为其对象命名空间的形式（如
\Registry\Machine\System\CurrentControlSet）。当Windows对象管理器解析该名称时，首先遇到的是以
Registry为名的键对象，随后会将名称的其余部分交给配置管理器处理。配置管理器接管名称解析工作，通过查找自己的内部配置单元树找到所需的键或
值。在介绍典型的注册表操作控制流之前，需要先谈谈键对象和键控制块。当应用程序打开或创建注册表键时，对象管理器会提供一个句柄，应用程序可借此引用
键。该句柄对应了配置管理器在对象管理器帮助下分配的键对象。借助对象管理器为对象提供的支持，配置管理器即可充分使用对象管理器所提供的安全性和引用计
数器功能。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于每个打开的注册表键，
配置管理器还会分配一个键控制块。键控制块存储了键的名称，以及控制块指向的键节点的单元格索引，此外还包含了一个标记，该标记决定了当键的最后一个句柄
关闭后，配置管理器是否需要删除键控制块指向的键单元格。Windows将所有键控制块保存在一个哈希表中，借此即可按照名称快速搜索现有的键控制块。会
有一个键对象指向对应的键控制块，因此如果两个应用程序打开同一个注册表键，每个应用程序都会收到一个键对象，这两个键对象都指向同一个键控制块。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当应用程序打开一个现有的
注册表键，应用程序在调用对象管理器名称解析例程的注册表API中指定键的名称时，控制流就开始运行了。对象管理器在命名空间中找到配置管理器的注册表键
对象后，会将名称路径传递给配置管理器。配置管理器在键控制块哈希表中查找，如果找到相关的键控制块，就无须执行后续的工作（附加到Registry进
程）了；否则查找操作会为配置管理器提供与搜索的键最接近的键控制块，并附加到Registry进程中，使用内存中的配置单元数据结构继续搜索键和子键，
借此查找特定的键。如果找到键单元格，配置管理器还会搜索键控制块树，以确定该键是否已（被同一个或其他应用程序）打开。搜索例程通过优化，始终会从已打
开的键控制块最接近的上一级键控制块开始搜索。举例来说，如果某应用程序要打开\Registry\Machine\Key1\Subkey2，而
\Registry\Machine已经打开，那么解析例程将使用\Registry\Machine的键控制块作为起点。如果该键已打开，配置管理器会
增大现有键控制块的引用计数。如果键尚未打开，配置管理器会分配一个新的键控制块并将其插入树中。随后配置管理器会分配一个键对象，将该键对象指向键控制
块，断开附加的Registry进程，并将控制权返回给对象管理器，对象管理器向应用程序返回一个句柄。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当应用程序新建注册表键
时，配置管理器首先会为父键新建一个单元格。随后，配置管理器会在新键将要创建到的配置单元中搜索可用单元格列表，以确定现有单元格是否足够大，可以保存
新的键单元格。如果没有足够大的可用单元格，配置管理器会分配一个新的Bin来保存单元格，并将该Bin末尾的所有空间加入可用单元格列表。新建的键单元
格会被填充相关信息，包括键的名称，此外配置管理器还会将键单元格添加到父键的子键列表单元格中的子键列表内。最后，系统将父单元格的单元格索引存储到新
子键的键单元格中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">配置管理器使用键控制块的
引用计数器决定何时删除键控制块。对于一个键控制块，当引用了其中一个键的所有句柄都关闭后，引用计数器归零，意味着该键控制块已经不需要了。如果一个调
用API删除该键的应用程序设置了删除标记，配置管理器即可从键所在的配置单元中删除相关键，因为它知道该键已经不被任何应用程序打开。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>键</b><b>控</b><b>制</b><b>块</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以使用内核调试器的!reg openkeys命令列出系统中关联的所有键控制块，或者使用!reg querykey命令查看已打开的特定键的键控制块：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0: kd&gt; !reg querykey \Registry\machine\software\microsoft </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Found KCB = ffffae08c156ae60 :: \REGISTRY\MACHINE\SOFTWARE\MICROSOFT </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Hive         ffffae08c03b0000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">KeyNode      00000225e8c3475c </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">[SubKeyAddr]         [SubKeyName] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">225e8d23e64          .NETFramework </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">225e8d24074          AccountsControl </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">225e8d240d4          Active Setup </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">225ec530f54          ActiveSync </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">225e8d241d4          Ads </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">225e8d2422c          Advanced INF Setup </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">225e8d24294          ALG </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">225e8d242ec          AllUserInstallAgent </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">225e8d24354          AMSI </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">225e8d243f4          Analog </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">225e8d2448c          AppServiceProtocols </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">225ec661f4c          AppV </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">225e8d2451c          Assistance </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">225e8d2458c          AuthHost </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">... </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后即可使用!reg kcb命令检查报告的键控制块：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">kd&gt; !reg kcb ffffae08c156ae60 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Key              : \REGISTRY\MACHINE\SOFTWARE\MICROSOFT </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">RefCount         : 1f </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">flags            : CompressedName, Stable </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Extflags         : </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Parent           : 0xe1997368 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">KeyHive          : 0xe1c8a768 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">KeyCell          : 0x64e598 [cell index] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">TotalLevels      : 4 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">DelayedCloseIndex: 2048 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">MaxNameLen       : 0x3c </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">MaxValueNameLen  : 0x0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">MaxValueDataLen  : 0x0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">LastWriteTime    : 0x1c42501:0x7eb6d470 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">KeyBodyListHead  : 0xe1034d70 0xe1034d70 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">SubKeyCount      : 137</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ValueCache.Count : 0</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">KCBLock          : 0xe1034d40</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">KeyLock          : 0xe1034d40</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">上述Flag字段代表名称以压缩的形式存储，SubKeyCount字段显示该键有137个子键。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_125" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>1</b><b>.</b><b>1</b><b>2</b><b> </b><b>稳</b><b>定</b><b>存</b><b>储</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">为确保非易失性注册表配置
单元（有磁盘文件的配置单元）始终处于可恢复的状态，配置管理器使用了日志配置单元。每个非易失配置单元都有相关的日志配置单元，这是一种隐藏文件，名称
与配置单元相同，但扩展名为logN。为了实现更进一步的保障，配置管理器使用了一种双重日志方案。日志文件可能有两个：.log1和.log2，如果出
于任何原因，导致.log1虽然被写入但在向主日志文件写入脏数据时出现了故障，下一次进行刷新时，就会用积累的脏数据切换至.log2。如果这次依然失
败了，积累的脏数据（.log1中的数据以及两次操作之间变脏的其他数据）会被保存到.log2中。因此再下一次将继续使用.log1，直到对主日志文件
成功执行了写入操作。如果未出现任何失败，那么将只使用.log1。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">举例来说，查
看%SystemRoot%\System32\Config目录（需要在文件夹选项中选中“显示隐藏的文件和文件夹”选项，并取消选择“隐藏受保护的操
作系统文件”选项，否则将看不到任何文件），将会在这里看到System.log1、Sam.log1以及其他.log1和.log2文件。当配置单元初
始化时，配置管理器会分配一个位数组，其中的每位代表配置单元中一个512字节的部分（也可称为“扇区”）。这个数组也可以叫脏扇区数组，因为该数组中设
置的位意味着系统已修改了内存中配置单元对应的扇区，必须将扇区回写到配置单元文件中（未设置该位则意味着相应扇区为最新状态，与内存中的配置单元内容一
致）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当新建键或值或修改现有键
或值时，配置管理器会记录主配置单元中发生改动的扇区，并将其写入配置单元在内存中的脏扇区数组。随后，配置管理器会安排一次延迟刷新操作，或者叫日志同
步操作。配置单元惰性写入器这个系统线程会在发出请求一分钟后被唤醒，以便同步配置单元的日志。它会从脏扇区数组的有效位引用的内存中为配置单元扇区生成
一个新的日志项，并将其写入磁盘上的配置单元日志文件。与此同时，系统会刷新从配置单元同步请求发出到配置单元同步实际进行期间产生的所有注册表改动。惰
性写入器会使用低优先级I/O将脏扇区写入磁盘上的日志文件（而非写入主配置单元）。在进行配置单元同步后，1分钟内将不会再进行下一次配置单元同步。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果惰性写入器只是简单地
将配置单元的所有脏扇区写入配置单元文件，而系统在操作过程中崩溃了，配置单元文件可能会处于不一致（损坏）并且不可恢复的状态。为防止出现此类情况，惰
性写入器首先会将配置单元的脏扇区数组以及所有脏扇区转储到配置单元的日志文件中，并在必要时增大日志文件的大小。配置单元的基块包含两个序列号。当进行
首次刷新操作（而非后续刷新操作）时，配置管理器会更新其中的一个序列号，使其大于另一个序列号。因此，如果系统在对配置单元执行写入操作时崩溃，下次重
启动时，配置管理器会注意到配置单元基块中的这两个序列号不匹配，此时就可以使用配置单元日志文件中的脏扇区更新配置单元，使配置单元的状态实现正确
的“前进”。这样一来，配置单元就可以处于最新且一致的状态了。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在将日志项写入配置单元的
日志后，惰性刷新器会清除脏扇区数组中对应的有效位，但实际上会将这些位插入另一个重要的向量——未协调数组（unreconciled 
array）中。配置管理器可以使用这个数组了解要将哪些日志项写入主配置单元。借助对新增的增量日志（见下文）的支持，主配置单元文件很少需要在操作系
统正常运行的过程中写入。配置单元的同步协议（与日志同步并非一回事）作为一种算法，可将所有内存和日志中的注册表改动写入主配置单元文件，并为配置单元
设置两个序列号。实际上根据下文可知，这是一种开销很高的多阶段操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">协调器
（reconciler）是另一种类型的惰性写入器系统线程，它每小时唤醒一次，会冻结日志，将所有脏日志项写入主配置单元文件。在脏扇区和未协调数组的
帮助下，协调算法可以知道内存中配置单元的哪些部分需要写入主文件。不过协调操作很少发生。如果系统崩溃，借助已经写入日志文件的日志项，配置管理器本就
具备了重建配置单元所需的全部信息。注册表协调操作每小时只进行一次（或会在日志的大小落后于某个阈值时进行，这取决于配置文件所在存储卷的大小），因此
可大幅改善性能。只有在日志刷新操作期间，配置单元才可能丢失某些数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">请注意，协调操作并不会更
新主配置单元文件中的第二个序列号。这两个序列号只有在“验证”阶段（另一种形式的配置单元刷新操作）才会被更新为相等的值，而只有在配置单元被卸载（应
用程序调用RegUnloadKey 
API）、系统关机时，或配置文件被首次加载时才会进行这种验证。这意味着在操作系统的大部分生命周期中，主注册表配置单元都处于脏状态，需要借助日志文
件才能正确读取。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows启动加载器
也包含一些与注册表可靠性有关的代码。例如，它可以在内核加载前解析System.log文件，并通过修复解决一致性问题。此外，在某些配置单元损坏的情
况下（例如基块、Bin或单元格包含的数据无法通过一致性检查），配置管理器可以重新初始化损坏的数据结构，甚至在该过程中删除某些子键，随后继续正常运
作。如果必须通过自愈操作进行还原，则会弹出系统错误对话框以提醒用户注意。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>增</b><b>量</b><b>日</b><b>志</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，Windows 8.1对配置单元同步算法的性能进行了大幅改进，而这要归功于增量日志（Incremental logging）功能。通常来说，配置单元文件中的单元格可处于下列四种状态之一。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>干</b><b>净</b></span>。单元格数据位于配置单元的主文件中且未被修改。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>脏</b></span>。单元格数据已修改但只位于内存中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>未</b><b>协</b><b>调</b></span>。单元格数据已修改并正确地写入日志文件中，但尚未写入主文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>脏</b><b>且</b><b>未</b><b>协</b><b>调</b></span>。单元格被写入日志文件后被再次修改，仅第一次修改位于日志文件中，第二次修改在内存中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows 8.1之前的系统中，最初的同步算法会在一个或多个单元格被修改5秒后执行。这个算法可总结为下列四步。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）配置管理器通过日志文件中一个项，写入“脏”矢量发送过信号的所有已修改单元格。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）让配置单元的基块失效（将一个序列号设置为大于另一个序列号的值）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）将所有修改后的数据写入主配置单元的文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）验证主配置单元（验证操作会将主配置单元文件的两个序列号设置为完全相同的值）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了保持配置单元的完整性和可恢复性，该算法会在完成每阶段操作后向文件系统驱动程序发出一个刷新操作，以免损坏数据。但是对随机访问数据执行刷新操作会产生极高的开销（对传统机械硬盘来说这一点尤为严重）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">增量日志解决了这个性能问
题。旧版算法通过一个日志项写入多次配置单元验证操作期间产生的所有脏数据，但增量模型打破了这个假设。新的同步算法会在每次执行延迟刷新器时写入一个日
志项，并且根据上文可知，它只会在首次执行时让配置单元的基块失效。后续刷新操作会继续写入新日志项，而不会触及配置单元的主文件。每小时，或如果日志空
间耗尽，协调器都会将日志项中存储的所有数据写入主配置单元的文件，但不进行验证操作。这样既可以回收日志文件中的空间，同时维持了配置单元的可恢复性。
如果系统在这个过程中崩溃，下一次加载配置单元时会重新应用日志中未写入的原始项；否则新项会重新应用到日志开头处，这样如果系统稍后崩溃了，那么在加载
配置单元时只有日志中的新项会被应用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图10-6展示了可能出现
的崩溃情形以及如何通过增量日志方案加以应对。在情况A中，系统已将新数据写入内存中的配置单元，惰性刷新器也已将相应的项写入日志（但未进行协调）。在
系统重启动时，恢复过程会将所有日志项应用给主配置单元并再次验证配置单元文件。在情况B中，协调器已在崩溃前将存储在日志项中的数据写入主配置单元（未
验证配置单元）。当系统重启动时，恢复过程会重新应用现有日志项，但不会对主配置单元文件进行任何修改。情况C与情况B类似，不过新项已在重协调后被写入
日志。在这种情况下，恢复过程会只写入最后修改但不在主文件中的数据。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ca21bbc8e8ae216545d92840dd5ba707.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-6 系统在不同时间崩溃后可能造成的结果</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">配置单元验证操作只在某些
罕见情况下进行。配置单元被卸载后，系统会进行协调，随后验证配置单元的主文件。验证结束后，会将配置单元主文件的两个序列号设置为一个完全相同的新值，
并在将配置单元从内存卸载之前发出最后一次文件系统刷新请求。当系统重启动时，配置单元加载的代码检测到配置单元主文件处于干净状态（因为那两个序列号的
值完全相同），此时不会执行任何形式的配置单元恢复过程。通过新增的增量同步协议，操作系统不再会因为旧版日志协议而损失性能。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 在运行旧版本Windows的计算机上加载Windows 
8.1或后续版本系统创建的配置单元时，如果配置单元主文件处于非干净状态，加载可能会造成一些问题。旧版操作系统（如Windows 
7）完全不知道该如何处理新版日志文件。因此微软创建了RegHiveRecovery微型过滤器驱动程序，该驱动程序被包含在Windows评估和部署
工具包（ADK）中。RegHiveRecovery驱动程序可以使用Registry回调拦截来自系统的“配置单元加载”请求，并判断配置单元的主文件
是否需要恢复以及是否需要使用增量日志。如果需要，它会执行恢复操作并修复配置单元的主文件，随后系统才有机会读取其中的内容。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_126" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>1</b><b>.</b><b>1</b><b>3</b><b> </b><b>注</b><b>册</b><b>表</b><b>过</b><b>滤</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows内核中的配
置管理器实现了一种强大的注册表过滤模型，借此可使用诸如进程监视器等工具监视注册表活动。当驱动程序使用回调机制时，会向配置管理器注册一个回调函数。
配置管理器会在执行注册表系统服务之前和之后执行驱动程序的回调函数，这样驱动程序就可以对注册表的访问获得完整的可视性和控制力。反病毒产品也会使用这
种回调机制在注册表数据中扫描病毒，或防止对注册表进行未经授权的更改。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">注册表回调也与海拔高度
（altitude）的概念有关。不同供应商可以借助海拔高度这种方式在注册表过滤栈上注册一个“高度”，这样系统就可以确定性的正确顺序调用不同的回调
例程。这样即可避免一些情况，例如反病毒产品可能会在加密产品运行自己的回调以解密被加密的键之前，试图扫描这些加密的键。为了避免这种情况，在
Windows注册表回调模型的帮助下，这两类工具都会被分配一个与它们所进行的过滤类型（本例中是加密和病毒扫描）相对应的基准海拔高度。此外，创建此
类工具的公司必须向微软注册，这样才能保证自己集团公司内部不会因为功能类似或相互竞争的产品产生冲突。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">该过滤模型还可以完全接管对注册表操作的处理（借此可绕过配置管理器，并防止配置管理器处理任何请求），或将一个操作重定向为另一个操作（例如WoW64的注册表重定向）。此外，借此还可以修改注册表操作的输出参数以及返回的值。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后，驱动程序可出于自己的目的分配并标记每个键或每个操作中由驱动程序定义的信息。驱动程序可在执行创建或打开操作期间创建并分配这种上下文数据，配置管理器会记住这些数据，并在针对键执行的后续操作中返回这些数据。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_127" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>1</b><b>.</b><b>1</b><b>4</b><b> </b><b>注</b><b>册</b><b>表</b><b>虚</b><b>拟</b><b>化</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows 10周年更新（RS1）为Argon和Helium容器引入了注册表虚拟化的概念，甚至可以加载1.6版配置单元所支持的差分配置单元。注册表虚拟化由配置管理器和VReg驱动程序（集成于Windows内核中）提供。这两个组件提供了如下服务。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>命</b><b>名</b><b>空</b><b>间</b><b>重</b><b>定</b><b>向</b></span>。应用程序可将虚拟键的内容重定向至主机中的另一个真实键。应用程序也可以将一个虚拟键重定向至差分配置单元中的键，随后合并到主机上的根键中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>册</b><b>表</b><b>合</b><b>并</b></span>。差分配置单元可理解为相对基准配置单元的差异化内容。基准配置单元代表一种基准层，其中包含不可变的注册表视图。差分配置单元中的键是相对于基准配置单元中的键增加或减少的内容，而后者也被叫作Thumbstone键。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">配置管理器会在操作系统初
始化的阶段1期间创建VRegDriver设备对象（并设置相应的安全描述符，只允许SYSTEM和Administrator访问）和
VRegConfigurationContext对象类型，代表用于跟踪命名空间重定向以及注册表合并所需的容器Silo上下文。服务器Silo详见卷
1第3章。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>命</b><b>名</b><b>空</b><b>间</b><b>重</b><b>定</b><b>向</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">注册表命名空间重定向只能
为Silo容器（服务器Silo和应用程序Silo）启用。应用程序创建Silo（但并未启动）后，会向VReg设备对象发送初始化IOCTL，并将句柄
传递给Silo。VReg驱动程序会创建一个空的配置上下文，并将其附加给Silo对象。随后它会创建一个命名空间节点，借此将容器的
\Registry\WC根键重新映射到主机键，因为所有容器需要共享主机键的同一个视图。创建\Registry\WC根键是为了挂载为Silo容器虚
拟化的所有配置单元。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">VReg驱动程序是一种注
册表过滤器驱动程序，可使用注册表回调机制正确地实现命名空间重定向。当应用程序首次初始化命名空间重定向时，VReg驱动程序会注册自己的主
RegistryCallback通知例程（通过一个类似CmRegisterCallbackEx的内部API）。为了向根键正确添加命名空间重定向，
应用程序会向VReg的设备发送一个Create Namespace Node 
IOCTL并指定虚拟键路径（容器可看到该路径）、真实的主机键路径，以及容器的作业句柄。作为回应，VReg设备会新建一个命名空间节点（一种包含键的
数据和某些标记的小型数据结构），并将其加入Silo的配置上下文。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当应用程序完成容器的所有
注册表重定向配置工作后，会将自己的进程（或新生成的进程）附加到Silo对象（使用AssignProcessToJobObject，详见本书卷1第
3章）。此后，容器进程发出的每个注册表I/O都将被VReg注册表微型过滤器拦截。我们一起通过一个例子看看命名空间重定向是如何生效的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">假设现代应用程序框架为一
个Centennial应用程序设置了多个注册表命名空间重定向，尤其是有一个重定向节点会将键从HKCU重定向到主机的
\Registry\WC\a20834ea- 
8f46-c05f-46e2-a1b71f9f2f9cuser_sid键。在某个时间点，该Centennial应用程序希望在
HKCU\Software\Microsoft父键下新建一个名为AppA的键。当进程调用RegCreateKeyEx 
API时，VReg注册表回调会拦截该请求并获得作业的配置上下文。随后它会在上下文中搜索与调用方指定的键路径最接近的命名空间节点。如果什么都没找
到，会返回一个对象未找到错误：不允许在非虚拟化路径上进行容器操作。假设上下文中有一个描述了HKCU根键的命名空间节点，并且该节点是
HKCU\Software\Microsoft子键的父节点，VReg驱动程序会使用主机键的名称替换原始注册表键的相对路径，并将请求转发给配置管理
器。因此在这种情况下，配置管理器实际看到的请求是需要创建\Registry\WC\a20834ea-8f46-
c05f-46e2a1b71f9f2f9cuser_sid\Software\Microsoft\AppA，该请求会成功完成。容器化应用程序不会
发现其中的差异。在应用程序看来，该注册表键就位于主机HKCU下。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>差</b><b>分</b><b>配</b><b>置</b><b>单</b><b>元</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然命名空间重定向是在
VReg驱动程序中实现的，并且仅限容器化的环境下使用，但注册表合并也可以在全局范围内工作，主要在配置管理器自身内部实现（不过VReg驱动程序依然
会被用作入口点，借此将差分配置单元挂载到基准键）。如上文所述，差分配置单元使用了1.6版本的配置单元，虽然与1.5版类似，但支持为差分键使用元数
据。配置单元版本的升高也杜绝了将配置单元挂载到不支持注册表虚拟化的系统的可能。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">应用程序可以创建一个差分
配置单元并向VReg设备发送IOCTL，借此将其全局挂载到系统或某个Silo容器。不过这需要具备备份和还原特权，因此只有以管理员身份运行的应用程
序可以管理差分配置单元。要挂载差分配置单元，应用程序需要用基准键（也叫基层，基层是一种根键，其中包含了差分配置单元的所有子键和值）的名称、差分配
置单元的路径以及一个挂载点来填充一个数据结构。随后通过VR_LOAD_DIFFERENCING_HIVE控制代码将该数据结构发送给VReg驱动程
序。挂载点包含了差分配置单元和基层中所含数据合并后的数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">VReg驱动程序通过一个
哈希表维护所有已加载差分配置单元的列表。这样VReg驱动程序就可以用不同挂载点挂载差分配置单元。如上文所述，现代应用程序架构使用
\Registry\WC根键中的随机GUID来挂载独立Centennial应用程序的差分配置单元。在该哈希表中创建一个项后，VReg驱动程序会直
接将请求转发给配置管理器的内部函数CmLoadDifferencingKey。大部分工作都是由该函数完成的。它会调用注册表回调并加载差分配置单
元。差分配置单元的创建过程与常规配置单元类似。配置管理器的底层创建好配置单元后，还将创建一个键控制块数据结构。这个新的键控制块会被链接至基层键控
制块。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当通过请求指示打开或读取
作为挂载点的键或其子键中包含的值时，配置管理器会知道表示差分配置单元的相关键控制块是哪个。因此解析过程会从差分配置单元开始。如果配置管理器在差分
配置单元中遇到子键，就会停止解析过程并读取差分配置单元中存储的键和数据。否则，如果未在差分配置单元中找到所需数据，配置管理器会从基准配置单元重新
启动解析过程。另一种情况则是验证是否在差分配置单元中找到了Thumbstone键：配置管理器会隐藏搜索的键并且不返回数据（或错误信息）。实际上，
Thumbstone可用于在基准配置单元中将键标记为已删除。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统支持三种类型的差分配置单元。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>可</b><b>变</b><b>配</b><b>置</b><b>单</b><b>元</b><b>（</b><b>m</b><b>u</b><b>t</b><b>a</b><b>b</b><b>l</b><b>e</b><b> </b><b>h</b><b>i</b><b>v</b><b>e</b><b>）</b><b>：</b></span>可被写入或更新。所有指向挂载点（或子键）的写入请求会被存储在差分配置单元中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>不</b><b>可</b><b>变</b><b>配</b><b>置</b><b>单</b><b>元</b><b>（</b><b>i</b><b>m</b><b>m</b><b>u</b><b>t</b><b>a</b><b>b</b><b>l</b><b>e</b><b> </b><b>h</b><b>i</b><b>v</b><b>e</b><b>）</b><b>：</b></span>无法被修改。这意味着对差分配置单元中键的所有修改请求都将失败。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>直</b><b>写</b><b>配</b><b>置</b><b>单</b><b>元</b><b>（</b><b>w</b><b>r</b><b>i</b><b>t</b><b>e</b><b>-</b><b>t</b><b>h</b><b>r</b><b>o</b><b>u</b><b>g</b><b>h</b><b> </b><b>h</b><b>i</b><b>v</b><b>e</b><b>）</b><b>：</b></span>代表不可变的差分配置单元，但指向挂载点（或子键）的写入请求会被重定向至基层（此时基层不再是不可变的）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NT内核和应用程序也可以挂载差分配置单元，随后在其挂载点上应用命名空间重定向，这样即可实现复杂的虚拟化配置，例如Centennial应用程序所用机制（如图10-7所示）。现代应用程序模型以及Centennial应用程序架构的详细信息请参阅第8章。</span></p><div style="display: block;text-align:center;">
	<img width="796" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/48057a578cc15c4091f34ef6fb34db70.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-7 Centennial应用程序的现代化应用程序模型中软件配置单元的注册表虚拟化</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_128" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>1</b><b>.</b><b>1</b><b>5</b><b> </b><b>注</b><b>册</b><b>表</b><b>优</b><b>化</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">配置管理器对注册表进行了
一些值得一提的优化。首先，几乎每个注册表键都由安全描述符提供访问保护。但为配置单元中每个键存储一个唯一的安全描述符是一种低效的做法，因为注册表的
整个子树往往会应用相同安全设置。在为键设置安全性时，配置管理器会在要设置新安全性的键所在的配置单元中检查一个由唯一安全描述符组成的池，并为键共享
现有的安全描述符，这样即可确保在每个配置单元中，每个唯一安全描述符最多只存在一个副本。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">配置管理器还会优化自己在配置单元中存储键和值的方式。虽然注册表是完全支持Unicode的，并使用Unicode约定来指定所有名称，但如果名称只包含ASCII字符，配置管理器会将名称以ASCII形式存储在配置单元中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当配置管理器读取名称（例如执行名称查找）时，会在内存中将名称转换为Unicode形式。以ASCII形式存储名称可大幅减小配置单元的大小。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为最大限度减小内存用量，
键控制块并不存储键的完整注册表路径名，相反只会引用键的名称。例如，一个指向\Registry\System\Control的键控制块会引用
Control这个名称而非完整路径。此外还有进一步的优化措施：配置管理器会使用键名称控制块存储键名称，而所有同名键的键控制块共享了同一个键名称控
制块。为优化性能，配置管理器会将键控制块的名称存储在一个哈希表中以便能快速查找。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了能快速访问键控制块，
配置管理器会将频繁访问的键控制块存储在缓存表（一种哈希表）中。当配置管理器需要查找一个键控制块时，首先会检查该缓存表。最后，配置管理器还有另一个
缓存，即延迟关闭表，其中存储了应用程序已经关闭的键控制块，这样，应用程序即可快速重新打开自己最近关闭的键。为了优化查找，每个配置单元都会存储这些
缓存表。随着添加最新关闭的块，配置管理器会从延迟关闭表中移除最旧的键控制块。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter10_0002.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_129" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>2</b><b> </b><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>服</b><b>务</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">几乎每个操作系统都有一种
机制，用于在系统启动时运行与交互式用户无关的进程。在Widows中，这种进程称为服务或Windows服务。服务类似于UNIX守护进程
（daemon 
process），通常用于实现客户端/服务器应用程序的服务器端。例如，Web服务器就是一种Windows服务，因为无论是否有人登录到计算机，它都
必须运行，并且它必须在系统启动时开始运行，这样管理员才不需要劳心费力亲自去启动。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows服务包含三
个组件：服务应用程序（service application）、服务控制程序（Service Control 
Program，SCP），以及服务控制管理器（Service Control 
Manager，SCM）。我们首先会介绍服务应用程序、服务账户、用户服务和打包的服务，以及SCM的所有操作；随后会介绍自启动服务是如何在系统启动
过程中启动的，还会介绍当服务启动失败后SCM会采取的措施，以及SCM关闭服务的方法；最后会介绍共享的服务进程以及系统管理受保护服务的方式。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_130" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>2</b><b>.</b><b>1</b><b> </b><b>服</b><b>务</b><b>应</b><b>用</b><b>程</b><b>序</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">服务应用程序（如Web服
务器）至少包含一个以Windows服务形式运行的可执行文件。用户可以通过SCP启动、停止或配置服务。虽然Windows提供了内置的SCP（最常用
的为命令行工具sc.exe以及由services.msc这个MMC管理单元提供的用户界面），这些SCP提供了常用的启动、停止、暂停和恢复功能，但
一些服务应用程序也提供了自己的SCP，可供管理员针对自己所管理的服务进行更有针对性的配置设置。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">服务应用程序实际上是一种Windows可执行文件（GUI或控制台形式），并带有额外的代码，可接收来自SCM的命令，以及将应用程序的状态反馈给SCM。因为大部分服务没有用户界面，因此会以控制台程序的方式构建。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安装包含服务的应用程序
时，应用程序的安装程序（通常也充当SCP）必须向系统注册自己的服务。为注册服务，安装程序需要调用Windows的CreateService函数，
这个与服务有关的函数在Advapi32.dll（%SystemRoot%\System32\Advapi32.dll）中导出。Advapi32
（即高级API DLL）只实现了小部分客户端SCM 
API。SCM客户端API最重要的部分都在另一个DLL（Sechost.dll）中实现，这也是SCM和LSA客户端API的主机库。所有未在
Advapi32.dll中实现的SCM 
API都会直接转发至Sechost.dll。大部分SCM客户端API会通过RPC与服务控制管理器通信。SCM则在Services.exe二进制文
件中实现，详见下文“服务控制管理器”一节。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当安装程序调用
CreateService注册服务时，会向目标计算机上运行的SCM实例发出RPC调用。随后，SCM在
HKLM\SYSTEM\CurrentControlSet\Services下为该服务创建一个注册表键。Services键是SCM数据库的非易失
性表示。每个服务对应的键定义了包含服务的可执行映像的路径，以及参数和配置选项。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">创建了服务后，安装或管理
应用程序即可通过StartService函数启动服务。因为一些基于服务的应用程序必须在启动过程中进行初始化，随后才能正常运行，因此很多安装程序会
将服务注册为自动启动的服务，并要求用户重启系统以完成安装过程，随后SCM即可在系统启动过程中启动服务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当程序调用
CreateService时，必须指定一系列用于描述服务特征的参数。这些特征包括：服务类型（是否是一个用自己的进程运行的服务，还是需要与其他服务
共享同一个进程）、服务的可执行映像文件位置、可选的显示名、可选的账户名和密码（借此以特定账户的安全上下文启动服务）、启动类型（决定了该服务是否会
在系统启动时自动运行，还是按照SCP的指示手动运行）、错误代码（决定了如果服务启动过程中遇到错误系统该如何处理，以及服务是否会自动启动）、可选信
息（指定了服务的启动是否与其他服务有相关性）。从Windows Vista开始，系统可以支持延迟加载的服务。Windows 
7引入了对触发的服务（triggered 
service）的支持，这种服务可在一个或多个特定事件被验证之后启动或停止。SCP可通过ChangeServiceConfig2 
API指定触发器事件信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">服务应用程序需要在服务进
程中运行。一个服务进程可以托管一个或多个服务应用程序。当SCM启动一个服务进程时，进程必须立即调用
StartServiceCtrlDispatcher函数（必须在事先定义的超时值到期前调用，详见“服务登录”一节）。
StartServiceCtrlDispatcher可接收进入服务的入口点列表，每个入口点对应了进程中的一个服务。每个入口点可由入口点对应的服务
名称来区分。在与SCM（充当管道）建立了本地RPC（ALPC）通信连接后，StartServiceCtrlDispatcher会通过一个循环等待
来自SCM管道的命令。请注意，该连接的句柄由SCM通过一个内部列表保存，借此即可向正确的进程发送和接收服务命令。每次启动一个进程托管的服务时，
SCM会发送一条服务启动命令。对于收到的每条启动命令，StartServiceCtrlDispatcher函数会创建一个被称为服务线程
（service thread）的线程，借此调用要启动的服务入口点（service 
main）并为该服务实现命令循环。StartServiceCtrlDispatcher会无限期地等待来自SCM的命令，并会在所有进程的服务均已停
止后将控制返回给进程的主函数，这样服务进程即可在退出前清理资源。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">服务入口点
（ServiceMain）的第一个操作是调用RegisterServiceCtrlHandler函数。该函数可以接收并存储一个指向函数的指针（名
为控制处理程序），服务实现这样的指针是为了处理自己从SCM收到的各种命令。RegisterServiceCtrlHandler不与SCM通信，而
是会在本地进程内存中为StartServiceCtrlDispatcher存储该函数。服务入口点会继续初始化服务，例如分配内存，创建通信端点，从
注册表读取私有的配置数据。如上文所述，大部分服务都遵循一种惯例，会将自己的参数存储在自己的服务注册表键下一个名为Parameters的子键中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">入口点初始化服务时，必须
通过SetServiceStatus函数向SCM定期发送状态信息，以此告知服务的启动进展。当入口点初始化工作完成后（服务可以通过
SERVICE_RUNNING向SCM告知），服务线程通常会进入一个循环，等待来自客户端应用程序的请求。例如，Web服务器可以初始化一个TCP监
听套接字，等待传入的HTTP连接请求。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">服务进程的主线程将在
StartServiceCtrlDispatcher函数中执行，接收发送给进程中服务的SCM命令，并调用目标服务的控制处理程序函数（由
RegisterServiceCtrlHandler存储）。SCM命令包括停止、暂停、恢复、质询、关闭，以及应用程序定义的其他命令。图10-8展
示了服务进程的内部组织，其中的主线程和服务线程组成一个托管单个服务的进程。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/508d4aa2049dcf409afcf885160ef49d.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-8 服务进程的结构</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>服</b><b>务</b><b>的</b><b>特</b><b>征</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SCM会将每个特征以值的形式存储在服务的注册表键中。图10-9展示了一个这样的服务注册表键范例。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/1a8b3cb950e11d147242bc97587dbba8.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-9 服务注册表键范例</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">表10-7列出了服务的所有特征，其中很多也适用于设备驱动程序（并非所有特征都适用于每一类服务或设备驱动程序）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 在服务被删除前，SCM不会访问服务的Parameters子键，服务被删除后，SCM会删除服务的整个键，包括Parameters之类的子键。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表10-7 服务和驱动程序的注册表参数</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e7a1f3110b7e66bdad9f7e8966157b0f.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/c46b1d4267b75c512212ef1ed1d60aca.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/839bef0d9de6d404d5f984941ade3164.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/871b053f7400b73e7b1b67ff97ed6ebe.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4ea7739240d00046b9260e88b8a0a925.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3cd0865c717f3a0958af6fb16d03b8fb.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a194672fdd2ad5af5954dd66904d6196.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">请注意，Type值包含三
个用于设备驱动程序的值：设备驱动程序、文件系统驱动程序和文件系统识别器。这些值都被Windows设备驱动程序所使用，并会将参数作为注册表数据存储
在Services注册表键中。SCM负责使用SERVICE_AUTO_START或SERVICE_DEMAND_START作为Start值启动而
非PNP驱动程序，因此，SCM数据库自然也就包含驱动程序。服务则使用了互斥的其他类型：SERVICE_WIN32_OWN_PROCESS和
SERVICE_WIN32_SHARE_PROCESS。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">只托管一个服务的可执行文
件将使用SERVICE_WIN32_OWN_PROCESS类型，托管多个服务的可执行文件将使用
SERVICE_WIN32_SHARE_PROCESS类型。相比启动多个服务进程造成的开销，用一个进程托管多个服务可节约系统资源。但这样做的一个
潜在不足之处在于：如果同一个进程中运行的多个服务中，有一个服务出错导致进程终止，那么该进程的其他所有服务也将终止。此外，另一个局限在于，所有服务
必须用同一个账户运行（如果有服务充分利用了服务安全性加固机制，则可限制暴露给恶意攻击的攻击面）。SERVICE_USER_SERVICE标记可用
来表示用户服务，这类服务会使用当前登录用户的身份运行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SCM通常会将触发器信息存储在另一个名为TriggerInfo的子键中。每个触发器事件都存储在一个以事件索引为名的子键中，该索引从0开始（例如第三个触发器会被存储在“TriggerInfo\2”子键中）。表10-8列出了所有可构成触发器信息的注册表值。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表10-8 触发的服务的注册表参数</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/bf275a650dac91d3c6c2fd7ba1ff3886.jpg" alt="" title=""></div>
</div><div class="header2"><h3><span id="sigil_toc_id_131" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>2</b><b>.</b><b>2</b><b> </b><b>服</b><b>务</b><b>账</b><b>户</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">对服务开发者以及系统管理
员来说，服务的安全上下文是一个重要的考虑因素，因为它决定了进程可以访问哪些资源。大部分内置服务运行在相应的服务账户安全上下文中（只具备有限的访问
权，详见下文）。当服务安装程序或系统管理员创建服务时，通常会选择Local 
System账户（有时会显示为SYSTEM，有时则显示为LocalSystem）的安全上下文，这个账户非常强大。此外还有两个内置账户：
Network Service账户和Local Service账户。从安全的角度来看，这些账户的能力低于Local 
System账户的。下文将介绍所有这些服务账户的特殊性。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>L</b><b>o</b><b>c</b><b>a</b><b>l</b><b> </b><b>S</b><b>y</b><b>s</b><b>t</b><b>e</b><b>m</b><b>账</b><b>户</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Local 
System账户也是核心Windows用户模式操作系统组件的运行账户，这些组件包括会话管理器（%SystemRoot%
\System32\Smss.exe）、Windows子系统进程（Csrss.exe）、本地安全机构进程（%SystemRoot%
\System32\Lsass.exe）以及登录进程（%SystemRoot%\System32\Winlogon.exe）。有关这些进程的详细
信息，请参阅卷1第7章。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">从安全的角度来看，Local System账户非常强大，在针对本地系统所能获得的安全能力方面，甚至远超任何本地或域账户。该账户具备下列特征。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·隶属于本地Administrators组。表10-9列出了Local System账户所属的组（有关组成员关系如何用于对象访问检查的详细信息，请参阅卷1第7章）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·有权启用所有特权（甚至包括通常不会提供给本地管理员账户的特权，如创建安全令牌）。表10-10列出了分配给Local System账户的所有特权（这些特权的使用请参阅卷1第7章）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·大部分文件和注册表键为Local System账户提供了完整的访问权限。即使没有提供完整的访问权限，使用Local System账户运行的进程也可以行使“所有权”特权来获得访问权。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·使用Local System账户运行的进程是通过默认用户配置文件（HKU\.DEFAULT）运行的，因此无法直接访问其他账户的用户配置文件中存储的配置信息（除非明确使用LoadUserProfile API）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·对于Windows域成员系统，Local System账户包含运行了服务进程的计算机的安全标识符（SID），因此，使用Local System账户运行的服务可以使用自己的计算机账户在同一个林（多个域可以组成一个森林）的其他计算机上自动完成身份验证。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
除非计算机账户被明确授予资源（如网络共享、命名管道等）访问权，否则进程可以访问允许空（Null）会话的网络资源，即无须凭据的连接。我们可在注册表
HKLM\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters键下的
NullSessionPipes和NullSessionShares值中指定特定计算机允许空会话的共享和管道。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">▼表10-9 服务账户组成员关系和完整性级别</span></p><div style="display: block;text-align:center;">
	<img width="806" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/7d747c3faf8feff79325583d07a1d573.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">▼表10-10 服务账户的特权</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/689572d1f6db2f5c8696808906b14518.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>N</b><b>e</b><b>t</b><b>w</b><b>o</b><b>r</b><b>k</b><b> </b><b>S</b><b>e</b><b>r</b><b>v</b><b>i</b><b>c</b><b>e</b><b>账</b><b>户</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Network 
Service账户可供需要使用计算机账户向网络上的其他计算机验证身份的服务使用，有些类似于Local 
System账户，但不具备Administrator组的成员关系，也无法使用分配给Local System账户的很多特权。由于Network 
Service账户不属于Administrators组，通过该账户运行的服务默认能访问的注册表键、文件系统文件夹以及文件要远少于使用Local 
System账户运行的服务。此外，因为分配的特权更少，也限制了Network Service进程被攻陷后的波及范围。例如，使用Network 
Service账户运行的进程无法加载设备驱动程序或打开任意进程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Network 
Service与Local System账户的另一个差别在于，Network Service账户运行的进程会使用Network 
Service账户的配置文件。Network 
Service配置文件的注册表组件位于HKU\S-1-5-20，而组成这些组件的文件和目录位于%SystemRoot%
\ServiceProfiles\NetworkService。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通过Network Service账户运行的服务有很多，例如DNS客户端，负责解析DNS名称并定位域控制器。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>L</b><b>o</b><b>c</b><b>a</b><b>l</b><b> </b><b>S</b><b>e</b><b>r</b><b>v</b><b>i</b><b>c</b><b>e</b><b>账</b><b>户</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Local 
Service账户与Network Service账户几乎完全相同，两者最大的差别在于，Local 
Service账户只能访问允许匿名访问的网络资源。如表10-10所示，Network Service账户与Local 
Service账户具备相同的特权，如表10-9所示，它们甚至属于相同的组，但唯一的例外是Local Service账户属于Local 
Service组，而非Network Service组。使用Local 
Service账户运行的进程所用配置文件为HKU\S-1-5-19，配置文件存储于%SystemRoot%
\ServiceProfiles\LocalService。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">使用Local Service账户运行的服务有很多，例如Remote Registry Service，可允许对本地系统的注册表进行远程访问；此外还有LmHosts服务，负责执行NetBIOS名称解析。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>用</b><b>备</b><b>选</b><b>账</b><b>户</b><b>运</b><b>行</b><b>服</b><b>务</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于上述限制，一些服务可
能需要使用用户账户的安全凭据来运行。在创建服务时，我们可以配置服务用备选账户运行，或在“Windows服务”这个MMC管理单元中指定服务运行所用
的账户和密码。在服务管理单元中，右击一个服务并选择“属性”，打开“登录”选项卡，选择“此账户”选项即可，如图10-10所示。</span></p><div style="display: block;text-align:center;">
	<img width="583" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3514243389dbb6ebf7653ae7c80dabb2.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-10 服务账户设置</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">请注意，当需要启动时，使
用备选账户运行的服务将始终使用备选账户的凭据来启动，哪怕所选账户当前并未登录。这意味着就算用户未登录，用户配置文件也会被加载。本章下文“用户服
务”一节要介绍的用户服务（user service）就是为了解决这个问题而诞生的。用户服务只有在用户登录后才会加载。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>用</b><b>最</b><b>小</b><b>特</b><b>权</b><b>运</b><b>行</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">服务的进程通常受制于一
种“全有或全无”的模型，这意味着运行服务进程的账户所拥有的全部特权，都适用于该进程中运行的服务，即使这些服务实际只需要其中的部分特权。为了更好地
符合最小特权原则，也就是Windows只为服务分配必需的特权，开发者可以指定自己的服务所需的特权，而SCM可以创建只包含这些特权的安全令牌。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">服务开发者可以使用
ChangeServiceConfig2 
API（指定SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO信息级别）来声明自己需要的特权列表。该API会将这些信
息存储在注册表中根服务键的RequiredPrivileges值中（详见表10-7）。当服务启动时，SCM会读取该键并将其中指定的特权添加到运行
服务的进程的令牌中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果存在
RequiredPrivileges值，并且服务是一个单独的服务（通过专用进程运行），那么SCM会创建一个只包含该服务所需特权的令牌。对于那些通
过共享服务进程来运行的服务（Windows内置的很多服务都是如此），在指定了所需特权后，SCM会计算这些特权的联合后的特权，并将其添加到服务托管
进程的令牌中。换句话说，同一个服务托管进程中，所有服务都未明确指定的特权将会被移除。如果不使用该注册表值，SCM将别无选择，只能假设服务不兼容最
小特权原则，或需要所有特权才能运行。此时将创建包含所有特权的完整令牌，这种模式无法提供额外的安全性。为了尽可能剥离几乎所有特权，服务甚至可以只指
定Change Notify特权。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 服务指定的特权必须是自己运行所用服务账户具备的特权的子集。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>服</b><b>务</b><b>所</b><b>需</b><b>的</b><b>特</b><b>权</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们可以通过服务控制工具sc.exe以及qprivs选项来查看服务所需的特权。另外，我们也可以使用Process 
Explorer查看系统中任何服务的安全令牌信息，然后将sc.exe返回的信息与令牌中的特权信息进行对比。下列操作介绍了如何对系统中某些已经加固
的服务查看并对比特权信息。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">1）使用sc.exe查看CryptSvc服务所需的特权，为此请运行下列命令：</span></p>
	<p><span style="font-size:14px;font-style: oblique;color:rgb(0, 0, 0);font-family:'Source Code Pro';"><i>s</i><i>c</i><i> </i><i>q</i><i>p</i><i>r</i><i>i</i><i>v</i><i>s</i><i> </i><i>c</i><i>r</i><i>y</i><i>p</i><i>t</i><i>s</i><i>v</i><i>c</i></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">应该可以看到三个特权：SeChangeNotifyPrivilege、SeCreateGlobalPrivilege和SeImpersonatePrivilege。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">2）以管理员身份运行Process Explorer并查看进程列表。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">应该可以看到有多个Svchost.exe进程托管了计算机中的多个服务（如果启用了Svchost拆分功能，还将显示更多Svchost实例）。Process Explorer会用粉红色强调显示这些进程。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">3）
CryptSvc服务运行在共享的托管进程中。在Windows 
10中，我们可以通过任务管理器轻松定位正确的进程实例。我们并不需要知道服务DLL的名称，它们都包含在
HKLM\SYSTEM\CurrentControlSet\Services\CryptSvc\Parameters注册表键中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">4）打开任务管理器的“服务”选项卡，应该可以轻松找到CryptSvc托管进程的PID。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">5）返回Process Explorer并双击任务管理器中找到的那个PID对应的Svchost.exe进程，打开Properties对话框。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">6）仔细检查Service选项卡是否包含CryptSvc服务。如果启用了服务拆分，这里应该只有一个服务，否则可能会包含多个服务。随后打开Security选项卡，应该可以看到类似下图所示的安全信息。</span></p><div style="display: block;text-align:center;">
	<img width="600" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/7ac5c470854523953f74dff51f74e6f9.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请注意，虽然使用Local Service账户运行，但该服务对应的特权列表窗口中列出的特权远比表10-10中列出的Local Service账户应有的特权少。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">对
于服务托管进程，令牌的特权部分是对所托管的所有服务需要的特权汇总在一起计算而来的，因此这一定意味着诸如DnsCache和
LanmanWorkstation等服务并未请求Process 
Explorer所示之外的其他特权。为了确认这一点，我们也可以在这些服务上运行Sc.exe工具（首先需要禁用Svchost服务拆分）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>服</b><b>务</b><b>隔</b><b>离</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然限制服务所能获得的特
权有助于降低通过攻陷的服务进程危及其他进程的可能性，但在正常情况下，这并不能将服务与运行服务所用账户可以访问的资源隔离开。如上文所述，Local
 System账户可以完整访问关键的系统文件、注册表键以及系统中其他可保护的对象，因为访问控制列表（ACL）提供了相关权限。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">有时候，对于一个服务，访
问某些资源是让其正常运行不可或缺的，但其他对象可能没必要允许该服务访问。以前，为避免让服务访问必需的资源而使用Local 
System账户，我们可以使用标准用户账户来运行服务，并且还可为系统对象添加ACL，但这大大增加了恶意代码攻击系统的风险。另一种做法是创建专用的
服务账户并为每个账户设置特定的ACL（与服务相关联），但这种方式会造成巨大的管理负担。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows现已将上述
两种方式结合在一起，提供了一种更易于管理的解决方案：它允许服务用一个非特权账户运行，但依然可以访问指定的特权资源，同时不会降低这些对象的安全性。
实际上，对象的ACL甚至可以直接为服务设置权限，而无须使用专用账户。此时Windows会生成一个能表示单个服务的服务SID，该SID可用于为注册
表键和文件等资源设置权限。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">服务控制管理器会通过不同
方式使用服务SID。如果服务被配置为使用NT 
SERVICE\域中的虚拟服务账户来启动，此时会生成一个服务SID并将其分配为新服务令牌的主用户。该令牌还会被包含在NT SERVICE\ALL
 
SERVICES组中。系统会使用该组以允许任意服务访问可保护的对象。对于共享服务的情况，SCM会使用令牌创建服务托管进程（一种可包含多个服务的进
程），该令牌包含隶属于同一个服务组的所有服务对应的服务SID，甚至其中可以包括尚未启动的服务（但令牌创建之后将无法添加新的SID）。受限和非受限
服务（详见本节下文）始终会在托管进程的令牌中拥有一个服务SID。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>理</b><b>解</b><b>服</b><b>务</b><b>S</b><b>I</b><b>D</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
第9章，我们通过“理解虚拟机工作进程和虚拟磁盘文件的安全性”这个实验介绍了系统如何为不同的虚拟机工作进程生成虚拟机SID。与虚拟机工作进程的情况
类似，系统也会使用一种明确定义的算法来生成服务SID。本实验将使用Process Explorer展示服务SID，并介绍系统如何生成服务SID。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">首先，我们需要选择一个使用虚拟服务账户运行的服务，或使用受限/非受限访问令牌的服务。请打开注册表编辑器（在搜索框中输入Regedit），然后打开HKLM\SYSTEM\CurrentControlSet\Services注册表键。接着从“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>编</b><b>辑</b></span>”菜单选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>查</b><b>找</b></span>”。
根据本节上文的介绍，服务账户存储在ObjectName注册表值中。但是并没有太多服务是使用虚拟服务账户运行的（这些账户的名称以NT 
SERVICE\VirtualDomain开头），因此更好的方式是查看受限令牌（非受限令牌也可以）。请输入ServiceSidType（其值决定
了服务应该用受限还是非受限令牌运行），然后点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>查</b><b>找</b><b>下</b><b>一</b><b>个</b></span>”按钮。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在这个实验中我们要找一个受限服务账户（其ServiceSidType值应该设置为3），但非受限服务账户也是可以的（值为1）。如果所需的值不匹配，可以使用F3按钮查找下一个匹配的服务。在本实验中我们将使用BFE服务。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">打开Process Explorer，搜索BFE托管进程（可参阅上文的实验了解如何找到正确的进程），随后双击打开。打开“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>安</b><b>全</b></span>”选
项卡，并点击NT SERVICE\BFE 
Group（这是服务SID的易读标记），如果选择其他服务SID，则请根据实际情况点击对应的服务SID。请留意组列表尾部显示的扩展组SID（如果服
务使用虚拟服务账户运行，服务SID则会被Process Explorer显示在“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>安</b><b>全</b></span>”选项卡的第二行）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">S-1-5-80-1383147646-27650227-2710666058-1662982300-1023958487</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">NT
 Authority（ID 5）负责服务SID的生成，为此会用到服务的基准RID（80）以及服务名称的大写形态下UTF-16 
Unicode字符串的SHA-1哈希值。SHA-1算法可以产生一个160位（20字节）的值。在Windows的安全世界中，这意味着SID可以有5
个（4字节）子权威值。BFE服务名称的Unicode（UTF-16）SHA-1哈希值为：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">7e 28 71 52 b3 e8 a5 01 4a 7b 91 a1 9c 18 1f 63 d7 5d 08 3d</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如果将上述哈希值拆分为5组，每组包含8个十六进制数字，那么将会发现：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·0x5271287E（第一个DWORD值），相当于十进制的1383147646（别忘了，Windows是小端序操作系统）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·0x01A5E8B3（第二个DWORD值），相当于十进制的27650227。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·0xA1917B4A（第三个DWORD值），相当于十进制的2710666058。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·0x631F189C（第四个DWORD值），相当于十进制的1662982300。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·0x3D085DD7（第五个DWORD值），相当于十进制的1023958487。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如果将上述数字与服务SID权威值以及第一个RID（S-1-5-80）相加，即可得到与Process Explorer中显示的相同SID。上述操作展示了系统生成服务SID的方式。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每个服务都有一个SID的
作用不仅仅在于获得为系统中不同对象添加ACL项和权限的能力，这样还可以对服务的访问进行更细化的控制。我们最初的讨论涵盖了这样一种情况：系统中某些
能被特定账户访问的对象，必须通过保护防止其被通过该账户运行的服务所访问。如上文所述，如果用服务SID的方式解决这个问题，只能将拒绝该服务SID的
ACL项配置给需要保护的每个对象，很明显，从管理的角度来说，这并不现实。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为避免使用拒绝访问的访问
控制项（Access Control 
Entry，ACE）来阻止服务访问运行自己的用户账户所能访问的资源，系统提供了两种类型的服务SID：受限服务SID
（SERVICE_SID_TYPE_RESTRICTED）以及非受限服务SID（SERVICE_SID_TYPE_UNRESTRICTED），后
者是默认服务SID，截至目前讨论的情况就是如此。实际上这些名称有些误导性，服务SID始终是通过相同方式生成的（参见上一个实验），不同的处理方式其
实要归功于托管进程生成的令牌。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">非受限服务SID会被创建
为默认启用的组所有者SID，而进程令牌还为服务登录SID提供了一个全新的、能提供完整访问权限的ACE，这样服务就可以继续与SCM通信（这方面的一
个主要用途是在服务启动或关闭期间，启用或禁用进程内部的服务SID）。通过SYSTEM账户运行的服务，如果使用非受限令牌启动，其效果甚至比标准的
SYSTEM服务更强大。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">另外，受限服务SID可将
服务托管进程的令牌变成一种写入受限的令牌。受限令牌（详见卷1第7章）在访问可保护对象时，通常需要系统进行两次访问检查：一次使用标准令牌的启用组
SID列表，另一次使用受限SID的列表。对于标准的受限令牌，只有在两次访问检查都允许所请求的访问权限时，才会允许访问。另一方面，写入受限令牌（通
常可为CreateRestrictedToken 
API指定WRITE_RESTRICTED标记来创建）只对写入请求执行两次访问检查：只读访问请求只使用令牌的启用组SID进行一次检查，这一点与普
通令牌相同。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">无论用什么账户运行，使用
写入受限令牌运行的服务托管进程只能写入明确为服务SID（以及下列三个为保持兼容性而添加的补充SID）授予写入访问权的对象。因此这种进程中运行的所
有服务（属于同一个服务组）必须具备受限类型的SID，否则使用受限类型SID的服务将无法启动。一旦令牌变成写入受限的，为维持兼容性，还会添加下列三
个SID。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·添加World SID是为了允许对通常可被任何人以任何方式访问的对象进行写入操作，其中最重要的是加载路径中的某些DLL。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·添加Service logon SID是为了允许服务与SCM通信。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·添加Write-restricted SID是为了让对象能明确允许任何写入受限服务对自己进行写入访问。例如ETW会对自己的对象使用该SID，以允许任何写入受限服务生成事件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图10-11展示了一个服
务托管进程的例子，该进程中包含被标记为具有受限服务SID的服务。例如，Base Filtering 
Engine（BFE）服务负责应用Windows防火墙过滤规则，该服务就包含在这个托管进程中，因为这些规则都存储在注册表中，因此必须保护相应注册
表键，防止被攻陷的服务通过写入访问恶意篡改防火墙的规则（例如，攻击者可以利用被攻陷的服务禁用防火墙的出站流量规则，或启用与攻击者的双向通信）。</span></p><div style="display: block;text-align:center;">
	<img width="706" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/7dcb5c13eadc4831003d0bc4ab04c57b.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-11 具备受限SID的服务</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通过阻止服务对原本自己
（继承运行自己的账户所具备的权限而）可写入的对象进行写入访问，受限服务SID还解决了我们最初提出的那个问题的另一方面：因为用户无须做任何事就可以
防止使用特权账户运行的服务对关键的系统文件、注册表键或其他对象执行写入访问，所以减小了被攻陷的服务可能的波及范围。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">表10-11中列出了三种行为，Windows还允许防火墙规则引用与其中任何一种行为相关的服务SID。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表10-11 网络限制规则</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/089eb8e5a0e0db9a17d8b4aea1d659ff.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>虚</b><b>拟</b><b>服</b><b>务</b><b>账</b><b>户</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，服务SID也
可以设置为以虚拟服务账户上下文运行的服务令牌的所有者。使用虚拟服务账户运行的服务将获得比LocalService或NetworkService类
型的服务更少的特权（特权列表可参阅表10-10），并且无法获得通过网络进行身份验证所需的凭据。服务SID是令牌的所有者，令牌包含在
Everyone、Users、Authenticated Users以及All 
Services组中。这意味着可以读取（或写入，除非服务使用了受限SID类型）属于标准用户，但不属于Administrators或System组
高特权用户的对象。与其他类型不同，使用虚拟服务账户运行的服务有私有的配置文件，该配置文件由ProfSvc服务（Profsvc.dll）在服务登录
期间加载，具体方式与常规服务类似（详见“服务登录”一节）。在服务首次登录期间，系统会使用%SystemRoot%\ServiceProfiles
路径下一个与服务名称同名的文件夹创建配置文件。服务的配置文件载入后，其注册表配置单元会挂载到HKEY_USERS根键，一个以虚拟服务账户的易读
SID（以S-1-5-80开头，详见“理解服务SID”实验）为名的键下。</span></p><div style="display: block;text-align:center;">
	<img width="555" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/2dabe4efc2f98a8c1b2f60dd8c4a690a.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-12 一个文件（可保护对象）的ACE允许了TestService的完整访问</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">用户可以轻松地为服务分配
虚拟服务账户，为此只需要将登录账户设置为NT 
SERVICE\&lt;ServiceName&gt;，其中&lt;ServiceName&gt;是服务的名称。登录时，服务控制管理器会识别出登
录账户是一个虚拟服务账户（这要归功于NT 
SERVICE登录提供程序），并验证账户的名称与服务名称相符。服务不能使用隶属于其他服务的虚拟服务账户来启动，这是SCM的强制要求（通过内部的
ScIsValidAccountName函数实现）。共享同一个托管进程的多个服务不能使用虚拟服务账户运行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在操作可保护的安全对象
时，用户可以使用服务登录账户（以NT 
SERVICE\&lt;ServiceName的形式）向对象的ACL添加一个ACE，进而允许或拒绝访问虚拟服务。如图10-12所示，系统能够将虚
拟服务账户的名称转换为正确的SID，借此即可对服务能访问的对象进行更细化的访问控制（这也适用于使用非系统账户运行的常规服务，详见上文）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>交</b><b>互</b><b>式</b><b>服</b><b>务</b><b>和</b><b>会</b><b>话</b><b>0</b><b>隔</b><b>离</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于通过恰当的服务账户
（Local System、Local Service以及Network 
Service账户）运行的服务来说，Windows中一直存在一项限制：这些服务无法在交互式用户桌面显示对话框或窗口。造成这种限制的直接原因并非使
用了这些特殊账户来运行服务，而是Windows子系统将服务进程分配给窗口站（window 
station）的方式所造成的。这种限制还被用户会话中一种名为会话0隔离（session 0 
isolation）的机制进一步加强，导致服务无法直接与用户桌面交互。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows子系统会将
每个Windows进程关联到一个窗口站。窗口站中包含桌面，而桌面又可以包含很多窗口。同一时间只有一个窗口站可见并能接收用户的鼠标和键盘输入。在终
端服务环境中，每个会话有一个窗口站可见，但所有服务都在隐藏的会话0中运行。Windows会将可见窗口站称为WinSta0，所有交互式进程都可以访
问WinSta0。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除非另有指示，否则
Windows子系统会将使用恰当服务账户或Local 
System账户运行的服务与一个名为Service-0x03e7$的不可见窗口站关联在一起，所有非交互式服务都共享这个窗口站。名称中
的“3e7”这个数字代表登录会话标识符，本地安全机构进程（LSASS）会将该标识符分配给登录会话，供SCM提供给Local 
System账户运行的非交互式服务使用。通过Local 
Service账户运行的服务也会借助类似的方式关联到登录会话3e5生成的窗口站，而通过Network 
Service账户运行的服务会关联到登录会话3e4生成的窗口站。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">配置为通过用户账户运行的
服务（即未使用Local 
System账户）会在另一个不可见窗口站中运行，该窗口站使用为服务的登录会话分配的LSASS登录标识符作为名称。图10-13展示了
Sysinternals 
WinObj工具显示的一个范例，其中展示了Windows保存窗口站对象的对象管理器目录。可以看到一个交互式窗口站（WinSta0）以及三个非交互
式服务窗口站。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/f685c5e26a04d26d1cadf0116a5aab81.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-13 窗口站列表</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">无论是否通过用户账户、Local System账户、Local Network账户或Network Service账户运行，未在可见窗口站中运行的服务都无法接收用户的输入或显示可见窗口。实际上，如果服务需要使用模式（modal）对话框
	<sup><img width="11" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="当一个应用程序显示了模式对话框后，用户必须完成与该对话框的交互并将其关闭，应用程序才能继续运行。也就是说，这种对话框要求用户必须对某些情况做出响应才能继续；与之相对的是无模式（modaless）对话框，在应用程序显示这种对话框的过程中，就算不将其关闭，用户也依然可以与应用程序本身进行交互。——译者注" title="当一个应用程序显示了模式对话框后，用户必须完成与该对话框的交互并将其关闭，应用程序才能继续运行。也就是说，这种对话框要求用户必须对某些情况做出响应才能继续；与之相对的是无模式（modaless）对话框，在应用程序显示这种对话框的过程中，就算不将其关闭，用户也依然可以与应用程序本身进行交互。——译者注" class="epub-footnote"></sup>，此时该服务看起来似乎会处于挂起状态，因为任何用户都看不到这样的对话框，当然也就无法通过用户的键盘或鼠标提供输入来解除对话框，以便让服务能够继续运行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">服务若要与用户通过对话框
或窗口进行交互，必须提供有效的理由。如果一个服务在注册表键的Type参数中配置了SERVICE_INTERACTIVE_PROCESS标记，那么
在启动时会通过托管进程连接到交互式WinSta0窗口站（请注意，通过用户账户运行的服务无法标记为可交互的）。如果用户进程与服务在同一个会话中运
行，那么这个到WinSta0的连接就可以让服务显示对话框和窗口，并允许这些窗口响应用户输入，因为它们与交互式服务共享了同一个窗口站。然而，只有系
统拥有的进程和Windows服务可以运行在会话0中，所有其他登录会话，包括控制台用户，都运行在不同会话中。因此，在会话0中显示的任何窗口都无法被
用户看到。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这个额外的边界有助于防止
Shatter攻击，即低权限应用程序向同一窗口站中的可见窗口发送窗口消息，借此利用拥有该窗口的高权限进程中存在的Bug在高权限进程中执行代码。在
过去，Windows还提供了交互式服务检测（interactive services 
detection）服务（UI0Detect），当服务在会话0的WinSta0窗口站主桌面上显示了窗口后，该服务会向用户发出通知。这样用户即可切
换到会话0的窗口站，进而让交互式服务可以正常运行。不过出于安全方面的考虑，该功能首先被禁用，并从Windows 
10的2018年4月更新（RS4）后被彻底移除。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">因此，即便服务控制管理器
依然支持交互式服务（只需将
HKLM\SYSTEM\CurrentControlSet\Control\Windows\NoInteractiveServices注册表值设
置为0），会话0依然是不可访问的。任何服务都已经无法再显示任何窗口了（除非使用一些未记载的“破解”方法）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_132" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>2</b><b>.</b><b>3</b><b> </b><b>服</b><b>务</b><b>控</b><b>制</b><b>管</b><b>理</b><b>器</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">SCM的可执行文件
为%SystemRoot%\System32\Services.exe，与大部分服务进程类似，它也以Windows控制台程序的形式运行。
Wininit进程会在系统启动的早期启动SCM（有关启动过程的详情可参阅第12章）。SCM的启动函数SvcCtrlMain会负责协调并启动被配置
为需要自动启动的服务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SvcCtrlMain首
先会执行自己的初始化过程，为此需要设置自己的进程安全缓解措施和未处理异常过滤器，并在内存中创建众所周知SID的表达。随后它会创建两个同步事件：一
个名为SvcctrlStartEvent_A3752DX，另一个名为SC_AutoStartComplete。这两个事件都会被初始化为非信号事
件。第一个事件由SCM在完成从SCP接收命令所需的全部操作后发出信号，第二个事件会在SCM初始化全部完成后收到信号。该事件可防止系统或其他用户启
动服务控制管理器的另一个实例。SCP会使用OpenSCManager函数与SCM建立对话，OpenSCManager函数会等待
SvcctrlStartEvent_A3752DX收到信号，借此防止SCP在SCM初始化完毕之前与SCM联系。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后，
SvcCtrlMain开始工作，创建适当的安全描述符并调用ScGenerateServiceDB，这个函数用于构建SCM的内部服务数据库。
ScGenerateServiceDB会读取并存储
HKLM\SYSTEM\CurrentControlSet\Control\ServiceGroupOrder\List的内容，其中有一个
REG_MULTI_SZ值列出了已定义服务组的名称和顺序。如果一个服务或设备驱动程序需要控制自己相对于其他组中服务的启动顺序，那么可以通过服务的
注册表键包含一个可选的Group值。例如，Windows网络栈是自下而上构建的，因此网络服务必须指定Group值，将自己放置在启动序列中网络设备
驱动程序的后方。SCM内部创建了一个组列表，该列表保存了从注册表中读到的组顺序。这些组包括（但不限于）NDIS、TDI、主磁盘、键盘端口、键盘
类、过滤器等。加载项和第三方应用程序甚至可以定义自己的组，并将其加入列表。例如Microsoft Transaction 
Server就会添加一个名为MS Transactions的组。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">接着会由
ScGenerateServiceDB扫描HKLM\SYSTEM\CurrentControlSet\Services的内容，在服务数据库中为自
己遇到的每个键创建一个项（名为“服务记录”）。这种数据库项包含了为服务定义的所有相关参数，以及一个用于跟踪服务状态的字段。SCM还会为设备驱动程
序添加这样的项，因为SCM会启动标记为“自动启动”的服务和驱动程序，并会检测标记为“引导启动”和“系统启动”驱动程序的启动失败状态。SCM还可以
让应用程序查询驱动程序的状态。由于I/O管理器会先于任何用户模式进程加载被标记为“引导启动”和“系统启动”的驱动程序，因此任何具备这种启动类型的
驱动程序都会先于SCM启动。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ScGenerateServiceDB
会读取服务的Group值以确定服务在组中的成员关系，并将该值与之前创建的组列表中的组项进行关联。该函数还会通过数据库读取并记录服务的组和服务依赖
项关系，为此需要查询服务的DependOnGroup和DependOnService注册表值。图10-14展示了SCM组织服务项和组顺序列表的方
式。请注意，服务列表是按照字母表顺序排序的，这是因为SCM从Services注册表键创建了该列表，而Windows是按照字母表顺序枚举这些注册表
键的。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4696ffa1f2aedae75095e59e47cca9bd.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-14 服务数据库内部的组织方式</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在服务启动过程中，SCM
会调用LSASS（例如用非本地系统账户登录服务），因此SCM会等待LSASS在初始化完成后向同步事件LSA_RPC_SERVER_ACTIVE发
出信号。Wininit也会启动LSASS进程，因此LSASS与SCM的初始化工作是同时进行的，而LSASS与SCM完成初始化的顺序可能各异。
SCM会清理（注册表，而非数据库中）所有被标记为删除（具备DeleteFlag这个注册表值）的服务，并为数据库中的每条服务记录生成依赖项列表。这
样SCM就可以知道哪个服务依赖特定的服务记录，这与存储在注册表中的依赖项信息是完全相反的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后SCM会查询系统是否
以安全模式启动（通过
HKLM\System\CurrentControlSet\Control\Safeboot\Option\OptionValue注册表值获
知）。该检查是必需的，稍后需要通过该检查的结果确定服务是否应当启动（详见下文“自启动服务的启动”一节）。随后SCM会创建自己的远程过程调用
（Remote Procedure 
Call，RPC）命名管道，名为\Pipe\Ntsvcs，接着RPC会启动一个线程来监听管道上由SCP传入的消息。SCM会为自己的初始化完成事件
SvcctrlStartEvent_A3752DX发送信号，并注册一个控制台应用程序关闭事件处理程序，同时会通过
RegisterServiceProcess与Windows子系统进程注册，借此让SCM为系统关闭做好准备。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在启动需要自动启动的服务
前，SCM还会执行一些工作。它会初始化UMDF驱动程序管理器，该管理器负责管理UMDF驱动程序。自从Windows 
10秋季创意者更新（RS3）以来，这个管理器已成为服务控制管理器的一部分，会等待已知DLL初始化完成（为此需要等待
\KnownDlls\SmKnownDllsInitialized事件收到会话管理器的信号）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>启</b><b>用</b><b>服</b><b>务</b><b>日</b><b>志</b><b>记</b><b>录</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">服
务控制管理器通常只会在检测到异常错误（如某服务启动失败或需要更改服务配置）时，才会记录ETW事件日志。只需手动启用或禁用不同类型的SCM事件，即
可修改这种行为。在这个实验中，我们将启用两类事件，借此可以更好地对服务的状态变化进行调试。当一个服务的状态有变化，或向服务发送了STOP控制请求
后，会产生事件7036和事件7042。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">服
务器版Windows默认启用了这两类事件，但客户端版的Windows 10默认并未启用。在Windows 
10计算机上，我们可以打开注册表编辑器（在搜索框中输入regedit.exe）并打开
HKLM\SYSTEM\CurrentControlSet\Control\ScEvents注册表键。如果ScEvents子键不存在，可以右键单
击Control子键并从“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>新</b><b>建</b></span>”菜单中选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>项</b></span>”。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后创建两个DWORD值，名称分别为7036和7042，并将这两个值的数据设置为1（设置为0可实现相反的效果，即禁止生成这些事件，服务器版系统也会受此影响）。至此我们应该可以看到类似下图所示的注册表状态。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/7599971d342509b5d492c3f1f098f19e.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">重启动计算机，随后使用sc.exe工具启动并停止一个服务（如AppXSvc服务），为此请在管理员身份运行的命令提示符窗口中运行下列命令：</span></p>
	<p><span style="font-size:14px;font-style: oblique;color:rgb(0, 0, 0);font-family:'Source Code Pro';"><i>s</i><i>c</i><i> </i><i>s</i><i>t</i><i>o</i><i>p</i><i> </i><i>A</i><i>p</i><i>p</i><i>X</i><i>S</i><i>v</i><i>c</i></span></p>
	<p><span style="font-size:14px;font-style: oblique;color:rgb(0, 0, 0);font-family:'Source Code Pro';"><i>s</i><i>c</i><i> </i><i>s</i><i>t</i><i>a</i><i>r</i><i>t</i><i> </i><i>A</i><i>p</i><i>p</i><i>X</i><i>S</i><i>v</i><i>c</i></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">打开事件查看器（在搜索框中输入eventvwr）并打开Windows日志，然后打开“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>系</b><b>统</b></span>”。随后应该可以看到来自服务控制管理器、ID为7036和7042的很多事件。在最上方应该可以看到AppXSvc服务停止事件，如下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="864" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/5c593753176143665e56a80dbb8a1d9d.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">需
要注意的是，服务控制管理器默认会记录系统启动时那些自动启动服务生成的所有事件，这可能会在系统事件日志中充斥大量不必要的事件。为缓解这种问题，我们
可以禁用SCM的自动启动事件，为此可在HKLM\System\CurrentControlSet\Control键下创建一个名为
EnableAutostartEvents的注册表值，并将其数据设置为0（服务器和客户端版本系统的默认隐含值均为1）。随后系统将只记录服务应用程
序在启动、暂停或停止服务时产生的事件。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>网</b><b>络</b><b>驱</b><b>动</b><b>器</b><b>盘</b><b>符</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了作为服务的接口，
SCM还有一个完全不相关的“副业”：当系统创建或删除了网络驱动器盘符连接后，它会向系统中的GUI应用程序发出通知。SCM会等待多提供程序路由器
（Multiple Provider 
Router，MPR）向命名事件\BaseNamedObjects\ScNetDrvMsg发出信号，每当应用程序为远程网络共享分配了驱动器盘符，
或删除这样的分配后，MPR就会发出信号。当MPR发出这样的信号后，SCM会调用GetDriveType这个Windows函数来查询已连接网络驱动
器盘符列表。如果列表内容在事件信号前后产生了变化，SCM会发出一条WM_DEVICECHANGE类型的Windows广播消息。SCM会使用
DBT_DEVICEREMOVECOMPLETE或DBT_DEVICEARRIVAL作为消息的子类型。该消息主要是为Windows资源管理器准备
的，资源管理器可以借此更新所有打开的“计算机”窗口，显示添加或删除的网络驱动器盘符。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_133" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>2</b><b>.</b><b>4</b><b> </b><b>服</b><b>务</b><b>控</b><b>制</b><b>程</b><b>序</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如“服务应用程序”一节
所述，服务控制程序（Service Control 
Program，SCP）是一种标准的Windows应用程序，它调用了SCM服务管理函数，包括CreateService、OpenService、
StartService、ControlService、QueryServiceStatus以及DeleteService。要使用SCM函数，
SCP必须首先打开到SCM的通信通道，为此需要调用OpenSCManager函数以指定自己要执行的操作类型。举例来说，如果一个SCP只是想要枚举
并显示SCM数据库中存在的服务，即可在调用OpenSCManager时请求“枚举服务访问”。在初始化过程中，SCM会创建一个代表SCM数据库的内
部对象，并使用Windows安全功能借助安全描述符保护该对象，安全描述符中指定了哪些账户能以怎样的权限打开该对象。例如，安全描述符可以指定：仅
Authenticated Users组可以用“枚举服务访问”权限打开SCM对象。不过仅管理员可以用创建或删除服务的权限打开该对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与在SCM数据库中的做法
类似，SCM也为服务本身实现了安全性。当SCP使用CreateService函数创建服务时，会指定一个安全描述符，借此在内部将SCM与服务数据库
中的服务项关联在一起。SCM会在服务的注册表键中使用Security值存储安全描述符，并会在初始化过程中扫描注册表的Services键时读取该
值，这样即使系统重启动，也可以应用相同的安全设置。就像SCP必须在调用OpenSCManager时指定自己对SCM数据库进行何种类型的访问一样，
SCP在调用OpenService时也必须告诉SCM自己想要如何访问服务。SCP可以请求的访问包括查询服务状态，以及配置、停止、启动服务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">大家最熟悉的SCP可能就
是Windows自带的“服务”MMC管理单元，该管理单元位于%SystemRoot%\System32\Filemgmt.dll中。
Windows还提供了Sc.exe（服务控制工具），这个命令行版本的服务控制程序已经在上文中多次提到了。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SCP有时会在SCM实现
的基础上使用分层的服务策略。例如在服务以手动方式启动时，“服务”MMC管理单元所实现的超时机制。该管理单元会显示一个表示服务启动状态的进度条。当
服务响应SCM命令（如启动命令）时，会设置能反映自己进度的配置状态，借此实现与SCP的间接交互。SCP可使用QueryServiceStatus
函数查询该状态，借此即可确定一个服务是在积极更新自己的状态，还是已经挂起了，而SCM可以酌情采取措施通知用户一个服务当前正在做什么。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_134" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>2</b><b>.</b><b>5</b><b> </b><b>自</b><b>启</b><b>动</b><b>服</b><b>务</b><b>的</b><b>启</b><b>动</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">SvcCtrlMain可
以调用SCM的ScAutoStartServices函数启动所有Start值被设定为“自启动”的服务（延迟启动服务和用户服务除外）。
ScAutoStartServices还会启动所有设置为自启动的驱动程序。为避免混淆，除非另有说明，否则可将“服务”这个词理解为服务和驱动程序。
ScAutoStartServices首先会启动两个重要且基础的服务：Plug and 
Play（实现于Umpnpmgr.dll库中）和Power（实现于Umpo.dll库中），系统管理即插即用硬件和电源接口必须用到这两个服务。随后
SCM会注册自己的Autostart WNF状态，该状态用于向Power和其他服务告知当前的自启动阶段。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在可以开始启动其他服务之
前，ScAutoStartService例程会调用ScGetBootAndSystemDriverState来扫描服务数据库，查找“引导启
动”和“系统启动”的设备驱动程序项。ScGetBootAndSystemDriverState会判断启动类型被设置为Boot 
Start或System 
Start的驱动程序是否已成功启动，为此会在设备管理器命名空间目录\Driver下寻找驱动程序的名称。当一个设备驱动程序成功加载时，I/O管理器
会将该驱动程序对象插入该命名空间的这个目录下，因此，如果名称不存在，则意味着驱动程序未加载。图10-15展示了WinObj中显示的Driver目
录内容。ScGetBootAndSystemDriverState会在一个名为ScStoppedDrivers的列表中记录尚未启动，但属于当前配
置文件的驱动程序的名称。稍后在SCM初始化完成后，将使用该列表向系统事件日志记录事件（ID 
7036），其中包含了启动失败的“启动驱动程序”列表。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e2db7c2e5e125a6ecfece3096fd7081f.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-15 驱动程序对象列表</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ScAutoStartServices
中按照正确顺序启动服务的算法是分阶段进行的，每个阶段对应一个组，而不同阶段将按照
HKLM\SYSTEM\CurrentControlSet\Control\ServiceGroupOrder\List注册表值中存储的组排序所
定义的顺序来处理。List值的内容如图10-16所示，其中包含了组的名称，SCM将按照这里的排序来依次启动。因此将服务分配到一个组中，只能微调该
服务的启动，无法影响其他组中的服务。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ac4ba97c3830bebace2a67c5dbde2e28.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-16 ServiceGroupOrder注册表键</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当一个阶段开始时，
ScAutoStartServices会标记属于该阶段对应的组包含的所有服务项，并将其启动。随后ScAutoStartServices会遍历标记
的服务，以确定自己是否可以启动每个服务。这个检查还会判断服务是否被标记为延迟自启动或属于用户模板服务，这两种情况的服务会被SCM在稍后的一个阶段
启动（延迟自启动服务还必须未加入任何组，用户服务详见下文“用户服务”一节）。在这个检查过程中，还需要确定服务是否依赖其他组，这是由服务在注册表键
中的DependOnGroup值确定的。如果存在依赖性，则该服务依赖的另一个组必须已经完成了初始化，并且被依赖的组中至少需要有一个服务已经成功启
动。如果在组的启动顺序中，服务依赖的组是晚于自己所在的组启动的，SCM会为该服务记录一个“循环依赖”的错误信息。如果
ScAutoStartServices所处理的是Windows服务或自动启动的设备驱动程序，那么随后还要检查该服务是否依赖一个或多个其他服务。如
果依赖，那么还要判断被依赖的服务是否已启动。服务的依赖性可通过服务注册表键中的DependOnService值来表示。如果一个服务依赖的其他服务
所属的组在ServiceGroupOrder\List中处于靠后的位置，SCM也会生成“循环依赖”错误并且无法启动该服务。如果一个服务依赖同组中
尚未启动的其他服务，那么该服务的启动将会被跳过。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当服务的依赖性被完全满足
后，在正式启动该服务前，ScAutoStartServices还会进行一次最终检查，以确认该服务是否是当前启动配置的一部分。如果系统以安全模式启
动，SCM会确保该服务无论按照名称或组来看，都处于适合的安全启动注册表键中。安全启动注册表键有两个：Minimal和Network，均位于
HKLM\SYSTEM\CurrentControlSet\Control\SafeBoot下，SCM具体用哪个键来检查，这取决于用户具体选择了
哪种安全模式。如果通过现代或遗留启动菜单选择“安全模式”或“带命令提示符的安全模式”，SCM会使用Minimal键；如果选择“网络安全模式”，
SCM会使用Network键。SafeBoot键下还存在一个名为Option的字符串值，该值不仅表明系统以安全模式启动，还能表明用户选择的安全模
式类型。有关安全启动的详细信息，请参阅第12章的“安全模式”一节。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>服</b><b>务</b><b>启</b><b>动</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SCM决定启动服务后将调
用StartInternal，后者会对服务和设备驱动程序采取不同的操作。如果StartInternal启动的是Windows服务，它首先会确定运
行该服务进程的文件的名称，为此需要从服务的注册表键中读取ImagePath值。如果服务文件与LSASS.exe相对应，SCM将初始化一个控制管
道，连接到已经运行的LSASS进程，并等待LSASS进程的响应。当管道就绪后，LSASS进程会调用经典的
StartServiceCtrlDispatcher例程以连接到SCM。如图10-17所示，一些服务（如凭据管理器或加密文件系统）需要与本地安全
机构子系统服务（LSASS）进行协调，这通常是为了给本地系统策略（如密码、特权、安全审核，详见卷1第7章）执行密码学操作。</span></p><div style="display: block;text-align:center;">
	<img width="585" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/d0a5acae5652284614e898e2ca7f24dd.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-17 有本地安全机构子系统服务（LSASS）进程托管的服务</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后SCM会判断该服务是
否为关键服务（通过分析FailureAction注册表值）或运行在WoW64下（对于32位服务，SCM将应用文件系统重定向，详见第8章
的“WoW64（Windows-on-Windows）”一节）。此外SCM还会检查服务的Type值。如果下列条件适用，SCM还会在内部的映像记录
数据库（Image Record Database）中进行搜索。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·服务Type值包含SERVICE_WINDOWS_SHARE_PROCESS (0x20)。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·服务上次出错后还未重新启动过。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·该服务不允许进行Svchost服务拆分（详见下文“Svchost服务拆分”一节）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">映像记录是一种数据结构，表示一个已经启动，且至少托管了一个服务的进程。如果上述条件适用，SCM会搜索是否存在一个进程可执行文件名称与新服务的ImagePath值相同的映像记录。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果SCM使用与
ImagePath值相同的名称找到了现有的映像数据库记录，则意味着这是一个可共享的服务，并且已经有一个正在运行的托管进程。SCM会保证所找到的托
管进程，其运行账户与打算启动的服务所指定的运行账户相同（这是为了确保服务不会使用错误的账户启动，例如LocalService账户，而是会使用
ImagePath指向的运行中的Svchost，例如通过LocalSystem运行的netsvcs服务）。服务的ObjectName注册表值存储
了运行该服务所需的用户账户信息。不具备ObjectName或ObjectName为LocalSystem的服务会使用Local 
System账户运行。一个进程只能用一个账户登录。因此如果一个服务所指定的运行账户不同于同一个进程中其他服务所用的账户，SCM将会报错。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果映像记录存在，在新服
务可以运行之前，还需要执行另一个最终检查：SCM要打开当前执行中的主机进程的令牌，并检查令牌中是否包含必要的服务SID（以及所有必需的特权是否均
已启用）。即便此时，如果无法验证条件，SCM依然会报错。请注意，正如下一节（“服务登录”）将要介绍的，对于共享的服务，创建令牌时会添加所托管的每
个服务的SID。当令牌已经创建好后，任何用户模式组件均无法向其中添加组SID。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果映像数据库中不包含新
服务ImagePath值对应的项，SCM会创建一个。当SCM创建新项时，会存储服务所用的登录账户名以及来自服务ImagePath值的数据。SCM
要求服务必须具备ImagePath值，如果没有ImagePath值，SCM会报错称找不到服务的路径并且无法启动该服务。当SCM创建了映像记录后，
会登录服务账户并启动新的托管进程（该过程详见下一节“服务登录”的描述）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当服务成功登录并且托管进
程正确启动后，SCM会等待来自服务的初始“连接”消息。服务会通过SCM 
RPC管道（\Pipe\Ntsvcs，详见“服务控制管理器（SCM）”一节）和LogonAndStartImage例程建立的通道上下文数据结构连
接至SCM。当SCM收到第一条消息后，会开始向服务进程发送SERVICE_CONTROL_START控制消息，借此启动服务。请注意，在所描述的通
信协议中，始终是由服务连接到SCM。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">服务应用程序可以借助
StartServiceCtrlDispatcher 
API（详见上文“服务应用程序”一节）中的消息循环顺利处理这条消息。服务应用程序会在自己的令牌中启用服务组SID（如果需要的话），并新建服务线程
（用于执行服务的Main函数）。随后它会回调SCM创建指向新服务的句柄，将该句柄存储在一个内部数据结构
（INTERNAL_DISPATCH_TABLE）中。该数据结构类似于作为输入提供给StartServiceCtrlDispatcher 
API的服务表，可用于跟踪托管进程中的活动服务。如果服务未能在超时时限内对启动命令做出积极响应，SCM将会放弃，并在系统事件日志中记录一条错误，
表明该服务未能及时启动。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果SCM通过调用
StartInternal启动的服务其Type注册表值为SERVICE_KERNEL_DRIVER或
SERVICE_FILE_SYSTEM_DRIVER，则意味着这是一个设备驱动程序，此时StartInternal会为SCM进程启用加载驱动程序
的安全特权，随后调用内核服务NtLoadDriver，并解析驱动程序的注册表键ImagePath值的数据。与服务不同，驱动程序无须指定
ImagePath值，并且如果该值不存在，SCM会将驱动程序的名称附加到字符串%SystemRoot%\System32\Drivers\末尾，
从而构建一个映像路径。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
启动值为SERVICE_AUTO_START或SERVICE_DEMAND_START的驱动程序是由SCM以运行时驱动程序的形式启动的，这意味着
所加载的映像会使用共享页面，并且有一个描述自己的控制区。这与启动值为SERVICE_BOOT_START或
SERVICE_SYSTEM_START的驱动程序完全不同，这些驱动程序由Windows加载器加载，并由I/O管理器启动。这些驱动程序都使用私有
页面，不可共享，也没有相关的控制区。更多信息请参阅卷1第5章。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ScAutoStartServices
会继续循环遍历同一个组的所有服务，直到所有服务均已启动，或者产生了依赖项错误。SCM就是通过这种循环，实现了对一个组中的所有服务按照相应的
DependOnService依赖性进行自动排序。SCM会在循环的早期阶段启动其他服务都依赖的服务，而跳过需要依赖其他服务的服务直到下一次循环再
开始处理。请注意，SCM会忽略Windows服务的Tag值，该值通常位于
HKLM\SYSTEM\CurrentControlSet\Services键的子键中；但是对于“引导启动”以及“系统启动”驱动程序，I/O管理
器则会通过Tag值对一个组中所有设备驱动程序的启动顺序进行排序。当SCM针对ServiceGroupOrder\List值列出的所有服务组完成了
所有阶段的操作后，还会通过一个阶段对该值中未列出组的服务执行操作，随后针对不包含在组中的服务执行最终阶段的操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">处理完自启动的服务后，
SCM会调用ScInitDelayStart，这个函数会将一个延迟工作项加入队列，该工作项所关联的工作线程负责处理所有因为被标记为延迟自启动（通
过DelayedAutostart注册表值）而被ScAutoStartServices跳过的服务。这个工作线程会在延迟结束后开始执行，默认延迟为
120秒，不过可在HKLM\SYSTEM\CurrentControlSet\Control下创建AutoStartDelay值来修改默认延迟。
对于延迟自启动服务，SCM会执行与非延迟自启动服务相同的操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当完成所有自动启动服务和驱动程序的启动，并且设置了延迟自动启动工作项后，SCM会向\BaseNamedObjects\SC_AutoStartComplete事件发送信号。Windows安装程序会使用该事件测量安装过程中的启动进度。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>服</b><b>务</b><b>登</b><b>录</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在启动过程中，如果SCM
未找到任何现有的映像记录，这意味着需要创建托管进程。实际上这意味着新服务是不可共享的、是要被第一个执行的、被重启动了，或这是一个用户服务。在启动
进程前，SCM需要为服务托管进程创建一个访问令牌。LogonAndStartImage函数的主要用途就是创建令牌并启动服务的托管进程。该过程取决
于要启动的服务的类型。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">用户服务（更确切地说是用
户服务实例）是通过检索当前登录用户的令牌（通过UserMgr.dll库中实现的函数）来启动的。在这种情况下，LogonAndStartImage
函数会复制用户令牌并添加“WIN://ScmUserServic”安全特性（该特性的值通常被设置为0）。该安全特性主要被服务控制管理器在接收来自
服务的连接请求时进行验证。虽然SCM可以通过服务SID（或系统账户SID，如果服务以Local 
System账户运行的话）识别托管经典服务的进程，但会使用这个SCM安全特性来识别托管用户服务的进程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于所有其他类型的服务，
SCM会从注册表（ObjectName值）读取用于启动服务的账户，并调用ScCreateServiceSids函数为新进程托管的每个服务创建一个
服务SID（SCM会在自己的内部服务数据库中为每个服务进行循环执行该操作）。请注意，如果服务使用LocalSystem账户运行（不包含受限或非受
限SID），将不执行该步骤。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SCM调用LSASS的
LogonUserExEx函数登录未使用System账户运行的服务。LogonUserExEx通常需要密码，但一般来说，SCM会告知LSASS：
密码是以服务的LSASS“机密”形式存储在HKLM\SECURITY\Policy\Secrets下的注册表键中的（请注意，SECURITY的内
容通常不可见，因为其默认安全设置只允许System账户访问）。当SCM调用LogonUserExEx时，需要指定一个“服务登录”作为登录类型，这
样LSASS即可在“_SC_&lt;Service Name&gt;”形式的名称对应的Secrets子键下查找所需的密码。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 使用虚拟服务账户运行的服务无须密码即可让LSA服务创建服务令牌。对于这种服务，SCM也不会向LogonUserExEx API提供任何密码。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在配置服务的登录信息时，
SCM会指示LSASS使用LsaStorePrivateData函数将登录密码存储为机密。如果登录成功，LogonUserEx会向调用方返回一个
指向访问令牌的句柄。SCM会将必要的服务SID添加到返回的令牌中，并且如果新服务使用了受限SID，还会调用
ScMakeServiceTokenWriteRestricted函数将令牌转换为“写入-限制”令牌（添加相应的受限SID）。Windows会使
用访问令牌来表示用户的安全上下文，随后SCM会将访问令牌关联给实现该服务的进程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">接下来，SCM会创建用户
环境块和安全描述符，并将其关联给新的服务进程。如果要启动的是一个打包的服务，SCM会从注册表读取与程序包有关的所有信息（包全名、来源、应用程序用
户模型ID）并调用Appinfo服务，由该服务使用必要的AppModel安全特性为令牌添加戳记，并让服务进程为现代程序包的激活做好准备（有关
AppModel的详情请参阅第8章的“打包的应用程序”一节）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">成功登录后，SCM会加载
账户的配置文件信息，如果配置文件尚未加载，则会调用用户配置文件基础API 
DLL（%SystemRoot%\System32\Profapi.dll）的LoadProfileBasic函数。
HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\&lt;user 
profile 
key&gt;\ProfileImagePath值包含了LoadUserProfile载入注册表的注册表配置单元在磁盘上的位置，这样配置单元中的
信息即可供服务的HKEY_CURRENT_USER键使用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">下一步，
LogonAndStartImage将继续启动服务的进程。SCM会通过Windows的CreateProcessAsUser函数以暂停状态启动进
程（但使用Local System账户的进程托管服务除外，这类服务是通过标准CreateProcess 
API创建的，SCM已经使用SYSTEM令牌运行，因此不需要其他任何登录）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">进程恢复前，SCM将会创建通信数据结构，借此让服务应用程序和SCM能通过异步RPC进行通信。该数据结构包含一个控制序列、一个指向控制和响应缓冲区的指针、服务和托管进程数据（如PID、服务SID等）、一个同步事件，以及一个指向异步RPC状态的指针。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SCM会通过
ResumeThread函数恢复服务进程，并等待服务连接到自己的SCM管道。注册表值
HKLM\SYSTEM\CurrentControlSet\Control\ServicesPipeTimeout如果存在，将借此确定服务调用
StartServiceCtrlDispatcher函数并建立连接之前的等待时长，超过这个时间后，SCM将放弃，终止进程，并认定服务启动失败（注
意，此时是SCM终止进程，这与上文“服务启动”一节讨论的服务不响应启动请求的情况不同）。如果ServicesPipeTimeout函数不存在，
SCM将使用默认的30秒超时值。SCM会为自己的所有服务通信使用相同的超时值。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_135" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>2</b><b>.</b><b>6</b><b> </b><b>延</b><b>迟</b><b>的</b><b>自</b><b>启</b><b>动</b><b>服</b><b>务</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">延迟的自启动服务使得
Windows可以更好地应对用户登录时需要启动的越来越多的服务，这类服务的增多会减慢系统启动速度，使得用户需要等待更长时间才能获得可快速响应的桌
面。自启动服务这个概念的诞生最初是为了用于需要在系统启动过程的早期就启动的服务，因为其他服务的启动可能需要依赖此类服务，例如RPC服务，所有其他
服务都依赖这个服务。该机制的另一个用途是启动无人值守的服务，例如Windows 
Update服务。因为很多自启动服务都属于第二类，因此将它们延迟启动即可让关键服务启动速度更快，让用户可以在系统启动完毕后立即获得可响应的桌面。
此外，这些服务都运行在后台模式，因此可以使用更低优先级的线程、I/O和内存。将服务配置为延迟自启动需要调用
ChangeServiceConfig2 API。我们可以使用sc.exe的qc选项检查服务的标记状态。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 如果非延迟的自启动服务依赖另一个延迟的自启动服务，那么延迟自启动标记将会被忽略，为满足依赖性，被依赖的服务会被立即启动。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_136" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>2</b><b>.</b><b>7</b><b> </b><b>触</b><b>发</b><b>启</b><b>动</b><b>的</b><b>服</b><b>务</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">有些服务需要在某些系统事
件发生后按需启动。因此Windows 7引入了触发启动的服务（triggered-start 
service）的概念。服务控制程序可以使用ChangeServiceConfig2 
API（通过指定SERVICE_CONFIG_TRIGGER_INFO信息级别）配置按需启动的服务在一个或多个系统事件发生后启动（或停止）。这些
系统事件的部分范例包括：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·特定设备接口被连接到系统。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·计算机加入或离开了域。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·系统防火墙中打开或关闭了某个TCP/IP端口。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·某条计算机或用户策略被更改。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·网络TCP/IP栈的IP地址变为可用或不可用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个RPC请求或命名管道数据包抵达特定的接口。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·系统中生成了某个ETW事件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">触发启动的服务的第一个实
现依赖于统一后台进程管理器（unified background process manager，详见下一节）。Windows 
8.1引入了一种代理（broker）基础架构，其主要目标是针对现代应用管理多种系统事件。因此上文列出的所有这些事件都开始由三个主要的代理负责管
理，这三个代理都是代理基础架构的一部分（Event Aggregation除外），它们分别是Desktop Activity 
Broker（桌面活动代理）、System Event Broker（系统事件代理）以及Event 
Aggregation（事件聚合）。有关代理基础架构的详细信息请参阅第8章的“打包的应用程序”一节。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当
ScAutoStartServices的第一阶段（通常用于启动
HKLM\SYSTEM\CurrentControlSet\Control\EarlyStartServices注册表值中列出的关键服务）操作完
成后，SCM会调用ScRegisterServicesForTriggerAction，该函数负责为每个触发启动的服务注册触发器。该例程会循环遍
历SCM数据库中的每个Win32服务。对于每个服务，该函数会生成一个临时WNF状态名（使用NtCreateWnfStateName原生API），
通过适当的安全描述符提供保护，并将其与作为状态数据存储的服务状态一起发布（WNF架构详见第8章的“Windows通知设施”一节）。该WNF状态名
可用于发布与服务状态有关的变更。随后这个例程会从TriggerInfo注册表键查询所有服务触发器，检查其有效性，并在没有可用触发器时直接跳出。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 上文提到的可支持的触发器列表以及相应的参数详见：https://docs.microsoft.com/windows/win32/api/winsvc/ns-winsvc-service_trigger。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果检查成功，SCM会为
每个触发器构建一个内部数据结构，其中包含了与触发器有关的所有信息（如目标服务名称、SID、代理名称、触发器参数），此外还会根据触发器类型确定正确
的代理，外部设备事件由System Events代理管理，所有其他类型的事件由Desktop 
Activity代理管理。随后，SCM就可以调用相应的代理注册例程。注册过程是私有的，并且取决于具体的代理：针对每个触发器和条件会生成多个私有的
WNF状态名（取决于特定代理）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Event 
Aggregation代理可以看作两个代理发布的私有WNF状态名和服务控制管理器之间的“黏合剂”。它会使用
RtlSubscribeWnfStateChangeNotification 
API订阅触发器对应的所有WNF状态名和条件。在足够数量的WNF状态名收到信号后，Event 
Aggregation即可回调SCM，由SCM启动或停止触发启动的服务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与每个触发器使用WNF状
态名的做法不同，SCM始终会独立地为每个Win32服务发布一个WNF状态名，无论该服务是否注册了触发器。这是因为当特定服务状态产生变化后，SCP
可以调用NotifyServiceStatusChange 
API收到通知，该API订阅了服务的WNF状态名的状态。每当SCM引发改变服务状态的事件后，都会将新的状态数据发布至“服务状态变更”WNF状态，
从而唤醒SCP中运行了状态变更回调函数的线程。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_137" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>2</b><b>.</b><b>8</b><b> </b><b>启</b><b>动</b><b>错</b><b>误</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果驱动程序或服务在响应
SCM的启动命令时报错，那么将由服务注册表键的ErrorControl值决定SCM的回应方式。如果ErrorControl值为
SERVICE_ERROR_IGNORE 
(0)或ErrorControl值未指定，SCM将直接忽略错误信息并继续处理服务的启动。如果ErrorControl值为
SERVICE_ERROR_NORMAL 
(1)，SCM会向系统事件日志写入一条事件称为“&lt;服务名&gt;服务因为下列错误未能启动”。在记录的事件日志中，SCM会列出服务返回给
SCM的Windows错误代码的文本化转换结果，借此告知启动失败的原因。图10-18展示了一条报告服务启动失败的事件日志项。</span></p><div style="display: block;text-align:center;">
	<img width="832" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/78b48e75fcb793019265bddebb3ce124.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-18 服务启动失败后的事件日志项</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果启动时报错服务的
ErrorControl值为SERVICE_ERROR_SEVERE (2)或SERVICE_ERROR_CRITICAL 
(3)，那么SCM会在事件日志中添加一条记录，随后调用内部函数ScRevertToLastKnownGood。该函数会检查最近一次的正确配置
（last known 
good）功能是否启用，如果启用，则会将系统的注册表配置切换为“最近一次的正确配置”版本，其中包含系统最近一次正确启动时所用的配置。随后SCM会
使用NtShutdownSystem系统服务（实现于执行体中）重启系统。如果系统已经使用最近一次的正确配置启动，或最近一次的正确配置功能未启用，
那么SCM除了记录一条日志事件，将不执行其他任何操作。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_138" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>2</b><b>.</b><b>9</b><b> </b><b>接</b><b>受</b><b>启</b><b>动</b><b>和</b><b>最</b><b>近</b><b>一</b><b>次</b><b>的</b><b>正</b><b>确</b><b>配</b><b>置</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了启动服务，系统还依赖
SCM决定在什么时候将系统的注册表配置HKLM\SYSTEM\CurrentControlSet保存为“最近一次的正确配置”。
CurrentControlSet键中包含了作为子键的Services键，因此CurrentControlSet也包含了SCM数据库在注册表中的
内容。此外，它还包含Control键，其中存储了很多内核模式和用户模式的子系统配置设置。默认情况下，系统的成功启动也意味着自启动服务均已成功启
动，并且用户成功登录。如果由于系统启动过程中设备驱动程序崩溃导致系统挂起，或ErrorControl值为SERVICE_ERROR_SEVERE
或SERVICE_ERROR_CRITICAL的自动启动服务报错，则意味着系统启动失败。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">客户端版本的
Windows通常会禁用最近一次正确配置功能。若要启动该功能，请将
HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Configuration 
Manager\LastKnownGood\Enabled注册表值设置为1。在服务器版本的Windows中，该设置的默认值就是1。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SCM知道自己何时成功启
动了自启动服务，但必须由Winlogon（%SystemRoot%\System32\Winlogon.exe）告知登录是否成功。用户登录时，
Winlogon会调用NotifyBootConfigStatus函数，并借此向SCM发送消息。当成功启动了自启动服务，或收到来自
NotifyBootConfigStatus的消息后（以较晚满足的情况为准），如果最近一次正确配置功能已启用，SCM会调用系统函数
NtInitializeRegistry保存当前的注册表启动配置。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">第三方软件开发者可以用自
己的定义取代Winlogon中对于“成功登录”的定义。例如，运行Microsoft SQL Server的系统只有在SQL 
Server可以成功接受并处理事务后才可以视为成功启动。开发者可以通过编写一个启动验证程序，并将注册表键
HKLM\SYSTEM\CurrentControlSet\Control\BootVerificationProgram存储的值指向这个验证程
序在磁盘上的位置（这等于安装了这个验证程序），从而设置自己对于“成功启动”的定义。此外，这种启动验证程序的安装必须禁用Winlogon对
NotifyBootConfigStatus的调用，为此可将HKLM\SOFTWARE\Microsoft\Windows 
NT\CurrentVersion\Winlogon\ReportBootOk注册表键设置为0。在安装启动验证程序后，SCM会在完成自动启动服务
的启动工作后运行该验证程序，并等待程序调用NotifyBootConfigStatus，随后存储最近一次正确配置。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows维护了
CurrentControlSet的多个副本，而CurrentControlSet实际上是一个指向其中一个副本的注册表符号链接。这些
ControlSet（控制集）的名称类似于HKLM\SYSTEM\ControlSetnnn，其中“nnn”是001、002这样的编号。
HKLM\SYSTEM\Select键包含的值决定了每个控制集的角色。举例来说，如果CurrentControlSet指向
ControlSet001，那么Select下的Current值就是1。Select下的LastKnownGood值包含了最近一次正确配置对应的
编号，这也是最近一次成功启动系统所用的配置。系统中的Select键可能还会包含另一个值：Failed，这样的值指向了系统最近一次未能成功启动时所
使用的配置集，随后系统放弃该配置集并使用最近一次正确配置，然后成功启动了。图10-19展示了Windows 
Server的系统控制集和Select值。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/665841e5f368d92200717c69d2505579.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-19 Windows Server 2019上的控制集选择键</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NtInitializeRegistry
函数获取最近一次正确配置集的内容，并将其与CurrentControlSet键的树进行同步。如果系统是首次成功启动，此时将不存在最近一次正确配
置，系统将为其新建一个控制集。如果最近一次正确配置树存在，则系统将使用该配置与CurrentControlSet之间的差异对其进行更新。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最近一次正确配置在某些情
况下非常有用，例如对CurrentControlSet的改动（如为了优化性能而更改了HKLM\SYSTEM\Control下的值，或增添了服务或
设备驱动程序）导致后续启动无法成功时。图10-20展示了现代启动菜单的“启动设置”。实际上，在启用最近一次正确配置功能，并且系统正在启动过程中的
情况下，用户可以通过现代启动菜单（或在Windows恢复环境中）的“故障排查”选项选择“启动设置”，随后即可通过选项，用最近一次正确配置控制集来
启动系统。（如果系统依然使用了旧版的启动菜单，用户可以按下F8并选择“高级启动选项”）。如图所示，在选中“启用最近一次的正确配置”选项后，系统在
启动时会将注册表配置回滚为最近一次成功启动时的配置。第12章将详细介绍现代启动菜单、Windows恢复环境，以及可对系统启动问题进行排错的其他恢
复机制。</span></p><div style="display: block;text-align:center;">
	<img width="696" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a7e07a4877577734b7ac51938d59ebcc.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-20 启用最近一次正确配置</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_139" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>2</b><b>.</b><b>1</b><b>0</b><b> </b><b>服</b><b>务</b><b>故</b><b>障</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">服务的注册表键中可能包含
可选的FailureActions值和FailureCommand值，SCM会在服务的启动过程中记录这些值。SCM会与系统注册，这样，当服务进程
退出时，系统就会向SCM发出信号。当服务进程意外终止时，SCM会判断该进程中运行了哪些服务，并采取与故障相关的注册表值所指定的恢复步骤。此外，服
务不仅会因为崩溃或意外终止而出现故障，其他问题（如内存泄漏）也可能导致服务出现故障。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果服务进入
SERVICE_STOPPED状态并且返回给SCM的错误代码并非ERROR_SUCCESS，SCM会检查该服务是否设置了
FailureActionsOnNonCrashFailures标记，并会像服务崩溃后那样执行相同的恢复操作。为了使用该功能，必须通过
ChangeServiceConfig2 
API配置服务，系统管理员也可以使用Sc.exe工具配合Failureflag参数将
FailureActionsOnNonCrashFailures设置为1。如果使用默认值0，SCM将继续为所有其他服务沿袭旧版本Windows中
相同的行为。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">服务可以为SCM配置的操
作包括重启动服务、运行某个程序、重启动计算机。此外，服务还可以分别为第一次、第二次和后续的失败指定不同的恢复操作。如果需要重启动服务，还可以让
SCM在重启动之前等待一定的时间。我们可以在服务MMC控制台中使用服务“属性”对话框的“恢复”选项卡灵活设置恢复选项，如图10-21所示。</span></p><div style="display: block;text-align:center;">
	<img width="621" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3d64a975ca9afe3c2e348f3928f1d448.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-21 服务恢复选项</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">请注意，如果下一个恢复操
作是重启动计算机，那么在启动服务后，SCM会使用ProcessBreakOnTermination信息类调用
NtSetInformationProcess原生API，将服务的托管进程标记为关键进程。如果关键进程意外终止，会导致系统崩溃并进行
CRITICAL_PROCESS_DIED这个Bug检查（详见卷1第2章）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_140" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>2</b><b>.</b><b>1</b><b>1</b><b> </b><b>服</b><b>务</b><b>关</b><b>闭</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">当Winlogon调用
Windows的ExitWindowsEx函数时，该函数会向Windows子系统进程Csrss发送一条消息，借此调用Csrss的关闭例程。
Csrss会循环遍历活动进程，告知它们系统即将关闭。对于除SCM外的其他每个系统进程，Csrss会等待进程退出，该等待时间的毫秒数由
HKCU\Control 
Panel\Desktop\WaitToKillTimeout定义（默认为5秒），随后会继续处理下一个进程。在遇到SCM进程后，Csrss也会通
知它系统即将关闭，但此时的超时值是专门针对SCM而设的。Csrss会使用SCM在自己初始化期间使用RegisterServicesProcess
函数向Csrss注册并保存的进程ID来识别SCM。SCM的超时值不同于其他进程，原因在于Csrss知道SCM需要负责与其他需要在关闭前进行清理的
服务通信，因此管理员可能只需要调整SCM的超时值。SCM的超时值可以用毫秒数为单位通过
HKLM\SYSTEM\CurrentControlSet\Control\WaitToKillServiceTimeout注册表值设置，默认为
20秒。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SCM的关闭处理程序负责
向与SCM注册时请求了关闭通知的所有服务发送关闭通知。SCM的ScShutdownAllServices函数首先会查询
HKLM\SYSTEM\CurrentControlSet\Control\ShutdownTimeout的值（默认为20秒，该值不存在时将使用
默认设置）。随后会循环遍历SCM服务数据库，对于每个服务，会取消注册最终的服务触发器，并判断该服务是否希望收到关闭通知，如果是，则会发送关闭命令
（SERVICE_CONTROL_SHUTDOWN）。请注意，所有通知会使用线程池工作线程并行发送给服务。对于发出了关闭命令的每个服务，SCM会
记录该服务的等待提示（wait 
hint）值，服务在向SCM注册时可以指定该值。SCM会跟踪自己所收到的最大的等待提示（如果计算而来的等待提示最大值依然小于注册表中
ShutdownTimeout指定的Shutdown超时值，那么Shutdown超时值会被作为最大等待提示）。发出关闭消息后，SCM会一直等待，
直到自己通知关闭的所有服务均已退出，或最大等待提示所指定的时段已结束。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当SCM正忙着通知服务即
将关闭并等待服务退出时，Csrss也在等待SCM退出。如果等待提示已过期但还有服务未退出，此时SCM将会退出，Csrss会继续进行关闭过程。如果
Csrss的等待已结束但SCM还未退出（WaitToKillServiceTimeout时间到期），Csrss将终止SCM并继续关闭过程。因此无
法及时关闭的服务最终将会被终止。这个逻辑使得系统在存在某些因设计缺陷而无法正常关闭的服务情况下，依然能够正常关闭，但同时这也意味着需要5秒以上时
间的服务将无法完成正常的关闭操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，因为关闭顺序是不确定的，一个服务可能需要依赖另一个服务才能关闭，但被依赖的服务可能被先关闭了（这称为关闭依赖性），此时该服务将无法向SCM报告，可能也没机会进行清理。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了解决这种问题，
Windows实现了预关闭通知（Preshutdown 
notification）和关闭排序机制，借此可以避免出现上文提到的两种情况。预关闭通知会发送给通过SetServiceStatus 
API（使用SERVICE_ACCEPT_PRESHUTDOWN接受的控制）请求过该功能的服务，而具体的通知机制与原本的关闭通知相同。预关闭通知
会在Wininit退出前发出。SCM通常会等待这种通知被确认。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这类通知背后的理念在于，
标记出可能需要更长清理时间的服务（如数据库服务器服务），并给这些服务留出更多时间完成自己的工作。SCM会发送一个进度查询请求，并等待10秒让服务
对该通知做出响应。如果服务没能及时响应，那么会在关闭过程中被终止；如果响应，那么只要继续回应SCM，就可以一直继续运行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">注册了预关闭通知的服务还
可以指定自己相较于其他注册了预关闭通知服务的关闭顺序。如果一个服务需要依赖另一个服务才能关闭（如组策略服务需要等待Windows 
Update服务的完成），即可在HKLM\SYSTEM\CurrentControlSet\Control\PreshutdownOrder注册
表值中指定自己的关闭依赖性。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_141" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>2</b><b>.</b><b>1</b><b>2</b><b> </b><b>共</b><b>享</b><b>服</b><b>务</b><b>进</b><b>程</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">用专用进程运行每个服务，而不是尽可能让多个服务共享同一个进程，会导致系统资源的浪费。然而共享进程意味着如果进程中的任何一个服务出现了会导致进程退出的Bug，该进程中的所有服务都将终止。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows的自带服务
有些运行在自己的进程中，有些与其他服务共享进程。例如，LSASS进程中就包含了很多与安全性有关的服务，如安全账户管理器（SamSs）服务、网络登
录（Netlogon）服务、加密文件系统（EFS）服务，以及下一代加密（CNG）密钥隔离（KeyIso）服务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">另外还有一个名为
Service 
Host（SvcHost，%SystemRoot%\System32\Svchost.exe）的通用进程包含了很多服务，同时SvcHost的多个
实例会以不同的进程运行。通过SvcHost进程运行的服务包括电话（TapiSrv）、远程过程调用（RpcSs），以及远程访问连接管理器
（RasMan）等。Windows会将运行在SvcHost中的服务以DLL形式实现，并会在服务的注册表键中包含一个ImagePath定义，其具体
形式为%SystemRoot%\System32\svchost.exe –k 
netsvcs。这些服务的注册表键中还必须在Parameters子键下包含一个名为ServiceDll的值，其数值指向服务的DLL文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">所有共享同一个
SvcHost进程的服务需要指定相同的参数（例如上文例子中的–k 
netsvcs），这样它们才能在SCM的映像数据库中使用同一个项。当SCM在服务启动过程中遇到第一个具备特定SvcHost 
ImagePath参数的服务时，它会新建一个映像数据库项，并使用这些参数启动一个SvcHost进程。用-k开关指定的参数将成为整个服务组的名称。
在创建新的共享托管进程时，SCM将解析整个命令行的内容。正如“服务登录”一节所述，如果数据库中的其他服务共享相同的ImagePath值，其服务
SID会被加入新建的托管进程的组SID列表中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">新建的SvcHost进程
会接收命令行中指定的服务组，并在HKLM\SOFTWARE\Microsoft\Windows 
NT\CurrentVersion\Svchost下查找具备相同名称的值。SvcHost会读取该值的内容，将其解析为一个服务名称列表，并在
SvcHost向SCM注册时通知SCM自己托管了这些服务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当SCM在服务启动过程中
遇到另一个共享服务（通过检查服务的Type值），并且该服务的ImagePath与自己映像数据库中现有的项匹配，此时就不需要再启动另一个进程，而是
可以直接将该服务的启动命令发送给自己针对相同ImagePath值已经启动的SvcHost进程。现有SvcHost进程读取服务注册表键中的
ServiceDll参数，在自己的令牌中启用新服务组SID，并将DLL载入自己的进程即可启动新的服务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">表10-12列出了Windows中的所有默认服务组，以及为每个服务组注册的部分服务。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表10-12 主要的服务组</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/df2ed0152dcbcdb9593326461f1b6f37.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/6be882bc4e2abb04195014fee97fd719.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>S</b><b>v</b><b>c</b><b>h</b><b>o</b><b>s</b><b>t</b><b>服</b><b>务</b><b>拆</b><b>分</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，通过一个共享
的托管进程运行多个服务可以节约系统资源，但一个很大的不足之处在于：一个服务中出现未能妥善处理的错误就可能导致托管进程中的所有其他服务被终止。为了
解决此问题，Windows 10创作者更新（RS2）引入了Svchost服务拆分（Svchost service splitting）功能。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当SCM启动时，会从注册
表读取三个值，这三个值表示服务的全局提交限制（分为低上限、中上限、硬上限）。当系统内存不足时，SCM会使用这些值来发送“资源不足”消息。随后
SCM会从HKLM\SYSTEM\CurrentControlSet\Control\SvcHostSplitThresholdInKB注册表值
中读取Svchost服务拆分阈值。该值决定了当系统物理内存的最小数量（以KB为单位）达到多少时才会启用Svchost服务拆分（客户端系统的默认值
为3.5GB，服务器系统的默认值为大约3.7GB）。随后，SCM会使用GlobalMemoryStatusEx 
API获取系统物理内存总数，并将其与之前从注册表中读取的阈值进行比较。如果物理内存总数高于阈值，就会（通过设置一个内部全局变量）启用
Svchost服务拆分。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">启用Svchost服务拆
分后，会修改SCM为共享服务启动Svchost托管进程时的行为。如上文“服务启动”一节所述，如果一个服务允许进行拆分，SCM将不在自己的数据库中
搜索现有映像记录。这意味着尽管服务被标记为共享，但依然会用私有的托管进程来启动（并且服务类型会变为
SERVICE_WIN32_OWN_PROCESS）。只有在符合下列情况时，才允许进行服务拆分。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Svchost服务拆分被全局启用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·服务未被标记为关键服务。如果一个服务的下一次恢复操作被设置为重启动计算机，那么这样的服务就被视作关键服务（详见上文“服务故障”一节的介绍）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·服务托管进程的名称为Svchost.exe。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·未通过服务控制键中的SvcHostSplitDisable注册表值明确禁用服务拆分。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内存管理器提供的内存压缩
与合并等技术有助于尽可能节约系统工作集。这也解释了Svchost服务拆分功能背后的一个动机。就算在系统中新建了很多进程，内存管理器也可以保证托管
进程的所有物理页面依然处于共享状态，尽可能减少对系统资源的用量。内存合并、压缩以及内存共享等机制请参阅卷1第5章。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>操</b><b>作</b><b>S</b><b>v</b><b>c</b><b>h</b><b>o</b><b>s</b><b>t</b><b>服</b><b>务</b><b>拆</b><b>分</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如
果使用具备至少4GB内存的Windows 
10工作站，在打开任务管理器后可能会注意到目前正在执行大量Svchost.exe进程实例。如上文所述，这并不会造成内存浪费的问题，但可能有人会想
知道该如何禁用Svchost拆分。首先请打开任务管理器并统计系统中当前运行的Svchost进程实例数量。在Windows 
10的2019年5月更新（19H1）版本中，应该有大约80个Svchost进程实例。我们可以用管理员身份打开PowerShell窗口，并运行下列
命令轻松统计出确切数字：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">(get-process -Name "svchost" | measure).Count </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在示例所用的系统中，上述命令返回的结果是85个。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">打
开注册表编辑器（在搜索框中输入regedit.exe）并打开HKLM\SYSTEM\CurrentControlSet\Control键。请记录
SvcHostSplitThresholdInKB这个DWORD值的当前数据。要全局禁用Svchost服务拆分，我们需要将该注册表值的数据修改为
0（双击该注册表值，并输入0即可修改）。修改结束后重启动系统并重新统计Svchost进程实例的数量。发现此时系统运行的实例数量少了很多：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PS C:\&gt; (get-process -Name "svchost" | measure).Count </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">26 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">要恢复至修改前的状态，请将SvcHostSplitThresholdInKB注册表值的数据还原。通过修改这个DWORD值，我们还可以进一步优化，决定当系统中的物理内存数量达到多少后才可以启用Svchost拆分。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_142" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>2</b><b>.</b><b>1</b><b>3</b><b> </b><b>服</b><b>务</b><b>标</b><b>签</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">使用服务托管进程的另一个
不足之处在于：更加难以按照不同服务核算CPU时间和用量以及其他资源的用量，因为很多服务都与同一个服务组中的其他服务共享了内存地址空间、句柄表，以
及每进程CPU数目。虽然在服务托管进程中始终有一个线程是属于某个特定服务的，但这种关联可能并不总是那么容易建立。例如，服务可能会使用工作线程执行
操作，或者线程的起始地址和栈无法揭示服务的DLL名称，这就很难确定一个线程正在做什么工作，以及这个线程到底属于哪个服务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows实现了一种
名为服务标签（service 
tag）的服务特性（请勿将其与驱动程序标记混淆），在创建新服务或系统启动过程中生成服务数据库时，SCM会调用
ScGenerateServiceTag生成服务标签。该属性实际上是一种识别服务的索引。服务标签存储在每个线程的线程环境块（TEB）中的
SubProcessTag字段内（有关TEB的详细信息请参阅卷1第3章），会被传播给主服务线程创建的所有线程（由线程池API间接创建的线程除
外）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然服务标签保存在SCM
内部，但很多Windows工具（如Netstat.exe，可显示每个程序打开了哪些网络端口）可使用未公开的API查询服务标签，并将其映射到服务名
称。此外还可以通过其他工具查看服务标签，例如Winsider Seminars &amp; Solutions 
Inc.提供的ScTagQuery（www.winsiderss.com/tools/sctagquery/sctagquery.htm）。该工
具可以向SCM查询每个服务标签的映射关系，随后显示整个系统或每进程范围的查询结果。该工具还可以告诉我们一个服务托管进程中的所有线程都分属哪个服务
（前提是这些线程关联了相应的服务标记）。借此，如果有一个失控的服务耗费了大量CPU时间，在通过线程的起始地址或堆栈无法直观了解该线程所关联的
DLL情况下，我们依然可以揪出“罪魁祸首”。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_143" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>2</b><b>.</b><b>1</b><b>4</b><b> </b><b>用</b><b>户</b><b>服</b><b>务</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如“用备选账户运行服
务”一节所述，我们可以使用本地系统中的用户账户运行服务。这样配置的服务将始终使用指定的用户账户运行，无论该用户当前是否已登录。但在多用户环境中，
这可能会造成一些局限，因为服务会使用当前登录用户的访问令牌来执行。此外，这也可能将所用的用户账户置于风险中，因为恶意用户将可能注入服务进程，并使
用服务令牌访问自己本不应访问的资源（也将可以通过网络进行身份验证）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">从Windows 
10创作者更新（RS2）开始，用户服务（user 
service）功能可以让服务使用当前已登录用户的令牌运行。用户服务可以通过自己的进程运行，或者可以像标准服务那样，与使用同一个已登录用户账户运
行的其他服务共享同一个进程。当用户执行交互式登录时，这些服务会被启动；用户注销后，服务也会停止。SCM内部支持两个额外的类型标记：
SERVICE_USER_SERVICE (64)和SERVICE_USERSERVICE_INSTANCE 
(128)，这两个标记用于识别用户服务模板和用户服务实例。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在发起交互式登录后，将执
行Winlogon有限状态机的一个状态（有关Winlogon和启动过程的详细信息，请参阅第12章）。该状态会新建一个用户登录会话、窗口站、桌面以
及环境，并映射HKEY_CURRENT_USER注册表配置单元，同时会向登录订阅方（LogonUI和用户管理器）发出通知。用户管理器服务
（Usermgr.dll）可通过RPC调用SCM以交付WTS_SESSION_LOGON会话事件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SCM会通过ScCreateUserServicesForUser函数处理该消息，这个函数会回调到用户管理器以获取当前登录用户的令牌，随后会从SCM数据库查询用户模板服务列表，并为每个模板生成新的用户实例服务名称。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>见</b><b>证</b><b>用</b><b>户</b><b>服</b><b>务</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">内
核调试器可以轻松显示出进程令牌的安全属性。在本实验中，我们需要一台启用了内核调试器的Windows 
10计算机，并连接到主机（本地调试也可以）。在该实验中，我们将选择一个用户服务实例并分析其托管进程的令牌。请打开服务工具（在搜索框中输入“服
务”），随后可以看到标准服务以及用户服务实例（尽管它错误地将Local 
System显示为一个用户账户），这些实例很容易区分，因为其显示名中带有一个本地唯一ID（LUID，由用户管理器生成）。在本例中，
Connected Device User Service就会被“服务”工具显示为Connected Device User 
Service_55d01。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">双
击这样的服务，随后可以看到用户服务实例的真实名称（本例中为CDPUserSvc_55d01）。如果该服务运行在共享进程中，例如本例中选择的这个服
务，那么可以使用注册表编辑器打开用户服务模板的服务根键，其中会显示与实例相同的名称，但不包含LUID（本例的用户服务模板名称为
CDPUserSvc）。正如在“查看服务所需的特权”实验中解释的那样，Service 
DLL名称会存储在Parameters子键下。在Process 
Explorer中可以使用DLL名称找到正确的托管进程ID（或在最新版的Windows 10中可以直接使用任务管理器找到）。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b3455779f7d8872c5080f8e3ddcbec46.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">找到托管进程的PID后，需要进入内核调试器并运行下列命令（请将&lt;ServicePid&gt;替换为服务托管进程的PID）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">!process &lt;ServicePid&gt; 1 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">调试器会显示很多信息，其中包含相关联的安全令牌对象的地址：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Kd: 0&gt; !process 0n5936 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Searching for Process with Cid == 1730 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PROCESS ffffe10646205080 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    SessionId: 2 Cid: 1730 Peb: 81ebbd1000 ParentCid: 0344 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    DirBase: 8fe39002 ObjectTable: ffffa387c2826340 HandleCount: 313. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Image: svchost.exe </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    VadRoot ffffe1064629c340 Vads 108 Clone 0 Private 962. Modified 214. Locked 0.</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    DeviceMap ffffa387be1341a0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Token                           ffffa387c2bdc060 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ElapsedTime                     00:35:29.441 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;Output omitted for space reasons&gt; </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">要查看令牌的安全属性，我们需要使用!token命令，后跟上一条命令得到的令牌对象地址（在内部，令牌对象会表示为一种_TOKEN数据结构）。只要看到WIN://ScmUserService安全特性，即可轻松确认该进程托管了用户服务，如下列输出结果所示：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0: kd&gt; !token ffffa387c2bdc060 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">_TOKEN 0xffffa387c2bdc060 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">TS Session ID: 0x2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">User: S-1-5-21-725390342-1520761410-3673083892-1001 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">User Groups: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> 00 S-1-5-21-725390342-1520761410-3673083892-513 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Attributes - Mandatory Default Enabled </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">... &lt;Output omitted for space reason&gt; ... </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">OriginatingLogonSession: 3e7 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PackageSid: (null) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">CapabilityCount: 0      Capabilities: 0x0000000000000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">LowboxNumberEntry: 0x0000000000000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Security Attributes: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> 00 Claim Name   : WIN://SCMUserService </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Claim flags: 0x40 - UNKNOWN </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Value Type   : CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Value Count: 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Value[0]   : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> 01 Claim Name   : TSA://ProcUnique </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Claim flags: 0x41 - UNKNOWN </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Value Type   : CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Value Count: 2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Value[0]   : 102 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Value[1]   : 352550 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">Process Hacker是一款与Process Explorer类似的工具，下载地址为https://processhacker.sourceforge.io/，我们可以借助该工具提取相同的信息。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如
上文所述，用户服务实例的名称是将服务的原名称与用户管理器为了识别用户的交互式会话（内部称之为上下文ID）所生成的本地唯一ID（LUID）结合在一
起生成的。交互式登录会话的上下文ID存储在易失的HKLM\SOFTWARE\Microsoft\Windows 
NT\CurrentVersion\Winlogon\VolatileUserMgrKey\&lt;Session 
ID&gt;\&lt;User SID&gt;\contextLuid注册表键中，其中&lt;Session ID&gt;和&lt;User 
SID&gt;表示登录会话ID和用户SID。如果在注册表编辑器中打开该键，则会发现与生成用户服务实例名称所用相同的上下文ID值。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图10-22展示了
Clipboard User 
Service这个用户服务实例的范例，该服务使用当前登录用户的令牌运行。根据用户管理器的易失注册表键（详见上一个实验）可知，为会话1生成的上下文
ID为0x3a182。随后，SCM会调用ScCreateService，借此在SCM数据库中创建服务记录。新服务记录表示这个新的用户服务实例，会
与常规服务一样保存到注册表中。服务安全描述符、所有依赖的服务及触发器信息则可从用户服务模板复制到新的用户服务实例。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/07fcbdad2f9ad7dd137e4fa49391d7a1.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-22 在上下文ID 0x3a182中运行的Clipboard User Service实例</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SCM会注册最终服务触发
器（详见上文“触发启动的服务”一节），随后启动该服务（如果其启动类型被设置为SERVICE_AUTO_START），根据“服务登录”一节的介绍，
当SCM启动托管用户服务的进程时，会分配当前登录用户的令牌以及SCM所使用的WIN://ScmUserService安全特性，借此确认该服务确实
托管了服务。如图10-23所示，当用户登录到系统后，实例和模板子键都会存储在表示同一个用户服务的服务根键中。用户注销时，实例子键会被删除，如果系
统启动时该子键依然存在，则会被忽略。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/abf6277f263eb1343e4f0c3a9fa7cdf6.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-23 用户服务实例和模板注册表键</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_144" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>2</b><b>.</b><b>1</b><b>5</b><b> </b><b>打</b><b>包</b><b>的</b><b>服</b><b>务</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如上文“服务登录”一节
所述，从Windows 10创作者更新（RS1）开始，服务控制管理器就已支持打包的服务（packaged 
service）。打包的服务可通过服务类型中设置的SERVICE_PKG_SERVICE 
(512)标记进行区分。在设计上，打包的服务主要是为了支持标准Win32桌面应用程序（可能会配合相关服务一起运行）转换而来的全新现代应用程序模
型。桌面应用程序转换器可将Win32应用程序转换为Centennial应用，通过一个轻量级容器（内部称为Helium）运行。有关现代应用程序模型
的更多信息请参阅第8章的“打包的应用程序”一节。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在启动打包的服务时，
SCM会从注册表读取程序包信息，随后和标准的Centennial应用程序一样，会调用AppInfo服务。后者会验证程序包信息是否存在于状态存储库
中，并验证应用程序所有程序包文件的完整性。接着AppInfo服务会使用正确的安全特性为新服务的托管进程令牌添加戳记。接着使用
CreateProcessAsUser API（以及Package Full 
Name特性）以暂停状态启动进程并创建Helium容器，由这个容器像处理常规Centennial应用程序那样为打包的服务应用注册表重定向和虚拟文
件系统（VFS）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_145" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>2</b><b>.</b><b>1</b><b>6</b><b> </b><b>受</b><b>保</b><b>护</b><b>服</b><b>务</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">卷1第3章详细介绍了受保
护进程以及轻量级受保护进程（Protected Processes Light，PPL）的架构。Windows 
8.1的服务控制管理器还为受保护服务提供了支持。截至撰写这部分内容，服务可以获得Windows、Windows 
light（Windows轻型）、Antimalware 
light（反恶意软件轻型）以及App（应用）四个级别的保护。服务控制程序可以使用ChangeServiceConfig2 
API（配合SERVICE_CONFIG_LAUNCH_PROTECTED信息级别）指定为服务提供的保护。服务的重要可执行文件（或共享服务的库）
必须具备正确的签名才能以受保护服务的方式运行，并且需要遵循与受保护进程相似的规则（意味着系统会检查数字签名的EKU和根证书，进而生成最大签名方级
别，详见卷1第3章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">以受保护形式启动的服务托管进程，可保证相对其他非受保护进程获得某种形式的保护。其他进程在试图访问受保护服务的托管进程时，基于保护级别，将无法获得某些访问权限（该机制与标准受保护进程完全相同，一个最典型的例子是：非受保护进程无法向受保护进程注入任何代码）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">即便使用SYSTEM账户
启动的进程也无法访问受保护进程。不过SCM依然能够完整访问受保护服务的托管进程。因此Wininit.exe在启动SCM时会指定用户模式最大保护级
别：WinTcb Light（WinTcb轻型）。图10-24展示了SCM主可执行文件services.exe的数字签名，其中包括Windows
 TCB组件EKU（1.3.6.1.4.1.311.10.3.23）。</span></p><div style="display: block;text-align:center;">
	<img width="587" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/21097b0f20ed93c9861488228bcab4d8.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-24 服务控制管理器主可执行文件（services.exe）的数字签名</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">第二层保护由服务控制管理
器提供。当客户端请求对受保护服务执行某个操作时，SCM会调用ScCheckServiceProtectedProcess例程，借此检查调用方是否
有足够的访问权限针对目标服务执行所请求的权限。表10-13列出了非受保护进程向受保护服务发出请求时会被拒绝的操作。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">表10-13 从非受保护客户端向受保护服务发出请求后的被拒绝操作列表</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/06474f11cf619efa1a48063f24c2ac99.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ScCheckServiceProtectedProcess函数会在调用方指定的服务句柄中查找服务记录，如果服务不受保护，则会授予访问权。如果服务受保护，则会模拟客户端进程令牌，获取服务保护级别，然后实施下列规则。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果请求的是一个STOP控制请求并且目标服务并未受到Antimalware级别的保护，将允许访问（Antimalware级别的受保护服务无法被非受保护进程停止）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果客户端的令牌组中包含TrustedInstaller服务SID，或客户端被设置为令牌用户，SCM会忽略客户端的进程保护状态允许访问。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
否则会调用RtlTestProtectedAccess，由后者执行与受保护进程相同的检查。只有在客户端进程具备与目标服务兼容的保护级别时才会允许
访问。例如，受保护的Windows进程始终可以针对所有保护级别的服务执行操作，而反恶意软件PPL只能针对Antimalware和App级别的受保
护服务执行操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">需要注意的是，对于任何以
TrustedInstaller虚拟服务账户运行的客户端进程，都不会进行上述最后一项检查。这是设计使然。当Windows 
Update安装更新时，需要能够启动、停止并控制任何类型的服务，而不要求自己必须具备强数字签名（这种要求会让Windows 
Update暴露在本不该存在的攻击面下）。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter10_0003.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_146" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>3</b><b> </b><b>任</b><b>务</b><b>计</b><b>划</b><b>和</b><b>U</b><b>B</b><b>P</b><b>M</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">随着操作系统的功能逐渐复
杂化，很多原本负责管理托管任务或后台任务的Windows组件（如上文介绍的服务控制管理器，以及DCOM服务器启动器和WMI提供程序）都开始负责执
行进程外托管代码。虽然现代版本Windows会使用后台代理基础架构（background broker 
infrastructure）管理现代应用程序的大部分后台任务（详见第8章），但任务计划程序（task 
scheduler）依然是管理Win32任务的主要组件。Windows实现了一个统一后台进程管理器（Unified Background 
Process Manager，UBPM），由它处理任务计划程序所管理的任务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">任务计划程序服务实现于
Schedsvc.dll库中，通过一个共享的Svchost进程运行。任务计划程序服务维护了任务数据库并托管了UBPM，UBPM则负责启动和停止任
务，并管理任务的操作和触发器。当生成了任务触发器后，UBPM可使用由桌面活动代理（Desktop Activity 
Broker，DAB）、系统事件代理（System Events Broker，SEB）以及资源管理器（resource 
manager）提供的服务接收相关通知（DAB和SEB都托管于系统事件代理服务中，而资源管理器托管于代理基础架构服务中）。任务计划程序和UBPM
都通过RPC提供了公开的接口。外部应用程序可以使用COM对象附加至这些接口并与常规Win32任务交互。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_147" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>3</b><b>.</b><b>1</b><b> </b><b>任</b><b>务</b><b>计</b><b>划</b><b>程</b><b>序</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">任务计划程序实现了任务存
储，借此保存每个任务。它还托管Scheduler 
idle（计划程序闲置）服务，借此可检测系统何时进入或离开闲置状态，此外还有事件陷阱提供程序，可以帮助任务计划程序在计算机状态发生变化时启动任
务，并提供了内部事件日志触发系统。任务计划程序还包含另一个组件：UBPM代理（UBPM 
proxy），该组件可收集所有任务的操作和触发器，将其描述符转换成一种UBPM可理解的格式，随后发送给UBPM。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图10-25展示了任务计
划程序的架构概览。如图所示，任务计划程序与UBPM深度配合（两者的组件均运行在任务计划程序服务中，该服务通过一个共享的Svchost.exe进程
运行）。UBPM负责管理任务状态，并通过WNF状态接收来自SEB、DAB以及资源管理器的通知。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">任务计划程序的一个重要工
作是公开COM任务计划程序API的服务器部分。当任务控制（task control）程序调用这种API时，COM引擎会将任务计划程序COM 
API库（Taskschd.dll）载入应用程序的地址空间。该库会代表任务控制程序，通过RPC接口向任务计划程序请求服务。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/c12b9343b73d11fe24d6008b13e8b4f6.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-25 任务计划程序架构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通过类似的方式，任务计划
程序WMI提供程序（Schedprov.dll）实现的COM类和方法可用于与任务计划程序COM 
API库通信。其WMI类、属性和事件可通过Windows PowerShell使用ScheduledTasks 
cmdlet（相关文档请访问https://docs.microsoft.com/powershell/module/
scheduledtasks/）调用。请注意，任务计划程序包含一个兼容性插件，借此可以让老旧的应用程序（如AT命令）配合任务计划程序使用。在
Windows 10的2019年5月更新（19H1）中，AT工具已被正式弃用，用户可以转为使用schtasks.exe。</span></p>
</div><div class="header2"><h3><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>初</b><b>始</b><b>化</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在被服务控制管理器启动
后，任务计划程序服务会开始自己的初始化过程。首先需要注册自己的基于清单的ETW事件提供程序（全局唯一ID为
DE7B24EA-73C84A09-985D- 
5BDADCFA9017）。任务计划程序生成的所有事件均可供UBPM使用。随后，任务计划程序会初始化凭据存储，该组件用于安全地访问凭据管理器和任
务存储中所保存的用户凭据。凭据管理器还会检查任务存储的二级影子副本（该副本的产生是为了实现兼容性，通常位于%SystemRoot%
\System32\Tasks下）中包含的所有XML任务描述符是否与任务存储缓存中的任务描述符保持同步。任务存储缓存由多个注册表键表示，其根键位
于HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">接下来，任务计划程序初始
化过程需要初始化UBPM。任务计划程序服务会使用UBPM.dll导出的UbpmInitialize 
API启动UBPM的核心组件。该函数会注册一个任务计划程序事件提供程序的ETW使用方，并连接到资源管理器。资源管理器组件由进程状态管理器
（Process State 
Manager，Psmsrv.dll，运行于代理基础架构服务上下文中）加载，可根据计算机状态和全局资源使用情况生成能够善用资源的策略。资源管理器
可以帮助UBPM管理维护性质的任务。此类任务通常会在特定系统状态下运行，例如计算机CPU用量低时、游戏模式被关闭时、用户不在计算机前时等等。随
后，UBPM初始化代码会从系统事件代理中检索代表任务条件的WNF状态名：交流电源、计算机空闲、可用IP地址或网络、计算机切换至电池供电（这些条件
可在任务计划程序MMC管理单元的创建任务对话框的条件选项卡下使用）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">UBPM会初始化自己的内
部线程池工作线程，获取系统电源能力，读取维护任务和关键任务操作列表（从
HKLM\System\CurrentControlSet\Control\Ubpm注册表键和组策略设置读取），并订阅系统电源设置通知（借此
UBPM即可了解系统的电源状态何时改变）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后执行控制会返回到任务
计划程序，最终由它为自己和UMPB注册全局RPC接口。这些接口将被任务计划程序API客户端DLL（Taskschd.dll）使用，以便为客户端进
程提供一种通过任务计划程序，借助任务计划程序COM接口进行交互的方式，详见文档：https://docs.microsoft.com/
windows/win32/api/taskschd/。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">初始化完成后，任务存储将
枚举并分别启动系统中安装的每个任务。任务存储在缓存中的四个组内：Boot、Logon、Plain以及Maintenance 
task。每个组都关联了一个名为Index Group 
Tasks键的子键，位于任务存储的根注册表键（HKLM\SOFTWARE\Microsoft\Windows 
NT\CurrentVersion\Schedule\TaskCache）下。在每个Index 
Tasks组键下，每个任务对应一个子键，不同任务可通过全局唯一标识符（GUID）区分。任务计划程序会枚举所有组子键的名称，对于每个子键，还会打开
相关任务的主键（master 
key），该主键位于任务存储根注册表键的Tasks子键下。图10-26展示了一个Boot任务范例，其GUID为{0C7D8A27- 
9B28-49F1-979C-AD37C4D290B1}。这个GUID在图中显示为Boot这个索引组键中的第一个项。从该图中还可以看到任务主键，
其中存储了用于完全描述该任务的二进制数据。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ee73487c963d9e5c519c61cb78f76cbb.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-26 一个Boot任务的主键</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">任务的主键包含描述任务的
所有信息。任务有两个最重要的属性：触发器（trigger）和操作（action），其中触发器指定了可触发任务的条件，操作指定了执行任务时要做的工
作。这两个属性都存储在二进制注册表值（名为Triggers和Actions，如图10-26所示）中。任务计划程序首先会读取整个任务描述符的哈希
（存储在Hash注册表值中），随后读取任务的配置数据以及有关触发器和操作的二进制数据。在解析这些数据后，即可将识别出的触发器和操作描述符存储到一
个内部列表中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后，任务计划程序会重新
计算新任务描述符（其中包含了从注册表读取的所有数据）的SHA256哈希，并将其与预期值进行比较。如果两个哈希不匹配，任务计划程序会打开任务存储影
子副本（%SystemRoot%\System32\Tasks文件夹）中与该任务关联的XML文件，解析其中的数据，并重新计算一个新的哈希，最终替
换注册表中的任务描述符。实际上，任务既可以用注册表中的二进制数据描述，也可以用XML文件描述，该XML文件遵循一种明确定义的方案，详见：
https://docs.microsoft.com/windows/win32/taskschd/task- 
scheduler-schema。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>任</b><b>务</b><b>的</b><b>X</b><b>M</b><b>L</b><b>描</b><b>述</b><b>符</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如
上文所述，任务描述符可由任务存储用两种格式来保存：XML文件和注册表数据。在这个实验中，我们将分别查看两个格式的内容。首先打开任务计划程序（在搜
索框中输入taskschd.msc），展开任务计划程序库节点以及所有子节点，直到看到Microsoft\Windows文件夹。浏览这里的每个子节
点，找出“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>操</b><b>作</b></span>”选项卡下被设置为“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>自</b><b>定</b><b>义</b><b>句</b><b>柄</b></span>”（Custom Handler）
	<sup><img width="11" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="通常来说，句柄是Handle，而Handler是执行某些处理任务的“处理程序”，微软的所有产品几乎都使用了这样的称呼。但如果使用简体中文版Windows系统执行该实验将会发现，此处需要查找的“Custom Handler”操作，在简体中文版Windows中被称为“自定义句柄”，这是错误的，正确叫法应为“自定义处理程序”。但为了与系统UI保持一致，正文依然沿用了“自定义句柄”的叫法。截至翻译这部分内容，译者在简体中文版Windows 11（21H2）系统中看到的依然是“自定义句柄”，不排除后续系统更新会修复这个小瑕疵的可能。——译者注" title="通常来说，句柄是Handle，而Handler是执行某些处理任务的“处理程序”，微软的所有产品几乎都使用了这样的称呼。但如果使用简体中文版Windows系统执行该实验将会发现，此处需要查找的“Custom Handler”操作，在简体中文版Windows中被称为“自定义句柄”，这是错误的，正确叫法应为“自定义处理程序”。但为了与系统UI保持一致，正文依然沿用了“自定义句柄”的叫法。截至翻译这部分内容，译者在简体中文版Windows 11（21H2）系统中看到的依然是“自定义句柄”，不排除后续系统更新会修复这个小瑕疵的可能。——译者注" class="epub-footnote"></sup>的任务。该操作类型描述了COM托管的任务，而任务计划程序并不支持此类任务。在本例中，我们选择了ProcessMemoryDiagnosticEvents，它位于MemoryDiagnostics文件夹下。选择操作为“自定义句柄”的其他任何任务也可以。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/09a74775bf10631da27fdd56dbf3e6a4.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">以管理员身份打开命令提示符窗口（在搜索框中输入CMD，选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>以</b><b>管</b><b>理</b><b>员</b><b>身</b><b>份</b><b>运</b><b>行</b></span>”），随后输入下列命令（请将任务路径替换为实际的目标任务路径）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">schtasks /query /tn "Microsoft\Windows\MemoryDiagnostic\ProcessMemoryDiagnosticEvents" /xml </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">输出结果中显示了该任务的XML描述符，其中包含该任务的安全描述符（用于保护任务不被未经授权实体打开）、任务的作者和描述、可运行该任务的安全主体、任务设置，以及任务触发器和操作：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">&lt;?xml version="1.0" encoding="UTF-16"?&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">&lt;Task xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task"&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  &lt;RegistrationInfo&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;Version&gt;1.0&lt;/Version&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;SecurityDescriptor&gt;D:P(A;;FA;;;BA)(A;;FA;;;SY)(A;;FR;;;AU)&lt;/SecurityDescriptor&gt;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;Author&gt;$(@%SystemRoot%\system32\MemoryDiagnostic.dll,-600)&lt;/Author&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;Description&gt;$(@%SystemRoot%\system32\MemoryDiagnostic.dll,-603)&lt;/Description&gt;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;URI&gt;\Microsoft\Windows\MemoryDiagnostic\ProcessMemoryDiagnosticEvents&lt;/URI&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  &lt;/RegistrationInfo&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  &lt;Principals&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;Principal id="LocalAdmin"&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      &lt;GroupId&gt;S-1-5-32-544&lt;/GroupId&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      &lt;RunLevel&gt;HighestAvailable&lt;/RunLevel&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;/Principal&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  &lt;/Principals&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  &lt;Settings&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;AllowHardTerminate&gt;false&lt;/AllowHardTerminate&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;DisallowStartIfOnBatteries&gt;true&lt;/DisallowStartIfOnBatteries&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;StopIfGoingOnBatteries&gt;true&lt;/StopIfGoingOnBatteries&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;Enabled&gt;false&lt;/Enabled&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;ExecutionTimeLimit&gt;PT2H&lt;/ExecutionTimeLimit&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;Hidden&gt;true&lt;/Hidden&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;MultipleInstancesPolicy&gt;IgnoreNew&lt;/MultipleInstancesPolicy&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;StartWhenAvailable&gt;true&lt;/StartWhenAvailable&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;RunOnlyIfIdle&gt;true&lt;/RunOnlyIfIdle&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;IdleSettings&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      &lt;StopOnIdleEnd&gt;true&lt;/StopOnIdleEnd&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      &lt;RestartOnIdle&gt;true&lt;/RestartOnIdle&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;/IdleSettings&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;UseUnifiedSchedulingEngine&gt;true&lt;/UseUnifiedSchedulingEngine&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  &lt;/Settings&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  &lt;Triggers&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;EventTrigger&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">       &lt;Subscription&gt;&lt;QueryList&gt;&lt;Query Id="0" Path="System"&gt;&lt;Select Pa</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">th="System"&gt;*[System[Provider[@Name='Microsoft-Windows-WER-SystemErrorReporting']</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">and (EventID=1000 or EventID=1001 or EventID=1006)]]&lt;/Select&gt;&lt;/Query&gt;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  &lt;/</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">QueryList&gt;&lt;/Subscription&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;/EventTrigger&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    . . . [cut for space reasons] . . . </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  &lt;/Triggers&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  &lt;Actions Context="LocalAdmin"&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;ComHandler&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      &lt;ClassId&gt;{8168E74A-B39F-46D8-ADCD-7BED477B80A3}&lt;/ClassId&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      &lt;Data&gt;&lt;![CDATA[Event]]&gt;&lt;/Data&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &lt;/ComHandler&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  &lt;/Actions&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">&lt;/Task&gt; </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">对
于ProcessMemoryDiagnosticEvents任务，其中包含多个ETW触发器（这些触发器使得该任务只能在生成某些诊断事件后执行，实
际上，触发器描述符也包含了以XPath格式指定的ETW查询）。唯一注册的一个操作是一个ComHandler，其中只包含了表示任务COM对象的
CLSID（类ID）。打开注册表编辑器并进入HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSIDkey，从“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>编</b><b>辑</b></span>”菜单选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>查</b><b>找</b></span>”，
复制并粘贴任务描述符ClassID 
XML标签之后的CLSID（可以包含或不包含大括号）。这样就应该能找到实现了用于表示任务的ITaskHandler接口的DLL，该DLL由
TaskHost客户端应用程序（Taskhostw.exe，详见下文“任务宿主客户端”一节）托管。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/5ed40a106e57bf61d28eb37d52c9ae72.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">打
开HKLM\SOFTWARE\Microsoft\Windows 
NT\CurrentVersion\Schedule\TaskCache\Tasks注册表键后，应该可以在这里找到任务存储缓存中存储的任务描述符
GUID。为此可使用任务的URI进行搜索。实际上，任务的GUID并未存储在XML配置文件中。注册表中与任务描述符有关的数据和任务存储影子副本
（%systemroot%
\System32\Tasks\Microsoft\Windows\MemoryDiagnostic\ProcessMemoryDiagnosticEvents）
中存储的XML配置文件完全相同。所有更改都会存储在二进制格式中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">启用的任务需要与UBPM
注册。任务计划程序会调用UBPM代理的RegisterTask函数，它首先连接到凭据存储并检索启动任务所需的凭据，然后处理所有操作和触发器列表
（存储在一个内部列表中），将其转换为UBPM可理解的格式。最后，它会调用从UBPM.dll导出的
UbpmTriggerConsumerRegister API。当正确的条件成功验证后，该任务就可以执行了。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_148" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>3</b><b>.</b><b>2</b><b> </b><b>统</b><b>一</b><b>后</b><b>台</b><b>进</b><b>程</b><b>管</b><b>理</b><b>器</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">以往，UBPM主要负责管
理任务的生命周期和状态（启动、停止、启用/禁用等），并为通知和触发器提供支持。Windows 
8.1引入了代理基础架构，将所有触发器和通知的管理工作转移给不同代理，这些代理可供现代应用程序和标准Win32应用程序使用。因此在Windows
 
10中，UBPM充当了标准Win32任务的触发器代理（Proxy），可将使用方发出的触发器请求转换为正确的代理（Broker）。UBPM依然负责
为应用程序提供可用的COM API，并将其应用于以下几个方面。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·注册和取消注册触发器的使用方，以及打开和关闭相应句柄。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·生成通知或触发器。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·向触发器提供程序发出命令。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与任务计划程序的架构类似，UBPM也包含多个内部组件：任务托管服务器和客户端、基于COM的任务托管库及事件管理器。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>任</b><b>务</b><b>宿</b><b>主</b><b>服</b><b>务</b><b>器</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当系统代理发出一条由
UBPM触发器使用方注册的事件（通过发布WNF状态变化做到）后，将执行UbpmTriggerArrived回调函数。UBPM会在内部列表中（根据
WNF状态名）搜索已注册的任务触发器，如果找到正确的触发器，便会处理该任务的操作。在撰写这部分内容时，这种方式仅支持“启动可执行文件”操作。该操
作可支持托管和非托管可执行文件。非托管可执行文件是指不直接与UBPM交互的常规Win32可执行文件，托管可执行文件是指直接与UBPM交互且需要由
任务托管客户端进程托管的COM类。基于托管的可执行文件（taskhostw.exe）启动后，即可根据相应令牌托管不同任务（基于托管的可执行文件类
似于共享的Svchost服务）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与SCM类似，UBPM支
持为任务的托管进程使用不同类型的登录安全令牌。UbpmTokenGetTokenForTask函数可以根据任务描述符中存储的账户信息创建新令牌，
而UBPM为任务生成的安全令牌可应用于下列任何一个所有者：已注册的用户账户、虚拟服务账户、Network Service账户或Local 
Service账户。与SCM的不同之处在于，UBPM完全支持交互式令牌。UBPM可使用由用户管理器（Usermgr.dll）公开的服务枚举当前活
跃的交互式会话。对于每个会话，它会对比任务描述符中指定的用户SID以及交互式会话的所有者。如果两者相符，则UBPM会复制附加到交互式会话的令牌，
并用它来登录新的可执行文件。因此，交互式任务只能用标准用户账户运行（非交互式任务可以使用上文提到的任何一种类型账户来运行）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">令牌生成后，UBPM会启
动相应任务的托管进程。对于这些托管的COM任务，UbpmFindHost函数会在Taskhostw.exe（任务宿主客户端）进程实例内部的内部列
表中进行搜索。如果找到有进程与新任务运行相同的安全上下文，那么将直接通过任务宿主本地RPC连接发送Start 
Task命令（包括COM任务的名称和CLSID），并等待第一个回应。任务宿主客户端进程和UBPM可通过一个静态RPC通道（名为
ubpmtaskhostchannel）连接，并使用与SCM的实现中类似的连接协议。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果未找到兼容的客户端进
程实例，或任务的宿主进程是常规的非COM可执行文件，UBPM会构建一个新的环境块，解析命令行，使用CreateProcessAsUser 
API以暂停状态新建一个进程。UBPM会在一个作业对象中运行每个任务的宿主进程，这样即可快速设置多个任务的状态，并优化后台任务的资源分配。
UBPM会在一个内部列表中搜索作业对象，这些作业对象包含了属于相同会话ID的宿主进程和相同任务类型（常规、关键、基于COM、非托管）。如果找到兼
容的作业，将直接向该作业分配新进程（通过使用AssignProcessToJobObject 
API）。如果未找到，则会新建一个作业并将其添加到自己的内部列表。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">作业对象创建完成后，任务
就可以启动了：初始化进程的线程将被恢复运行。对于COM托管的任务，UBPM会等待来自任务宿主客户端的首次联系（客户端想要与UBPM建立RPC通信
通道时会执行该操作，类似于服务控制应用程序打开到SCM的通道），并发送Start 
Task命令。UBPM最终会向任务的宿主进程注册一个等待回调，这样即可检测到任务宿主进程什么时候会意外终止。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>任</b><b>务</b><b>宿</b><b>主</b><b>客</b><b>户</b><b>端</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">任务宿主客户端进程会从任
务计划程序服务中的UBPM（任务宿主服务器）实时接收命令。在初始化时，它会打开UBPM在初始化过程中创建的本地RPC接口并永远循环下去，等待通过
该通道收到的命令。目前支持以下四种命令，这些命令都是通过TaskHostSendResponseReceiveCommand RPC 
API发出的。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·停止宿主。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·启动任务。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·停止任务。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·终止任务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">所有基于任务的命令都是通
过一个通用COM任务库实现的，本质上，这些任务会创建并销毁COM组件。尤其是托管任务，它们是一种自ITaskHandler接口继承而来的COM对
象。该接口仅公开了四种必要的方法，分别对应任务的四种状态转换——Start、Stop、Pause和Resume。当UBPM向自己的客户端宿主进程
发送命令以启动任务时，客户端宿主进程（Taskhostw.exe）会为该任务创建一个新线程。新的任务工作线程使用CoCreateInstance
函数创建能表示该任务的ITaskHandler 
COM对象实例，随后调用自己的Start方法。UBPM可以准确得知特定任务的CLSID（类唯一ID）是什么：任务的CLSID由任务存储保存在该任
务的配置中，并会在任务注册时指定。此外，托管任务使用由ITaskHandlerStatus 
COM接口公开的函数向UBPM告知自己的当前执行状态。该接口会使用RPC调用UbpmReportTaskStatus并将新状态反馈给UBPM。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>C</b><b>O</b><b>M</b><b>托</b><b>管</b><b>的</b><b>任</b><b>务</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
这个实验中，我们将观察到任务宿主客户端进程如何加载实现任务的COM服务器DLL。为完成本实验，需要在系统中安装调试工具（调试工具包含在
Windows 
SDK中，下载地址为https://developer.microsoft.com/windows/downloads/windows-10-
sdk/）。随后可通过下列步骤启用任务启动时的调试器断点。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">1）将Windbg设置为默认的后台调试器（如果已将内核调试器连接到目标系统，可跳过这一步）。为此，请用管理员身份打开命令提示符窗口，并运行下列命令：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">cd "C:\Program Files (x86)\Windows Kits\10\Debuggers\x64" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">windbg.exe /I </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请注意，调试工具路径为C:\Program Files (x86)\Windows Kits\10\Debuggers\x64，请根据调试器的版本和安装程序酌情调整上述命令。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">2）Windbg将运行并展示如下的消息界面，这证明操作已成功。</span></p><div style="display: block;text-align:center;">
	<img width="609" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/d55e1e98ac3ad8d7c03b4b7686493f8d.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">3）点击OK按钮后，WinDbg将自动关闭。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">4）打开任务计划程序（在命令提示符下输入taskschd.msc）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">5）请注意，除非附加了内核调试器，否则无法为非交互式任务启用初始任务的断点，进而无法与调试器窗口交互，此时会在另一个非交互式会话中打开调试器窗口。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">6）查看各种任务（可参阅上一个实验“查看任务的XML描述符”），应该可以在\Microsoft\Windows\Wininet路径下找到一个名为CacheTask的交互式COM任务。请注意，任务的“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>操</b><b>作</b></span>”页面应显示“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>自</b><b>定</b><b>义</b><b>句</b><b>柄</b></span>”，否则这并不是COM任务。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">7）打开注册表编辑器（在命令提示符窗口中输入regedit），随后打开HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule注册表键。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">8）右击Schedule键，从“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>新</b><b>建</b></span>”菜单中选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>多</b><b>字</b><b>符</b><b>串</b><b>值</b></span>”，新建一个注册表值。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">9）
将新注册表值的名称设置为EnableDebuggerBreakForTaskStart。若启用初始任务断点，需要插入任务的完整路径。本例中的完整
路径为\Microsoft\Windows\Wininet\CacheTask。在上一个实验中，任务路径可通过任务的URI来引用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">10）关闭注册表编辑器并切换到任务计划程序。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">11）右击CacheTask任务并选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>运</b><b>行</b></span>”。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">12）如果系统配置一切无误，随后将出现一个新的WinDbg窗口。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">13）配置调试器使用的符号，为此请从“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>文</b><b>件</b></span>”菜单选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>符</b><b>号</b><b>文</b><b>件</b><b>路</b><b>径</b></span>”选项，并输入一个指向Windows符号服务器的有效路径（详见https://docs.microsoft.com/windows-hardware/drivers/debugger/microsoft-public-symbols）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">14）随后即可使用k命令查看Taskhostw.exe进程在中断之前的调用栈：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0:000&gt; k </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> # Child-SP         RetAddr          Call Site </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">00 000000a7`01a7f610 00007ff6`0b0337a8 taskhostw!ComTaskMgrBase::[ComTaskMgr]::Sta</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">rtComTask+0x2c4 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">01 000000a7`01a7f960 00007ff6`0b033621 taskhostw!StartComTask+0x58 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">02 000000a7`01a7f9d0 00007ff6`0b033191 taskhostw!UbpmTaskHostWaitForCommands+0x2d1</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">03 000000a7`01a7fb00 00007ff6`0b035659 taskhostw!wWinMain+0xc1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">04 000000a7`01a7fb60 00007ffa`39487bd4 taskhostw!__wmainCRTStartup+0x1c9 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">05 000000a7`01a7fc20 00007ffa`39aeced1 KERNEL32!BaseThreadInitThunk+0x14 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">06 000000a7`01a7fc50 00000000`00000000 ntdll!RtlUserThreadStart+0x21 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">15）通过该堆栈可知：任务宿主客户端刚刚被UBPM创建，并收到了启动任务的Start命令。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">16）在Windbg控制台中输入“~.”命令并按下回车，随后即可看到当前执行线程的ID。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">17）到这里，我们可以在CoCreateInstance COM API上放置一个断点并恢复执行，为此请使用下列命令：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">bp combase!CoCreateInstance </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">g </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">18）调试器中断后，再次在Windbg控制台中插入“~.”命令并按下回车，随后会看到线程ID已完全不同了。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">19）
这证明了任务宿主客户端为任务入口点的执行创建了一个新线程。相关文档中介绍的CoCreateInstance函数可用于创建与特定CLSID相关的单
一COM对象类，并将其指定为一个参数。这个实验中还有两个GUID比较有趣：表示任务的COM类GUID，以及COM对象实现的接口ID。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">20）在64位系统中，调用惯例定义了前四个函数参数是通过寄存器传递的，因此这些GUID很容易提取：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0:004&gt; dt combase!CLSID @rcx </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> {0358b920-0ac7-461f-98f4-58e32cd89148} </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x000 Data1            : 0x358b920 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x004 Data2            : 0xac7 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x006 Data3            : 0x461f </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x008 Data4            : [8] "???" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0:004&gt; dt combase!IID @r9 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> {839d7762-5121-4009-9234-4f0d19394f04} </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x000 Data1            : 0x839d7762 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x004 Data2            : 0x5121 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x006 Data3            : 0x4009 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x008 Data4            : [8] "???" </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">从
上述输出结果中可以看到，COM服务器CLSID为{0358b920-0ac7-461f98f4- 
58e32cd89148}。通过验证可知，它与CacheTask任务XML描述符中唯一的COM操作的GUID相符（详见上一个实验）。所请求的接口
ID为{839d7762-5121-4009-9234- 
4f0d19394f04}，这也与COM任务处理程序操作接口（ITaskHandler）的GUID相符。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_149" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>3</b><b>.</b><b>3</b><b> </b><b>任</b><b>务</b><b>计</b><b>划</b><b>程</b><b>序</b><b>C</b><b>O</b><b>M</b><b>接</b><b>口</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，COM任务需
要遵循明确定义的接口要求，UBPM会通过该接口控制任务的状态转换。当UBPM决定何时启动任务并管理任务的所有状态时，所有其他用于注册、删除，或手
动启动和停止任务的接口都将由任务计划程序在自己的客户端DLL（Taskschd.dll）中实现。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ITaskService
是一种中央接口，客户端可以通过它连接到任务计划程序并执行各种操作，如枚举已注册的任务、获取任务存储实例（由ITaskFolder 
COM接口表示），以及启用、禁用、删除或注册任务及其相关的所有触发器和操作（为此要使用ITaskDefinition 
COM接口）。当客户端应用程序首次通过COM调用一个任务计划程序API时，系统会将任务计划程序客户端DLL（Taskschd.dll）加载到客户
端进程的地址空间（按照COM合约的要求：任务计划程序COM对象需要位于进程内的COM服务器中）。该COM 
API是通过将请求使用RPC调用路由至任务计划程序服务实现的，该服务会分别处理每个请求，并在需要时将其转发给UBPM。任务计划程序COM架构可供
用户通过PowerShell等脚本语言（使用ScheduledTasks cmdlet）或VBScript与其交互。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter10_0004.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_150" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>4</b><b> </b><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>管</b><b>理</b><b>规</b><b>范</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows管理规范
（WMI）是分布式管理任务组（DMTF，一个行业联盟）所定义的基于Web的企业管理（Web-Based Enterprise 
Management，WBEM）的一种实现。WBEM标准提供了一种可扩展的企业数据收集和数据管理设施设计，能以灵活、可扩展的方式管理包含任意组件
的本地系统和远程系统。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_151" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>4</b><b>.</b><b>1</b><b> </b><b>W</b><b>M</b><b>I</b><b>架</b><b>构</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如图10-27所示，
WMI包含四个主要组件：管理应用程序、WMI基础架构、提供程序及托管对象。管理应用程序是指那些可以访问、显示或处理与托管对象有关数据的
Windows应用程序。管理应用程序的例子有很多，利用WMI而非性能API来获取性能信息的性能工具就是一种简单的管理应用程序；能够自动盘点企业中
每台计算机软硬件配置的企业管理工具，则是一种比较复杂的管理应用程序。</span></p><div style="display: block;text-align:center;">
	<img width="897" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4141621baebe7377edfb09d15140b046.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-27 WMI架构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">开发者在管理应用程序时，
通常需要收集并管理特定对象所产生的数据。这种对象可能是某一个组件，如网络适配器设备；也可能是一系列组件，如一整台计算机（计算机对象可能包含了网络
适配器对象）。为此需要通过编写提供程序定义并导出管理应用程序所关注的对象的具体呈现。例如，网络适配器供应商可能希望在Windows包含的网络适配
器WMI类中添加与特定适配器有关的属性，借此按照管理应用程序的指示查询并设置适配器的状态和行为。某些情况下（例如对设备驱动程序来说），微软提供了
一个有着自己API的提供程序，借此帮助开发者以最小的开发工作量让自己管理的对象能更充分地利用系统实现的提供程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">WMI基础架构的核心是通
用信息模型（Common Information 
Model，CIM）对象管理器（CIMOM），它充当了管理应用程序和提供程序之间的“黏合剂”（CIM的详细介绍请参阅本章下文）。该基础架构本身也
是一种对象类存储，很多情况下，还可作为持久性对象属性的存储管理器。WMI通过一种保存在磁盘上，名为CIMOM对象存储库的数据库实现了存储（即存储
库）。作为这种基础架构的一部分，WMI可支持多种API，借此让管理应用程序访问对象数据，并让提供程序提供数据和类定义。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows程序和脚本
（如Windows PowerShell）使用WMI COM API作为最主要的管理API，这样就可以与WMI直接交互。COM 
API基础上还衍生出其他API，甚至包括一个适用于Microsoft Access数据库应用程序的开放数据库连接（Open Database 
Connectivity，ODBC）适配器。数据库开发者可以使用WMI 
ODBC适配器在自己的数据库中嵌入可引用的对象数据。随后，开发者即可使用包含WMI数据的数据库查询轻松创建报告。WMI 
ActiveX控件还支持另一层API，Web开发者可通过ActiveX控件构建基于Web的WMI数据接口。WMI脚本API则是另一种管理API，
可用于基于脚本的应用程序（如Visual Basic Scripting Edition）中。微软的所有编程语言技术均支持WMI脚本。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">WMI 
COM接口适用于管理应用程序，它们构成了提供程序的主要API。然而，与COM客户端形式的管理应用程序不同，提供程序是一种COM或分布式COM
（DCOM）服务器（也就是说，提供程序实现了可与WMI交互的COM对象）。WMI提供程序可行的实施方案包括载入WMI管理器进程的DLL、独立的
Windows应用程序，或Windows服务。微软提供了一系列系统自带的提供程序，借此呈现一些众所周知来源的数据，例如性能API、注册表、事件管
理器、活动目录、SNMP以及现代设备驱动程序。开发者可通过WMI SDK开发第三方WMI提供程序。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_152" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>4</b><b>.</b><b>2</b><b> </b><b>W</b><b>M</b><b>I</b><b>提</b><b>供</b><b>程</b><b>序</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">WBEM的核心是DMTF
设计的CIM规范。CIM决定了管理系统如何从系统管理的角度呈现从计算机到应用程序，再到计算机上的设备等一切内容。提供程序的开发者可以使用CIM呈
现想要管理的应用程序的组成部件。开发者可以使用托管对象格式（Managed Object Format，MOF）语言来实现CIM的呈现结果。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了定义表示对象的类外，
提供程序还必须通过接口将WMI与对象连接起来。WMI根据所提供的功能对提供程序进行了分类。表10-14列出了WMI提供程序的不同类别。请注意，一
个提供程序可以实现一个或多个功能，因此举例来说，提供程序既可以是类，也可以是事件提供程序。为了澄清表10-14定义的功能，一起先来看看一个实现了
多个功能的提供程序。事件日志（event log）提供程序支持多种对象，包括Event Log Computer（事件日志计算机）、Event 
Log Record（事件日志记录），以及Event Log 
File（事件日志文件）。事件日志是一种实例提供程序，因为它可以为自己的多个类定义多个实例。例如Event Log 
File类（Win32_NTEventlogFile）就是事件日志提供程序定义的多种实例中的一个类；事件日志提供程序为系统的每个事件日志（即系统
事件日志、应用程序事件日志以及安全事件日志）都定义了类的一个实例。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表10-14 提供程序的分类</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/739a592bacb4848083f2248d947fbdf9.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">事件日志提供程序定义了实
例数据，并让管理应用程序能够枚举记录。为了让管理应用程序使用WMI备份并还原事件日志文件，事件日志提供程序为Event Log 
File对象实现了备份和还原方法。这样，事件日志提供程序就成了一种方法提供程序。最后，管理应用程序注册后，还可在事件日志中写入了新记录后收到通
知。因此，当事件日志提供程序使用WMI事件通知的方式告知“WMI事件日志记录已抵达”时，它就成了一种事件提供程序。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_153" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>4</b><b>.</b><b>3</b><b> </b><b>通</b><b>用</b><b>信</b><b>息</b><b>模</b><b>型</b><b>和</b><b>托</b><b>管</b><b>对</b><b>象</b><b>格</b><b>式</b><b>语</b><b>言</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">CIM借鉴了C++和C#
等面向对象语言的步骤。在这些语言中，建模者会将表征设计为类。通过使用类，开发者可以配合使用各种自己早已熟悉的强大建模技术。子类可以继承父类的属
性，可以添加自己的特征并重写自己从父类继承的特征。如果类A从类B继承了属性，那么可以看作类A是从类B中派生出来的。类还可以组合，开发者可以创建包
含其他类的类。CIM类由属性和方法组成，属性描述了WMI托管资源的配置和状态，方法则是一种可以针对WMI托管资源执行操作的可执行函数。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">作为WBEM标准的一部
分，DMTF提供了多个类。这些类是CIM的基础语言，表示适用于所有管理领域的对象。这些类也是CIM核心模型的一部分。例如
CIM_ManagedSystemElement就是一种核心类，这个类包含一些可用于识别物理组件（如物理设备）和逻辑组件（如进程和文件）的基本属
性。属性包含标题、描述、安装日期和状态等信息，因此CIM_LogicalElement和CIM_PhysicalElement类可继承
CIM_ManagedSystemElement类的属性。这两个类也是CIM核心模型的一部分。WBEM标准将这些类称作“抽象类”，因为它们只作为
可被其他类继承的类而存在（也就是说，抽象类不存在对象实例）。我们可以把抽象类看成模板，借此可定义供其他类使用的属性。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">第二种类表示管理领域特
有，但与特定实现无关的对象。这种类构成了通用模型，可以看作核心模型的拓展。例如CIM_FileSystem就是一种通用模型类，它继承了
CIM_LogicalElement的属性。由于几乎每个操作系统（包括Windows、Linux以及其他UNIX变体）都依赖基于文件系统的结构化
存储，因此CIM_FileSystem类也是通用模型中一个非常适合的组成部分。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后一种类是扩展模型，包
含对通用模型进行的、与特定技术有关的额外补充。Windows定义了大量这种类来表示Windows环境所特有的对象。由于所有操作系统都会将数据存储
在文件中，CIM模型也描述了CIM_LogicalFile类。CIM_DataFile类继承了CIM_LogicalFile类，Windows还
为这些Windows文件类型增加了Win32_PageFile和Win32_ShortcutFile文件类。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows包含的不同
WMI管理应用程序可供管理员与WMI命名空间和类进行交互。WMI命令行工具（WMIC.exe）和Windows 
PowerShell均可连接到WMI，执行查询，并调用WMI类对象方法。图10-28展示了一个PowerShell窗口，其正在从事件日志提供程序
中的Win32_NTEventlogFile类提取信息。该类大量使用了继承，由CIM_DataFile派生而来。事件日志文件是具备额外事件日志特
性的数据文件，例如，日志文件名（LogfileName）和文件包含的记录数量（NumberOfRecords）等属性。
Win32_NTEventlogFile基于多个层次的继承，其中CIM_DataFile派生自CIM_LogicalFile，后者派生自
CIM_LogicalElement，而CIM_LogicalElement又派生自CIM_ManagedSystemElement。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b6c9f3f5731ad70f49c00be90c6a3af9.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-28 Windows PowerShell正在从Win32_NTEventlogFile类提取信息</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，WMI提供程序开发者可以用MOF语言编写自己的类。下列输出结果显示了事件日志提供程序中Win32_NTEventlogFile的定义，图10-28中查询的就是这个类。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">[dynamic: ToInstance, provider("MS_NT_EVENTLOG_PROVIDER"): ToInstance, SupportsUpdate,</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Locale(1033): ToInstance, UUID("{8502C57B-5FBB-11D2-AAC1-006008C78BC7}"): ToInstance]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">class Win32_NTEventlogFile : CIM_DataFile </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">{</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   [Fixed: ToSubClass, read: ToSubClass] string LogfileName;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   [read: ToSubClass, write: ToSubClass] uint32 MaxFileSize;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   [read: ToSubClass] uint32 NumberOfRecords;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   [read: ToSubClass, volatile: ToSubClass, ValueMap{"0", "1..365", "4294967295"}:</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ToSubClass] string OverWritePolicy;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   [read: ToSubClass, write: ToSubClass, Range("0-365 | 4294967295"): ToSubClass]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    uint32 OverwriteOutDated;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   [read: ToSubClass] string Sources[];</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   [ValueMap{"0", "8", "21", ".."}: ToSubClass, implemented, Privileges{</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    "SeSecurityPrivilege", "SeBackupPrivilege"}: ToSubClass] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      uint32 ClearEventlog([in] string ArchiveFileName); </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   [ValueMap{"0", "8", "21", "183", ".."}: ToSubClass, implemented, Privileges{ </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    "SeSecurityPrivilege", "SeBackupPrivilege"}: ToSubClass] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      uint32 BackupEventlog([in] string ArchiveFileName); </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">}; </span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上述内容中需要注意
Dynamic（动态）这个术语，这是一种描述性代号，应用于MOF文件中的Win32_NTEventlogFile类。Dynamic意味着每当管理
应用程序查询对象属性时，WMI基础架构都会要求WMI提供程序提供与该类对象相关的属性值。静态类位于WMI存储库中，WMI基础架构会引用存储库以获
取值，而不会要求提供程序提供值。由于存储库的更新是一种开销较高的操作，为属性频繁更改的对象使用动态提供程序就是一种更高效的做法。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>W</b><b>M</b><b>I</b><b>类</b><b>的</b><b>M</b><b>O</b><b>F</b><b>定</b><b>义</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以使用Windows中自带的Windows Management Instrumentation测试器工具（WbemTest）查看任何WMI类的MOF定义。在这个实验中，我们将查看Win32_NTEventLogFile类的MOF定义。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">1）在搜索框中输入Wbemtest并按下回车键，随后将打开Windows Management Instrumentation测试器。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">2）点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>连</b><b>接</b></span>”按钮，将命名空间改为root\cimv2并连接。该工具将启用所有命令按钮，如下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="720" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e8804c697c487c78e0603a3df97c86b2.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">3）点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>枚</b><b>举</b><b>类</b></span>”按钮，选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>递</b><b>归</b></span>”单选框并点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>确</b><b>定</b></span>”按钮。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">4）在类列表中找到Win32_NTEventLogFile，随后双击查看类属性。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">5）点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>显</b><b>示</b></span>MOF”按钮，即可打开一个新窗口，其中显示了MOF定义。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在MOF中构建了类后，
WMI开发者可通过多种方式将类的定义提供给WMI。WDM驱动程序开发者可将MOF文件编译为二进制MOF（BMF）文件（这是一种比MOF文件更紧凑
的二进制表示格式），并可选择动态地将BMF文件提供给WDM基础架构，或静态地将其包含在自己的二进制文件中。另一种方法是编译MOF文件，随后使用
WMI COM 
API将定义提供给WMI基础架构。最后，提供程序可以使用MOF编译器（Mofcomp.exe）工具直接为WMI基础架构提供编译后的类的表示。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 以前的Windows版本（Windows 7及以前的版本）在WMI管理工具中提供了一个名为WMI CIM 
Studio的图形化工具。该工具能以图形化方式展示WMI命名空间、类、属性以及方法。目前该工具已停止支持，也不再提供下载，因为其功能已被
Windows PowerShell的WMI功能所取代。PowerShell是一种无须GUI即可运行的脚本语言。一些第三方工具提供了与CIM 
Studio类似的界面，例如WMI 
Explorer：https://github.com/vinaypamnani/wmie2/releases。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通用信息模型（CIM）存储库位于%SystemRoot%\System32\wbem\Repository，其中包含：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Index.btr：二叉树（btree）索引文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·MappingX.map：事务控制文件（X是一个从1开始的数字）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Objects.data：CIM存储库，其中存储了托管的资源定义。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>W</b><b>M</b><b>I</b><b>命</b><b>名</b><b>空</b><b>间</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">类定义了对象，对象由WMI提供程序提供。对象是类在系统中的实例。WMI使用的命名空间包含多个子命名空间，WMI会按照层次结构整理所有对象。管理应用程序必须连接到命名空间，随后应用程序才能访问其中的对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">WMI的命名空间根目录名
为ROOT。所有WMI安装都包含四个预定义的命名空间，它们位于ROOT之下，分别是CIMV2、Default、Security、WMI。其中一些
命名空间内部还有其他命名空间。例如，CIMV2下包含子命名空间Applications和ms_409。提供程序有时也会定义自己的命名空间，我们可
以在Windows的ROOT之下看到WMI命名空间（这些命名空间由Windows设备驱动程序WMI提供程序定义）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与通过目录和文件组成层次
结构的文件系统的命名空间不同，WMI命名空间的深度只有一个层级。并且不像文件系统会使用名称，WMI会使用自己定义的对象属性作为识别对象所使用的
键。管理应用程序通过键名称指定类的名称，借此在命名空间中定位特定的对象。因此，类的每个实例必须能用自己的唯一键值来识别。例如，事件日志提供程序使
用Win32_NTLogEvent类表示事件日志中的记录。该类有两个键：字符串Logfile，以及无符号整数RecordNumber。查询事件日
志记录WMI实例的管理应用程序可以从识别记录的提供程序“键对”中获得这些信息。应用程序会使用下列对象路径名称示例中所示的语法引用一条记录。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">\\ANDREA-LAPTOP\root\CIMV2:Win32_NTLogEvent.Logfile="Application", </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                                     RecordNumber="1" </span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">名称中的第一个组件（\\ANDREA-LAPTOP）标识了对象所在的计算机，第二个组件（\root\CIMV2）是对象所在的命名空间。冒号后面是类名称，句号后面是键名称和相关的值，键值可使用逗号分隔。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">WMI提供的接口可供应用程序枚举特定类下的所有对象，或进行查询并返回与查询条件匹配的类实例。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_154" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>4</b><b>.</b><b>4</b><b> </b><b>类</b><b>关</b><b>联</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">很多对象类型相互之间都以
某种方式有所关联。例如，计算机对象有处理器、软件、操作系统、活跃进程等。WMI可以让提供程序通过构建关联类来表示不同类之间的逻辑关联。关联类可将
一个类与另一个类关联在一起，因此这种类只有两个属性：类名称和Ref修改器（Ref 
modifier）。下列输出结果展示了一个关联，其中事件日志提供程序的MOF文件将Win32_NTLogEvent类与
Win32_ComputerSystem类关联在一起。对于对象，管理应用程序可以查询相关联的对象，借此提供程序就定义了一种由对象组成的层级结构。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">[dynamic: ToInstance, provider("MS_NT_EVENTLOG_PROVIDER"): ToInstance, EnumPrivileges{"SeSe </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">curityPrivilege"}: ToSubClass, Privileges{"SeSecurityPrivilege"}: ToSubClass, Lo-</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">cale(1033): </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ToInstance, UUID("{8502C57F-5FBB-11D2-AAC1-006008C78BC7}"): ToInstance, Association: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">DisableOverride ToInstance ToSubClass] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">class Win32_NTLogEventComputer </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">{</span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [key, read: ToSubClass] Win32_ComputerSystem ref Computer; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    [key, read: ToSubClass] Win32_NTLogEvent ref Record; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">}; </span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图10-29展示了一个
PowerShell窗口，其中显示了CIMV2命名空间中第一个Win32_NTLogEventComputer类的实例。通过聚合类实例，可以查询
相关的Win32_ComputerSystem对象实例WIN-46E4EFTBP6Q，它在应用程序日志文件中生成一个编号为1031的记录。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/5b8be2ece72d1875e4da3645cf39f23a.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-29 Win32_NTLogEventComputer聚合类</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>使</b><b>用</b><b>W</b><b>M</b><b>I</b><b>脚</b><b>本</b><b>管</b><b>理</b><b>系</b><b>统</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">WMI
的一个强大之处在于可支持脚本语言。微软已为执行常用管理任务创建了数百个脚本，可借此管理用户账户、文件、注册表、进程及硬件设备。Microsoft
 
TechNet脚本中心网站集中提供了微软创建的这些脚本。脚本中心的脚本使用起来就像从浏览器复制文字一样简单，只需将内容保存到.vbs扩展名的文件
中，随后用cscript 
script.vbs命令运行即可，其中“Script”是要运行脚本的名称，Cscript是Windows脚本宿主（WSH）命令行接口。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">TechNet脚本的一个范例如下所示，经过注册，该脚本可在Win32_Process对象实例创建完成后（即新进程开始运行后）收到相关事件，随后会用一行输出内容显示该对象所表示的进程名称：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">strComputer = "." </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Set objWMIService = GetObject("winmgmts:"_</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    &amp; "{impersonationLevel=impersonate}!\\" &amp; strComputer &amp; "\root\cimv2") </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Set colMonitoredProcesses = objWMIService._</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ExecNotificationQuery("SELECT * FROM__InstanceCreationEvent "_</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        &amp; " WITHIN 1 WHERE TargetInstance ISA 'Win32_Process'") </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">i = 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Do While i = 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Set objLatestProcess = colMonitoredProcesses.NextEvent </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Wscript.Echo objLatestProcess.TargetInstance.Name </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Loop </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">其
中调用ExecNotificationQuery的那一行使用了包含一个Select语句的参数，这也凸显了WMI对ANSI标准结构化查询语言
（SQL）只读子集（即WQL）的支持，借此可以让WMI使用方灵活地指定自己希望从WMI提供程序获取的信息。使用Cscript运行上述脚本，随后即
可用记事本看到如下输出结果：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;cscript monproc.vbs </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Microsoft (R) Windows Script Host Version 5.812 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright (C) Microsoft Corporation. All rights reserved. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">NOTEPAD.EXE </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">PowerShell也可通过Register-WmiEvent和Get-Event命令支持相同的功能：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PS C:\&gt; Register-WmiEvent -Query “SELECT * FROM__InstanceCreationEvent WITHIN 1 WHERE </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">TargetInstance ISA 'Win32_Process'” -SourceIdentifier “TestWmiRegistration” </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PS C:\&gt; (Get-Event)[0].SourceEventArgs.NewEvent.TargetInstance | Select-Object -Property </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ProcessId, ExecutablePath </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ProcessId ExecutablePath </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">--------- --------------</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    76016 C:\WINDOWS\system32\notepad.exe </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PS C:\&gt; Unregister-Event -SourceIdentifier "TestWmiRegistration" </span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_155" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>4</b><b>.</b><b>5</b><b> </b><b>W</b><b>M</b><b>I</b><b>的</b><b>实</b><b>现</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">WMI服务运行在一个以
Local 
System账户执行的共享Svchost进程中。它会将提供程序载入WmiPrvSE.exe提供程序托管进程，后者可作为DCOM启动器（RPC服
务）进程的子进程启动。WMI可通过Local System账户、Local Service账户或Network 
Service账户执行WmiPrvSE，具体使用哪个账户取决于代表提供程序具体实现的WMI 
Win32Provider对象实例的HostingModel属性值。提供程序被从缓存中移除后（收到最后一个提供程序请求后等待一分钟便会移除），
WmiPrvSE进程就会退出。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>观</b><b>察</b><b>W</b><b>m</b><b>i</b><b>P</b><b>r</b><b>v</b><b>S</b><b>E</b><b>的</b><b>创</b><b>建</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们可以启动Process 
Explorer并执行Wmic，这样就可以看到WmiPrvSE的创建过程。WmiPrvSE进程将出现在托管DCOM启动器服务的Svchost进程
之下。如果Process 
Explorer启用了作业突出显示功能，那么WmiPrvSE进程将使用作业的强调色来显示，原因在于，为防止失控的提供程序耗尽系统的所有虚拟内存资
源，WmiPrvSE会在一个作业对象中执行，该对象可创建的子进程数量，以及每个进程和作业中所有进程可分配的虚拟内存数量均有所限制（有关作业对象的
详细信息，请参阅卷1第5章）。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/8a2395f8900d696c572b00d281e50b72.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">大部分WMI组件默认位
于%SystemRoot%\System32和%SystemRoot%\System32\Wbem下，包括Windows 
MOF文件、内置提供程序DLL，以及管理应用程序WMI 
DLL。在%SystemRoot%\System32\Wbem目录中可以看到Ntevt.mof，这是事件日志提供程序MOF文件。此外还有
Ntevt.dll，这是事件日志提供程序的DLL，WMI服务会用到这些文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">提供程序通常会实现为动态
链接库（DLL），借此公开可实现一组接口的COM服务器（IWbemServices是核心服务器，一般来说，每个提供程序都会实现为一个COM服务
器）。WMI包含很多自带的、适用于Windows操作系统的提供程序。这些自带提供程序也称标准提供程序，可通过众所周知的操作系统资源（如Win32
子系统、事件日志、性能计数器、注册表）提供数据和管理功能。表10-15列出了Windows中自带的多个标准WMI提供程序。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">表10-15 Windows自带的多个标准WMI提供程序</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/15590a298a170a544e0c1fb43b44e620.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">事件日志提供程序DLL
（Ntevt.dll）是一种COM服务器，注册在HKLM\Software\Classes\CLSID注册表键下，其CLSID为
{F55C5B4C-517D-11d1-AB57-00C04FD9159E}（可以在MOF描述符中找到）。%SystemRoot%
\System32\Wbem之下的目录保存了存储库、日志文件以及第三方MOF文件。WMI使用一种专有版本的Microsoft 
JET数据库引擎实现了该存储库（名为CIMOM对象存储库）。该数据库文件默认位于SystemRoot%
\System32\Wbem\Repository\下。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">WMI沿用了服务的HKLM\SOFTWARE\Microsoft\WBEM\CIMOM注册表键中存储的很多注册表设置，例如某些参数的阈值和最大值。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">设备驱动程序使用特殊接口提供数据并接收来自WMI的命令，该接口名为WMI系统控制命令，是WDM的一部分（WDM详见卷1第6章）。由于该接口是跨平台的，因此位于\root\WMI命名空间中。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_156" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>4</b><b>.</b><b>6</b><b> </b><b>W</b><b>M</b><b>I</b><b>的</b><b>安</b><b>全</b><b>性</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">WMI在命名空间层面上实
现安全性。如果管理应用程序能成功连接到命名空间，那么可查看并访问该命名空间中所有对象的属性。管理员可以使用WMI控件来控制哪些用户可以访问某个命
名空间。在内部，这种安全模型是通过使用ACL和安全描述符实现的，标准Windows安全模型也会使用它们来实现访问检查（访问检查详见卷1第7章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">要启动WMI控件应用程
序，请在搜索框中输入“计算机管理”，并打开“计算机管理”窗口。随后打开服务和应用程序节点，右击WMI控件并选择“属性”，打开图10-30所示
的“WMI控件属性”对话框。要为命名空间配置安全性，请点击“安全”选项卡，选择命名空间，随后选择“安全设置”。WMI控件属性对话框的其他选项卡可
用于修改注册表中存储的性能和备份设置。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/62e9a3518b7b276329ef45c57a66d37b.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-30 WMI控件属性应用程序以及root\virtualization\v2命名空间的安全选项卡</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter10_0005.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_157" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>5</b><b> </b><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>事</b><b>件</b><b>跟</b><b>踪</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows事件跟踪
（Event Tracing for 
Windows，ETW）是为应用程序和内核模式驱动程序提供、消费和管理日志与跟踪事件的主要机制。这些事件可以存储在日志文件或循环缓冲区中，也可以
实时消费。事件可用于驱动程序、框架（如.NET 
CLR）或应用程序的调试，并可用于了解它们是否存在潜在的性能问题。ETW设施主要在NT内核中实现，但应用程序也可以使用专用日志记录器，这样就完全
不需要切换到内核模式了。使用ETW的应用程序主要可分为如下几个类别。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>控</b><b>制</b><b>器</b><b>（</b><b>C</b><b>o</b><b>n</b><b>t</b><b>r</b><b>o</b><b>l</b><b>l</b><b>e</b><b>r</b><b>）</b></span>。
控制器负责启动和停止事件跟踪会话，管理缓冲区池的大小，并负责启用提供程序，这样提供程序即可将事件记录到会话中。控制器的一些例子包括可靠性和性能监
视器，以及Windows性能工具包（现已包含在Windows评估和部署工具包中，下载地址为https://docs.microsoft.com/
windows-hardware/get-started/adk-install）中包含的XPerf。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>提</b><b>供</b><b>程</b><b>序</b><b>（</b><b>P</b><b>r</b><b>o</b><b>v</b><b>i</b><b>d</b><b>e</b><b>r</b><b>）</b></span>。提供程序是一种包含事件跟踪检测机制的应用程序或驱动程序。提供程序会向ETW注册一个GUID（全局唯一标识符），借此定义自己可产生的事件。注册之后，提供程序即可生成事件，控制程序可通过相关跟踪会话启用或禁用这些事件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>消</b><b>费</b><b>者</b><b>（</b><b>C</b><b>o</b><b>n</b><b>s</b><b>u</b><b>m</b><b>e</b><b>r</b><b>）</b></span>。消费者是一种应用程序，它可以选择一个或多个自己想要从中读取跟踪数据的跟踪会话。消费者可以接收存储在日志文件或循环缓冲区中的事件，或从提供事件的会话中实时读取事件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">值得一提的是，在ETW中，每个提供程序、会话、特征（trait）和提供程序组都由GUID来标识（有关这些概念的详情请参阅下文）。系统在ETW的基础上建立了四种用于提供事件的技术，它们的差别主要在于存储和定义事件的方式（不过其他方面也有所差别）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·MOF（或“经典”）提供程序是一种传统的提供程序，主要被WMI使用。MOF提供程序会将事件描述符存储在MOF类中，这样消费者就会知道该如何使用这些事件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·WPP（Windows软件跟踪处理器）提供程序用于跟踪应用程序或驱动程序的操作（属于WMI事件跟踪的扩展），并使用TMF（Trace Message Format，跟踪消息格式）文件让消费者解码跟踪事件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·基于清单的提供程序会使用XML清单文件定义可被消费者解码的事件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·TraceLogging提供程序与WPP提供程序类似，可用于快速跟踪应用程序或驱动程序的操作，它使用的自描述事件中包含了供控制器使用的所有必要信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在首次安装时，
Windows已经包含了数十个提供程序，操作系统的每个组件会使用这些提供程序记录诊断事件和性能跟踪结果。例如，Hyper-V就有多个提供程序，它
们为虚拟机监控程序、动态内存、VID驱动程序以及虚拟化堆栈提供了跟踪事件。如图10-31所示，ETW是通过多个组件实现的。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/c2a253451c84c55936079ed2735f7489.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-31 ETW的架构</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·ETW的大部分实现（全局会话创建、提供程序注册和启用、主日志记录器线程）位于NT内核中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·SCM/
SDDL/LSA查找API库宿主（sechost.dll）为应用程序提供创建ETW会话，启用提供程序并消费事件所需的主要的用户模式API。
Sechost使用Ntdll提供的服务调用NT内核中的ETW。一些ETW用户模式API是直接在Ntdll中实现的，并未向Sechost公开相关功
能。例如，提供程序注册和事件生成就是Ntdll（而非Sechost）中实现的用户模式功能。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·事件跟踪解码助手库（TDH.dll）实现了消费者解码ETW事件所需的服务。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
事件消费和配置库（WevtApi.dll）实现了Windows事件日志API（也叫Evt 
API），消费者应用程序可借此管理本地和远程计算机中的提供程序和事件。在解析由ETW会话产生的事件时，Windows事件日志API支持XPath
 1.0或结构化XML查询。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·安全内核实现了基本的安全服务，借此即可与VTL 0中NT内核里运行的ETW进行交互。这样，Trustlet和安全内核即可使用ETW记录自己的安全事件。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_158" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>5</b><b>.</b><b>1</b><b> </b><b>E</b><b>T</b><b>W</b><b>初</b><b>始</b><b>化</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">ETW的初始化始于NT内
核启动的早期阶段（有关NT内核初始化的详情请参阅第12章）。该过程由内部EtwInitialize函数分为三个阶段进行协调。NT内核初始化的阶段
0，将调用EtwInitialize以正确地分配并初始化每Silo的ETW专用数据结构，该数据结构将用于存储代表全局ETW会话的记录器上下文数组
（详见“ETW会话”一节）。全局会话数量最大值可通过查询
HKLM\System\CurrentControlSet\Control\WMI\EtwMaxLoggers注册表值获知，具体数量应介于32和
256之间（如果该注册表值不存在，则使用64作为默认值）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在NT内核启动过程中，阶段1的IoInitSystemPreDrivers例程继续进行ETW的初始化，并执行下列工作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）获取系统启动时间和参考系统时间，并计算QPC频率。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）初始化ETW安全密钥，并读取默认会话和提供程序的安全描述符。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）初始化位于PRCB中的每处理器全局跟踪结构。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）创建实时ETW消费者对象类型（名为EtwConsumer），用户模式实时消费者进程可借此连接到主ETW记录器线程和ETW注册（内部称之为EtwRegistration）对象类型，进而可以从用户模式应用程序注册提供程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">5）注册ETW的错误检查回调，借此即可在错误检查转储过程中转储记录器会话数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">6）根据HKLM\System\CurrentControlSet\Control\WMI根键下的AutoLogger和GlobalLogger注册表值，初始化并启动全局记录器和自动记录器会话。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">7）使用EtwRegister内核API注册各种NT内核事件提供程序，例如内核事件跟踪、常规事件提供程序，以及进程、网络、磁盘、文件名、IO、内存提供程序等。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">8）发布ETW初始化后的WNF状态名，表明ETW子系统已完成初始化。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">9）将SystemStart事件同时写入全局跟踪日志和常规事件提供程序。该事件如图10-32所示，记录了操作系统的大致启动时间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">10）如果需要，则可加载FileInfo驱动程序，该驱动程序向Superfetch（有关前瞻性内存管理的详细信息请参阅卷1第5章）提供了有关文件I/O的补充信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在启动的早期阶段，
Windows注册表和I/O子系统尚未完成初始化。因此，ETW无法直接写入日志文件。在启动过程的后续阶段，在会话管理器（SMSS.exe）正确初
始化软件配置单元后，才会真正开始进行ETW初始化最后阶段的工作。该阶段的目的仅仅是通知每个已注册的全局ETW会话，告诉它们文件系统已就绪，随后它
们就可以将ETW缓冲区中记录的事件全部刷新到日志文件中。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a3f8fdb051bd1a1b33dc5982716e509d.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-32 事件查看器中显示的SystemStart ETW事件</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_159" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>5</b><b>.</b><b>2</b><b> </b><b>E</b><b>T</b><b>W</b><b>会</b><b>话</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">会话（session，内
部称之为记录器实例）是ETW最重要的实体之一，它是提供程序和消费者之间的黏合剂。一个事件跟踪会话可从控制器启用的一个或多个提供程序处记录事件。会
话通常包含所需的全部信息，借此可以描述需要将哪个提供程序提供的哪个事件记录起来，以及事件的具体处理方式。例如，某个会话可能会被配置为记录来自
Microsoft- 
Windows-Hyper-V-Hypervisor提供程序（在内部，可使用{52fc89f8-995e-434c-
a91e-199986449890}这个GUID进行标识）的所有事件。用户还可以配置过滤器。提供程序（或提供程序组）生成的每个事件均可根据事件级
别（信息、警报、错误、关键）、事件关键字、事件ID以及其他特征进行过滤。会话配置还可以定义会话的其他细节，例如，事件时间戳该使用哪种时间来源（如
QPC、TSC或系统时钟），哪些事件应捕获堆栈跟踪信息等。会话还有一个重要作用：托管ETW记录器线程，这是将事件刷新到日志文件或实时提供给消费者
的主要实体。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">会话可使用
StartTrace 
API创建，并使用ControlTrace和EnableTraceEx2进行配置。一些命令行工具（如xperf、logman、tracelog和
wevtutil）可使用这些API启动或控制跟踪会话。会话还可配置为创建会话的进程专用的。这种情况下，ETW只能消费由同一个应用程序（该应用程序
同时也是提供程序）创建的事件。这可以帮助应用程序消除内核模式转换相关的开销。专用ETW会话只能记录执行自己进程的线程所产生的事件，不能实时传递事
件。本书并不涉及专用ETW的内部架构。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在创建了全局会话后，
StartTrace API会验证参数并将其复制到一个数据结构中，NtTraceControl 
API会使用该数据结构来调用内核中的内部函数EtwpStartLogger。在内部，ETW会话是通过ETW_LOGGER_CONTEXT数据结构
所表示的，其中包含了指向会话内存缓冲区的重要指针，而事件会被写入这样的缓冲区中。如“ETW初始化”一节所述，系统支持的ETW会话数量是有限的，具
体数量存储在全局每Silo数据结构内的一个数组中。EtwpStartLogger会检查该全局会话数组，确定是否还有可用空间或使用相同名称的会话是
否已经存在。如果已存在，则它会退出并返回一个错误代码。否则它会生成一个会话GUID（如果调用方未指定GUID），分配并初始化表示该会话的
ETW_LOGGER_CONTEXT数据结构，为其分配索引，再将其插入每Silo数组中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ETW会根据
HKLM\System\CurrentControlSet\Control\Wmi\Security注册表键下的会话安全描述符来查询权限。如图
10-33所示，该键下的每个注册表值都以会话的GUID命名（不过注册表键还包含了提供程序的GUID），其中存储了一种自关联安全描述符的二进制表
示。如果会话的安全描述符不存在，则会为会话返回一个默认安全描述符（详见下文“查看ETW会话的默认安全描述符”实验）。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/653f13d30e017482bdf4528571caaa73.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-33 ETW安全注册表键</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">EtwpStartLogger
函数会使用当前进程的访问令牌对会话的安全描述符执行访问检查，并检查是否具有TRACELOG_GUID_ENABLE访问权限（以及
TRACELOG_CREATE_REALTIME或TRACELOG_CREATE_ONDISK权限，取决于日志文件模式）。如果检查成功，则该例程
会计算事件缓冲区的默认大小和数量，这是根据系统物理内存大小计算而来的（默认缓冲区大小为8KB、16KB或64KB）。缓冲区数量取决于处理器数量以
及是否存在EVENT_TRACE_NO_PER_PROCESSOR_BUFFERING记录器模式标记，该标记可避免（由不同处理器生成的）事件写入
每处理器缓冲区。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ETW会获取会话的初始参
考时间戳。目前支持三种时钟精度：查询性能计数器（Query Performance 
Counter，QPC，一种不受系统时钟影响的高精度时间戳）、系统时钟（system time）以及CPU周期计数器（CPU cycle 
counter）。EtwpAllocateTraceBuffer函数可将每个缓冲区分配给相关的记录器会话（缓冲区数量可在此之前计算确定，也可以由
用户指定）。缓冲区可以从分页池、非分页池或直接从物理大页面分配，这主要取决于记录模式。每个缓冲区都会存储在多个内部每会话列表中，这样即可为ETW
主记录器函数和ETW提供程序提供更快的查找速度。最后，如果日志模式未设置为循环缓冲区，EtwpStartLogger函数还将启动主ETW记录器线
程，该线程的作用是将与会话相关的提供程序写入的事件刷新到日志文件，或提供给实时消费者。这个主线程启动后，ETW会向已注册的会话通知提供程序
（GUID为2a6e185b-90de-4fc5-826c-9f44e608a427）发送一个会话通知，这个特殊的提供程序可以在某些ETW事件发
生后（如新会话已创建或已销毁）、新日志文件创建后，或日志出现错误后向自己的消费者发出通知。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>枚</b><b>举</b><b>E</b><b>T</b><b>W</b><b>会</b><b>话</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
Windows 
10中可通过多种方式枚举活跃的ETW会话。在有关ETW的这个以及下一个实验中，我们将用到伴随Windows评估和部署工具包（ADK）提供的
Windows性能工具包中的XPERF工具。ADK可从下列地址免费下载：https://docs.microsoft.com/windows-
hardware/get-started/adk-install。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">活跃ETW会话的枚举可通过多种方式进行。如果使用XPERF，则可执行下列命令（XPERF通常会被安装到C:\Program Files (x86)\Windows Kits\10\Windows Performance Toolkit）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">xperf -Loggers </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">上述命令的输出结果很长，因此建议将输出结果重定向至一个TXT文件：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">xperf -Loggers &gt; ETW_Sessions.txt </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">该工具可解码所有会话配置数据，并以人工易读形式显示。下列例子显示了EventLog-Application会话的相关信息，事件记录器服务（Wevtsvc.dll）会使用该会话写入事件查看器中所有与Application.evtx文件有关的数据：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Logger Name           : EventLog-Application </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Logger Id             : 9 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Logger Thread Id      : 000000000000008C </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Buffer Size           : 64 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Maximum Buffers       : 64 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Minimum Buffers       : 2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Number of Buffers     : 2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Free Buffers          : 2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Buffers Written       : 252 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Events Lost           : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Log Buffers Lost      : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Real Time Buffers Lost: 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Flush Timer           : 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Age Limit             : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Real Time Mode        : Enabled </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Log File Mode         : Secure PersistOnHybridShutdown PagedMemory IndependentSession </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">NoPerProcessorBuffering </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Maximum File Size     : 100 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Log Filename          : </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Trace flags           : "Microsoft-Windows-CertificateServicesClient-Lifecycle-User":0x800</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0000000000000:0xff+"Microsoft-Windows-SenseIR":0x8000000000000000:0xff+ </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">... (output cut for space reasons) </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">该
工具还可显示会话中启用的每个提供程序的名称，以及提供程序应该记录的事件类别位掩码。有关位掩码（显示在“Trace 
flags”下）的解读取决于具体的提供程序。例如，提供程序可以定义用类别1（设置位0）表示在初始化和清理阶段生成的事件，用类别2（设置位1）表示
执行注册表I/O过程中生成的事件，以此类推。System会话对Trace 
flags的解读方式略有差异（详见下文“系统记录器”一节）。对于System会话，标记将由启用的内核标记进行解码，内核标记指定了系统会话应该记录
哪些类型的内核事件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">Windows性能监视器除了可以处理系统性能计数器，还可以轻松枚举ETW会话。打开性能监视器（在搜索框中输入perfmon），展开“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>数</b><b>据</b><b>收</b><b>集</b><b>器</b><b>集</b></span>”，并点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>事</b><b>件</b><b>跟</b><b>踪</b><b>会</b><b>话</b></span>”。随后该应用程序会列出与XPERF中所示完全相同的会话。右击一个会话的名称并选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>属</b><b>性</b></span>”，即可查看该会话的各种属性。尤其是“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>安</b><b>全</b></span>”属性会列出该ETW会话安全描述符的解码结果。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/0bfca02bc872cb65ada13ccd5ddd91e9.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">最后，我们也可以使用Microsoft Logman控制台工具（%SystemRoot%\System32\logman.exe）枚举活跃的ETW会话（使用命令行参数-ets）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_160" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>5</b><b>.</b><b>3</b><b> </b><b>E</b><b>T</b><b>W</b><b>提</b><b>供</b><b>程</b><b>序</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，提供程序是一
种产生事件的组件（而包含提供程序的应用程序通常也包含了事件跟踪检测机制）。ETW支持不同类型的提供程序，它们有着类似的编程模型（主要差异在于解码
事件的方式）。提供程序必须首先向ETW注册，随后才能生成事件。通过类似的方式，控制器应用程序可以启用提供程序并将其与ETW会话关联，这样才能接收
来自提供程序的事件。如果任何会话都未启动某个提供程序，那么这个提供程序将无法生成任何事件。何为启用，何为禁用，具体的解释是由提供程序定义的。一般
来说，启用的提供程序可以生成事件，禁用的提供程序无法生成事件。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>提</b><b>供</b><b>程</b><b>序</b><b>的</b><b>注</b><b>册</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">不同类型的提供程序都有自
己的API，需要通过提供程序应用程序（或驱动程序）调用该API才能注册提供程序。例如，基于清单的提供程序需要调用EventRegister 
API进行用户模式的注册，需要调用EtwRegister进行内核模式的注册。所有类型的提供程序最终都需要调用内部的
EtwpRegisterProvider函数，由该函数执行实际的注册过程（并在NT内核和NTDLL中实现）。后者会分配并初始化一个
ETW_GUID_ENTRY数据结构，该数据结构代表了提供程序（这个数据结构还会用于通知和特征）。该数据结构包含重要信息，如提供程序GUID、安
全描述符、引用计数器、启用信息（每个启用了该提供程序的ETW会话），以及提供程序的注册列表。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于用户模式提供程序的注
册，NT内核会针对调用方进程的令牌执行访问检查，并要求具有TRACELOG_REGISTER_GUIDS访问权限。如果检查成功，或如果注册请求源
自内核代码，ETW会将新的ETW_GUID_ENTRY数据结构插入全局ETW每Silo数据结构的一个哈希表中，并以提供程序GUID的哈希值作为表
键（这样即可快速查找系统中注册的所有提供程序）。如果哈希表中已经存在相同GUID的项，则ETW会复用现有项而不再新建。导致GUID已经存在于哈希
表中的原因主要有以下两个。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·另一个驱动程序或应用程序在提供程序实际注册前就已启用该提供程序（详见下文“提供程序的启用”一节）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·该提供程序已经被注册了一次。系统支持同一个提供程序GUID的多次注册。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在将提供程序成功加入全局
列表后，ETW会创建并初始化一个ETW注册对象，该对象代表了具体的某一个注册。该对象中封装了一个ETW_REG_ENTRY数据结构，用于将提供程
序与请求注册的进程和会话绑定（ETW也支持来自不同会话的注册）。该对象会被插入ETW_GUID_ENTRY（此前初始化ETW时，
EtwRegistration对象类型已创建完成，并与NT对象管理器注册结束）内部的一个列表中。图10-34展示了这两个数据结构以及它们之间的相
互关系。在图10-34中，两个提供程序的进程（会话4中的进程A，以及会话16中的进程B）已经向提供程序1进行了注册。因此，两个
ETW_REG_ENTRY数据结构已创建，并链接到代表的提供程序1的ETW_GUID_ENTRY。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/fc5266a9c9a583767d97f1e86c0a0951.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-34 ETW_GUID_ENTRY数据结构和ETW_REG_ENTRY</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">至此，提供程序已注册并已
准备好在请求自己的会话中启用（通过EnableTrace 
API）。如果在注册前已经有至少一个会话启用了该提供程序，则ETW会直接启用（详见下一节）并调用Enablement回调，该回调可由启动注册过程
的EventRegister（或EtwRegister）API的调用方指定。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>枚</b><b>举</b><b>E</b><b>T</b><b>W</b><b>提</b><b>供</b><b>程</b><b>序</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">与
ETW会话类似，XPERF亦可枚举当前已注册提供程序的列表（Windows自带的WEVTUTIL工具也可以做到）。以管理员身份打开一个命令提示符
窗口，并进入Windows性能工具包安装路径。要枚举已注册的提供程序，请使用-providers命令行选项。该选项支持不同的标记。在本实验中，我
们主要涉及I标记和R标记，这两个标记可以让XPERF枚举已安装或已注册的提供程序。正如下文“事件解码”一节所述，这两者的区别在于提供程序已注册
（通过指定GUID），但未安装到
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Publishers注册表键下。这将
阻止任何消费者使用TDH例程解码事件。下列命令：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">cd /d "C:\Program Files (x86)\Windows Kits\10\Windows Performance Toolkit" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">xperf -providers R &gt; registered_providers.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">xperf -providers I &gt; installed_providers.txt </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">会
产生两个包含类似信息的文本文件。打开registered_providers.txt文件可以看到名称和GUID的组合。名称标识不仅已注册，同时也
已安装到Publisher注册表键的提供程序，而GUID代表了只通过上文讨论的EventRegister 
API注册过的提供程序。这里出现的所有名称会与相应的GUID一起出现在installed_providers.txt文件中，但第一个文本文件中列
出的GUID完全不会出现在第二个文本文件中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">XPERF还支持使用K标记（K标记是KF标记和KG标记的超集）枚举系统记录器（详见下文“系统记录器”一节）所支持的全部内核标记和组。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>提</b><b>供</b><b>程</b><b>序</b><b>的</b><b>启</b><b>用</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在提供程序生成事件之前，
必须先与ETW会话关联。这个关联过程也叫提供程序启用，可通过两种方式实现：在提供程序注册前启用，或注册后启用。控制器应用程序可通过
EnableTraceEx 
API为会话启用提供程序，该API可供我们指定一个关键字位掩码，用于确定会话想接收的事件分类。通过相同的方式，该API还支持对其他类型数据进行高
级过滤，如生成事件的进程ID、程序包ID、可执行文件名等（详见https://docs.microsoft.com/windows/win32/
api/evntprov/ns-evntprov-event_filter_descriptor）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">提供程序的启用过程由
ETW在内核模式下通过内部函数EtwpEnableGuid管理。对于用户模式的请求，该函数可针对会话和提供程序安全描述符执行访问检查，并代表调用
方进程的令牌请求TRACELOG_GUID_ENABLE访问权限。如果记录器会话包含SECURITY_TRACE标记，则
EtwpEnableGuid会要求调用进程必须为PPL（详见下文“ETW的安全性”一节）。如果检查成功，则该函数将执行一个与上文讨论的提供程序注
册过程类似的任务。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·分配并初始化一个表示提供程序的ETW_GUID_ENTRY数据结构，如果提供程序已注册，则会使用已经链接的全局ETW每Silo数据结构。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·在ETW_GUID_ENTRY中添加相关会话启用信息，借此将提供程序与记录器会话链接在一起。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果提供程序尚未注册，也就不存在链接至ETW_GUID_ENTRY数据结构的ETW注册对象，此时过程将终止（提供程序必须在首次注册后才能启用）。否则提供程序将成功启用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">老旧的MOF提供程序和
WPP提供程序一次只能在一个会话中启用。基于清单的提供程序和Tracelogging提供程序最多可以在8个会话中启用。如图10-32所示，
ETW_GUID_ENTRY数据结构包含每个可能启用了提供程序的ETW会话（最多8个）的启用信息。EtwpEnableGuid函数会根据启用的会
话计算新的会话启用掩码，并将其存储在ETW_REG_ENTRY数据结构中（代表提供程序的注册）。该掩码非常重要，是生成事件的关键。当一个应用程序
或驱动程序将事件写入提供程序时，还需要进行一项检查：启用掩码中的某位是否等于1。若等于1，则意味着该事件应被写入特定ETW会话维持的缓冲区中；若
不等于1，则意味着会话会被跳过，事件不会被写入其缓冲区。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">请注意，对于安全会话，在
更新提供程序注册所对应的会话启用掩码前，还需要进行一项补充检查。ETW会话的安全描述符应当允许调用方进程访问令牌的
TRACELOG_LOG_EVENT访问权限。否则启用掩码中的相关位将不会被设置为1（目标ETW会话将无法收到来自该提供程序注册所产生的任何事
件）。有关安全会话的详细信息请参阅下文“安全记录器”一节。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_161" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>5</b><b>.</b><b>4</b><b> </b><b>提</b><b>供</b><b>事</b><b>件</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在注册了一个或多个ETW
提供程序后，提供程序即可开始生成事件。请注意，甚至在控制器应用程序还没有机会在ETW会话中启用提供程序的情况下，该提供程序也可以生成事件。应用成
程序或驱动程序生成事件的方式取决于提供程序的类型。例如，将事件写入基于清单的提供程序的应用程序，通常会直接创建事件描述符（按照XML清单的形
式），并使用EventWrite 
API将事件写入启用了该提供程序的ETW会话。而管理MOF和WPP提供程序的应用程序通常会使用TraceEvent API。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文“ETW会话”一节
所述，基于清单的提供程序生成的事件可通过多种方式过滤。ETW会从提供程序注册对象中找到ETW_GUID_ENTRY数据结构（该数据结构由应用程序
通过一个句柄提供）。随后内部函数EtwpEventWriteFull将使用提供程序的注册会话启用掩码在所有与该提供程序（由
ETW_LOGGER_CONTEXT表示）相关，并且已启用的ETW会话之间循环。对于每个会话，会检查事件是否满足所有过滤器的条件。如果满足，则会
计算事件载荷的完整大小，并检查该会话的当前缓冲区中是否还有足够的空间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果没有足够的可用空间，
则ETW会检查该会话是否还有其他可用缓冲区：可用缓冲区存储在一个FIFO（先入先出）队列中。如果有可用缓冲区，则ETW会将原先的缓冲器标记
为“脏”，并切换至新的可用缓冲区。这样，记录器线程即可唤醒并将整个缓冲区刷新到日志文件中，或交付给实时消费者。如果该会话的日志模式为循环记录器，
则不会创建记录器线程：ETW会直接将已写满的旧缓冲区链接到可用缓冲区队列的末尾（因此队列永远不可能为空）。否则，如果队列中没有可用的缓冲区，则
ETW会尝试着分配额外的缓冲区，失败后会向调用方返回错误信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在找到有足够空间的缓冲区后，EtwpEventWriteFull会自动将整个事件载荷写入缓冲区并退出。请注意，如果会话的启用掩码为0，这意味着没有任何会话与该提供程序相关联，此时事件会被丢弃，不会被记录到任何位置。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">MOF事件和WPP事件也
会经历类似过程，但只支持一个ETW会话，并且通常支持的过滤器数量更少。对于此类提供程序，还需要对相关会话进行补充检查：检查控制器应用程序是否将会
话标记为安全的，谁也无法向安全会话中写入任何事件。这种情况下会直接向调用方报错（安全会话详见下文“安全记录器”一节）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>使</b><b>用</b><b>E</b><b>T</b><b>W</b><b>列</b><b>出</b><b>进</b><b>程</b><b>活</b><b>动</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
这个实验中，我们将使用ETW监控系统进程活动。Windows 
10中有两个提供程序可监控此类信息：Microsoft-Windows-Kernel-Process和具备PROC_THREAD内核标记的NT内
核记录器。本实验将使用前者，这是一种经典提供程序，已经包含解码事件所需的全部信息。我们可以使用多种工具捕获跟踪记录，本实验将使用XPERF（但也
可以使用Windows性能监视器）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">打开命令提示符窗口，输入下列命令：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">cd /d "C:\Program Files (x86)\Windows Kits\10\Windows Performance Toolkit" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">xperf -start TestSession -on Microsoft-Windows-Kernel-Process -f c:\process_tr-</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ace.etl </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">上述命令会启动一个名为TestSession的ETW会话（名称可更改），该会话会消费由Kernel-Process提供程序生成的事件，并将其存储在C:\process_trace.etl日志文件（文件名可更改）中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">要确认该会话已成功启动，请重复上文“枚举ETW会话”实验中的步骤（XPERF和Windows性能监视器工具都应该能列出TestSession跟踪会话）。随后即可启动一些新的进程或应用程序（例如记事本或画图）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">要停止ETW会话，请运行如下命令：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">xperf -stop TestSession </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">解
码ETL文件的相关步骤请参阅下文“解码ETL文件”实验。Windows的几乎所有组件都有提供程序，例如Microsoft-Windows-
MSPaint提供程序可生成与“画图”程序功能有关的事件。我们也可以利用从MsPaint提供程序捕获的事件来做这个实验。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_162" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>5</b><b>.</b><b>5</b><b> </b><b>E</b><b>T</b><b>W</b><b>记</b><b>录</b><b>器</b><b>线</b><b>程</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">记录器线程是ETW中最重
要的实体之一。它的主要作用是将事件刷新（Flush）到日志文件或提供给实时消费者，以及跟踪已交付和已丢失事件的数量。每当创建一个新的ETW会话
时，都会启动一个记录器线程，但前提是该会话未使用循环日志模式。线程记录器的执行逻辑很简单。启动后，它会将自己链接至表示相关ETW会话的
ETW_LOGGER_CONTEXT数据结构并等待两个主要同步对象。每当属于一个会话的缓冲区被写满（提供程序生成新的事件后可能会发生这种情况，例
如上文“提供事件”一节中讨论的那样）时，每当一个新的实时消费者请求连接或每当一个记录器会话即将停止时，ETW都会向Flush事件发出信号。只有当
该会话属于实时会话，或用户在调用StartTrace 
API创建新会话时要求明确的情况下，TimeOut计时器才会被初始化为一个有效值（通常为1秒）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当上述两个同步对象中有一
个收到信号时，记录器线程会重置（Rearm）同步对象，并检查文件系统是否就绪。如果未就绪，则主记录器线程会重新返回休眠状态（启动过程的早期阶段，
任何会话均无法进行刷新）。否则会开始刷新该会话所属的每个缓冲区，将其中的内容保存到日志文件或交付给实时消费者。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于实时会话，记录器线程
首先会在%SystemRoot%\System32\LogFiles\WMI\RtBackup文件夹中创建一个临时的每会话ETL文件（见图
10-35）。日志文件的名称是通过为实时会话的名称添加“EtwRT”前缀生成的。该文件可用于在交付给实时消费者之前保存临时事件（日志文件还可以保
存未能及时交付给消费者而丢失的事件）。启动后，实时自动记录器会从日志文件还原丢失的事件，并将其交付给消费者。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3095f056b7d54bd52fb0fab72f0a3491.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-35 实时临时ETL日志文件</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">记录器线程是唯一能在实时
消费者和会话之间建立连接的实体。当消费者首次调用ProcessTrace 
API以便从实时会话接收事件时，ETW会设置一个新的RealTimeConsumer对象，并用它在消费者和实时会话之间创建链接。该对象可以解析为
NT内核中的一个ETW_REALTIME_CONSUMER数据结构，借此即可将事件“注入”消费者的进程地址空间（消费者应用程序提供的另一个用户模
式缓冲区）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于非实时会话，记录器线程会打开（或创建，如果文件不存在）创建会话的实体指定的初始ETL日志文件。如果会话的日志模式指定了EVENT_TRACE_FILE_MODE_NEWFILE标记，并且当前日志文件已经到达最大大小，记录器线程还可以创建全新的日志文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">至此，ETW记录器线程会
将与会话相关的所有缓冲区刷新到当前日志文件（如上文所述，该日志文件可以是实时会话的临时日志文件）。刷新操作在执行过程中会为缓冲区中每条事件添加一
个事件头，并使用NtWriteFile 
API将二进制内容写入ETL日志文件。对于实时会话，记录器线程下一次被唤醒时，会将临时日志文件中存储的所有事件注入目标用户模式实时消费者应用程
序。因此，对实时会话而言，ETW事件从不会以同步的方式交付。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_163" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>5</b><b>.</b><b>6</b><b> </b><b>事</b><b>件</b><b>的</b><b>消</b><b>费</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">ETW中的事件消费几乎完
全是由用户模式下的消费者应用程序负责的，这其中也用到了Sechost.dll提供的服务。消费者应用程序会使用OpenTrace 
API打开主记录器线程生成的ETL日志文件，或通过该API与实时记录器建立连接。应用程序可指定事件回调函数，随后在ETW消费了一个事件后，都会调
用该回调函数。此外，对于实时会话，应用程序还可以提供可选的缓冲区回调函数，该函数可在ETW每次刷新缓冲区后接收统计信息，并在每次有一个缓冲区被写
满并交付给消费者时调用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">实际的事件消费操作是由ProcessTrace API发起的。该API适用于标准会话和实时会话，具体模式取决于之前传递给OpenTrace的日志文件模式标记。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于实时会话，该API会
使用内核模式服务（可通过NtTraceControl系统调用访问）验证ETW会话是实时会话。NT内核会验证ETW会话的安全描述符是否向调用方进程
的令牌授予了TRACELOG_ACCESS_REALTIME访问权限。如果不具备这个权限，则该API将失败并向控制器应用程序报错。否则会分配一个
临时的用户模式缓冲区和位图，借此接收事件并连接到主记录器线程（该线程创建了相关的EtwConsumer对象，详见上文“ETW记录器线程”一节）。
连接建立后，该API会等待来自会话记录器线程的新数据。数据抵达后，该API会枚举每个事件并调用事件回调。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于常规的非实时ETW会
话，将由ProcessTrace 
API执行类似的处理，但并不需要连接到记录器线程，只需要打开并解析ETL日志文件，逐个读取缓冲区并为找到的每个事件调用事件回调（事件会按时间先后
顺序排序）。与每次只能消费一个事件的实时记录器不同，非实时情况下，API甚至可以与OpenTrace 
API创建的多个跟踪处理程序一同工作，这意味着可以解析来自不同ETL日志文件的事件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">使用循环缓冲区的ETW会
话所产生的事件并不使用上述方法处理（此时并不存在负责转储事件的记录器线程）。通常情况下，当控制器应用程序希望将配置为循环缓冲区的ETW会话的当前
缓冲区快照转储为日志文件时，会使用FlushTrace 
API。该API可通过NtTraceControl系统调用来调用NT内核，借此定位ETW会话并验证其安全描述符为调用方进程的访问令牌授予了
TRACELOG_CREATE_ONDISK访问权限。如果一切正常，并且控制器应用程序指定了有效的日志文件名，则NT内核会调用内部
EtwpBufferingModeFlush例程，借此创建新的ETL文件，添加适当的文件头，并写入与该会话相关的所有缓冲区。随后消费者应用程序即
可按照上文描述的方式，使用OpenTrace和ProcessTrace API解析新日志文件中写入的事件。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>事</b><b>件</b><b>解</b><b>码</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当
ProcessTrace 
API检测到ETW缓冲区中出现新事件后，会调用通常位于消费者应用程序中的事件回调。为了正确处理事件，消费者应用程序还需要解码事件载荷。事件跟踪解
码助手库（TDH.dll）为消费者应用程序提供了解码事件所需的一系列服务。如上文所述，提供程序（或驱动程序）应包含相关信息，这些信息描述了该如何
解码已注册提供程序所生成的事件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">根据提供程序类型的不同，
这些信息的编码方式各异。例如，基于清单的提供程序会将事件的XML描述符编译为二进制文件，并将其存储在它们的提供程序（或驱动程序）的资源节中。在提
供程序注册过程中，需要由安装程序在
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Publishers注册表键下注册提
供程序的二进制文件。这对事件解码很重要，特别是出于下列原因。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·当系统需要将提供程序的名称解析为对应的GUID时，需要查询Publishers键（从ETW的角度来看，提供程序并不需要具备名称）。这样即可让Xperf之类的工具能够显示更易读的提供程序名称，而非GUID。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·跟踪解码助手库会查询该键以检索提供程序的二进制文件，解析其资源节，并读取事件描述符的二进制内容。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在获得事件描述符后，跟踪
解码助手库就通过解析二进制描述符获得了解码事件所需的全部信息，进而可以让消费者应用程序使用TdhGetEventInformation 
API获取事件载荷所包含的全部字段，并正确解读其中关联的所有数据。TDH为MOF和WPP提供程序采取了类似过程（TraceLogging会将所有
解码数据纳入载荷中，并使用标准的二进制格式）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">请注意，所有事件都会被
ETW以原生形式存储在ETL日志文件中，该文件采用了一种明确定义的未压缩二进制格式，其中不包含事件解码信息。这意味着如果ETL文件被另一个未获得
跟踪结果的系统打开，则很可能将无法解码事件。为解决这些问题，事件查看器使用了另一种二进制格式，即EVTX。该格式包含所有事件及其解码信息，可被其
他应用程序更轻松地解析。应用程序可以使用EvtExportLog这个Windows事件日志API，将ETL文件中包含的事件及其解码信息保存为
EVTX文件。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>解</b><b>码</b><b>E</b><b>T</b><b>L</b><b>文</b><b>件</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">Windows自带的多个工具可使用EvtExportLog API自动转换ETL日志文件并包含所有解码信息。在这个实验中，我们将使用netsh.exe，但TraceRpt.exe也有类似功能。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">1）打开命令提示符窗口并进入上一个实验（“使用ETW列出进程活动”实验）生成的ETL文件所在目录，输入：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">netsh trace convert input=process_trace.etl output=process_trace.txt dump=</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">txt overwrite=yes </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">2）其中process_trace.etl是输入日志文件的名称，process_trace.txt是解码后的输出文件的名称。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">3）打开该文本文件即可看到解码后的事件（一行一个事件）及其描述，例如：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">[2]1B0C.1154::2020-05-01 12:00:42.075601200 [Microsoft-Windows-Kernel-Process]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Process 1808 started at time 2020 - 05 - 01T19:00:42.075562700Z by parent 6924 running</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">in session 1 with name \Device\HarddiskVolume4\Windows\System32\notepad.exe. </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">4）从日志中可以看到，可能有少数事件不能完整解码或不包含任何描述。这是因为提供程序清单未包含所需信息（例如ThreadWorkOnBehalfUpdate事件）。为了排除这些事件，可以获取不包含响应关键字的跟踪。事件关键字存储在CSV或EVTX文件中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">5）使用netsh.exe通过下列命令生成EVTX文件：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">netsh trace convert input=process_trace.etl output=process_trace.evtx dump=evtx </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">overwrite=yes </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">6）打开事件查看器，在左侧的控制台树窗格中，右键点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>事</b><b>件</b><b>查</b><b>看</b><b>器</b><b>（</b><b>本</b><b>地</b><b>）</b></span>”根节点，选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>打</b><b>开</b><b>保</b><b>存</b><b>的</b><b>日</b><b>志</b></span>”，选择刚创建的process_trace.evtx文件并点击打开。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">7）在打开保存的日志窗口中为该日志设置一个名称，选择要显示到的文件夹（本例使用了默认名称process_trace以及默认的Saved Logs文件夹）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">8）随后事件查看器应该会显示该日志文件中的每条事件。点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>日</b><b>期</b><b>和</b><b>时</b><b>间</b></span>”列可以按照日期和时间以降序排列所有事件（从最老的到最新的）。请使用Ctrl+F搜索ProcessStart，找到代表Notepad.exe进程成功创建的事件。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/96f4266f686aa8a6fedeb4388c401bc7.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">9）ThreadWorkOnBehalfUpdate事件不包含人工易读的描述，因为噪声太多，因此可以将其从跟踪中排除。如果点击一个此类事件并打开“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>详</b><b>细</b><b>信</b><b>息</b></span>”选
项卡，随后在System节点下应该可以看到该事件属于WINEVENT_KEYWORD_WORK_ON_BEHALF类别，其关键字位掩码被设置为
0x8000000000002000（请注意，关键字的最高16位是为微软定义的类别保留的）。64位0x8000000000002000值的
Bitwise NOT（非）运算结果为0x7FFFFFFFFFFFDFFF。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">10）关闭事件查看器，通过XPERF使用下列命令捕获另一个跟踪：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">xperf -start TestSession -on Microsoft-Windows-Kernel-Process:0x7FFFFFFFFFFFDFFF </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-f c:\process_trace.etl </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">11）打开注册表或其他应用程序，随后停止跟踪，具体操作可参阅“使用ETW列出进程活动”实验。将ETL文件转换为EVTX。这次获得的解码后日志文件应该小很多，并且其中不包含ThreadWorkOnBehalfUpdate事件。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_164" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>5</b><b>.</b><b>7</b><b> </b><b>系</b><b>统</b><b>记</b><b>录</b><b>器</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">至此，我们介绍的都是常规
ETW会话和提供程序的工作原理。自Windows 
XP开始，ETW支持系统记录器的概念，借此NT内核可以在全局范围内发出日志事件，这种日志不与任何提供程序绑定，通常用于测量性能。截至撰写这部分内
容，主要有两种系统记录器可用，它们分别由NT内核记录器和循环内核上下文记录器所表示（全局记录器是NT内核记录器的子集）。NT内核记录器最多支持8
个系统记录器会话。从系统记录器接收事件的每个会话都可视为一个系统会话。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">要启动系统会话，应用程序
需要使用StartTrace 
API，并指定EVENT_TRACE_SYSTEM_LOGGER_MODE标记或系统记录器会话的GUID作为输入参数。表10-16列出了系统记录
器及其GUID。NT内核中的EtwpStartLogger函数可以识别该标记或特殊GUID，并针对NT内核记录器安全描述符进行一项额外检查，代表
调用方进程安全令牌请求TRACELOG_GUID_ENABLE访问权限。如果检查通过，则ETW会计算系统记录器索引，并更新记录器组掩码和系统全局
性能组掩码。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表10-16 系统记录器</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/de144eda8f3a90d746d4a72fcfe8bc80.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上述最后一步是系统记录器
正常工作的关键。很多底层系统函数可以在高IRQL下运行（如Context 
Swapper），解析分析性能组掩码并决定是否将一个事件写入系统记录器。控制器应用程序可以为系统记录器启用或禁用不同的事件记录，为此只需要修改
StartTrace API和ControlTrace 
API使用的Enableflags位掩码。系统记录器记录的事件在内部会以明确定义的顺序存储在全局性能组掩码中。该掩码由8个32位值的数组组成，数
组中的每个索引都表示一个事件集。系统事件集（也叫组）可使用Xperf工具来枚举。表10-17列出了系统记录器事件及其在不同组的分类。大部分系统记
录器事件的详细信息可参阅https://docs.microsoft.com/windows/win32/api/evntrace/ns-
evntrace-event_trace_properties。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">表10-17 系统记录器事件（内核标记）及其组</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a25e8ce018e27da9d21a755800df957a.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/0c3d1259d0e771358ee0cbf39dd7471c.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/630225c8cbcfc3b8f58089e2b6818232.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/782b527a0b50786bf40ebe9e86bd5454.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/95d8998b2cca3adce9c5da43e3284140.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/238a9780c9c23f8d42656666c6e10959.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/46a420ebd8c1ba176e95fa9ee1008d53.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当系统会话启动时，事件会
被立即记录，无须启用任何提供程序。这意味着消费者应用程序无法以常规的方式对事件进行解码。基于事件类型，系统记录器事件使用了一种精确的事件编码格式
（名为NTPERF）。大部分代表不同NT内核记录器事件的数据结构都在Windows平台SDK文档中有详细记录。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>使</b><b>用</b><b>内</b><b>核</b><b>记</b><b>录</b><b>器</b><b>跟</b><b>踪</b><b>T</b><b>C</b><b>P</b><b>/</b><b>I</b><b>P</b><b>活</b><b>动</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
这个实验中，我们将使用Windows性能监视器监听系统记录器生成的网络活动事件。正如“枚举ETW会话”实验中介绍的那样，这个图形化工具不仅可以获
取来自系统性能计数器的数据，还能启动、停止和管理ETW会话（包括系统会话）。要启用内核记录器并让它为TCP/IP活动生成日志文件，请执行如下操
作。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">1）运行性能监视器（在搜索框中输入perfmon）并点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>数</b><b>据</b><b>收</b><b>集</b><b>器</b><b>集</b><b>，</b><b>用</b><b>户</b><b>定</b><b>义</b></span>”。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">2）右击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>用</b><b>户</b><b>定</b><b>义</b></span>”，选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>新</b><b>建</b></span>”，随后选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>数</b><b>据</b><b>收</b><b>集</b><b>器</b><b>集</b></span>”。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">3）为该数据收集器集设置一个名称（例如“Experiment”），选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>手</b><b>动</b><b>创</b><b>建</b><b>（</b><b>高</b><b>级</b><b>）</b></span>”，随后点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>下</b><b>一</b><b>页</b></span>”。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">4）在随后出现的对话框中，选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>创</b><b>建</b><b>数</b><b>据</b><b>日</b><b>志</b></span>”，选中“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>事</b><b>件</b><b>跟</b><b>踪</b><b>数</b><b>据</b></span>”，再点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>下</b><b>一</b><b>页</b></span>”。在提供程序选项中点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>添</b><b>加</b></span>”，再选择Windows Kernel Trace。点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>确</b><b>定</b></span>”。在属性列表中选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>关</b><b>键</b><b>字</b><b>（</b><b>任</b><b>意</b><b>）</b><b>”</b></span>，随后点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>编</b><b>辑</b></span>”。</span></p><div style="display: block;text-align:center;">
	<img width="632" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3e8865d34b92ec5273eeba91bfabc235.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">5）在随后显示的属性窗口中，选中“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>自</b><b>动</b></span>”，然后只选择对应Network TCP/IP的“net”，再点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>确</b><b>定</b></span>”。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">6）点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>下</b><b>一</b><b>页</b></span>”，选择日志文件的保存位置。如果将该数据收集器命名为“Experiment”，默认情况下，位置为%SystemDrive%\PerfLogs\Admin\experiment\。点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>下</b><b>一</b><b>页</b></span>”，并在身份文本框中输入Administrator账户名和正确的密码。点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>完</b><b>成</b></span>”，然后应该可以看到类似下图所示的窗口。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3a5bf0b951a7ee2cbff146eb73d92353.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">7）右击这个数据收集器集的名称（本例中为“Experiment”），点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>开</b><b>始</b></span>”。随后打开浏览器并访问一些网页，借此生成一些网络活动。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">8）再次右击该数据收集器集节点，选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>停</b><b>止</b></span>”。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">接
下来按照上文“解码ETL文件”实验中列出的步骤解码所获得的ETL跟踪文件，可以发现，读取结果的最佳方式是使用CSV文件类型。这是因为系统会话并不
包含任何事件的解码信息，因此，netsh.exe无法通过适当方法解码EVTX文件中表示这些事件的自定义数据结构。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">最后，我们可以借助XPERF工具使用下列命令重复该实验（可选：将C:\network.etl文件替换为自己希望使用的其他名称）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">xperf -on NETWORKTRACE -f c:\network.etl </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">停止系统跟踪会话并转换获得的跟踪文件后，将能看到与性能监视器中类似的事件。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>全</b><b>局</b><b>记</b><b>录</b><b>器</b><b>和</b><b>自</b><b>动</b><b>记</b><b>录</b><b>器</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">一些记录器会话会在系统启
动时自启动。全局记录器（global 
logger）会话可记录在操作系统启动早期阶段发生的事件，包括NT内核记录器所生成的事件（全局记录器实际上是一种系统记录器，详见表10-16）。
应用程序和设备驱动程序可以使用全局记录器会话记录用户登录前产生的跟踪（某些设备驱动程序，如磁盘设备驱动程序，无法在全局记录器会话开始时加载）。全
局记录器主要用于捕获NT内核提供程序（详见表10-17）产生的跟踪，而自动记录器（autologger）可捕获来自经典ETW提供程序（而不是来自
NT内核记录器）的跟踪。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">我们可以通过注册表中的
GlobalLogger键配置全局记录器，该键位于HKLM\SYSTEM\CurrentControlSet\Control\WMI根键下。通过
类似的方式，也可以创建与登录会话同名的注册表子键Autologger（位于WMI根键下）来配置自动记录器。配置和启动自动记录器的详细过程请参阅
https://docs.microsoft.com/windows/win32/etw/configuring-and- 
starting-an-Autologger-session。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如上文“ETW初始
化”一节所述，在NT内核初始化的阶段1期间，ETW会几乎同时启动全局记录器和自动记录器。内部函数EtwStartAutoLogger会从注册表中
查询所有记录器配置数据，并对其进行验证，随后使用EtwpStartLogger例程创建记录器会话（该例程的详细信息请参阅“ETW会话”一节）。全
局记录器是一种系统记录器，因此在会话创建完成后，不会再进一步启用提供程序。与全局记录器不同，自动记录器需要启用提供程序，为此需要从
Autologger注册表键枚举每个会话的名称。会话创建完成后，ETW会枚举为该会话启用的提供程序，这些提供程序以注册表子键的形式包含在
Autologger键下（提供程序可通过GUID来识别）。图10-36展示了EventLog-System会话中启用的多个提供程序。该会话是
Windows事件查看器中显示的Windows主要日志之一（由Event Logger服务捕获）。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/c8d7a75fbe8435efb4a08e654e957c0b.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-36 EventLog-System自动记录器中启用的提供程序</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">提供程序的配置数据验证完毕后，即可通过内部函数EtwpEnableTrace在会话中启用提供程序，这与ETW会话中的做法类似。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_165" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>5</b><b>.</b><b>8</b><b> </b><b>E</b><b>T</b><b>W</b><b>的</b><b>安</b><b>全</b><b>性</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">ETW会话的启动和停止被
视为一种高特权操作，因为事件中可能包含可利用系统完整性的系统数据（对于系统记录器来说，这种情况尤为重要）。Windows安全模型通过扩展可以为
ETW的安全性提供支持。正如上文所述，ETW执行的每个操作都需要一个明确定义的访问权限，该权限需要由保护会话、提供程序或提供程序组（取决于具体操
作）的安全描述符来赋予。表10-18列出了ETW中引入的所有新访问权限及其用途。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表10-18 ETW安全访问权限及其用途</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/8ba973ea6cd82f7e0506196fcc328379.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">大部分ETW访问权限会自
动授予SYSTEM账户，以及Administrators、Local Service和Network 
Service组的成员。这意味着普通用户不允许与ETW交互（除非会话和提供程序的安全描述符明确允许）。为解决该问题，Windows提供了一个
Performance Log 
Users组，按照设计，该组可以让普通用户与ETW交互（尤其是可以控制跟踪会话）。虽然默认安全描述符将所有ETW访问权限都授予了
Performance Log Users组，但Windows还为另一个组Performance Monitor 
Users提供了支持，该组在设计上只用于向会话通知提供程序收发通知。这是因为该组在设计上可以访问系统性能计数器，可以通过诸如性能监视器和资源监视
器等工具进行枚举，但无法访问完整的ETW事件。这两个工具的详细信息请参阅卷1第1章。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如上文“ETW会话”一
节所述，所有ETW安全描述符均以一种二进制格式存储在
HKLM\System\CurrentControlSet\Control\Wmi\Security注册表键下。在ETW中，一切可由GUID表示
的东西均可使用自定义的安全描述符加以保护。为了管理ETW安全性，应用程序通常并不直接与存储在注册表中的安全描述符交互，而是会使用
Sechost.dll中实现的EventAccessControl和EventAccessQuery API。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>E</b><b>T</b><b>W</b><b>会</b><b>话</b><b>的</b><b>默</b><b>认</b><b>安</b><b>全</b><b>描</b><b>述</b><b>符</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">借
助内核调试器可以轻松查看与ETW会话相关，但没有明确指定的默认安全描述符。在这个实验中，我们需要一台运行Windows 
10的计算机，以及通过内核调试器附加并连接的主机系统。或者也可以使用本地内核调试器或LiveKd（下载地址：https://
docs.microsoft.com/sysinternals/downloads/livekd）。配置了正确的符号后，即可使用下列命令转储默认
安全描述符：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">!sd poi(nt!EtwpDefaultTraceSecurityDescriptor) </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后应该能看到类似下列输出结果（为节约版面，输出内容有所删减）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Revision: 0x1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Sbz1    : 0x0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Control : 0x8004 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">             SE_DACL_PRESENT </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">             SE_SELF_RELATIVE </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Owner    : S-1-5-32-544 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Group    : S-1-5-32-544 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;AclRevision: 0x2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Sbz1       : 0x0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;AclSize    : 0xf0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;AceCount   : 0x9 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Sbz2       : 0x0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[0]: -&gt;AceType: ACCESS_ALLOWED_ACE_TYPE </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[0]: -&gt;Aceflags: 0x0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[0]: -&gt;AceSize: 0x14 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[0]: -&gt;Mask : 0x00001800 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[0]: -&gt;SID: S-1-1-0 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[1]: -&gt;AceType: ACCESS_ALLOWED_ACE_TYPE </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[1]: -&gt;Aceflags: 0x0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[1]: -&gt;AceSize: 0x14 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[1]: -&gt;Mask : 0x00120fff </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[1]: -&gt;SID: S-1-5-18 </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[2]: -&gt;AceType: ACCESS_ALLOWED_ACE_TYPE </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[2]: -&gt;Aceflags: 0x0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[2]: -&gt;AceSize: 0x14 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[2]: -&gt;Mask : 0x00120fff </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[2]: -&gt;SID: S-1-5-19 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[3]: -&gt;AceType: ACCESS_ALLOWED_ACE_TYPE </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[3]: -&gt;Aceflags: 0x0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[3]: -&gt;AceSize: 0x14 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[3]: -&gt;Mask : 0x00120fff </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[3]: -&gt;SID: S-1-5-20 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[4]: -&gt;AceType: ACCESS_ALLOWED_ACE_TYPE </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[4]: -&gt;Aceflags: 0x0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[4]: -&gt;AceSize: 0x18 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[4]: -&gt;Mask : 0x00120fff </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[4]: -&gt;SID: S-1-5-32-544 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[5]: -&gt;AceType: ACCESS_ALLOWED_ACE_TYPE </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[5]: -&gt;Aceflags: 0x0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[5]: -&gt;AceSize: 0x18 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[5]: -&gt;Mask : 0x00000ee5 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[5]: -&gt;SID: S-1-5-32-559 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[6]: -&gt;AceType: ACCESS_ALLOWED_ACE_TYPE </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[6]: -&gt;Aceflags: 0x0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[6]: -&gt;AceSize: 0x18 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[6]: -&gt;Mask : 0x00000004 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">-&gt;Dacl     : -&gt;Ace[6]: -&gt;SID: S-1-5-32-558 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们可以使用Psgetsid工具（下载地址为https://docs.microsoft.com/sysinternals/downloads/
psgetsid），将SID转换为人工易读的名称。从上述输出结果可以看到，所有ETW访问权限均已授予SYSTEM（S-1-5-18）、LOCAL
 SERVICE（S-1-5-19）、NETWORK 
SERVICE（S-1-5-18）以及Administrators（S-1-5-32-544）组。如上文所述，Performance Log 
Users组（S-1-5-32-559）几乎拥有所有ETW访问权限，而Performance Monitor 
Users组（S-1-5-32-558）只具备会话的默认安全描述符所授予的WMIGUID_NOTIFICATION访问权限。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\Users\andrea&gt;psgetsid64 S-1-5-32-559 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PsGetSid v1.45 - Translates SIDs to names and vice versa </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright (C) 1999-2016 Mark Russinovich </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sysinternals - www.sysinternals.com </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Account for AALL86-LAPTOP\S-1-5-32-559: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Alias: BUILTIN\Performance Log Users </span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>安</b><b>全</b><b>审</b><b>核</b><b>记</b><b>录</b><b>器</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全审核记录器
（security audit logger）是一种ETW会话，Windows Event 
logger服务（wevtsvc.dll）会使用它来监听Security Lsass提供程序生成的事件。Security 
Lsass提供程序（GUID为{54849625-5478-4994-a5ba-3e3b0328c30d}）只能由NT内核在ETW初始化过程中注
册，永远不会插入全局提供程序的哈希表中。只有将EnableSecurityProvider注册表值配置为1的安全审核记录器和自动记录器可以从
Security 
Lsass提供程序接收事件。当内部函数EtwStartAutoLogger遇到设置为1的这个值后，便会启用相关ETW会话的
SECURITY_TRACE标记，将会话添加到可接收安全审核事件的记录器列表中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">该标记还会产生一个重要影响：用户模式应用程序将无法继续查询、停止、刷新或控制会话，除非应用程序以受保护进程轻型（Antimalware、Windows或WinTcb级别）形式运行（有关受保护进程的详情请参阅卷1第3章）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>安</b><b>全</b><b>记</b><b>录</b><b>器</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">经典（MOF）和WPP提
供程序在设计上并不能支持基于清单的提供程序和Tracelogging提供程序所实现的所有安全功能。因此，可以使用
EVENT_TRACE_SECURE_MODE标记创建自动记录器或通用ETW会话，借此将会话标记为安全的。安全会话意在确保自己只从可信赖的实体接
收事件。该标记的影响主要有以下两个。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·防止经典（MOF）和WPP提供程序将事件写入安全会话。如果安全会话中启用了经典提供程序，则该提供程序将无法生成任何事件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·要求补充TRACELOG_LOG_EVENT访问权限，该权限由会话的安全描述符授予控制器应用程序的访问令牌，同时会在安全会话中启用提供程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">TRACE_LOG_EVENT
访问权限可用于在会话的安全描述符中指定更细化的安全设置。如果安全描述符只向一个不受信任的用户授予TRACELOG_GUID_ENABLE，并且
ETW会话由另一个实体（内核驱动程序或更高特权的应用程序）创建为安全会话，那么这个不受信任的用户将无法在安全会话中启用任何提供程序。如果该会话是
非安全会话，那么这个不受信任的用户就可以在其中启用任何提供程序。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter10_0006.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_166" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>6</b><b> </b><b>动</b><b>态</b><b>跟</b><b>踪</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，
Windows事件跟踪（ETW）是Windows在操作系统中集成的一种强大的跟踪技术，但它是静态的，意味着最终用户只能跟踪和记录由操作系统或第三
方框架/应用程序（如.NET CLR）妥善定义的组件所产生的事件。为了打破这一限制，Windows 
10的2019年5月更新（19H1）引入了DTrace，这是Windows自带的一种动态跟踪技术。管理员可以使用DTrace针对正在运行的系统检
查用户程序和操作系统自身的行为。DTrace是一种开源技术，最初为Solaris操作系统（及其后续版本illumos，它们均是基于UNIX的）开
发，现已移植到Windows之外的很多操作系统。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">DTrace可以在用户关
注的某些位置（这些位置也叫探针，Probe）动态地监测操作系统和用户应用程序的某些部分。探针是一种二进制代码位置或活动，当它被触发时，
DTrace可以绑定一个请求进而执行一系列活动，例如记录消息、捕获堆栈跟踪或时间戳等。启动探针后，DTrace会收集来自探针的数据，并执行与探针
相关的活动。探针和活动均可通过脚本文件使用D编程语言来指定（或直接在DTrace应用程序中通过命令行指定）。对探针的支持是由名为提供程序的内核模
块提供的。最初的illumos 
DTrace支持约20个提供程序，这些提供程序与基于UNIX的操作系统紧密相联。在撰写这部分内容时，Windows可支持下列提供程序。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·SYSCALL：用于跟踪从用户模式应用程序和内核模式驱动程序（通过Zw* API）发出的OS系统调用（进入和退出）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·FBT（函数边界跟踪）：借助FBT，系统管理员可以跟踪在NT内核中运行的所有模块中所实现的各个函数的执行情况。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·PID（用户模式进程跟踪）：该提供程序与FBT类似，可用于跟踪用户模式进程和应用程序中的函数。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·ETW（Windows事件跟踪）：DTrace可使用该提供程序附加至ETW引擎发出的基于清单的事件和TraceLogging事件。DTrace可以定义新的ETW提供程序并通过etw_trace操作（不属于任何提供程序）提供相关的ETW事件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·PROFILE：提供与基于时间的中断相关的探针，每隔指定的固定时间触发。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·DTRACE：内置提供程序，在DTrace引擎中隐式启用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上述提供程序可供系统管理员动态跟踪Windows操作系统和用户模式应用程序的几乎所有组件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 Windows中的第一版DTrace出现在Windows 
10的2019年5月更新中，该版本与目前的稳定版（截至撰写这部分内容，包含在Windows 
10的2021年5月更新中）有较大差异。其中最明显的差异在于：第一版需要设置内核调试器才能启用FBT提供程序。此外，在第一版DTrace中，
ETW提供程序并不完全可用。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>启</b><b>用</b><b>D</b><b>T</b><b>r</b><b>a</b><b>c</b><b>e</b><b>并</b><b>列</b><b>出</b><b>已</b><b>安</b><b>装</b><b>的</b><b>提</b><b>供</b><b>程</b><b>序</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
这个实验中，我们将安装并启用DTrace，随后列出可动态跟踪各种Windows组件的提供程序。我们需要一台运行Windows 
10的2020年5月更新（20H1）或后续版本的计算机。按照微软文档（https://docs.microsoft.com/windows-
hardware/drivers/devtest/DTrace）的说明，首先需要启用DTrace，为此请以管理员身份打开命令提示符窗口，然后输入
下列命令（如果BitLocker已启用，请先将其禁用）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">bcdedit /set dtrace ON </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后下载并安装DTrace软件包（https://www.microsoft.com/download/details.aspx? id=100441）。重启动计算机（或虚拟机），随后以管理员身份打开命令提示符窗口（在搜索框中输入CMD并选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>以</b><b>管</b><b>理</b><b>员</b><b>身</b><b>份</b><b>运</b><b>行</b></span>”）。运行下列命令（可将providers.txt替换为自己希望使用的其他文件名）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">cd /d "C:\Program Files\Dtrace" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">dtrace -l &gt; providers.txt </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">打
开生成的文件（本例中为providers.txt）。如果DTrace已成功安装并启用，则应该能在输出文件中看到探针和提供程序（DTrace、
syscall和ETW）列表。探针由ID和人工易读的名称组成。这个人工易读的名称则由四部分组成，每部分可能存在，也可能不存在，这主要取决于提供程
序本身。一般来说，提供程序会尽可能遵守相关约定的要求，但某些情况下，每部分的含义也可能超出最初的定义。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>提</b><b>供</b><b>程</b><b>序</b><b>（</b><b>P</b><b>r</b><b>o</b><b>v</b><b>i</b><b>d</b><b>e</b><b>r</b><b>）</b></span>：发布该探针的DTrace提供程序的名称。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>模</b><b>块</b><b>（</b><b>M</b><b>o</b><b>d</b><b>u</b><b>l</b><b>e</b><b>）</b></span>：如果该探针对应程序中的某个特定位置，那么这部分表示探针所在模块的名称。模块仅供PID（上述DTrace -l命令的输出结果并未包含PID信息）和ETW提供程序使用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>函</b><b>数</b><b>（</b><b>F</b><b>u</b><b>n</b><b>c</b><b>t</b><b>i</b><b>o</b><b>n</b><b>）</b></span>：如果该探针对应程序中的某个特定位置，那么这部分表示探针所在程序函数的名称。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>名</b><b>称</b><b>（</b><b>N</b><b>a</b><b>m</b><b>e</b><b>）</b></span>：探针名称的最后一部分表示探针在语义方面的某些含义，例如BEGIN或END。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在写出探针完整的人工易读名称时，名称的不同部分会使用冒号隔开，例如：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">syscall::NtQuerySystemInformation:entry </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">上述名称指定了对Syscall提供程序提供NtQueryInformation函数项进行的探测。请注意，上述例子中的模块名称是空的，因为Syscall提供程序并未指定任何名称（所有Syscall都由NT内核隐式提供）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">PID和FBT提供程序反而会根据自己应用到的进程或内核映像以及当前可用的符号动态地生成探针。例如，为了正确列出进程的PID探针，我们首先需要获得分析的进程对应的进程ID（PID）（只需打开“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>任</b><b>务</b><b>管</b><b>理</b><b>器</b></span>”，打开“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>详</b><b>细</b><b>信</b><b>息</b></span>”选项卡。本例中我们选择了Notepad，在测试系统中，它的PID为8020）。随后使用下列命令执行DTrace：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">dtrace -ln pid8020:::entry &gt; pid_notepad.txt </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后会列出PID提供程序为Notepad进程生成的函数条目上的所有探针。输出结果会包含大量条目。请注意，如果未设置符号存储路径，则输出结果将不包含任何由私有函数生成的探针。要限制输出的内容，可以添加下列模块名称：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">dtrace.exe -ln pid8020:kernelbase::entry &gt;pid_kernelbase_notepad.txt </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">这样即可得到在Notepad中映射的kernelbase.dll模块的函数条目所产生的全部PID探针。如果使用下列命令设置符号存储路径：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">set_NT_SYMBOL_PATH=srv*C:\symbols*http://msdl.microsoft.com/download/symbols</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">再重新执行之前的两条命令，则会发现输出结果会产生巨大的差异（并且可以看到私有函数的探针）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">正
如下文“函数边界跟踪（FBT）和进程（PID）提供程序”一节所述，PID和FBT提供程序可应用于函数代码中的任何偏移量。下列命令可返回PID提供
程序能为Kernelbase.dll中的SetComputerNameW函数生成探针的所有偏移量（总是位于指令边界处）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">dtrace.exe -ln pid8020:kernelbase:SetComputerNameW: </span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_167" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>6</b><b>.</b><b>1</b><b> </b><b>内</b><b>部</b><b>架</b><b>构</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文“启用DTrace
并列出已安装的提供程序”实验所述，在Windows 
10的2020年5月的更新（20H1）中，需要通过外部程序包来安装DTrace的某些组件。未来版本的Windows可能会将DTrace完全集成在
操作系统映像中。虽然DTrace与操作系统深度集成，但仍然依赖三个外部组件才能正常工作。这些组件包括NT特有的实现，以及根据通用开发和分发许可证
（Common Development and Distribution 
License，CDDL）自由发布的原始DTrace代码，这些代码可从https://github.com/microsoft/DTrace-
on-Windows/tree/windows下载。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如图10-37所示，Windows中的DTrace包含下列组件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·DTrace.sys：DTrace扩展驱动程序是最主要的组件，负责执行与探针相关的操作并将结果存储在循环缓冲区中，用户模式应用程序可通过IOCTL从缓冲区中获取内容。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·DTrace.dll：该模块封装了LibDTrace，这是DTrace的用户模式引擎。它实现了D脚本编译器，可将IOCTL发送给DTrace驱动程序，同时也是循环DTrace缓冲区（DTrace驱动程序在这里存储操作结果）的主要消费者。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·DTrace.exe：入口点可执行文件，负责将所有可能的命令（通过命令行指定）分发给LibDTrace。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/28e6f7661fe431f19460f2d708d1f584.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-37 DTrace内部架构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了启动对Windows
内核、驱动程序或用户模式应用程序的动态跟踪，用户只需调用DTrace.exe主可执行文件，并指定一个命令或外部D脚本即可。在这两种情况下，命令或
脚本文件中可包含一个或多个探针，以及用D编程语言表达的其他操作。DTrace.exe会解析输入的命令行，并将相应请求转发给LibDTrace（实
现于DTrace.dll中）。例如，当启动并启用一个或多个探针时，DTrace可执行文件会调用LibDTrace中实现的内部函数
DTrace_program_fcompile，由该函数编译D脚本并在输出缓冲区中生成DTrace中间格式（DTrace 
Intermediate Format，DIF）字节码。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 有关DIF字节码和D脚本（或D命令）编译方式的详细介绍已超出了本书范围。感兴趣的读者可通过剑桥大学出版的<span style="font-size:16px;font-style: oblique;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><i>O</i><i>p</i><i>e</i><i>n</i><i>D</i><i>T</i><i>r</i><i>a</i><i>c</i><i>e</i><i> </i><i>S</i><i>p</i><i>e</i><i>c</i><i>i</i><i>f</i><i>i</i><i>c</i><i>a</i><i>t</i><i>i</i><i>o</i><i>n</i></span>（OpenDTrace规范）一书进一步了解详情：https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-924.pdf。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然D编译器完全是在用户
模式下的LibDTrace中实现的，但为了执行编译后的DIF字节码，LibDTrace模块只需将DTRACEIOC_ENABLE 
IOCTL发送给DTrace驱动程序，该驱动程序实现了一种DIF虚拟机。DIF虚拟机可以评估字节码中表达的每条D子句，并执行与其相关的可选操作。
有一组较为有限的可用操作可通过原生代码执行，而无须通过D虚拟机进行解释。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如图10-37所示，DTrace扩展驱动程序实现了所有提供程序。在讨论主提供程序工作原理之前，有必要先介绍Windows操作系统中的DTrace初始化过程。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>D</b><b>T</b><b>r</b><b>a</b><b>c</b><b>e</b><b>初</b><b>始</b><b>化</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">DTrace的初始化始于
系统启动的早期阶段，当时Windows加载器正在加载内核正确启动所需的全部模块。加载和验证过程有个重要部件：API集文件
（apisetschema.dll），它是Windows系统的重要组件（API集详见卷1第3章）。如果启动项中设置了BCD的
DTRACE_ENABLED元素（值为0x26000145，可通过DTrace的人工易读名称来设置。有关BCD对象的详细信息请参阅第12章），
Windows加载器将检查%SystemRoot%\System32\Drivers路径下是否存在DTrace.sys驱动程序。如果存在，
Windows加载器会构建一个名为ext-ms-win-ntos-trace-l1-1-0的全新API集Schema扩展。该Schema以
DTrace.sys驱动程序为目标，会合并到系统API集Schema（OslApiSetSchema）中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">后续启动过程中，当NT内
核开始自己的阶段1初始化过程后，将调用TraceInitSystem函数以初始化动态跟踪子系统。该API会通过ext-ms-win-ntos-
trace-l1-1-0.dll这个API集Schema导入NT内核。这意味着如果DTrace未被Windows加载器启用，名称解析将会失败，该
函数基本上将起不到任何作用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">TraceInitSystem
有一个重要职责：计算跟踪调用数组的内容，该数组包含发出跟踪探针后需要由NT内核调用的函数。该数组存储在全局符号
KiDynamicTraceCallouts中，这个符号稍后会受到Patchguard的保护，以防止恶意驱动程序对系统例程的执行流进行非法的重定
向。最后，NT内核会通过TraceInitSystem函数向DTrace驱动程序发送另一个重要数组，该数组中包含了DTrace驱动程序应用探针所
需的私有系统接口（该数组会被暴露在一种跟踪扩展上下文数据结构中）。在这种类型的初始化过程中，DTrace驱动程序和NT内核都交换了私有接口，而这
也是DTrace驱动程序被称为扩展驱动程序的一个主要原因。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后，Pnp管理器将启动
（以“启动驱动程序”形式安装在系统中）DTrace驱动程序，并调用其主入口点（DriverEntry）。该例程会注册\Device\DTrace
控制设备及其符号链接（\GLOBAL??\DTrace）。随后它会初始化内部的DTrace状态，创建第一个DTrace内置提供程序。最后，它会调
用每个提供程序的初始化函数，借此注册每个可用的提供程序。具体的初始化方法取决于每个提供程序，通常最终都需要调用内部的
DTrace_register函数，该函数可将提供程序注册给DTrace框架。提供程序的初始化过程中还有另一个常见操作：为控制设备注册处理程序。
用户模式应用程序可以与DTrace通信，并通过DTrace控制设备与提供程序通信，而控制设备向提供程序公开虚拟文件（处理程序）。例如，用户模式的
LibDTrace可以打开到\\.\DTrace\Fasttrap虚拟文件（处理程序）的句柄，借此直接与PID提供程序通信。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>S</b><b>y</b><b>s</b><b>c</b><b>a</b><b>l</b><b>l</b><b>提</b><b>供</b><b>程</b><b>序</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当Syscall提供程序
被启用后，DTrace最终会调用KeSetSystemServiceCallback例程，通过该例程为探针中指定的系统调用设置一个回调。在NT系
统接口数组的帮助下，该例程会暴露给DTrace驱动程序。DTrace驱动程序由NT内核在DTrace初始化时编译（详见上一节），会被封装在一个内
部称为KiDynamicTraceContext的扩展上下文数据结构中。KeSetSystemServiceCallback被首次调用时，该例程
的重要任务是构建全局服务跟踪表（KiSystemServiceTraceCallbackTable），这是一种RB（红黑）树，其中包含了所有可用
系统调用的描述符。每个描述符都包含Syscall名称、地址、参数数量以及表示该回调是在进入或退出时才会被启用的标记哈希值。NT内核包含一个通过
KiServicesTab内部数组公开的Syscall静态列表。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">全局服务跟踪表被填满后，
KeSetSystemServiceCallback会计算探针所指定的Syscall的名称哈希，并在红黑树中搜索该哈希。如果没有匹配的结果，则意
味着探针指定了错误的Syscall名称（即函数退出时发出了错误信号）。否则函数会修改所找到的Syscall描述符中的启用标记，并增大启用的跟踪回
调数量（存储在一个内部变量中）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当第一个DTrace 
syscall回调被启用时，NT内核会在全局KiDynamicTraceMask位掩码中设置Syscall位。这个操作很重要，借此系统调用处理程
序（KiSystemCall64）才可以调用全局跟踪处理程序（系统调用和系统服务的调度详见第8章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这样的设计使得
DTrace能与系统调用处理机制共存，并且不会对性能造成任何负面影响。如果没有活跃的DTrace 
syscall探针，跟踪处理程序将不被调用。跟踪处理程序可在进入或退出系统调用时被调用。其功能很简单：扫描全局服务跟踪表，从中查找系统调用的描述
符。找到目标描述符后，它会检查启用标记是否已设置，如果设置，则会调用正确的标注（Callout，根据上一节的介绍，包含在全局动态跟踪标注数组
KiDynamicTraceCallouts中）。这种标注是在DTrace驱动程序中实现的，可使用常规的内部DTrace_probe函数发出
Syscall探针并执行相关操作。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>函</b><b>数</b><b>边</b><b>界</b><b>跟</b><b>踪</b><b>（</b><b>F</b><b>B</b><b>T</b><b>）</b><b>和</b><b>进</b><b>程</b><b>（</b><b>P</b><b>I</b><b>D</b><b>）</b><b>提</b><b>供</b><b>程</b><b>序</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">FBT和PID提供程序较
为类似，它们都可以在任意函数（并不一定是Syscall）的入口和出口点上启用探针。目标函数可以位于NT内核中，或者是驱动程序的组成部分（这些情况
将使用FBT提供程序），此外也可以位于用户模式模块中，由进程负责执行（PID提供程序可以跟踪用户模式应用程序）。在系统中，FBT或PID探针可通
过直接写入目标函数代码的断点操作码（x86中的INT 3，ARM64中的BRK）激活，这种做法有一些重要意义。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
在发出PID或FBT探针后，DTrace应该能在调用回到目标函数之前重新执行被替换的指令。为此，DTrace使用了一种指令仿真器。截至撰写这部分
内容，该仿真器可兼容AMD64和ARM64架构。这个仿真器实现于NT内核中，通常可由系统异常处理程序在处理断点异常时调用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·DTrace需要通过一种方法来按照名称识别不同函数。在最终的二进制文件中，函数名称并未编译（导出的函数除外）。DTrace使用了多种技术来实现这一目标，详见下文“DTrace类型库”一节。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
一个函数可以从不同代码分支以多种方式退出（返回）。为识别这些退出点，需要通过函数图分析器（Function graph 
analyzer）反汇编函数指令并找到退出点。尽管最初的函数图分析器是Solaris代码的一部分，但Windows中DTrace的实现使用了一种
更优化版本的函数图分析器，该分析器依然位于LibDTrace库（DTrace.dll）中。在使用该函数图分析器分析用户模式函数时，DTrace会
通过PDATA 
v2展开（Unwind）信息可靠地找出内核模式函数退出点（有关函数展开和异常调度的详情请参阅第8章）。如果内核模式模块未使用PDATA 
v2展开信息，FBT提供程序将不会为返回的函数创建任何探针。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">DTrace通过调用
KeSetTracepoint函数来安装FBT或PID探针，该函数由NT内核通过NT系统接口数组导出，可验证参数（尤其是回调指针），并且对于内核
目标，还会验证目标函数是否位于已知内核模式模块的可执行代码节中。与Syscall提供程序类似，此时会构建并使用一个
KI_TRACEPOINT_ENTRY数据结构来跟踪被激活的跟踪点。该数据结构包含拥有者进程、访问模式以及目标函数地址，会被插入全局哈希表
KiTpHashTable中，该表则会在FBT或PID探针被首次激活时分配。最后，位于目标代码中的一条指令被解析（导入仿真器中）并替换为断点操作
码，同时还会设置全局KiDynamicTraceMask位掩码中的Trap位。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于内核模式的目标，只有
在启用VBS（Virtualization Based 
Security，基于虚拟化的安全性）时才能进行断点替换。MmWriteSystemImageTracepoint例程将定位与目标函数相关的加载
器数据表项，并调用SECURESERVICE_SET_TRACEPOINT安全调用。安全内核是唯一能与HyperGuard协作的实体，从而使断点
应用成为合法的代码修改。正如卷1第7章所述，Kernel 
Patch保护（也称Patchguard）可防止对NT内核和某些重要的内核驱动程序代码进行任何改动。如果系统中未启用VBS，并且未连接调试器，此
时将返回错误代码并且探针应用程序会失败。如果已连接内核调试器，即可通过MmDbgCopyMemory函数为NT内核应用断点操作码（被调试的系统将
不启用Patchguard）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在为调试器异常进行调用
（这可能是DTrace的FTB或PID探针发出引起的）时，系统异常处理程序（KiDispatchException）会检查全局
KiDynamicTraceMask位掩码中的Trap位是否已设置。如果已设置，异常处理程序将调用KiTpHandleTrap函数，由该函数搜索
KiTpHashTable以确定该异常的产生是否是因为发出了已注册的FTB或PIF探针所导致的。对于用户模式探针，该函数会检查进程上下文是否符合
预期。如果符合，或如果探针是内核模式探针，该函数将直接调用DTrace回调FbtpCallback，由它执行探针关联的操作。该回调执行完毕后，处
理程序会调用仿真器，借此在将执行上下文转移到目标函数之前模拟目标函数的第一条原始指令。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>跟</b><b>踪</b><b>动</b><b>态</b><b>内</b><b>存</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
这个实验中，我们将动态跟踪虚拟机所应用的动态内存。为此需要使用Hyper-V管理器创建一个第二代虚拟机，设置内存容量最小值为768MB，动态内存
最大容量为无限（有关动态内存和Hyper-V的详细信息请参阅第9章）。该虚拟机需要运行Windows 
10的2019年5月的更新（19H1）或2020年5月的更新（20H1），或者后续的新版本。此外该虚拟机中需要安装DTrace程序包（具体方法详
见本章上文“启用DTrace并列出已安装的提供程序”实验）</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请将本书随附资源中提供的dynamic_memory.d脚本复制到DTrace目录，并在管理员身份运行的命令提示符窗口中通过下列命令启动：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">cd /d "c:\Program Files\DTrace" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">dtrace.exe -s dynamic_memory.d </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如果只运行上述命令，DTrace将拒绝编译该脚本，此时可能会显示类似下列错误信息：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">dtrace: failed to compile script dynamic_memory.d: line 62: probe description fbt:nt:MiRem </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ovePhysicalMemory:entry does not match any probes </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">这
是因为标准配置中并未设置符号存储路径。该脚本会通过操作系统的两个函数连接到FBT提供程序。一个函数是从NT内核二进制文件中导出的
MmAddPhysicalMemory，另一个是未被导出也未包含在公开WDK中的MiRemovePhysicalMemory。对于后者，FBT提
供程序完全无法计算它在系统中的地址。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">DTrace可以从不同来源获得类型和符号信息，详见本章下文“DTrace类型库”一节。为了让FBT提供程序能与操作系统内部函数正确配合，我们需要将符号存储的路径指向微软的公开符号服务器，为此请使用下列命令：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">set_NT_SYMBOL_PATH=srv*C:\symbols*http://msdl.microsoft.com/download/symbols </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">设置了符号存储路径后，如果以dynamic_memory.d脚本为目标重启动DTrace，此时应该可以正确编译并显示如下的输出：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">The Dynamic Memory script has begun. </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随
后可以模拟一些高内存压力的场景。这可以通过多种方式实现，例如启动浏览器并打开大量网页标签，运行3D游戏，或直接通过-d命令开关运行
TestLimit工具，这会迫使系统持续分配并写入内存，直到所有资源均已耗尽。根分区中的虚拟机工作进程应该会检测到这种情况，并向子虚拟机注入新内
存。DTrace会检测到这个操作：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Physical memory addition request intercepted. Start physical address 0x00112C00, </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Number of pages: 0x00000400. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Addition of 1024 memory pages starting at PFN 0x00112C00 succeeded! </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">通过类似的方式，如果关闭客户虚拟机中的所有应用程序，并在宿主系统中重新创建这种高内存压力场景，则该脚本能拦截动态内存的移除请求：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Physical memory removal request intercepted. Start physical address 0x00132000, </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Number of pages: 0x00000200. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Removal of 512 memory pages starting at PFN 0x00132000 succeeded! </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">使用Ctrl+C中断DTrace后，脚本会输出一些统计信息：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Dynamic Memory script ended. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Numbers of Hot Additions: 217 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Numbers of Hot Removals: 1602 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Since starts the system has gained 0x00017A00 pages (378 MB). </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">使用记事本打开dynamic_memory.d脚本，我们会看到它共安装了6个探针（4个FBT，2个内置探针），并执行了日志和计数操作。例如：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fbt:nt:MmAddPhysicalMemory:return </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">/self-&gt;pStartingAddress != 0 /</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">上述内容会在MmAddPhysicalMemory函数的退出点上安装一个探针，但前提是在函数入口点获得的起始物理地址非0。有关DTrace中所用D编程语言的详细信息请参考<span style="font-size:16px;font-style: oblique;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><i>T</i><i>h</i><i>e</i><i> </i><i>i</i><i>l</i><i>l</i><i>u</i><i>m</i><i>o</i><i>s</i><i> </i><i>D</i><i>y</i><i>n</i><i>a</i><i>m</i><i>i</i><i>c</i><i> </i><i>T</i><i>r</i><i>a</i><i>c</i><i>i</i><i>n</i><i>g</i><i> </i><i>G</i><i>u</i><i>i</i><i>d</i><i>e</i></span>一书，本书可通过下列地址免费阅读：http://DTrace.org/guide/preface.html。</span></p>
</div><div class="header2"><h3><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>E</b><b>T</b><b>W</b><b>提</b><b>供</b><b>程</b><b>序</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">DTrace可同时支持
ETW提供程序和etw_trace操作，前者可让探针在特定提供程序生成某些ETW事件后触发，后者可以让DTrace脚本生成新的定制化
TraceLogging ETW事件。Etw_trace操作实现于LibDTrace中，而LibDTrace可使用TraceLogging 
API动态地注册新的ETW提供程序并生成与之相关的事件。有关ETW的详细信息请参阅上文“Windows事件跟踪”一节。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ETW提供程序实现于
DTrace驱动程序中。当PNP管理器初始化DTrace引擎时，会向DTrace引擎注册所有提供程序。在注册时，ETW提供程序会配置一种名为
DTraceLoggingSession的DTrace会话，该会话会设置为将事件写入循环缓冲区。在从命令行启动DTrace时，会向DTrace驱
动程序发送一个IOCTL，IOCTL处理程序会调用每个提供程序提供的函数，并由内部函数DtEtwpCreate使用
EtwEnumTraceGuidList函数代码调用NtTraceControl 
API。这样DTrace就可以枚举系统中注册的所有ETW提供程序，并为每个提供程序创建一个探针（dtrace -l也能显示ETW探针）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在编译并执行以ETW提供
程序为目标的D脚本时，将会调用内部例程DtEtwEnable，借此可启用一个或多个ETW探针。随后将启动在注册时配置的日志会话（如果还没开始运行
的话）。在跟踪扩展上下文（如上文所述，其中包含了私有系统接口）的帮助下，DTrace可以注册一个内核模式回调，每当DTrace日志会话中有新事件
被记录后，都会调用这个回调。会话首次启动时，还没有相关联的提供程序。与Syscall和FBT提供程序类似，DTrace会为每个探针创建一个跟踪数
据结构，并将其插入一个表示所有已启用ETW探针的全局红黑树（DtEtwpProbeTree）。这个跟踪数据结构很重要，它表示了ETW提供程序和相
关探针之间的链接。DTrace会为提供程序计算正确的启用级别和关键字位掩码（详见上文“提供程序的启用”一节），并会调用
NtTraceControl API在会话中启用提供程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">生成事件后，ETW子系统会调用回调例程，由回调例程在全局ETW探针树中搜索表示该探针的上下文数据结构。找到后，DTrace即可触发该探针（依然使用了内部函数DTrace_probe）并执行所有相关操作。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_168" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>6</b><b>.</b><b>2</b><b> </b><b>D</b><b>T</b><b>r</b><b>a</b><b>c</b><b>e</b><b>类</b><b>型</b><b>库</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">DTrace支持不同的类
型。系统管理员可以借此检查操作系统内部的数据结构，并在D子句中使用类型来描述与探针有关的操作。除了标准D编程语言支持的类型，DTrace还支持补
充数据类型。为了处理依赖操作系统的复杂数据类型，并让FBT和PID提供程序在内部操作系统和应用程序函数上设置探针，DTrace可从不同来源获取所
需的信息。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·最初，可从（符合可移植可执行文件格式要求的）可执行二进制文件中嵌入的信息内提取函数名称、签名和数据类型，例如从导出表和调试信息中提取。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
在最初的DTrace项目中，Solaris操作系统提供了对Compact C Type 
Format（CTF）的支持，并能支持CTF的可执行二进制文件（符合可执行和可链接格式，即ELF标准）。这样操作系统就可以将DTrace所需的调
试信息直接存储在自己的模块中（调试信息也可以使用Deflate压缩格式存储）。Windows版本的DTrace依然支持部分CTF，并已作为资源节
添加到LibDTrace库（DTrace.dll）中。LibDTrace库中的CTF可存储公开WDK（Windows驱动程序包）和SDK（软件开
发包）中包含的类型信息，并让DTrace能在无需任何符号文件的前提下与基础的操作系统数据类型配合工作。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
大部分私有类型和内部操作系统函数签名是从PDB符号中获取的。大部分操作系统模块的公开PDB符号可从微软符号服务器下载（Windows调试器也使用
了这些符号）。FBT提供程序大量使用了这些符号，借此正确地识别内部操作系统函数，并让DTrace能够为每个Syscall和函数检索到正确的参数类
型。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>D</b><b>T</b><b>r</b><b>a</b><b>c</b><b>e</b><b>符</b><b>号</b><b>服</b><b>务</b><b>器</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">DTrace中包含一个自
主的符号服务器，可从微软公开的符号存储中下载PDB符号并提供给DTrace子系统使用。该符号服务器主要是在LibDTrace中实现的，
DTrace驱动程序可使用反转调用模型（inverted call 
model）查询。在提供程序注册过程中，DTrace驱动程序会注册一个SymServer伪提供程序，这并非真正的提供程序，只是一个快捷方式，可以
让DTrace的Symsrv处理程序控制要注册的设备。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当从命令行启动
DTrace时，LibDTrace库会使用标准的CreateFile 
API打开一个指向\\.\DTrace\symsrv控制设备的句柄，以便启动符号服务器。DTrace驱动程序会通过符号服务器IRP句柄处理该请
求，借此注册用户模式进程，将其添加到一个符号服务器进程内部列表中。随后，LibDTrace将启动一个新线程，借此向DTrace符号服务器设备发送
虚拟（Dummy）IOCTL，并无限期地等待设备回复。驱动程序会将该IRP标记为挂起，直到提供程序或DTrace子系统要求解析新符号时才会将其标
记为已完成。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在驱动程序完成挂起的
IRP后，DTrace符号服务器线程都会被唤醒，并使用由Windows映像助手库（Dbghelp.dll）公开的服务正确地下载并解析所需符号。随
后该驱动程序会等待符号线程发来新的虚拟IOCTL。这次的新IOCTL将包含符号解析过程产生的结果。只有在DTrace驱动程序需要时，用户模式线程
才会被再次唤醒。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter10_0007.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_169" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>7</b><b> </b><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>错</b><b>误</b><b>报</b><b>告</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows错误报告（Windows Error Reporting，WER）是一种复杂的机制，可自动提交用户模式进程和内核模式系统崩溃报告。为了在用户模式进程、受保护进程、Trustlet或内核崩溃后生成报告，该机制设计了多种系统组件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与前身不同，
Windows 
10并未提供图形化对话框，以供用户配置WER在应用程序崩溃后应该获取并向微软（或系统管理员配置的内部服务器）发送哪些信息。如图10-38所示，在
Windows 
10中，控制面板中的安全性和维护界面可以向用户展示应用程序或内核崩溃后，Windows错误报告生成的历史报告信息。该界面还可以显示与报告有关的基
础信息。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/c374c2986e954597df819ce2035111da.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-38 控制面板中安全性和维护界面下的可靠性监视器</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows错误报告通过操作系统中的多个组件实现，主要是因为它需要处理各种类型的崩溃。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Windows Error Reporting服务（WerSvc.dll）作为主服务，管理了用户模式进程、受保护进程或Trustlet崩溃后的报告生成和发送工作。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Windows
 Fault Reporting和Secure Fault 
Reporting（WerFault.exe与WerFaultSecure.exe）主要用于获取崩溃应用程序的快照，生成报告并发送给微软在线崩溃
分析网站（或在配置后，发送给内部错误报告服务器）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
报告的实际生成和传输工作由Windows Error Reporting 
Dll（Wer.dll）执行。该库包含了WER引擎使用的全部内部函数，并包含一些导出的API，应用程序可以借助这些API与Windows 
Error 
Reporting交互（详见https://docs.microsoft.com/windows/win32/api/_wer/）。请注意，某些
WER API也实现于Kernelbase.dll和Faultrep.dll中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Windows
 User Mode Crash Reporting 
DLL（Faultrep.dll）包含用户模式应用程序崩溃或不响应后系统模块（Kernel32.dll、WER服务等）使用的常用WER存根代码。
其中还包含生成崩溃签名以及向WER服务报告不响应情况所需的服务，这些服务还负责管理报告创建和传输过程中的安全上下文（包括在正确的安全令牌下创建
WerFault可执行文件）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Windows Error Reporting转储编码库（Werenc.dll）被Secure Fault Reporting用于加密Trustlet崩溃后生成的转储文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Windows
 Error 
Reporting内核驱动程序（WerKernel.sys）是一个内核库，它导出了捕获实时内核内存转储，并将报告提交给微软在线崩溃分析网站所需的
函数。此外，该驱动程序还包含通过内核模式驱动程序为用户模式错误创建和提交报告所需的API。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">WER完整架构的详细讨论已超出了本书范围。本节将主要探讨用户模式应用程序和NT内核（或内核驱动程序）崩溃后的错误报告。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_170" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>7</b><b>.</b><b>1</b><b> </b><b>用</b><b>户</b><b>应</b><b>用</b><b>程</b><b>序</b><b>崩</b><b>溃</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如卷1第3章所述，
Windows中所有用户模式线程都是由Ntdll中的RtlUserThreadStart函数启动的。该函数只需在一个结构化异常处理程序下调用真正
的线程启动例程（结构化异常处理详见第8章）即可。为真正的启动例程提供保护的处理程序在内部称为未处理异常处理程序（Unhandled 
Exception 
Handler），因为它是可以管理用户模式线程中所发生异常的最后一道机制（如果线程本身还没有处理）。如果该处理程序被执行，通常会使用
NtTerminateProcess 
API来终止进程。未处理异常过滤器（RtlpThreadExceptionFilter）将决定是否执行该处理程序。值得注意的是，未处理异常过滤器
和处理程序只会在非寻常状况下执行，通常应该由应用程序通过自己内部的异常处理程序来管理自己的异常。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当Win32进程启动时，
Windows加载器会映射所需的导入库。Kernelbase初始化例程会为进程安装自己的未处理异常过滤器（即
UnhandledExceptionFilter例程）。当进程的线程中发生致命的未处理异常后，会调用该过滤器来判断如何处理异常。
Kernelbase未处理异常过滤器会构建上下文信息（如计算机寄存器和堆栈的当前值、出现致命错误的进程ID以及线程ID）并开始处理异常。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果进程连接了调试器，则该过滤器会让异常发生（为此会返回CONTINUE_SEARCH），这样调试器才可以中断并看到异常。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果进程是Trustlet，则该过滤器会停止所有处理工作，并调用内核以启动Secure Fault Reporting（WerFaultSecure.exe）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·过滤器可调用CRT未处理异常例程（如果存在），如果后者不知道如何处理该异常，则会调用内部WerpReportFault函数，借此连接到WER服务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在打开ALPC连接前，
WerpReportFault应唤醒WER服务并准备一个可继承的共享内存节，该内存节中存储了之前获得的所有上下文信息。WER服务是一种直接触发启
动的服务，只有当WER_SERVICE_START 
WNF状态被更新，或事件被写入虚拟WER激活ETW提供程序（名为Microsoft-Windows-Feedback-Service-
Triggerprovider）后，该服务才会被SCM启动。WerpReportFault会更新相关的WNF状态并等待
\KernelObjects\SystemErrorPortReady事件，该事件收到WER服务发出的信号就意味着已经准备好接收新连接了。连接建
立后，Ntdll会连接到WER服务的\WindowsErrorReportingServicePort 
ALPC端口，发送WERSVC_REPORT_CRASH消息，并无限期地等待回复。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">该消息会触发WER服务开
始分析崩溃程序的状态，并执行生成崩溃报告所需的操作。在大部分情况下，这就意味着要启动WerFault.exe程序。对于用户模式的崩溃，会使用崩溃
进程的凭据将Windows Fault Reporting进程调用两次。第一次用于获取崩溃进程的“快照”，快照功能最早出现在Windows 
8.1中，目的是更快速地为UWP应用程序（当时的UWP应用程序还是一种单实例应用程序）生成崩溃报告。这样，用户就可以重新启动崩溃的UWP应用程
序，而无须等待报告生成完毕（UWP和现代应用程序栈的详细信息请参阅第8章）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>快</b><b>照</b><b>创</b><b>建</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">WerFault会映射包
含了崩溃数据的共享内存节，并打开发生错误的进程和线程。在使用命令行参数-pss调用的情况下（用于请求进程快照），它会调用Ntdll导出的
PssNtCaptureSnapshot函数。该函数会使用原生API查询与崩溃进程有关的多种信息（如基本信息、作业信息、进程时间、安全缓解、进程
文件名、共享的用户数据节）。此外，该函数还可以查询与文件支持的内存节有关的信息，并能对进程的整个用户模式地址空间进行映射。随后它会将获得的全部数
据保存到表示快照的PSS_SNAPSHOT数据结构中。最后，它会使用NtCreateProcessEx 
API（并提供特殊的标记组合）将崩溃进程的完整VA空间在另一个虚拟进程（克隆的进程）中创建完全相同的副本。这样，原进程就可以终止了，报告错误所需
的后续操作可以在这个克隆的进程上执行。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> WER不会对受保护进程和Trustlet执行快照创建操作。此时报告是通过从原始出错进程中获取数据创建的，该过程中出错进程会被暂停，报告完成后才能恢复。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>崩</b><b>溃</b><b>报</b><b>告</b><b>的</b><b>生</b><b>成</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">创建快照后，执行控制将返回给WER服务，该服务会初始化生成崩溃报告所需的环境。这主要通过两种方式完成。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果崩溃的是常规的非受保护进程，WER服务会直接调用从Windows用户模式崩溃报告（Faultrep.dll）导出的WerpInitiateCrashReporting例程。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果崩溃的是受保护进程并且需要另一个代理进程，那么会在SYSTEM账户（而非出错进程对应的凭据）下生成这个代理进程。该代理进程会执行一些验证，随后调用与常规进程崩溃后相同的例程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在通过WER服务调用
WerpInitiateCrashReporting例程时，该例程会准备好执行错误报告进程所需的环境。该例程会使用从WER库导出的API来初始化
计算机存储（默认配置下位于C:\ProgramData\Microsoft\Windows\WER目录），并从Windows注册表加载所有WER
设置。WER实际上包含了很多可定制选项，用户可通过组策略或修改注册表的方式进行配置。至此，WER会模仿运行了出错应用程序的用户，并使用命令行开
关-u启动相应的Fault Reporting进程，这表示着WerFault（或WerFaultSecure）将处理用户崩溃并生成新的报告。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 如果崩溃的是使用低完整性级别或使用AppContainer令牌运行的现代应用程序进程，WER将使用User Manager服务生成一个新的低IL令牌，借此代表启动了出错应用程序的用户。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">表10-19列出了WER
的注册表配置选项，以及这些选项的用途与可用值。这些注册表值均存储在HKLM\SOFTWARE\Microsoft\Windows\Windows
 Error 
Reporting子键（针对计算机的配置）以及HKEY_CURRENT_USER下相对应的路径中（针对用户配置）。有些值也可能出现在
\Software\Policies\Microsoft\Windows\Windows Error Reporting键下。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表10-19 WER注册表设置</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/db9737c7e42512b07dec85f6efc49d3a.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3c3f0dc35ee5a4429f9d3d28df4692ae.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/67dbc2beae7438e4fe230a392700df69.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">使用-u开关启动的
Windows错误报告进程可以开始生成报告：该进程会再次映射包含崩溃数据的共享内存段，识别异常记录和描述符，并获取之前创建的快照。如果快照不存
在，则WerFault进程将直接对出错进程执行操作，并将出错进程暂停。WerFault首先会确定故障进程的类型（服务、原生、标准、Shell进
程）。如果出错进程（通过SetErrorMode 
API）要求系统不报告任何硬错误，则整个进程都将被忽略，并且不会创建任何报告。否则WER会通过存储在AeDebug子键（受保护进程则使用
AeDebugProtected子键）中的设置检查是否启用了默认的后台调试器，该子键位于
HKLM\SOFTWARE\Microsoft\Windows 
NT\CurrentVersion\根注册表键下。表10-20列出了这些键的可能值。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">表10-20 AeDebug和AeDebugProtected根键的有效注册表值</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/adfd95a22f561ba7a72acfcb409cf98c.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果调试器启动类型被设置
为Auto，则WER会启动调试器并等待调试器事件收到信号，随后才会继续创建报告。报告的创建过程由用户模式崩溃报告DLL
（Faultrep.dll）中实现的内部函数GenerateCrashReport启动。该DLL会配置所有的WER插件，并使用从WER.dll导
出的WerReportCreate 
API初始化报告（请注意，在这一阶段，报告仅存在于内存中）。GenerateCrashReport例程计算报告ID并为报告签名，同时向报告中添加
后续的诊断数据（如进程时间和启动参数，或应用程序定义的数据）。随后它会检查WER配置以确定要创建哪种类型的进程转储（默认情况下将创建小型转储）。
随后它会调用导出的WerReportAddDump 
API，借此对出错进程的转储进行初始化（该转储将被添加到最终报告中）。请注意，如果之前已经创建了快照，则会通过快照创建转储。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">从WER.dll导出的WerReportSubmit API是一个核心函数，它负责为出错进程创建转储，创建要包含报告中的所有文件，显示UI（如果DontShowUI注册表键被配置为要显示的话），随后将报告发送给在线崩溃服务器。报告通常包含以下内容。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·崩溃进程的小型转储文件（通常名为memory.hdmp）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·人工易读的文本报告，其中包含异常信息，计算出的崩溃签名，操作系统信息，报告相关所有文件的列表，以及崩溃进程所加载全部模块的列表（该文件通常名为report.wer）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个CSV（逗号分隔值）文件，其中包含本崩溃发生时所有活跃进程的列表以及一些基本信息（例如线程数量、私有工作集大小、硬错误数量等）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个文本文件，其中包含全局内存状态信息。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个文本文件，其中包含应用程序兼容性信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Fault 
Reporting进程会通过ALPC与WER服务通信，并发送命令让该服务生成要包含在报告中的大部分信息。在所有文件均已生成后，如果配置无误，
Windows Fault 
Reporting进程会向用户显示一个对话框（见图10-39），通知用户目标进程发生了关键错误（该功能在Windows 10中默认被禁用）。</span></p><div style="display: block;text-align:center;">
	<img width="543" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ae99d8afc8e5158a3e9857a839bd66ee.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-39 Windows错误报告对话框</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在系统未连接互联网的环
境，或当管理员希望控制要将哪些错误报告提交给微软的情况下，也可将错误报告的发送位置指定为内部文件服务器。System Center 
Desktop Error Monitoring（包含在Microsoft Desktop Optimization 
Pack中）可以了解Windows错误报告所创建的目录结构，并为管理员提供选项，以便选择性地创建错误报告并将其提交给微软。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，WER服务使
用ALPC端口与崩溃的进程通信。该机制使用了WER服务通过NtSetInformationProcess（使用
DbgkRegisterErrorPort）注册的系统级的错误端口。因此所有Windows进程都有一个错误端口，而该端口实际上是WER服务注册的
ALPC端口对象。内核与Ntdll中的未处理异常过滤器使用该端口向WER服务发送消息，随后WER服务即可分析崩溃的进程。这意味着即便在线程状态损
坏这种严重情况下，WER依然能够接收通知并启动WerFault.exe，借此将关键错误的详细信息记录到Windows事件日志（或向用户展示一个用
户界面），而无须在崩溃的线程内部执行这些工作。这就解决了进程“无声死亡”造成的所有问题：用户可以收到通知，可以进行调试，服务管理员可以看到崩溃事
件。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>启</b><b>用</b><b>W</b><b>E</b><b>R</b><b>用</b><b>户</b><b>界</b><b>面</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">从
首发版Windows 10开始，系统默认禁用了应用程序崩溃后 WER 显示的用户界面。这主要是因为系统引入了重启动管理器（Restart 
Manager，属于应用程序恢复和重启动技术的一部分）。该技术可以让应用程序注册一个重启动或恢复回调，当应用程序崩溃、不响应，或因为安装了更新而
需要重启动时，即可调用该回调。因此在遇到未处理的异常后，未注册任何此类恢复回调的传统应用程序会直接终止，并不会向用户展示任何信息（但依然会将错误
正确记录到系统日志中）。如本节所述，WER依然支持用户界面，只需在注册表中保存设置的WER键中添加一个值即可启用。在这个实验中，我们将使用全局系
统键重新启用WER的用户界面。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请
将本书随附资源中附带的BuggedApp可执行文件复制到计算机上并运行。按下一个按键后，该应用程序将生成一个关键的未处理异常，WER会拦截并报告
该错误。默认配置下，这个过程不会显示任何错误信息。进程会被终止，系统日志中会记录一条错误事件，报告的生成和发送过程完全无须用户介入。随后请打开注
册表编辑器（在搜索框中输入regedit）并打开HKLM\SOFTWARE\Microsoft\Windows\Windows Error 
Reporting键。如果DontShowUI值不存在，请右击根键，选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>新</b><b>建</b><b>，</b><b>D</b><b>W</b><b>O</b><b>R</b><b>D</b><b>（</b><b>3</b><b>2</b><b>位</b><b>）</b></span>值”，随后将其设置为0。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随
后重新启动BuggedApp并按下键盘上的任意一个键，WER将显示类似图10-39所示的用户界面，随后终止崩溃的应用程序。我们可以在为
AeDebug 键添加调试器后重复该实验。使用-I开关运行Windbg即可自动执行注册，详见上文“查看COM托管的任务”实验。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_171" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>7</b><b>.</b><b>2</b><b> </b><b>内</b><b>核</b><b>模</b><b>式</b><b>（</b><b>系</b><b>统</b><b>）</b><b>崩</b><b>溃</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在讨论内核崩溃后WER的
运作之前，首先需要介绍内核是如何记录崩溃信息的。默认情况下，所有Windows系统都会配置为在出现蓝屏死机（BSOD）界面前，首先尝试记录系统状
态信息，随后重启动系统。要查看或修改这些设置，请打开“控制面板”中的“系统属性”工具（在“系统和安全、系统、高级系统设置”中），点击“高级”选项
卡，随后点击启动和故障恢复选项对应的“设置”按钮。Windows系统的默认设置如图10-40所示。</span></p><div style="display: block;text-align:center;">
	<img width="713" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/cbd22cd585f5a01706eeb013f801328a.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-40 崩溃转储设置</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>崩</b><b>溃</b><b>转</b><b>储</b><b>文</b><b>件</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统崩溃后可记录不同级别的信息。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>活</b><b>动</b><b>内</b><b>存</b><b>转</b><b>储</b><b>。</b></span>活
动内存转储包含崩溃发生时，Windows可访问并正在使用的所有物理内存。此类转储是“完全内存转储”的子集，其中会排除掉主机上与故障排查无关的内存
页面。此类转储包含分配给用户模式应用程序的内存，以及映射到内核或用户空间的活动内存，同时还包含由页面文件支持的特定过渡页、备用页和已修改页，例
如，使用VirtualAlloc分配的内存或页面文件支持的节。活动转储不包含闲置和归零列表中的页面，也不包含文件缓存、客户虚拟机页面，以及对调试
工作无法提供帮助的其他类型的内存。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>完</b><b>全</b><b>内</b><b>存</b><b>转</b><b>储</b><b>。</b></span>完
全内存转储会产生最大的内核模式转储文件，其中包含Windows能访问的所有物理内存页。此类转储在所有平台上都不能完全支持（活动内存转储取代了完全
内存转储）。Windows要求页面文件的大小至少是物理内存的大小外加1MB的头部。设备驱动程序可以为二级崩溃转储数据额外增加最多256MB，因此
稳妥起见，建议将页面文件的大小再增加256MB。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>核</b><b>心</b><b>内</b><b>存</b><b>转</b><b>储</b><b>。</b></span>核
心内存转储仅包含操作系统、HAL以及设备驱动程序分配，且在崩溃时位于物理内存中的内核模式页面。此类转储不包含用户进程所属的页面。因为仅内核模式代
码可以直接导致Windows崩溃，而用户进程页面通常不太可能是崩溃调试所必需的。此外，与崩溃转储分析有关的所有数据结构（包括运行中进程列表、当前
线程的内核模式堆栈、已加载驱动程序列表）都存储在非分页内存中，因此也会包含在核心内存转储中。核心内存转储文件的大小无法预测，因为其大小取决于由操
作系统和计算机中的驱动程序分配的内核模式内存的数量。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>自</b><b>动</b><b>内</b><b>存</b><b>转</b><b>储</b><b>。</b></span>这
是Windows客户端和服务器系统的默认设置。自动内存转储类似于核心内存转储，但也会存储与崩溃时处于活跃状态的用户模式进程相关的元数据。此外，此
类转储可以更好地管理系统分页文件大小。Windows可将分页文件的大小设置为小于RAM的大小，但又足够大，以保证大部分时候都可以创建核心内存转
储。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>小</b><b>内</b><b>存</b><b>转</b><b>储</b><b>。</b></span>小
内存转储文件的大小通常介于128KB到1MB之间，因此也叫作小型转储（Minidump）或会审（Triage）转储，其中包含了停止代码和参数、已
加载驱动程序列表、描述当前进程和线程的数据结构（名为EPROCESS和ETHREAD，详见卷1第3章）、导致崩溃的线程的内核堆栈，以及崩溃转储启
发算法认为可能与崩溃有关系的其他内存，例如由处理器寄存器引用的包含内存地址的页面，以及驱动程序添加的二级转储数据。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
设备驱动程序可以通过调用KeRegisterBugCheckReasonCallback注册二级转储数据回调例程。内核会在崩溃后调用这些回调，并
通过回调例程向崩溃转储文件中添加额外的数据，例如设备硬件内存或设备信息，借此为调试提供帮助。整个系统的所有驱动程序最多可添加256MB的数据，这
个限制取决于存储转储所需的空间以及转储文件的大小，每个回调例程最多可增加额外可用空间1/8容量的数据。一旦额外空间耗尽，后续调用的驱动程序将无法
增加数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在加载小型转储时，调试器
会提醒用户自己可用的信息较为有限，而类似!process这种列出活跃进程的基础命令也无法获得自己所需的数据。核心内存转储包含了更多信息，但无法切
换至其他进程的地址空间映射，因为转储文件不包含所需数据。虽然完全内存转储是其他几种转储类型的超集，但其不足之处在于，此类转储文件的大小会与系统可
用物理内存数量相等，因此使用并不广泛。在分析大部分崩溃时，虽然并不会用到用户模式的代码和数据，但活动内存转储克服了这一限制，只转储实际使用的内存
（不包括闲置列表和归零列表中的物理页）。因此活动内存转储中可以切换地址空间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">小型转储的优势在于占用空
间小，方便通过电子邮件等方式传输。此外，每次崩溃都会在%SystemRoot%\Minidump目录下生成一个文件，文件名由日期、系统启动后经历
过的时间毫秒数以及一个序列号组成（例如040712-24835-01.dmp），这种名称具备唯一性。如果存在冲突，系统会调用Windows的
GetTickCount函数返回一个更新后的系统时钟周期计数并增大序列号，借此额外创建一个具备唯一性的文件名。默认情况下，Windows会保存最
新的50个小型转储。该数量可修改HKLM\SYSTEM\CurrentControlSet\Control\CrashControl注册表键下的
MinidumpsCount值进行定制。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">小型转储的最大不足在于，
可存储的数据极为有限，可能会对有效的分析产生负面影响。但在将系统配置为产生核心转储、完全转储、活动转储、自动转储的情况下，我们可以然可以使用
WinDbg打开更大的转储文件，随后使用.dump 
/m命令从中提取小型转储，借此获得小型转储所提供的优势。需要注意的是，就算将系统配置为创建完整或核心转储，依然会同时自动创建小型转储。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
我们可以在LiveKd中使用.dump命令为运行中的系统生成内存映像，随后即可在不关闭系统的情况下进行脱机分析。如果系统出现问题但依然可以提供服
务，并且我们希望在不中断服务的情况下进行排错，这种方法将较为有用。由于内存中的不同区域反映了不同时间点的状态，为避免创建不一定完全一致的崩溃映
像，LiveKd支持了–m标记。这种镜像转储选项可借助内存管理器的内存镜像API为内核模式内存创建一致的快照，为系统提供一种时间点视图。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">核心内存转储选项提供了一
种实用的“折中”。因为它包含所有内核模式物理内存，提供了与完全内存转储一致的分析数据，但忽略了通常无关的用户模式数据和代码，因此转储文件的体积大
幅降低。例如在一台具备4GB RAM、运行64位Windows的系统中，核心内存转储文件的大小仅为294MB。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，在配置使用核
心内存转储时，系统会检查分页文件是否足够大。我们无法可靠地预测核心内存转储的文件大小，因为这个大小取决于在崩溃那一刻，操作系统和驱动程序使用的内
核模式内存的数量。因此在崩溃时，有可能分页文件太小而不足以容纳核心转储，这种情况下系统将转为创建小型转储。如果想查看自己系统创建的核心转储大小，
可以配置注册表选项，强制以手动方式从控制台让系统崩溃（详见https://docs.microsoft.com/windows-
hardware/drivers/debugger/forcing-a-system-crash-from-the-keyboard），或者也可
以使用Notmyfault工具（https://docs.microsoft.com/sysinternals/downloads/
notmyfault）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">不过自动内存转储克服了这些局限。借此，系统将能创建一个足够大的分页文件，以保证大部分时候都能捕获核心内存转储。如果计算机崩溃，而分页文件不够大，无法捕获核心内存转储，Windows会将分页文件的大小增大到至少和已安装的物理内存相等。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为减少崩溃转储占用的磁盘
空间，Windows需要确定自己是否应当保留最后一个核心转储或完全转储的副本。在报告了内核错误（详见下文）后，Windows会使用下列算法决定是
否要保留Memory.dmp文件。对于服务器系统，Windows会始终存储转储文件。在客户端Windows系统中，仅加入域的计算机默认会始终存储
转储文件。对于未加入域的计算机，Windows只有在目标卷，也就是系统配置的要将Memory.dmp文件保存到的那个卷的可用磁盘空间大于25GB
（ARM64系统大于4GB时，该值可通过
HKLM\SYSTEM\CurrentControlSet\Control\CrashControl\PersistDumpDiskSpaceLimit
注册表键进行定制）时才会保留崩溃转储。如果因为磁盘空间限制，系统无法保存崩溃转储文件的副本，此时会将一条事件写入系统事件日志，表明转储文件已被删
除（见图10-41）。该行为也可以调整，为此只需创建
HKLM\SYSTEM\CurrentControlSet\Control\CrashControl\AlwaysKeepMemoryDump这
个DWORD值，并将其数据设置为1。这样，无论可用磁盘空间有多少，Windows都会保留一个崩溃转储。</span></p><div style="display: block;text-align:center;">
	<img width="868" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/17e6a8227094089333b97f3c4919020c.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-41 转储文件删除事件日志项</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>转</b><b>储</b><b>文</b><b>件</b><b>信</b><b>息</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">每
个崩溃转储文件都包含一个转储头，其中描述了停止代码及其参数、发生崩溃的系统类型（包括版本信息），以及分析过程中需要的重要内核模式结构的指针列表。
转储头还包含了所写入的崩溃转储类型以及与该类型转储有关的其他信息。调试器的.dumpdebug命令可显示崩溃转储文件的转储头信息。例如，下列内容
是一个配置了自动转储的系统所创建的转储文件的相关信息：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0: kd&gt; .dumpdebug </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">----- 64 bit Kernel Bitmap Dump Analysis - Kernel address space is available, </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">      User address space may not be available. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">DUMP_HEADER64: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">MajorVersion        0000000f </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">MinorVersion        000047ba </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">KdSecondaryVersion  00000002 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">DirectoryTableBase  00000000`006d4000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PfnDataBase         ffffe980`00000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PsLoadedModuleList  fffff800`5df00170 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PsActiveProcessHead fffff800`5def0b60 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">MachineImageType    00008664 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">NumberProcessors    00000003 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">BugCheckCode        000000e2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">BugCheckParameter1  00000000`00000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">BugCheckParameter2  00000000`00000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">BugCheckParameter3  00000000`00000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">BugCheckParameter4  00000000`00000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">KdDebuggerDataBlock fffff800`5dede5e0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">SecondaryDataState  00000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ProductType         00000001 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">SuiteMask           00000110 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Attributes          00000000 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">BITMAP_DUMP: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">DumpOptions         00000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">HeaderSize          16000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">BitmapSize          9ba00 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Pages               25dee </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">KiProcessorBlock at fffff800`5e02dac0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  3 KiProcessorBlock entries: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  fffff800`5c32f180 ffff8701`9f703180 ffff8701`9f3a0180 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">其
中，.enumtag命令可以显示崩溃转储中存储的所有二级转储数据（如下文所示）。对于二级数据的每个回调，都会显示标签、数据长度以及数据本身（以字
节和ASCII格式显示）。开发者可以使用Debugger Extension 
API创建自定义的调试器扩展，借此读取二级转储数据（详见帮助文件中的“Windows调试工具”一节）。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">{E83B40D2-B0A0-4842-ABEA71C9E3463DD1} - 0x100 bytes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  46 41 43 50 14 01 00 00 06 98 56 52 54 55 41 4C  FACP......VRTUAL </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  4D 49 43 52 4F 53 46 54 01 00 00 00 4D 53 46 54  MICROSFT....MSFT </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  53 52 41 54 A0 01 00 00 02 C6 56 52 54 55 41 4C  SRAT......VRTUAL </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  4D 49 43 52 4F 53 46 54 01 00 00 00 4D 53 46 54  MICROSFT....MSFT </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  57 41 45 54 28 00 00 00 01 22 56 52 54 55 41 4C  WAET(...."VRTUAL </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  4D 49 43 52 4F 53 46 54 01 00 00 00 4D 53 46 54  MICROSFT....MSFT </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  41 50 49 43 60 00 00 00 04 F7 56 52 54 55 41 4C  APIC`.....VRTUAL </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">... </span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>崩</b><b>溃</b><b>转</b><b>储</b><b>的</b><b>生</b><b>成</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在系统启动过程的阶段1期
间，I/O管理器可读取HKLM\SYSTEM\CurrentControlSet\Control\CrashControl注册表键来检查崩溃转储
选项配置。如果转储已配置，则I/O管理器会加载崩溃转储驱动程序（Crashdmp.sys）并调用其入口点函数。该入口点会向I/O管理器回传一个控
制函数表，I/O管理器会通过该表与崩溃转储驱动程序交互。I/O管理器还会初始化安全内核所需的安全加密，以便在转储中保存加密后的页。控制函数表中的
一个控制函数还会初始化全局崩溃转储系统，借此获得存储分页文件的物理扇区（文件范围）以及与之相关的卷设备对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">全局崩溃转储初始化函数会
获得管理存储分页文件的物理磁盘的微型端口驱动程序，随后使用MmLoadSystemImageEx例程为崩溃转储驱动程序以及磁盘微型端口驱动程序创
建副本，通过dump_字符串为它们的原始名称添加前缀。请注意，这意味着还要为微型端口驱动程序导入的所有驱动程序创建一个副本，如图10-42所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/2bdbef5f49d85802fb51ab0e555ee553.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-42 为了生成和写入崩溃转储文件而复制的内核模块</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统还会查询
DumpFilters值，以获得对卷执行写入操作所需的过滤器驱动程序，例如，BitLocker驱动器加密崩溃转储过滤器驱动程序
Dumpfve.sys。系统还会收集与写入崩溃转储所涉及的组件有关的信息，包括磁盘微型端口驱动程序的名称、写入转储所必需的I/O管理器结构，以及
分页文件在磁盘上的映射。这些数据会通过两个副本保存到转储上下文结构中。至此，系统已经准备好通过安全的、不会造成破坏的方式创建并写入转储了。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当系统崩溃时，崩溃转储驱
动程序（%SystemRoot%\System32\Drivers\Crashdmp.sys）会执行内存比较，借此来验证启动过程中获得的两个转储
上下文结构的完整性。如果比较不匹配，则不会写入崩溃转储，因为这样做可能导致磁盘故障或损坏。如果验证通过，则Crashdmp.sys会在复制的磁盘
微型端口驱动程序以及所需的其他过滤器驱动程序帮助下，将转储信息直接写入磁盘上被分页文件占据的扇区中，并会绕过文件系统驱动程序和存储驱动程序栈（因
为它们可能已经损坏，甚至可能是导致崩溃的“罪魁祸首”）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
由于在系统启动的早期阶段，分页文件会被提前打开以用于崩溃转储，因此，系统启动阶段初始化的驱动程序所包含的Bug导致的大部分崩溃都会产生转储文件。
对于Windows启动过程早期阶段涉及的组件（如HAL或此时初始化的驱动程序）导致的崩溃，由于发生得太早，系统此时还没有分页文件，这种情况下只能
使用另一台计算机对启动过程进行调试，进而进行崩溃分析。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在启动过程中，会话管理器
（Smss.exe）会检查注册表值HKLM\SYSTEM\CurrentControlSet\Control\Session 
Manager\Memory 
Management\ExistingPageFiles，以获取系统上次启动时存在的分页文件列表（有关分页文件的详情请参阅卷1第5章）。随后它会
循环遍历该列表，针对存在的每个文件调用SmpCheckForCrashDump函数，查看其中是否包含崩溃转储数据。在检查过程中，它会搜索每个分页
文件最前方的文件头是否存在PAGEDUMP（32位系统）或PAGEDU64（64位系统）签名（找到匹配的签名意味着该分页文件包含崩溃转储信息）。
如果存在崩溃转储数据，会话管理器随后会从HKLM\SYSTEM\CurrentControlSet\Control\CrashControl注册
表键读取一系列崩溃参数，包括DumpFile值，其中包含了目标转储文件的名称（除非另外配置，否则通常为%SystemRoot%
\Memory.dmp）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">接下来，Smss.exe
会检查目标转储文件是否位于与分页文件不同的其他卷上。如果是这种情况，则会检查目标卷是否有足够的可用磁盘空间（崩溃转储文件所需的空间大小信息存储在
分页文件的转储头中），随后会将分页文件截断为转储数据的大小，并将其重命名为临时转储文件名（会话管理器会调用NtCreatePagingFile函
数新建一个分页文件）。这个临时转储文件名采用了DUMPxxxx.tmp的格式，其中“xxxx”是系统时钟周期计数器的当前低字值（为了找到一个不冲
突的值，系统会尝试100次）。重命名分页文件后，系统会移除文件的隐藏和系统属性，并设置必要的安全描述符来保护崩溃转储文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后，会话管理器会创建易
失注册表键HKLM\SYSTEM\CurrentControlSet\Control\CrashControl\MachineCrash，并在
DumpFile值中存储临时转储文件的名称。随后它会向TempDestination值写入一个DWORD，以此表明转储文件位置是否为一个临时位
置。如果分页文件和目标转储文件在同一个卷上，则将不使用临时转储文件，因为分页文件会被截断并直接重命名为目标转储文件的名称。此时DumpFile值
将会是目标转储文件，而TempDestination的值会是0。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在启动过程后期，
Wininit会检查是否存在MachineCrash键，如果存在，则会使用-k 
–c命令行开关（k标记表示内核错误报告，c标记表示要将完整或核心转储转换为小型转储）启动Windows Fault 
Reporting进程（Werfault.exe）。WerFault会读取TempDestination和DumpFile值。如果
TempDestination值设置为1，这意味着使用了临时文件，WerFault会将临时文件移动到目标位置并为目标文件提供保护，只允许
System账户和本地Administrators组访问。随后WerFault会将最终的转储文件名写入MachineCrash键下的
FinalDumpFileLocation值。这一系列步骤如图10-43所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/9ef165c4550ceb5815143e40a36c5a60.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图10-43 崩溃转储文件的生成</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为对转储文件写入位置进行
更多控制，例如，对从SAN启动的系统或存储分页文件的卷磁盘空间不足的系统进行控制，Windows还支持使用专用转储文件，该文件可通过
HKLM\SYSTEM\CurrentControlSet\Control\CrashControl注册表键下的
DedicatedDumpFile和DumpFileSize值配置。指定专用转储文件后，崩溃转储驱动程序会创建指定大小的转储文件，并向其中（而不
再向分页文件中）写入崩溃数据。如果未指定DumpFileSize值，则Windows会使用存储完整转储文件所需的最大文件尺寸来创建专用转储文件。
为了计算所需的大小，Windows会将系统中配备的物理内存页的总大小与转储头所需的大小（32位系统为一页，64位系统为两页）相加，另外会加上二级
崩溃转储数据的最大值（256MB）。如果配置了完整转储或核心转储，但目标卷可用的磁盘空间不足以创建专用转储文件，那么系统将改为创建小型转储。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>内</b><b>核</b><b>报</b><b>告</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在Wininit启动了WerFault进程并正确生成最终的转储文件后，WerFault将生成随后会发送给微软在线分析网站（如果已配置，还可发送给内部的错误报告服务器）的报告。为内核崩溃生成报告的过程包含下列工作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）如果转储类型不是小型
转储，则会从转储文件中提取小型转储，并将其保存在默认位置%SystemRoot%\Minidump。这个位置可通过
HKLM\SYSTEM\CurrentControlSet\Control\CrashControl注册表键下的MinidumpDir值进行调
整。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）将小型转储文件的名称写入HKLM\SOFTWARE\Microsoft\Windows\Windows Error Reporting\KernelFaults\Queue。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）在
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce下添加一条执行
WerFault.exe（%SystemRoot%\System32\WerFault.exe）的命令，并为该命令使用–k 
–rq标记（rq标记指定使用队列报告模式，并且WerFault会重启动），这样即可在第一个用户登录系统时执行WerFault并发送错误报告。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在登录过程中执行
WerFault时，由于配置了自身的启动方式，所以会使用–k 
–q标记来运行（q标记本身就指定了使用队列报告模式），并会终止前一个实例。这是为了防止Windows外壳（Shell）在WerFault上等待并
尽快将控制返回给RunOnce。新启动的WerFault.exe会检查
HKLM\SOFTWARE\Microsoft\Windows\Windows Error 
Reporting\KernelFaults\Queue键，查找可能在之前的转储转换阶段添加到队列中的报告。此外，它还会检查之前的会话中是否有未
发送的崩溃报告。如果有，WerFault.exe会生成两个XML格式的文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·第一个包含有关系统的基本描述，如操作系统版本、系统中安装的驱动程序列表、系统中存在的设备列表。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·第二个包含OCA服务使用的元数据，如触发WER的事件类型、系统制造商等额外的配置信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后，WerFault会
将两个XML文件的副本和小型转储文件发送给微软OCA服务器，该服务器会将数据转发至服务器场并进行自动分析。该服务器场的自动分析功能使用了与我们在
微软内核调试器中加载崩溃转储文件时相同的分析引擎。同时该分析功能会生成一个桶ID，借此可以区分特定的崩溃类型。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_172" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>7</b><b>.</b><b>3</b><b> </b><b>进</b><b>程</b><b>挂</b><b>起</b><b>检</b><b>测</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">当应用程序因自身代码缺陷
或Bug而挂起或停止工作时，也会用到Windows错误报告。应用程序挂起所导致的一个直接影响是，该应用将不再响应用户的任何交互。检测应用程序挂起
所用的算法取决于应用程序的具体类型。现代应用程序栈认定Centennial或UWP应用程序挂起的依据为，HAM（主机活动管理器）发出的请求在一个
明确定义的超时值（通常为30秒）内未能成功处理；任务管理器认定应用程序挂起的依据为，应用程序不响应WM_QUIT消息；Win32桌面应用程序视为
不响应和挂起的依据为，前台窗口不再处理GDI消息且持续超过5秒。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">有关各种挂起检测算法的详
细介绍已超出了本书范围。这里我们只考虑最常见的情况：经典Win32桌面应用程序不再响应用户的任何输入。检测工作始于Win32k内核驱动程序，当5
秒超时值到期后，该驱动程序会向桌面窗口管理器（DWM.exe）创建的DwmApiPort 
ALPC端口发送一条消息。DWM会使用一种复杂的算法处理该消息，最终在挂起的窗口上层创建一个“幽灵”窗口。幽灵窗口重绘了挂起的窗口原本显示的内
容，将内容模糊显示，并在窗口标题中添加“（未响应）”字样。该幽灵窗口会通过一个内部消息泵例程处理GDI消息，该例程可调用Windows User
 Mode Crash Reporting 
DLL（faultrep.dll）导出的ReportHang例程拦截关闭、退出和激活消息。ReportHang函数会直接构建一条
WERSVC_REPORT_HANG消息，并将其发送给WER服务并等待回复。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">WER服务会读取注册表
HKLM\Software\Microsoft\Windows\Windows Error 
Reporting\Hangs根键中的设置值来处理消息并初始化挂起报告。尤其是可使用MaxHangrepInstances值指示在同一时间里能生
成多少个挂起报告（如果该值不存在，则默认值为8个），而TerminationTimeout值决定了WER服务试图终止挂起的进程前需要等待的时间，
超过该时间后才会认定整个系统处于挂起状态（默认为10秒）。造成这种情况的原因有很多，例如某个应用程序有一个活跃的挂起IRP，但从未被内核驱动程序
完成。WER服务会打开挂起的进程，获取其令牌和其他基本信息。随后WER服务会创建一个共享内存节对象来存储这些信息（类似于用户应用程序的崩溃，不过
此时该共享节的名称为Global\&lt;随机GUID&gt;）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后将使用挂起进程的令牌
和-h命令行开关（指定了要为挂起的进程生成报告），以暂停状态启动一个WerFault进程。与用户应用程序的崩溃不同，此时，WER服务调用
Ntdll导出的PssNtCaptureSnapshot 
API，借此使用完整的SYSTEM令牌创建一个快照。该快照的句柄会被复制到暂停的WerFault进程中，快照成功创建后该进程会恢复运行。当
WerFault启动后，它会发出一个事件信号，表明报告创建过程已开始。随后，原始进程即可被终止。系统将从克隆的进程中获取报告所需的信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为挂起进程生成报告的过程
与崩溃进程的报告过程类似：WerFault进程首先查询位于全局HKLM\Software\Microsoft\Windows\Windows 
Error 
Reporting\Hangs注册表根键下的Debugger值。如果存在有效的调试器，则会启动调试器并连接到挂起的原始进程。如果Disable注
册表值被设置为1，该过程将被忽略，WerFault进程会直接退出而不生成任何报告。其他情况下，WerFault会打开共享内存节，验证其内容，随后
获取WER服务之前保存的所有信息。报告会使用WER.dll中导出的WerReportCreate函数进行初始化，崩溃报告也用到了这个函数。无论
WER如何配置，挂起进程的对话框（见图10-44）将始终显示。最后，将使用（WER.dll中导出的）WerReportSubmit函数生成报告所
需的全部文件（包括小型转储文件），这一过程与应用程序崩溃后的情况类似（详见上文“崩溃报告的生成”一节）。报告最终将发送给在线崩溃分析服务器。</span></p><div style="display: block;text-align:center;">
	<img width="566" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/62bea7c3d33dff27a4822078f51fc79d.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-44 Windows错误报告为挂起的应用程序显示的对话框</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当开始生成报告并且
WERSVC_HANG_REPORTING_STARTED消息返回DWM时，WER会使用TerminateProcess 
API终止挂起的进程。如果该进程未在预期时间范围（通常为10秒，但可按照上文介绍通过TerminationTimeout设置来调整）内终止，
WER服务将使用完整的SYSTEM令牌重新启动另一个WerFault实例并等待更长的时间（通常为60秒，但可通过
LongTerminationTimeout设置来调整）。如果更长的超时等待后进程依然未能终止，WER将只能向应用程序日志中写入一条ETW事件，
借此报告无法终止进程。该ETW事件的内容如图10-45所示。需要注意的是，该事件的描述信息有些误导，因为WER根本无法终止挂起的应用程序。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b1bc145c09e0d8df6ed380a61517a23d.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-45 当挂起的应用程序无法终止时，ETW向应用程序日志中写入的错误事件</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter10_0008.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_173" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>8</b><b> </b><b>全</b><b>局</b><b>标</b><b>记</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows在
NtGlobalFlag和NtGlobalFlag2这两个系统级全局变量中存储了一系列标记，这些标记可用于操作系统的内部调试、跟踪和验证支持等工
作中。这两个系统变量是在系统启动过程中（NT内核初始化阶段0）通过注册表键
HKLM\SYSTEM\CurrentControlSet\Control\Session 
Manager下的GlobalFlag和GlobalFlag2值初始化而来的。默认情况下，这两个注册表值均为0，因此大家的系统很可能并未使用任何
全局标记。此外，每个映像也有一组可用于开启内部跟踪和验证代码的全局标记（不过这些标记的位布局可能与系统级全局标记有些许差异）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">幸好调试工具包含一个名为
Gflags.exe的工具，我们可以用它来查看并更改系统全局标记（可在注册表或运行中的系统内更改）和映像全局标记。Gflags同时提供了命令行和
GUI界面。要查看命令行标记，请运行gflags /?。如果在不指定任何开关的情况下运行该工具，则可以看到如图10-46所示的对话框。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows全局标记中包含的标记可分为下列几个类别。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·内核标记，由NT内核的不同组件（堆管理器、异常、中断处理程序等）直接处理。</span></p><div style="display: block;text-align:center;">
	<img width="779" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ce794e7c4a38f1c344ff78c4a4cd6bc0.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-46 使用Gflags设置系统调试选项</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·用户标记，由用户模式应用程序中运行的组件（通常为Ntdll）处理。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·仅启动标记，只在系统启动过程中处理。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·每映像文件全局标记（与其他标记的含义略有差异），由加载器、WER以及用户模式的其他组件处理，主要取决于运行映像文件的用户模式进程上下文。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Gflags工具显示的标
签页名称有些误导性，每个标签页上的内核标记、仅启动标记以及用户标记都被混在一起显示了。这几个标签页的最大不同在于，System 
Registry页可供用户针对GlobalFlag和GlobalFlag2注册表值设置全局标记，这些标记会在系统启动时进行解析。这意味着只有在系
统重启动后，最终的新标记才得以启用。Kernel 
Flags页虽然名字中带有“Kernel”字样，但并不允许对运行中的系统即时应用内核标记。只有某些用户模式标记可以在无须重启动系统的情况下设置或
移除（例如Enable page 
heap标记）。Gflags工具会使用NtSetSystemInformation原生API（配合SystemFlagsInformation信
息类）来设置这些标记。但只有用户模式标记可以这样设置。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>并</b><b>设</b><b>置</b><b>全</b><b>局</b><b>标</b><b>记</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们可以使用内核调试器的!gflag命令查看并设置NtGlobalFlag内核变量的状态。!gflag命令可列出已启用的全部标记。我们可以使用!
gflag -?获取可支持的全局标记完整列表。截至撰写这部分内容，!gflag扩展尚未进行更新，无法显示NtGlobalFlag2变量的内容。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Image 
File页需要填写可执行映像文件的文件名。通过该选项即可有针对性地更改特定的映像（而非整个系统）的全局标记。该页内容如图10-47所示。请注意，
这里显示的标记与图10-46所示的操作系统标记有所不同。Image File和Silent Process 
Exit页中提供的大部分标记和设置都是通过在HKLM\SOFTWARE\Microsoft\Windows 
NT\CurrentVersion\Image File Execution 
Options注册表键（也叫IFEO键）下一个与映像文件（例如图10-47中所示的notepad.exe）同名的子键中保存新的值来获得应用的。尤
其是GlobalFlag（以及GlobalFlag2）的值，代表了所有可用每映像全局标记的位掩码。</span></p><div style="display: block;text-align:center;">
	<img width="779" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/bd2afcba7a9e2f01290801fd3a802273.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图10-47 使用Gflags设置每映像全局标记</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当加载器初始化先前创建的
新进程并加载主要基本可执行文件依赖的所有库（关于进程的诞生，详见卷1第3章）时，系统就会处理每映像的全局标记。内部例程
LdrpInitializeExecutionOptions会根据基本映像的名称打开IFEO注册表键，并解析所有每映像设置和标记。尤其是，在从注
册表获取了每映像全局标记后，它们会被存储到进程PEB的NtGlobalFlag（和NtGlobalFlag2）字段中，以便被进程中映射的任何映像
（包括Ntdll）轻松访问。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">大部分可用的全局标记都有相关文档，详见https://docs.microsoft.com/windows- hardware/drivers/debugger/gflags-flag-table。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>加</b><b>载</b><b>器</b><b>故</b><b>障</b><b>排</b><b>错</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
卷1第3章的“观察映像加载器”实验中，我们使用Gflags工具查看了Windows加载器运行时的信息。那些信息可以帮助我们理解某个应用程序为何完
全不启动（未返回任何有用的错误信息）。我们可以重命名%SystemRoot%\system32下的Msftedit.dll文件（富文本编辑控件
库），然后针对mspaint.exe重新执行该实验。实际上，MSPaint是间接依赖这个DLL的。Msftedit库由MSCTF.dll以动态的
方式加载（并非静态链接至MSPaint的可执行文件）。请以管理员身份打开命令提示符窗口并运行下列命令：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">cd /d c:\windows\system32 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">takeown /f msftedit.dll </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">icacls msftedit.dll /grant Administrators:F </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ren msftedit.dll msftedit.disabled </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后使用Gflags工具启用Loader snaps，具体方法请参阅“观察映像加载器”实验。随后使用Windbg启动mspaint.exe，Loader snaps几乎会立即强调显示出遇到的问题，并返回下列文本：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">142c:1e18 @ 00056578 - LdrpInitializeNode - INFO: Calling init routine 00007FFC79258820 for</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">DLL "C:\Windows\System32\MSCTF.dll"142c:133c @ 00229625 - LdrpResolveDllName - ENTER: DLL </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">name: .\MSFTEDIT.DLL </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">142c:133c @ 00229625 - LdrpResolveDllName - RETURN: Status: 0xc0000135 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">142c:133c @ 00229625 - LdrpResolveDllName - ENTER: DLL name: C:\Program Files\Debugging Tools </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">for Windows (x64)\MSFTEDIT.DLL </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">142c:133c @ 00229625 - LdrpResolveDllName - RETURN: Status: 0xc0000135 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">142c:133c @ 00229625 - LdrpResolveDllName - ENTER: DLL name: C:\Windows\</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">system32\MSFTEDIT.DLL </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">142c:133c @ 00229625 - LdrpResolveDllName - RETURN: Status: 0xc0000135 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">. . . </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\Users\test\AppData\Local\Microsoft\WindowsApps\MSFTEDIT.DLL </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">142c:133c @ 00229625 - LdrpResolveDllName - RETURN: Status: 0xc0000135 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">142c:133c @ 00229625 - LdrpSearchPath - RETURN: Status: 0xc0000135 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">142c:133c @ 00229625 - LdrpProcessWork - ERROR: Unable to load DLL: "MSFTEDIT.DLL", Parent </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Module: "(null)", Status: 0xc0000135 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">142c:133c @ 00229625 - LdrpLoadDllInternal - RETURN: Status: 0xc0000135 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">142c:133c @ 00229625 - LdrLoadDll - RETURN: Status: 0xc0000135 </span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter10_0009.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_174" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>9</b><b> </b><b>内</b><b>核</b><b>填</b><b>充</b><b>码</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">新版Windows操作系
统可能会对旧版的驱动程序造成一些问题，导致驱动程序难以在新环境中运行，进而导致系统挂起或蓝屏死机。为了解决这些问题，Windows 
8.1引入了内核填充码（kernel 
shim）引擎，借此动态修改旧版本的驱动程序，使其可以在新版的操作系统中正常运行。内核填充码引擎主要是在NT内核中实现的。驱动程序的填充码可通过
Windows注册表和填充码数据库文件进行注册。驱动程序的填充码由填充码驱动程序提供。填充码驱动程序可使用导出的
KseRegisterShimEx API注册填充码，将其应用给需要的目标驱动程序。内核填充码引擎主要支持两种适用于设备或驱动程序的填充码。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_175" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>9</b><b>.</b><b>1</b><b> </b><b>填</b><b>充</b><b>码</b><b>引</b><b>擎</b><b>初</b><b>始</b><b>化</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在操作系统启动的早期阶
段，Windows加载器在加载所有“引导加载”的驱动程序同时，还会读取并映射位于%SystemRoot%
\apppatch\Drvmain.sdb（以及Drvpatch.sdb文件，如果存在）中的驱动程序兼容性数据库文件。在NT内核初始化阶段1期
间，I/O管理器会启动内核填充码引擎初始化工作，相关工作分为两个阶段。NT内核会将数据库文件的二进制内容复制到一个从分页池分配的全局缓冲区中（由
内部全局变量KsepShimDb指向）。随后它会检查内核填充码是否被全局禁用。如果系统要启动到安全模式或WinPE模式，或驱动程序验证器已启用，
那么填充码引擎将不被启用。内核填充码引擎也可以使用系统策略或
HKLM\System\CurrentControlSet\Control\Compatibility\DisableFlags注册表键加以控
制。随后，NT内核会收集应用设备填充码时所需的底层系统信息，如BIOS信息和OEM ID，为此需要检查系统固定ACPI描述符表（System 
Fixed ACPI Descriptor Table，FADT）。内核填充码引擎会使用KseRegisterShimEx 
API注册第一个内置的填充码提供程序，其名称为DriverScope。Windows内置的填充码请参阅表10-21，其中一些确实是在NT内核中直
接实现的，不在任何外部驱动程序中。DriverScope是阶段0注册的唯一的一个填充码。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">表10-21 Windows自带的内核填充码</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/f041b59e17f78254e0fdf4181f7bcba5.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/36ab02a6872772b3efb62a3748def173.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ab6d5d79c9244e8a094ec74c9e01933e.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a4a7d4d9405a91a3efdf4238f2046175.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在系统内部，填充码是由
KSE_SHIM数据结构（KSE是指Kernel Shim 
Engine，即内核填充码引擎）所表示的。该数据结构包含GUID、填充码的人工易读名称，以及挂钩集合数组（KSE_HOOK_COLLECTION
数据结构）。驱动程序填充码支持不同类型的挂钩：由NT内核、HAL、驱动程序库导出的函数上的挂钩，以及驱动程序的对象回调函数上的挂钩。在初始化的阶
段1过程中，填充码引擎会注册名为MicrosoftWindows-Kernel- 
ShimEngine的ETW提供程序（GUID为{0bf2fb94-7b60-4b4d-9766-e82f658df540}），打开驱动程序填充
码数据库，并初始化NT内核中实现的其余自带填充码（参阅表10-21）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">若通过
KseRegisterShimEx注册填充码，NT内核需要对KSE_SHIM数据结构以及集合中的每个挂钩（所有挂钩必须位于调用方驱动程序的地址空
间内）进行一些初始完整性检查。随后它会分配并填充一个KSE_REGISTERED_SHIM_ENTRY数据结构，顾名思义，该数据结构代表了已注册
的填充码。其中包含一个引用计数器和一个指向驱动程序对象的指针（仅在非NT内核中实现的填充码下使用）。分配的这个数据结构会链接至一个全局链表，该链
表记录了系统中已注册的所有填充码。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_176" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>9</b><b>.</b><b>2</b><b> </b><b>填</b><b>充</b><b>码</b><b>数</b><b>据</b><b>库</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">填充码数据库（SDB）文
件格式最早出现在Windows 
XP中，其目的在于改善应用程序的兼容性。该文件格式最初的用途是，为需要在操作系统的帮助下才能正常运行的程序和驱动程序存储一种二进制XML样式的数
据库。经过调整，SDB文件已经可以包含内核模式填充码。该文件格式使用标签来描述一种XML数据库。标签是一种2字节的基础数据结构，可充当数据库中项
和特性的唯一标识符。它由4位的类型和12位的索引组成，类型标识了与标签相关数据的格式。每个标签都表示了数据类型、大小，以及标签本身的解释。SDB
文件有一个12字节的头和一组标签，这一组标签通常定义了填充码数据库文件中的三个主要块。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·INDEX块，包含索引标签，用于快速索引数据库中的元素。INDEX块中的索引以升序的形式存储，因此在索引中搜索元素的速度非常快（使用了二分搜索算法）。对于内核填充码引擎，元素使用从填充码名称派生而来的一个8字节键存储在INDEX块中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·DATABASE块，包含描述填充码、驱动程序、设备以及可执行文件的顶级标签。每个顶级标签都包含子标签，这些子标签描述了根项之下包含的属性或内联块。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·STRING
 
TABLE块，其中包含的字符串可被DATABASE块中的下层标签所引用。DATABASE块中的标签通常不直接描述字符串，而是包含对标签（名为
STRINGREF）的引用，描述了位于字符串表中的字符串。这样包含大量通用字符串的数据库就不会变的体积过于巨大。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">微软已经部分公开了SDB
文件格式和读/写SDB的API，详见https://docs.microsoft.com/windows/win32/devnotes/
application-compatibility-database。所有SDB 
API都是在应用程序兼容性客户端库（apphelp.dll）中实现的。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_177" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>9</b><b>.</b><b>3</b><b> </b><b>驱</b><b>动</b><b>程</b><b>序</b><b>填</b><b>充</b><b>码</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NT内存管理器使用
KseDriverLoadImage函数来决定是否在加载时为内核驱动程序应用填充码（引导加载的驱动程序是由I/O管理器处理的，详见第12章）。该
例程会在内核模块生命周期的正确时间调用，并会在运行驱动程序验证器、导入优化和应用Kernel 
Patch保护之前进行调用（这个顺序很重要，否则系统会进入错误检查状态）。目前已经应用填充码的内核模块列表存储在一个全局变量中。
KsepGetShimsForDriver例程会检查列表中是否有与已加载模块具备相同基址的模块。如果有，则意味着目标模块已经应用了填充码，因此后
续过程可以忽略。否则需要决定是否为新模块应用填充码，该例程会从两个不同的来源进行检查。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·查询HKLM\System\CurrentControlSet\Control\Compatibility\Driver根键下，与被加载模块同名的注册表键的“Shims”多字符串值。该注册表值包含了需要为目标模块应用的由填充码的名称组成的数组。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
如果目标模块的上述注册表值不存在，则会解析驱动程序兼容性数据库文件，查找KDRIVER标签（由INDEX块建立了索引），该标签应该会与被加载的模
块同名。如果在SDB文件中找到了驱动程序，NT内核会对比驱动程序版本（KDRIVER根标签下存储的TAG_SOURCE_OS）、文件名、路径（如
果SDB中存在相对标签），以及引擎初始化过程中收集的底层系统信息（借此判断驱动程序是否兼容系统）。如果上述任何一类信息不匹配，驱动程序将会被跳
过，不会应用任何填充码。否则将从KSHIM_REF底层标签（根KDRIVER的一部分）获取填充码名称列表。这些标签是对SDB数据库块中KSHIM
的引用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果通过上述两个来源之一
获得了要应用给目标驱动程序的一个或多个填充码名称，那么随后将再次解析SDB文件，这次的目的是验证是否存在有效的KSHIM描述符。如果特定填充码名
称没有相关标签（意味着数据库中不存在填充码描述符），则该过程将被中断（借此防止管理员为驱动程序应用随机的非微软填充码）。如果找到相关的标签，则会
向KsepGetShimsForDriver返回一个KSE_SHIM_INFO数据结构数组。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">接下来需要判断描述符所描
述的填充码是否已在系统中注册。为此，填充码引擎会搜索已注册填充码的全局链表（每当注册新填充码后，都会填写该链表，详见上文“填充码引擎初始化”一
节）。如果填充码尚未注册，则填充码引擎会试图加载提供该填充码的驱动程序（驱动程序名称存储在根KSHIM项的MODULE子标签中），随后会再次重
试。当填充码首次应用时，填充码引擎会解析已注册填充码（KSE_SHIM数据结构）包含的KSE_HOOK_COLLECTION数据结构数组描述的所
有挂钩的指针。填充码引擎会分配并填写一个KSE_SHIMMED_MODULE数据结构，该数据结构代表了要被应用填充码的目标模块（及其基址），并将
其添加到最开始检查的全局列表中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">至此，填充码引擎即可使用
内部例程KsepApplyShimsToDriver为目标模块应用填充码。该例程会在KSE_HOOK_COLLECTION数组描述的每个挂钩中循
环，修补目标模块的导入地址表（IAT），用新的挂钩（由挂钩集描述）替换挂钩函数的原始地址。请注意，在这个阶段并不处理驱动程序的对象回调函数
（IRP处理程序），这些函数稍后会在调用目标驱动程序的DriverInit例程之前被I/O管理器修改。原始驱动程序的IRP回调例程会保存在目标驱
动程序的驱动程序扩展（driver extension）中。这样，挂钩函数在需要时就可以通过简单的方式重新调用到原来的函数中。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>驱</b><b>动</b><b>程</b><b>序</b><b>填</b><b>充</b><b>码</b><b>的</b><b>作</b><b>用</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">虽
然使用Windows评估和部署工具包发布的官方微软应用程序兼容性工具包可供我们打开、修改、创建填充码数据库文件，但无法借此操作系统数据库文件（可
通过内部GUID识别不同的数据库文件），因此，也就无法借助该工具解析drvmain.sdb数据库描述的所有内核填充码。不过有很多第三方SDB解析
程序。例如，一款名为SDB Explorer的工具就可以在这里免费下载：https://ericzimmerman.github.io/。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">这个实验将查看drvmain系统数据库文件的内容，并向本书随附资源中包含的测试驱动程序ShimDriver应用内核填充码。为了完成该实验，我们需要启用测试签名（ShimDriver使用自签名测试证书签名）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">1）以管理员身份打开命令提示符窗口，并运行下列命令：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">bcdedit /set testsigning on </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">2）重启计算机，通过上述链接下载并运行SDB Explorer，打开%SystemRoot%\apppatch下的drvmain.sdb数据库文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">3）
在SDB 
Explorer主窗口中，我们可以浏览整个数据库文件，该文件分为Indexes、Databases以及String表三个主要的块。请展开
DATABASES根块并向下滚动，找到KSHIM列表（应该在KDEVICE后面）。随后应该能看到类似下图所示的窗口。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/323765961843aa3a7ab4a116e74a344b.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">4）我们需要向测试驱动程序应用一个Version lie填充码。首先请将ShimDriver复制到%SystemRoot%\System32\Drivers，随后在管理员身份启动的命令提示符窗口中运行下列命令安装该驱动程序（假设系统是64位的）。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">sc create ShimDriver type= kernel start= demand error= normal binPath= c:\Windows\System32\ShimDriver64.sys </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">5）
在启动测试驱动程序前，需要从Sysinternals网站下载并运行DebugView工具（https://docs.microsoft.com/
sysinternals/downloads/debugview）。这一步是必需的，因为ShimDriver会输出一些调试信息。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">6）使用下列命令启动ShimDriver：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">sc start shimdriver </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">7）检查DebugView工具的输出结果。应该可以看到类似下图所示的消息。实际看到的内容取决于运行该驱动程序的Windows版本。在本例中，我们在Insider版的Windows Server 2022上运行了该驱动程序。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/1ef65b64386656f8be5c59ffe6dc7615.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">8）此时即可停止驱动程序并启用SDB数据库中的填充码。在本例中，我们将使用一个Version lie填充码。停止目标驱动程序并使用下列命令安装填充码（其中ShimDriver64.sys是上一步安装的驱动程序的文件名）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">sc stop shimdriver </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">reg add "HKLM\System\CurrentControlSet\Control\Compatibility\Driver\</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    ShimDriver64.sys" /v Shims /t REG_MULTI_SZ /d</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">KmWin81VersionLie /f /reg:64 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">9）上述命令会添加Windows 8.1的Version lie填充码，但我们也可以随意选择其他版本。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">10）随后如果重新启动该驱动程序，将能看到DebugView工具显示了不同的输出结果，类似下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e79c244993e2bf28dfa6b21496b84f4c.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">11）
这是因为填充码引擎为获取操作系统版本信息的NT 
API正确地应用了挂钩（驱动程序也能检测到填充码）。我们也可以使用其他填充码重复该实验，例如使用SkipDriverUnload或
KernelPadSectionsOverride填充码，借此可以让驱动程序卸载例程归零，或阻止目标驱动程序加载，效果如下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/8b755ceac2d5c1098c34df44e14bffc4.jpg" alt="" title=""></div>
</div><div class="header2"><h3><span id="sigil_toc_id_178" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>9</b><b>.</b><b>4</b><b> </b><b>设</b><b>备</b><b>填</b><b>充</b><b>码</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">与驱动程序填充码不同，应
用给设备对象的填充码是按需加载和应用的。NT内核导出的KseQueryDeviceData函数可供驱动程序检查是否需要为设备对象应用填充码（请注
意，KseQueryDeviceFlags也是导出的函数，不过该API仅仅是第一个API的子集）。用户模式应用程序也可以通过
NtQuerySystemInformation 
API配合SystemDeviceDataInformation信息类查询设备填充码。设备填充码始终存储在三个不同的位置，会按照下列顺序查询。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）
HKLM\System\CurrentControlSet\Control\Compatibility\Device注册表根键下，以设备的PNP
硬件ID为名的键，并使用“!”替代“\”符号（这是为了避免与注册表产生混淆）。设备键下的值指定了设备被查询的填充码数据（对某些设备类来说，通常是
一种标记，即Flag）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）内核填充码缓存。内核填充码引擎实现了一种填充码缓存（通过KSE_CACHE数据结构公开），其目的是加快设备标记和数据的搜索速度。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）填充码数据库文件中，
使用KDEVICE设备标签。根标签和其他很多标签（如设备描述、制造商名称、GUID等）包含子NAME标签，这个标签中包含以
&lt;DataName: HardwareID&gt;形式组成的字符串。KFLAG或KDATA子标签包含设备的填充码数据值。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果设备填充码不在缓存中，而在SDB文件中，那么也会加入缓存。这样未来的查询速度可以更快，并且不再需要访问填充码数据库文件。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter10_0010.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_179" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>0</b><b>.</b><b>1</b><b>0</b><b> </b><b>总</b><b>结</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">本章介绍了Windows
操作系统中提供管理设施最重要的功能，例如Windows注册表、用户模式服务、任务计划、UBPM及Windows管理规范（WMI）。此外还介绍了如
何通过Windows事件跟踪（ETW）、DTrace、Windows错误报告（WER）以及全局标记（Gflag）提供的服务，让用户更好地跟踪并诊
断操作系统或用户模式应用程序组件遇到的问题。最后简要介绍了内核填充码引擎，该引擎可以帮助系统应用兼容性策略并正确执行针对旧版本操作系统设计的旧版
组件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">第11章将深入介绍Windows支持的各种文件系统，以及可用于加快文件和数据访问速度的全局缓存。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11.xhtml">
</div><div class="header0"><h1><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';display: block;text-align:center;"><b>第</b><b>1</b><b>1</b><b>章</b></span></h1></div>
<div class="part">
</div><div class="header0"><h1><span id="sigil_toc_id_180" style="font-size:22px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';display: block;text-align:center;"><b>缓</b><b>存</b><b>和</b><b>文</b><b>件</b><b>系</b><b>统</b></span></h1></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存管理器是一系列内核模
式函数和系统线程，它们与内存管理器配合，可以为所有的Windows文件系统（本地或网络）驱动程序提供数据缓存。本章将介绍缓存管理器及其内部数据结
构和函数的工作原理、如何在系统初始化时确定缓存大小、缓存如何与操作系统的其他元素交互，以及如何通过性能计数器观察缓存的活动。我们还将介绍
Windows 
CreateFile函数会对文件缓存和DAX卷产生影响的五个标记。DAX卷是一种内存映射的磁盘，在某些类型的I/O中会绕过缓存管理器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存管理器公开的服务可被
所有Windows文件系统驱动程序使用，它们之间会严格合作，进而尽可能快速地管理磁盘I/O。我们将介绍Windows支持的不同文件系统，尤其将深
入介绍NTFS和ReFS（两个使用广泛的文件系统）。我们还将介绍它们的内部架构和基本操作，包括如何与其他系统组件（如内存管理器和缓存管理器）进行
交互。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">本章还将概括介绍存储空间，这种全新的存储解决方案是为取代动态磁盘而设计的。空间可创建为分层或精简配置的虚拟磁盘，借此为上层的文件系统提供各种功能。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11_0001.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_181" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b> </b><b>术</b><b>语</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了更好地理解本章内容，首先需要熟悉下列基本术语。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·磁盘（disk）：一种物理存储设备，例如硬盘、CD-ROM、DVD、蓝光盘、固态硬盘（SSD）、非易失性内存盘（NVMe）或闪存盘（Flash）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
扇区（sector）：存储介质上的硬件可寻址块。扇区大小由硬件决定。大部分硬盘扇区为4096字节或512字节，DVD-ROM和蓝光盘扇区通常为
2048字节。因此，如果扇区大小为4096字节，但操作系统需要修改磁盘上第5120字节的内容，就必须将4096字节的数据块写入磁盘上的第二个扇区
中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·分区（partition）：磁盘上一系列连续扇区的集合。分区表或其他磁盘管理数据库存储了分区的起始扇区、大小及其他特征，这些信息会存储到分区所在的磁盘上。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·卷（volume）：文件系统驱动程序总是将大量扇区作为一个单位进行管理，而卷是一种可以表示所有这些扇区的对象。简单卷表示来自同一个分区的扇区，多分区卷则表示来自多个分区的扇区。多分区卷通常可提供简单卷无法提供的性能、可靠性和大小调整功能。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
文件系统格式（file system 
format）：定义了文件数据在存储介质上的存储方式，并影响着文件系统的功能。例如，若不支持为文件和目录分配用户权限的格式，就无法支持安全性。文
件系统格式也会对文件系统可支持的文件和存储设备大小施加压力。最后，一些文件系统格式对大文件、小文件、大磁盘、小磁盘实现了更高效的支持。NTFS、
exFAT和ReFS都是常见的文件系统格式，它们提供了不同的功能和使用场景。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
簇（cluster）：很多文件系统格式所使用的可寻址块。簇大小始终是扇区大小的整数倍，如图11-1所示，8个扇区组成1个簇。文件系统格式可使用簇
来更有效地管理磁盘空间，比扇区更大的簇可以将磁盘划分为更易于管理的块。但更大的簇也需要付出潜在的代价——浪费磁盘空间，或更易于产生内部碎片。当文
件大小不是簇大小的整数倍时，就容易产生这种情况。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·元数据（metadata）：是指为支持文件系统格式管理而在卷中存储的数据。应用程序通常无法访问此类数据。例如，元数据包含的数据定义了文件和目录在卷上的放置情况。</span></p><div style="display: block;text-align:center;">
	<img width="614" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a1b9c19efccc413b11b8f49089bdd0a5.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-1 传统机械硬盘中的扇区和簇</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11_0002.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_182" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>2</b><b> </b><b>缓</b><b>存</b><b>管</b><b>理</b><b>器</b><b>的</b><b>重</b><b>要</b><b>功</b><b>能</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存管理器提供了多个重要功能。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·支持所有文件系统类型（本地和网络），因此，不再需要每种文件系统实现自己的缓存管理代码功能。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·使用缓存管理器能控制将哪个文件的哪些部分保留在物理内存中（在用户进程和操作系统之间对物理内存需求进行权衡）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·在虚拟块（文件中的偏移量）基础上缓存数据，而不像很多缓存系统那样在逻辑块（磁盘卷中的偏移量）的基础上缓存数据，这样即可在无须调用文件系统驱动程序的前提下对缓存进行智能预读取和高速访问（这种缓存方法也叫快速I/O，详见下文）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·支持应用程序打开文件时给出的“提示”（例如，随机访问或顺序访问、临时文件创建等）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·支持可恢复文件系统（例如使用事务日志的文件系统），由此在系统故障后恢复数据。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·支持固态硬盘、NVMe硬盘以及直接访问（DAX）磁盘。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">下文将详细介绍这些功能在缓存管理器中的使用，本节将重点介绍这些功能背后的概念。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_183" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>2</b><b>.</b><b>1</b><b> </b><b>单</b><b>一</b><b>集</b><b>中</b><b>化</b><b>系</b><b>统</b><b>缓</b><b>存</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">一些操作系统依靠每个不同
类型的文件系统来缓存数据，这种做法要么导致操作系统中存在重复的缓存和内存管理代码，要么导致可缓存的数据种类面临某些限制。相比之下，Windows
提供了一种集中化的缓存设施，可以缓存所有外部存储的数据，无论这些数据位于本地硬盘、USB可移动存储设备、网络文件服务器或DVD-ROM中。任何数
据，无论用户数据流（文件内容以及针对文件进行的持续读/写操作）或文件系统元数据（如目录和文件头）均可缓存。正如下文的介绍，Windows访问缓存
的方法取决于被缓存数据的类型。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_184" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>2</b><b>.</b><b>2</b><b> </b><b>内</b><b>存</b><b>管</b><b>理</b><b>器</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存管理器不同寻常的地方
在于，它永远不会知道物理内存中实际包含多少缓存的数据。这种说法也许会让人感觉奇怪，毕竟缓存的目的就是将一部分频繁访问的数据保留在物理内存中，以此
提高I/O性能。而缓存管理器不知道物理内存中保留了多少缓存数据的原因在于，它是通过将文件视图映射到系统虚拟地址空间中来访问数据的，这一过程中使用
了标准的节对象（或者使用符合Windows 
API术语的称呼，叫作文件映射对象）（节对象是内存管理器的一种基本基元，详见卷1第5章）。当访问映射视图中所包含的地址时，内存管理器会对不在物理
内存中的块进行页面换入（pages-in）。而当内存需求发生变化时，内存管理器会将这些页面解除映射，从缓存中移出，如果数据发生了变化，则会将数据
重新分页回到文件中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通过在虚拟地址空间的基础
上使用映射的文件进行缓存，缓存管理器可避免为访问所缓存的文件数据而生成读取或写入的I/O请求包（IRP）。相反，缓存管理器只是简单地针对被缓存文
件中已映射部分对应的虚拟地址进行数据复制操作，并根据需要依赖的内存管理器将数据换入或换出内存。该过程使得内存管理器可以在全局范围内权衡要为系统缓
存和用户进程分别分配多少RAM（缓存管理器也会发起I/O操作，如延迟写入，详见下文。不过它会调用内存管理器来写入页面）。此外，正如下一节将要讨论
的，这种设计使得打开了被缓存文件的进程，可以像将同一个文件映射到自己用户地址空间的进程那样看到相同的数据。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_185" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>2</b><b>.</b><b>3</b><b> </b><b>缓</b><b>存</b><b>的</b><b>一</b><b>致</b><b>性</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存管理器的一个重要功能
是，确保任何访问缓存数据的进程都能得到最新版本的数据。但当一个进程打开了一个文件进而导致该文件被缓存时，如果其他进程（使用Windows的
MapViewOfFile函数）直接将该文件映射至自己的地址空间，此时将会出现问题。不过在Windows下并不会出现这种潜在问题，因为缓存管理器
和将文件映射到自己地址空间的用户应用程序使用了同一个内存管理文件映射服务。由于内存管理器可以保证对每个映射的唯一文件都只有一个表达（无论产生了多
少个节对象或映射视图），因此可以将一个文件的所有视图（哪怕视图有所重叠）都映射至物理内存的同一组页面内，如图11-2所示（有关内存管理器处理映射
文件的方法，请参阅卷1第5章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">举例来说，如果进程1有一
个映射到自己的用户地址空间的文件视图（视图1），进程2正在通过系统缓存访问同一个视图，进程2将看到进程1对文件进行的所有改动，而无须等待缓存刷
新。内存管理器不会刷新所有用户映射的页面，只会刷新自己知道已经被写入数据的页面（因为这些页面已设置了“已修改”位）。因此，任何在Windows下
访问文件的进程始终都能看到该文件的最新版本，哪怕其他进程已经通过I/O系统打开了该文件，并且还有其他进程使用Windows文件映射函数将文件映射
到了自己的地址空间。</span></p><div style="display: block;text-align:center;">
	<img width="852" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/13f1c11ae2860187a7606fea2c512478.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-2 一致缓存结构</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
这里的缓存一致性是指用户映射的数据和缓存的I/O之间的一致性，并非“非缓存”和“缓存”的硬件访问与I/O之间的一致性，后者几乎可以保证是无法一致
的。此外，网络重定向器的缓存一致性往往比本地文件系统缓存一致性更难实现，因为网络重定向器必须实现额外的刷新和清除操作，以保证访问网络数据时的缓存
一致性。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_186" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>2</b><b>.</b><b>4</b><b> </b><b>虚</b><b>拟</b><b>块</b><b>缓</b><b>存</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows缓存管理器
使用了一种称为虚拟块缓存（virtual block 
caching）的方法，缓存管理器可以通过这种方法跟踪哪些文件的哪些部分位于缓存中。缓存管理器还可以使用位于内存管理器中的特殊系统缓存例程，将文
件的256KB视图映射到系统虚拟地址空间，以此监控文件中被缓存的部分。这种方法可以实现多种好处。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·为智能预读取（read-ahead）提供了可能，因为缓存可以跟踪哪些文件的哪些部分位于缓存中，进而预测调用方接下来可能会访问什么。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·可以让I/O系统绕过文件系统直接请求已经位于缓存中的数据（快速I/O）。因为缓存管理器知道哪些文件的哪些部分已经位于缓存中，所以可以直接返回已缓存数据的地址来满足I/O请求，而无须调用文件系统。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">有关智能预读取和快速I/O工作原理的详细介绍请参阅下文“快速I/O”和“预读取和延后写入”中的内容。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_187" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>2</b><b>.</b><b>5</b><b> </b><b>基</b><b>于</b><b>流</b><b>的</b><b>缓</b><b>存</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存管理器在设计上不仅可
以进行文件缓存，还可以进行流缓存。流（stream）是指文件中的字节序列。一些文件系统（如NTFS）允许一个文件包含多个流，缓存管理器通过分别缓
存每个流来适应这种文件系统。NTFS可以将自己的主文件表（详见下文“主文件表”一节）组织成不同的流，并缓存这些流，由此利用这一功能。实际上，虽然
缓存管理器可以说是在缓存文件，但实际上它缓存的是流（所有文件都至少有一个数据流），这些数据流可以通过文件名以及流名称（如果文件中包含多个流的话）
加以识别。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 在内部，缓存管理器并不知道文件或流的名称，而是会使用指向这些结构的指针。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_188" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>2</b><b>.</b><b>6</b><b> </b><b>可</b><b>恢</b><b>复</b><b>文</b><b>件</b><b>系</b><b>统</b><b>支</b><b>持</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">按照设计，诸如NTFS这
种可恢复文件系统可以在系统故障后重建磁盘卷结构。这种功能意味着系统故障那一刻正在进行的I/O操作必须能全部完成，或者当系统重启后可以完全从磁盘中
恢复。半完成的I/O操作会损坏磁盘卷，甚至让整个卷无法访问。为了避免出现此类问题，需要由可恢复文件系统维护一个日志文件，以此记录自己希望对文件系
统结构（文件系统的元数据）进行的每个更新，随后才能将变更写入卷。如果系统故障打断了正在对卷进行的修改，可恢复文件系统将使用日志中存储的信息重新对
卷进行更新。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了保证卷可以成功恢复，每个记录了卷更新的日志文件必须首先完全写入磁盘，随后才会将更新实际应用到卷。由于磁盘写入操作会被缓存，缓存管理器和文件系统必须协调元数据更新，以确保日志文件的刷新操作会先于元数据更新。总的来说，将会依次发生下列事情。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）文件系统写入一个日志文件记录，其中记录了自己打算进行的元数据更新。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）文件系统调用缓存管理器，将日志文件记录刷新到磁盘。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）文件系统将卷更新写入缓存，即修改了自己缓存的元数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）缓存管理器将修改后的元数据刷新到磁盘并更新卷结构（实际上，日志文件记录在被刷新到磁盘之前是分批进行的，卷的修改也是分批进行的）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 此处的“元数据”一词只适用于文件系统结构的变化：文件和目录创建、更名、删除。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当文件系统向缓存写入数据
时，可提供一个逻辑序列号（Logical Sequence 
Number，LSN）来标识日志文件中的记录，这些记录对应了缓存的更新。缓存管理器会持续跟踪这些序列号，记录缓存中每个页面关联的最低和最高LSN
（分别代表最老和最新的日志文件记录）。此外，被事务日志记录保护的数据流会被NTFS标记为“不可写入”，这样映射页的写入器就不会在相应的日志记录被
写入前无意中写出（write 
out）这些页面（当映射页面写入器看到带有这种标记的页面后，会将页面移入一个特殊列表，随后缓存管理器会在适当的时间进行刷新，例如进行延迟写入
时）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当它准备将一组脏页刷新到
磁盘时，缓存管理器会确定刷新页面的最高LSN，并将该序列号汇报给文件系统。随后文件系统即可调用缓存管理器，指示它将日志文件数据刷新到所汇报的
LSN代表的那一点。当缓存管理器将日志文件刷新到这个LSN后，还会将相应的“卷结构更新”刷新到磁盘，以此确保实际执行操作前已将所有打算进行的操作
记录在案。文件系统和缓存管理器之间的这些交互保证了系统故障后磁盘卷依然可以恢复。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_189" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>2</b><b>.</b><b>7</b><b> </b><b>N</b><b>T</b><b>F</b><b>S</b><b> </b><b>M</b><b>F</b><b>T</b><b>工</b><b>作</b><b>集</b><b>的</b><b>增</b><b>强</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如前几段所述，缓存管理
器缓存文件的机制与内存管理器为操作系统提供的常规内存映射I/O接口相同。为了访问或缓存文件，缓存管理器会将文件的视图映射至系统虚拟地址空间。随后
只需从映射的虚拟地址范围读取，即可访问缓存的内容。当文件中被缓存的内容已不再需要时（原因有很多，详见下一段），缓存管理器会撤销对文件视图的映射。
这种策略适用于任何类型的文件数据，但如果将其用于文件系统为正确地在卷中存储文件而使用的元数据，可能会造成一些问题。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在文件句柄被关闭（或拥有
句柄的进程终止）后，缓存管理器会保证缓存的数据不再位于工作集中。NTFS将主文件表（Master File 
Table，MFT）作为一个大文件访问，而MFT也会像其他用户文件那样被缓存管理器缓存起来。但MFT的问题在于，它是一种系统文件，需要在
System进程上下文中映射和处理，任何人都无法关闭它的句柄（除非卷被卸载），因此系统从来不会卸载MFT的任何缓存视图的映射。最初导致MFT的特
定视图被映射的进程，可能已经关闭了句柄或者已经退出，这会导致可能已经不再需要的MFT视图依然被映射，浪费了宝贵的系统缓存（只有在系统面临内存压力
时，这些视图才会被解除映射）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows 
8.1通过在一个动态分配的多级数组中存储每个MFT记录的引用计数器解决了这个问题，这个数组存储在NTFS卷控制块（Volume Control 
Block，VCB）结构中。在创建了文件控制块（File Control 
Block，FCB）数据结构后（有关FCB和VCB的详细信息请参阅下文），文件系统会增大相对MFT索引记录的计数器值。通过同样的方式，当FCB被
销毁（意味着MFT项指向的所有文件或目录句柄均已关闭）时，NTFS会取消对相对计数器的引用，并调用缓存管理器的
CcUnmapFileOffsetFromSystemCache例程，以此解除对不再需要的MFT部分的映射。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_190" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>2</b><b>.</b><b>8</b><b> </b><b>内</b><b>存</b><b>分</b><b>区</b><b>支</b><b>持</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了对Hyper-V容器
和游戏模式提供支持，Windows 
10引入了内存分区的概念。内存分区的概念已经在卷1第5章进行了介绍。通过那些介绍可知，内存分区由一种大型数据结构（MI_PARTITION）所代
表，它维护了与分区有关的内存管理结构，如页面列表（备用、已修改、清零、闲置等）、内存使用（commit 
charge）、工作集、页面裁边器（page 
trimmer）、已修改页面写入器以及零页面线程。为了支持分区，缓存管理器必须与内存管理器相互配合。在NT内核初始化的阶段1期间，系统会创建并初
始化缓存管理器分区（有关Windows内核初始化的详细信息请参阅第12章），该分区将成为系统执行体分区（MemoryPartition0）的一部
分。为支持分区，缓存管理器的代码已进行了大规模重构，所有全局缓存管理器数据结构和变量已被移入缓存管理器分区数据结构（CC_PARTITION）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存管理器的分区包含与缓
存有关的数据，如全局共享缓存映射列表、工作线程列表（预读取、后写入、额外后写入、惰性写入、惰性写入扫描、异步读取）、惰性写入器扫描事件、保存后写
入历史吞吐量的数组、脏页阈值上限和下限、脏页数量等。当缓存管理器系统分区被初始化时，会在属于该分区的System进程上下文中启动所有需要的系统线
程。每个分区总是有一个相关的最小System进程，它是在创建分区时由NtCreatePartition API创建的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当系统通过
NtCreatePartition 
API创建新的分区时，始终会创建并初始化一个空的MI_PARTITION对象（内存会从父分区移入子分区，或稍后由
NtManagePartition函数热添加）。缓存管理器分区对象只在需要时创建。如果新分区的上下文中没有创建文件，此时就无须创建缓存管理器的分
区对象。当文件系统创建或打开用于缓存访问的文件时，CcinitializeCacheMap(Ex)函数会检查该文件属于哪个分区，以及该分区是否具
备指向缓存管理器分区的有效链接。如果不存在缓存管理器分区，系统就会通过CcCreatePartition例程创建并初始化一个新分区。这个新分区会
启动一个与缓存管理器有关的独立线程（预读取、延迟写入等），并根据属于特定分区的页面数量来计算脏页阈值的新值。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">文件对象通过其控制区包含
一个指向自己所属分区的链接，该控制区最初由文件系统驱动程序在创建和映射流控制块（Stream Control 
Block，SCB）时分配。目标文件的分区会被存储到一个文件对象扩展（其类型为MemoryPartitionInformation）中，内存管理
器在为SCB创建节对象时会检查该分区。一般来说，文件是一种共享的实体，因此文件系统驱动程序无法自动将文件关联到系统分区之外的其他分区。不过应用程
序可以通过NtSetInformationFileKernel 
API和新增的FileMemoryPartitionInformation类为文件设置不同的分区。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11_0003.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_191" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>3</b><b> </b><b>缓</b><b>存</b><b>虚</b><b>拟</b><b>内</b><b>存</b><b>管</b><b>理</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于Windows系统缓
存管理器会以虚拟的方式缓存数据，因此需要占用系统虚拟地址空间（而非物理内存）中的区域，并在一个名为虚拟地址控制块（Virtual Address
 Control 
Block，VACB）的结构中进行管理。VACB将这些地址空间区域定义为256KB大小、名为视图（view）的槽。当缓存管理器在系统启动过程中初
始化时，会分配一个初始VACB数组来描述缓存的内存。随着缓存需求的增加而需要使用更多内存，缓存管理器会按需分配更多的VACB数组。当其他需求为系
统造成压力时，它也可以收缩虚拟地址空间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在文件的首次I/O（读或
写）操作中，缓存管理器会将文件中按照256KB对齐区域所包含请求数据的256KB视图映射至系统缓存地址空间中闲置的槽内。举例来说，如果要将从偏移
量300000字节处开始的10字节读入文件，那么被映射的视图将从偏移量262144处开始（文件的第二个256KB对齐区域），并延伸到256KB。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存管理器会以循环的方式
将文件视图映射到缓存地址空间的槽中，第一个被请求的视图会被映射至第一个256KB槽，第二个视图会被映射至第二个256KB槽，以此类推，如图
11-3所示。在本例中，文件B首先被映射，文件A其次被映射，文件C第三个被映射，因此文件B被映射的块占据了缓存中的第一个槽。请注意，只有文件B的
第一个256KB部分被映射了，因为该文件中只有这部分被实际访问。由于文件C仅100KB（小于系统缓存中的一个视图），因此只会在缓存中占据一个
256KB槽。</span></p><div style="display: block;text-align:center;">
	<img width="509" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/0ea2b3ff7b7442c996d9f5b603f3356d.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-3 不同大小的文件被映射至系统缓存</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存管理器保证只要视图处
于活动状态，就会被映射（不过视图变为不活动状态后也可能维持映射）。然而，只有在对文件进行读取或写入操作时，视图才会被标记为活动。除非进程在调用
CreateFile时指定了用FILE_FLAG_RANDOM_ACCESS标记打开文件，否则缓存管理器在映射新视图时，如果检测到文件正在被连续
访问，则会解除对不活动视图的映射。未映射视图的页面会被发送至备用或已修改列表（取决于内容是否有更改）中，因为内存管理器为缓存管理器导出一个特殊接
口，缓存管理器可以指示将这些页面放置到这些列表的头部或尾部。对于使用FILE_FLAG_SEQUENTIAL_SCAN标记打开的文件，其对应的视
图页面会移动至列表头部，所有其他页面会移至尾部。这种设计方案是为了鼓励重复使用属于顺序读取文件的页面，尤其可防止大文件复制操作影响到太多物理内
存。该标记还会对解除映射的操作产生影响，提供此标记时，缓存管理器会主动解除视图映射。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果缓存管理器需要映射文
件的视图，但缓存中已经没有空闲的槽位，此时会取消最近最少使用的非活动视图并使用其释放出的槽位。如果没有可取消映射的视图，则将会返回I/O错误，这
表明没有足够的系统资源来执行该操作。不过考虑到视图只会在执行读取或写入操作时标记为活动，因此这种情况极为罕见，只有在同时访问成千上万个文件时才可
能出现这种情况。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11_0004.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_192" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>4</b><b> </b><b>缓</b><b>存</b><b>大</b><b>小</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">本节将介绍Windows计算虚拟和物理系统缓存大小的方法。与大部分和内存管理有关的计算工作类似，系统缓存的大小取决于很多因素。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_193" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>4</b><b>.</b><b>1</b><b> </b><b>缓</b><b>存</b><b>虚</b><b>拟</b><b>大</b><b>小</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在32位Windows系
统中，系统缓存的虚拟大小只受制于内核模式虚拟地址空间的数量以及可选配置的SystemCacheLimit注册表键（有关内核虚拟地址空间大小限制的
详情请参阅卷1第5章）。这意味着缓存大小受到2GB系统地址空间大小的限制，但实际的缓存大小往往要比这个限制小很多，主要是因为系统地址空间需要与其
他资源共享，包括系统分页表项（PTE）、非分页和分页内存池及页表。64位Windows中虚拟缓存大小的最大值为64TB，即便在这种情况下，大小限
制依然受制于系统地址空间的大小。在以后可支持56位寻址模式的系统中，该限制将被增大至32PB。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_194" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>4</b><b>.</b><b>2</b><b> </b><b>缓</b><b>存</b><b>工</b><b>作</b><b>集</b><b>大</b><b>小</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，与其他操作系
统相比，Windows中的缓存管理器在设计上有一个关键区别：物理内存的管理工作被完全委派给全局内存管理器。因此，负责处理工作集扩展和修剪以及管理
已修改和备用列表的现有代码也被用于控制系统缓存的大小，并动态地平衡进程和操作系统对物理内存的需求。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统缓存没有自己的工作
集，而是共享同一个工作集，其中包含缓存数据、分页池、可分页内核代码及可分页驱动程序代码。正如卷1第5章“系统工作集”一节所述，该工作集在内部被称
为系统缓存工作集，实际上系统缓存只是其中的一个组成部分。本书会把这个工作集叫作“系统工作集”。另外第5章还介绍了这样一种情况：如果
LargeSystemCache注册表值被设置为1，内存管理器的工作将更偏向于系统工作集，而非系统中运行的进程。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_195" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>4</b><b>.</b><b>3</b><b> </b><b>缓</b><b>存</b><b>物</b><b>理</b><b>大</b><b>小</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然系统工作集包含映射至缓存的虚拟地址空间中视图所对应物理内存的数量，但不一定能反映物理内存中缓存的文件数据总量。这两个值之间可能存在差异，因为可能有更多的文件数据位于内存管理器的备用或已修改页面列表中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">回顾第5章，在工作集修剪
或页面替换的过程中，根据页面包含的数据是否需要写入分页文件或其他文件，内存管理器可以将脏页从工作集移至备用列表或已修改的页面列表，随后这些页面才
可以重复使用。如果内存管理器未实现这些列表，当进程访问之前从工作集中移除的数据时，内存管理器就需要发出硬故障并从磁盘读取。相反，如果被访问的数据
存在于这些列表中，内存管理器只需要发出软故障即可将数据重新换页到进程工作集中。因此这些列表可以充当分页文件，或可执行映像文件以及数据文件中数据的
内存中缓存。进而系统中缓存的文件数据总量不仅包含系统工作集，同时也包含备用和已修改页面列表的总大小。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">下面通过一个例子来演示缓
存管理器将比系统工作集容量更大的文件数据缓存到物理内存中。假设有一个充当专用文件服务器的系统。客户端应用程序通过网络访问其中的文件数据，而服务
器，例如文件服务器驱动程序（%SystemRoot%\System32\Drivers\Srv2.sys，详见下文介绍）会使用缓存管理器接口代表
客户端读/写文件数据。如果客户端读取了数千个1MB大小的文件，当映射空间耗尽后，缓存管理器将不得不开始重复使用视图（无法扩大VACB映射区域）。
对于随后读取的每个文件，缓存管理器需要解除视图映射，然后为新文件重新映射。当缓存管理器解除视图映射时，内存管理器并不会丢弃缓存工作集中该视图对应
的文件数据，而是会将这些数据移动到备用列表。在没有其他物理内存需求的情况下，该备用列表可以消耗系统工作集之外的几乎所有物理内存。换句话说，服务器
上几乎所有的物理内存都可以用来保存文件数据缓存，如图11-4所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4fb261b8f06dc7a22137fa9ef3602c66.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-4 大部分物理内存被用于文件缓存的例子</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于缓存的文件数据总量包
括系统工作集、已修改页面列表以及备用列表（它们的大小均由内存管理器控制），从某种意义来说，内存管理器才是真正的缓存管理器。缓存管理器子系统只是为
通过内存管理器访问的文件数据提供一种方便的接口。在决定内存管理器需要将哪些数据保存到物理内存中，以及管理系统空间虚拟地址视图方面，缓存管理器的预
读取和后写入策略也起到了重要作用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了准确反映系统中缓存的
文件数据总量，任务管理器在性能视图中提供了一个名为“已缓存”的值，该值反映了系统工作集、备用列表以及已修改内存列表的总大小。不过Process 
Explorer会将这些值分别显示为Cache WS（系统缓存工作集）、Standby以及Modified。图11-5展示了Process 
Explorer的系统信息对话框，图中左下角的Physical Memory区域显示了Cache WS值，靠近中央位置的Paging Lists
 区域显示了备用和已修改列表的大小。请注意，任务管理器中的缓存值还包括Process Explorer 所显示的Paged WS、Kernel 
WS和Driver WS值。在选中这些值后，大部分System WS数值将来自Cache 
WS。虽然目前已经不是这种情况，但任务管理器中依然保留了这种不合时宜的显示方式。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/380d9ba1f8874cf06c115ddbfb26cf47.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-5 Process Explorer的系统信息对话框</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11_0005.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_196" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>5</b><b> </b><b>缓</b><b>存</b><b>数</b><b>据</b><b>结</b><b>构</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存管理器使用下列数据结构来跟踪缓存的文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·通过VACB描述系统缓存中每个256KB大小的槽。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·每个单独打开的缓存文件都有一个专用缓存映射，其中包含用于控制预读取（详见“智能预读取”一节）所需的信息。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·每个缓存文件都有一种共享的缓存映射结构，该结构指向系统缓存中包含文件已映射视图的槽。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">下文将介绍这些结构及其关系。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_197" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>5</b><b>.</b><b>1</b><b> </b><b>系</b><b>统</b><b>级</b><b>缓</b><b>存</b><b>数</b><b>据</b><b>结</b><b>构</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，缓存管理器会
使用一个名为虚拟地址控制块（VACB）的数据结构数组来跟踪系统缓存中的视图状态，该数组位于非分页池中。在32位系统中，每个VACB大小为32字
节，VACB数组大小为128KB，因此每个数组包含4096个VACB。在64位系统中，VACB大小为40字节，因此每个数组可包含3276个
VACB。缓存管理器会在系统初始化阶段分配初始VACB数组，并将其链接至名为CcVacbArrays的系统级VACB数组列表。如图11-6所示，
每个VACB代表系统缓存中一个大小为256KB的视图。VACB的数据结构如图11-7所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3f5f5098700fe87e59b706053671ebbe.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-6 系统VACB数组</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，每个VACB数组都
包含两类VACB：低优先级映射VACB和高优先级映射VACB。系统会为每个VACB数组分配64个初始高优先级VACB。高优先级VACB有一个特
点，即它们的视图都是从系统地址空间预分配的。当内存管理器映射某些数据时，如果无法为缓存管理器提供视图，并且如果映射请求被标记为高优先级，缓存管理
器将会使用高优先级VACB中一个预分配的视图。例如，可以使用这些高优先级VACB映射关键的文件系统元数据或从缓存中清除数据。不过在高优先级
VACB用完后，任何需要VACB视图的操作都会因为资源不足而失败。通常来说，映射优先级默认设置为低，但在使用PIN_HIGH_PRIORITY标
记固定（Pin，详见下文）缓存数据时，如果需要，文件系统可以请求转为使用高优先级VACB。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如图11-7所示，
VACB中的第一个字段是数据在系统缓存中的虚拟地址。第二个字段是一个指针，指向共享缓存映射结构，以此识别哪些文件被缓存。第三个字段标识了视图在文
件中起始位置的偏移量（粒度始终为256KB）。在这种粒度下，文件偏移量最底部的16位将始终为0，因此这些位会重新用于存储视图的引用数量，即有多少
活跃的读取和写入操作正在访问该视图。当缓存管理器释放VACB时，第四个字段可将VACB链接至最近最少使用（Least-Recently-
Used，LRU）的VACB列表，分配新的VACB时，缓存管理器会首先检查该列表。最后，第五个字段可将该VACB链接至VACB数组头，这个数组头
代表存储该VACB的数组。</span></p><div style="display: block;text-align:center;">
	<img width="456" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/1514ba150fa63b22d5f04776ac024c9e.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-7 VACB的数据结构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在对文件执行I/O操作的过程中，文件的VACB引用计数会增大，I/O操作结束后则会减小。当引用计数非零时，VACB就处于活动状态。对于文件系统元数据的访问来说，活动计数代表了视图中有多少个文件系统驱动程序的页面被锁定在内存中。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>V</b><b>A</b><b>C</b><b>B</b><b>和</b><b>V</b><b>A</b><b>C</b><b>B</b><b>统</b><b>计</b><b>信</b><b>息</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">缓存管理器内部跟踪调试时记录的各种值可以对开发者和支持工程师的崩溃转储调试提供很大帮助。所有这些调试变量均以CcDbg为前缀，因此可以使用x命令很轻松地看到完整列表：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">1: kd&gt; x nt!*ccdbg* </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fffff800`d052741c nt!CcDbgNumberOfFailedWorkQueueEntryAllocations = &lt;no type </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">information&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fffff800`d05276ec nt!CcDbgNumberOfNoopedReadAheads = &lt;no type information&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fffff800`d05276e8 nt!CcDbgLsnLargerThanHint = &lt;no type information&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fffff800`d05276e4 nt!CcDbgAdditionalPagesQueuedCount = &lt;no type information&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fffff800`d0543370 nt!CcDbgFoundAsyncReadThreadListEmpty = &lt;no type information&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fffff800`d054336c nt!CcDbgNumberOfCcUnmapInactiveViews = &lt;no type information&gt;</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fffff800`d05276e0 nt!CcDbgSkippedReductions = &lt;no type information&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fffff800`d0542e04 nt!CcDbgDisableDAX = &lt;no type information&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">... </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">由于32位和64位在实现方式上的差异，一些系统中的变量名称可能有所区别。在这个实验中，确切的变量名称并不重要，我们需要关注的是这些变量所解释的方法。借助这些变量以及对VACB数组头数据结构的理解，我们可以使用内核调试器列出所有VACB数组头。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">CcVacbArrays变量是一种指向VACB数组头的指针数组，解除对它的引用即可转储_VACB_ARRAY_HEADER的内容。首先我们需要取得最高数组索引：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">1: kd&gt; dd nt!CcVacbArraysHighestUsedIndex l1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fffff800`d0529c1c 00000000 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后即可解除对每个索引的引用，直到抵达最大索引。在本例所用的系统中（同时也是常规情况下），最高索引为0，这意味着只需要对一个头解除引用：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">1: kd&gt; ?? (*((nt!_VACB_ARRAY_HEADER***)@@(nt!CcVacbArrays)))[0] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">struct_VACB_ARRAY_HEADER * 0xffffc40d`221cb000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x000 VacbArrayIndex   : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x004 MappingCount     : 0x302 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x008 HighestMappedIndex : 0x301 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x00c Reserved         : 0 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如果有更多索引，则需要将命令末尾的数组索引改为更大数字，直到抵达已使用的最高索引。由输出结果可知，该系统只有一个VACB数组，其中包含770（0x302）个活动的VACB。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">最后，CcNumberOfFreeVacbs变量存储了可用VACB列表中的VACB数量。对实验系统中该变量进行转储得到的结果为2506（0x9ca）个：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">1: kd&gt; dd nt!CcNumberOfFreeVacbs l1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fffff800`d0527318 000009ca </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">这
符合我们的预期：在只使用了一个VACB数组的64位系统中，可用VACB（0x9ca，十进制为2506个）和活动VACB（0x302，十进制为
770个）的总数等于3276个，即一个VACB数组中的VACB总数量。如果系统的可用VACB耗尽，那么缓存管理器会分配一个新的VACB数组。由于
该实验存在易失性，所以实际做实验使用的系统可能会在这两个步骤（转储活动VACB及转储可用VACB）期间创建和释放额外的VACB。这可能导致实际看
到的可用和活动VACB总数不等于3276个。如果遇到这种情况，不妨快速重复几次该实验，不过可能永远也无法得到稳定的数值，尤其是在系统中正在进行大
量文件系统活动的情况下。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_198" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>5</b><b>.</b><b>2</b><b> </b><b>每</b><b>文</b><b>件</b><b>缓</b><b>存</b><b>数</b><b>据</b><b>结</b><b>构</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">每个打开的文件句柄都有一
个对应的文件对象（文件对象的详细信息请参阅卷1第6章）。如果文件被缓存，则文件对象会指向一个专用的缓存映射结构，其中包含最近两次读取的位置，这样
缓存管理器就可以执行智能预读取（详见下文“智能预读取”一节）。此外，同一个文件所有打开的实例对应的专用缓存映射都会被链接在一起。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每个缓存的文件（而非文件
对象）都有一个共享缓存映射结构，该结构描述了被缓存文件的状态，包括所属分区、大小，以及有效数据长度（有效数据长度字段的功能详见下文“回写缓存和惰
性写入”一节）。该共享缓存映射还会指向节对象（由内存管理器维护，描述了文件在虚拟内存中的映射）及与文件相关联的私有缓存映射列表和VACB，该
VACB描述了文件在系统缓存中当前映射的视图（有关节对象指针的详细信息请参阅卷1第5章）。不同文件的所有已打开的共享缓存映射会链接到一个全局链
表，该链表位于缓存管理器的分区数据结构中。每文件缓存数据结构之间的关系如图11-8所示。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当被要求读取特定文件时，缓存管理器必须确定下列两个问题的答案。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）文件是否位于缓存中？</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）如果是，哪个VACB（如果存在的话）引用了所请求的位置？</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">换句话说，缓存管理器必须明确处于所需地址的文件视图是否已被映射到系统缓存。如果任何VACB都不包含所需的文件偏移量，意味着所请求的数据目前并未映射至系统缓存。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a9ac6383785c93be687710c95c1d7db5.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-8 每文件缓存数据结构的关系</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了跟踪特定文件的哪些视
图已被映射至系统缓存，缓存管理器维护了一个指向VACB的指针数组，该数组名为VACB索引数组。VACB索引数组中的第一项指向了文件的前256KB
内容，第二项指向接下来的256KB内容，以此类推。图11-9展示了目前已映射至系统缓存的、来自三个文件的四个节。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/beddb01f9cd2120c843649229da92da8.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-9 VACB索引数组</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当进程访问特定位置的文件
时，缓存管理器会在该文件的VACB索引数组中寻找对应的项，以确定所请求的数据是否已映射至缓存。如果数组项非零（意味着包含指向VACB的指针），那
么文件中被引用的区域位于缓存中。而VACB指向了系统缓存中映射了文件视图的位置。如果该项为零，那么缓存管理器必须在系统缓存中找到一个空槽（以及可
用VACB）来映射所需的视图。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了优化大小，共享缓存映
射包含了一个只具备4个项的VACB索引数组。由于每个VACB可描述256KB的数据，因此这个小型、固定大小的索引数组中的项可以指向VACB数组中
的项，一起描述最大可达1MB的文件。如果文件大于1MB，则需要将文件大小除以256KB并在结果包含余数时向上取整，从非分页池中分配一个单独的
VACB索引数组。随后共享缓存映射即可指向这个单独的结构。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了进一步进行优化，如果文件大于32MB，从非分页池中分配的VACB索引数组还会变成一种稀疏的多级索引数组，其中每个索引数组包含128个项。我们可以通过下列公式计算一个文件需要的级别总数：</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';display: block;text-align:center;">(代表文件大小所需的位总数−18) /7</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上述计算结果需要向上取整
到下一个整数。公式中的“18”含义为，VACB代表256KB（2^18）数据。“7”的含义为，数组中的每一级都有128个项（2^7）。因此，最大
的文件也可以使用63位（缓存管理器可支持的最大值）来描述，并且只需要七个层级。该数组是稀疏的，因为缓存管理器只会为在最低级索引数组中具备活动视图
的内容创建分支。图11-10展示了一个足够大，总共需要三级的稀疏文件所对应的多级VACB数组范例。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/998d9a8c778994ad9107efd9d005d20e.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-10 多级VACB数组</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种方案是高效处理稀疏文
件所必需的，这类稀疏文件可能是非常大的文件，但实际上只包含少量有效数据，这种情况下可以只分配足够数量的数组来处理文件当前映射的视图。例如，一个
32GB的稀疏文件如果只有256KB被映射至缓存的虚拟地址空间，那么此时只需要一个分配三个索引数组的VACB数组，因为该数组只映射了一个分支，因
而32GB的文件只需要一个三级数组。如果缓存管理器不使用这种多级VACB索引数组优化措施，那么就需要分配一个包含128000项的VACB索引数
组，也就等于要分配1000个VACB索引数组。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11_0006.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_199" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>6</b><b> </b><b>文</b><b>件</b><b>系</b><b>统</b><b>接</b><b>口</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">当文件数据被首次执行缓存读取或写入操作时，需由文件系统驱动程序负责判断文件的部分内容是否已映射至系统缓存。如果还未映射，那么文件系统驱动程序必须调用CcInitializeCacheMap函数来设置上文介绍的每文件数据结构。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">一旦文件设置好缓存访问，文件系统驱动程序就将调用多种函数中的一种来访问文件数据。缓存的数据主要可通过三种方法访问，每种方法适合不同的情况。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·复制方法可在系统空间的缓存缓冲区和用户空间的进程缓冲区之间复制数据。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·映射和固定方法可使用虚拟地址直接向缓存缓冲区读/写数据。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·物理内存访问方法可使用物理地址直接向缓存缓冲区读/写数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">文件系统驱动程序必须提供
两个版本的文件读取操作：缓存的（Cached）和未缓存的（Noncached），这是为了防止内存管理器在处理页面错误时陷入无限循环。当内存管理器
调用文件系统（通过设备驱动程序）从文件获取数据以解决页面错误时，必须在IRP中设置“未缓存”和“分页IO”标记，以此指定这是一次分页读取操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图11-11展示了缓存管
理器、内存管理器以及文件系统驱动程序为响应用户的文件读取或写入I/O而进行的典型交互。文件系统会通过复制接口（CcCopyRead和
CcCopyWrite路径）来调用缓存管理器。例如，为了处理CcFastCopyRead或CcCopyRead读取，缓存管理器会在缓存中创建视
图，以此对文件中被读取的部分进行映射，并通过从视图中复制的方式将文件数据读入用户缓冲区。复制操作在访问视图中每个原本无效的页面时会产生页面错误，
作为回应，内存管理器会向文件系统驱动程序发起未缓存I/O，借此获取映射到出错页面的文件部分所对应的数据。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/78c287dcd18be69ad60f6fdec48ca9c3.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-11 缓存管理器和内存管理器之间的文件系统交互</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后的三节内容将介绍这些缓存机制，以及它们的用途和使用方式。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_200" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>6</b><b>.</b><b>1</b><b> </b><b>向</b><b>/</b><b>从</b><b>缓</b><b>存</b><b>复</b><b>制</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于系统缓存位于系统空间
内，它会被映射至每个进程的地址空间。不过与所有系统空间页面类似，缓存页面无法从用户模式访问，因为这可能造成潜在的安全隐患（例如某个进程可能无权读
取数据目前被包含在系统缓存中某些部分内的文件）。因此，用户应用程序对缓存文件的读/写访问必须由内核模式例程提供服务，由这样的例程在位于系统空间的
缓冲区和应用程序位于进程地址空间的缓冲区之间复制数据。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_201" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>6</b><b>.</b><b>2</b><b> </b><b>通</b><b>过</b><b>映</b><b>射</b><b>和</b><b>固</b><b>定</b><b>接</b><b>口</b><b>进</b><b>行</b><b>缓</b><b>存</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如用户应用程序需要读/
写磁盘上的文件数据一样，文件系统驱动程序也需要读/写描述文件本身的数据（元数据或卷结构数据）。然而，由于文件系统驱动程序运行在内核模式中，如果缓
存管理器收到正确的通知，它们将可以直接修改系统缓存中的数据。为了允许这种优化，缓存管理器提供了一些函数，帮助文件系统驱动程序在虚拟内存中找到文件
系统元数据的位置，因而可以在无需中间缓冲区的情况下直接修改这些数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果文件系统驱动程序需要读取缓存中的文件系统元数据，它会调用缓存管理器的映射接口，以此获得所需数据的虚拟地址。缓存管理器会解除所请求的全部页面，将其带入内存，随后将控制返回给文件系统驱动程序。这样文件系统驱动程序就可以直接访问数据了。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果文件系统驱动程序需要
修改缓存页面，则会调用缓存管理器的固定（pinning）服务，借此让页面在虚拟内存中保持活动状态，使其无法被回收。但实际上这些页面并未锁定到内存
中（例如设备驱动程序可能会锁定这些页面以便进行直接内存访问传输）。大多时候，文件系统驱动程序会将自己的元数据流标记为不可写入，借此告诉内存管理器
的已映射页面写入器（详见卷1第5章）不要将这些页面写入磁盘，除非被明确告知需要这样做。当文件系统驱动程序取消固定（释放）页面后，缓存管理器也将释
放自己的资源，以便通过延迟刷新的方式将改动写入磁盘，并释放元数据之前占用的缓存视图。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">映射和固定接口解决了文件
系统实现过程中的一个棘手问题：缓冲区管理。在无法直接操作已缓存元数据的情况下，更新卷结构时，文件系统必须预测自己需要的缓冲区的最大数量。通过允许
文件系统直接在缓存中访问并更新自己的元数据，缓存管理器将不再需要缓冲区，只需直接在内存管理器提供的虚拟内存中更新卷结构即可。此时，可用内存量将是
文件系统唯一可能受到的限制。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_202" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>6</b><b>.</b><b>3</b><b> </b><b>通</b><b>过</b><b>直</b><b>接</b><b>内</b><b>存</b><b>访</b><b>问</b><b>接</b><b>口</b><b>进</b><b>行</b><b>缓</b><b>存</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了用于直接在缓存中访问
元数据的映射和固定接口，缓存管理器还为缓存的数据提供了第三个接口：直接内存访问（Direct Memory 
Access，DMA）。DMA功能可用于在不使用中间缓冲区的情况下向缓存的页面读/写数据，例如，网络文件系统通过网络进行的文件传输工作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">DMA接口可以向文件系统
返回已缓存用户数据的物理地址（而不像映射和固定接口那样返回虚拟地址），随后即可使用这种物理地址直接从物理内存向网络设备传输数据。尽管少量数据（1
～2KB）可以使用基于缓冲区的常规复制接口，但对于大型文件的传输，DMA接口可大幅改善网络服务器处理远程系统文件请求时的性能。为了描述对物理内存
的这种引用，需要使用一种内存描述符列表（MDL，详见卷1第5章）。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11_0007.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_203" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>7</b><b> </b><b>快</b><b>速</b><b>I</b><b>/</b><b>O</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在可能的情况下，缓存文件
的读/写是由一种名为快速I/O（Fast 
I/O）的高速机制处理的。快速I/O是一种无须生成IRP，直接对缓存文件进行读/写的方式。借助快速I/O，I/O管理器可以调用文件系统驱动程序的
快速I/O例程，以查看是否无须生成IRP，直接通过缓存管理器满足I/O需求。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于缓存管理器在架构上位于虚拟内存子系统之上，文件系统驱动程序可以使用缓存管理器访问文件数据，为此只需要对映射至被引用实际文件的页面进行复制即可，无须因为生成IRP而产生不必要的开销。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">快速I/O并不能总是实
现。例如，对文件的首次读/写需要设置文件以便进行缓存（将文件映射至缓存，并设置缓存数据结构，详见“缓存数据结构”一节）。此外，如果调用方指定了异
步读取或写入，此时也将不使用快速I/O，因为调用方可能会在满足从/向系统缓存复制数据所需的分页I/O操作中停滞，因而无法真正提供所需的异步I/O
操作。但是，即便在同步I/O操作中，文件系统驱动程序可能也会确定自己无法使用快速I/O机制处理I/O操作，例如，目标文件可能有锁定的字节范围（可
能因为调用了Windows的LockFile和UnlockFile函数）。因为缓存管理器并不知道哪个文件的哪些部分被锁定，文件系统驱动程序必须检
查读/写操作的有效性，这就会产生IRP。快速I/O的决策树如图11-12所示。</span></p><div style="display: block;text-align:center;">
	<img width="871" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4a45d076cb2f72e3fad136ba1ffacbb9.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-12 快速I/O的决策树</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通过快速I/O提供服务的读/写操作涉及下列步骤。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）线程执行了读取或写入操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）如果文件被缓存并且I/O是同步的，操作请求会被传递给文件系统驱动程序堆栈的快速I/O入口点。如果文件未被缓存，文件系统驱动程序会设置文件以便将其缓存，这样下一次就可以使用快速I/O满足读/写请求。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）如果文件系统驱动程序的快速I/O例程判断快速I/O可行，那么它会调用缓存管理器的读取或写入例程，借此直接访问缓存中的文件数据（如果快速I/O不可行，文件系统驱动程序会返回到I/O系统，随后为该I/O生成一个IRP，并最终调用文件系统的常规读取例程）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）缓存管理器将收到的文件偏移量转换为缓存中的虚拟地址。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">5）对于读取操作，缓存管理器会将数据从缓存复制到请求进程的缓冲区；对于写入操作，则会将数据从缓冲区复制到缓存。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">6）随后将进行下列一种操作。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·对于读取操作，如果打开文件时未指定FILE_FLAG_RANDOM_ACCESS，则调用方的专用缓存图中的预读取信息会被更新。如果文件未指定FO_RANDOM_ACCESS标记，则预读取操作可能会被放入队列。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·对于写入操作，缓存中任何已修改页面均会被设置“脏”位，这样延迟写入器就会知道要将其刷新到磁盘。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·对于直接写入（write-through）的文件，任何改动都会被刷新到磁盘。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11_0008.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_204" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>8</b><b> </b><b>预</b><b>读</b><b>取</b><b>和</b><b>延</b><b>后</b><b>写</b><b>入</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">本节将介绍由缓存管理器代
表文件系统驱动程序实现文件数据读取和写入的方式。请注意，只有在文件未使用FILE_FLAG_NO_BUFFERING标记打开的情况下，缓存管理器
才会参与到文件I/O操作中，并使用Windows的I/O函数（如ReadFile和WriteFile函数）进行读/写。映射的文件或设置有
FILE_FLAG_NO_BUFFERING标记的文件不经过缓存管理器。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
当应用程序使用FILE_FLAG_NO_BUFFERING标记打开一个文件时，其文件I/O必须从与设备对齐的偏移量处开始，大小必须为对齐大小的倍
数，输入和输出缓冲区也必须是与设备对齐的虚拟地址。对于文件系统，这通常与扇区大小（通常NTFS为4096字节，CDFS为2048字节）一致。除了
改善缓存性能，缓存管理器提供的另一个好处是可以执行中间缓冲，借此实现以任意方式对齐的，或者任意大小的I/O。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_205" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>8</b><b>.</b><b>1</b><b> </b><b>智</b><b>能</b><b>预</b><b>读</b><b>取</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存管理器可以利用空间定
位的原理执行智能预读取，借此根据目前读取的数据来预测调用方的进程接下来最有可能读取哪些数据。由于系统缓存基于虚拟地址，而对特定文件来说虚拟地址是
连续的，因此，实际上在物理内存中是否连续并不重要。逻辑块缓存的文件预读取更为复杂，需要文件系统驱动程序与块缓存之间的紧密配合，因为该缓存系统基于
磁盘上被访问数据的相对位置，当然，文件并不一定会以连续的方式存储在磁盘上。我们可以使用Cache: Read 
Aheads/sec性能计数器或CcReadAheadIos系统变量查看预读取活动。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">读取一个正在按顺序访问文
件的下一个块，这种做法可以明显提高性能，但不足之处在于需要寻找头部（head 
seek）。为了将这种预读取带来的好处拓展至连续数据访问的情况（包括向前和向后的文件访问），缓存管理器会使用映射缓存映射，为被访问的文件句柄维持
一个包含最近两次读取请求的历史记录，这种方法也称“带历史记录的异步预读取”。如果能从调用方的明显随机读取操作中确定某种模式，缓存管理器就会做出相
应推断。举例来说，如果调用方读取页面4000后又读取了页面3000，缓存管理器就会假设调用方接下来会读取页面2000并进行预读取。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 虽然调用方必须至少发出三个读取操作才能建立可预测的序列，但私有缓存映射中只存储最近的两个操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了使预读取变得更加高
效，Win32的CreateFile函数还提供了一个指示前向顺序文件访问的标记：FILE_FLAG_SEQUENTIAL_SCAN。如果设置了该
标记，缓存管理器将不会为调用方保留预测所需的读取历史，而是会执行顺序性的预读取。不过随着文件被读入缓存的工作集，缓存管理器会取消对文件中不再活跃
的视图的映射，如果这些视图未被修改，则会指示内存管理器将属于未映射视图的页面放在备用列表的前端，以便能快速重用。此外还会预读取两倍的数据（例如读
取2MB，而非1MB）。当调用方继续读取时，缓存管理器还会预读取额外的数据块，始终比调用方领先一个读取（按照当前读取的数据大小进行预读取）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存管理器的预读取是一种
异步操作，因为这是通过独立于调用方线程的另一个线程来执行的，并且会与调用方同时进行。调用检索缓存的数据时，缓存管理器首先会访问被请求的虚拟页，以
满足请求，随后将一个额外的I/O请求放入队列，借此为系统工作线程检索更多的数据。随后会在后台执行该工作线程，读取额外数据并等待调用方的下一个读取
请求。当程序继续执行时，预读取的页面进入内存，这样，当调用方请求时，相关数据就已经位于内存中了。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于读取模式不可预测的应
用程序，可在调用CreateFile函数时指定FILE_FLAG_RANDOM_ACCESS标记。该标记会指示缓存管理器不要试图预测应用程序接下
来读取什么，进而可以禁用预读取。该标记还可以阻止缓存管理器在文件被访问时积极地解除文件视图映射，进而在应用程序重新访问文件中的部分内容时，最大限
度地减少文件的映射/取消映射活动。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_206" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>8</b><b>.</b><b>2</b><b> </b><b>预</b><b>读</b><b>取</b><b>的</b><b>增</b><b>强</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows 8.1对缓存管理器的预读取功能进行了一些增强。文件系统驱动程序和网络重定向器可以通过CcSetReadAheadGranularityEx API函数确定智能预读取的大小和增长情况。缓存管理器客户端可以决定：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>预</b><b>读</b><b>取</b><b>粒</b><b>度</b></span>。设置预读取单位大小的最小值以及下一次预读取结束时的文件偏移量。缓存管理器设置的默认粒度为4KB（内存页的大小），但每个文件系统可以通过不同的方式设置该值（例如NTFS可设置为64KB）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图11-13展示了一个
200KB文件的预读取范例，缓存粒度设置为64KB。如果用户请求在偏移量0x10800处进行1KB非对齐读取，并且已检测到顺序读取，智能预读取将
发出一个I/O，该I/O涵盖了从偏移量0x10000到0x20000范围内共64KB的数据。如果已经产生超过两次的顺序读取，缓存管理器就会发起一
个从偏移量0x20000到0x30000（总共192KB）的补充读取。</span></p><div style="display: block;text-align:center;">
	<img width="857" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e3425b31f8221f7e30c1f5c52eef0afa.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-13 粒度设置为64KB时一个200KB文件的预读取</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>管</b><b>道</b><b>大</b><b>小</b></span>。对于某些远程文件系统驱动程序，将大型预读取I/O拆分为多个小块可能是更合理的做法，这样，缓存管理器工作线程就可以并行发出多个请求。网络文件系统通过这种技术可以实现更高的吞吐量。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>预</b><b>读</b><b>取</b><b>激</b><b>进</b><b>度</b></span>。
文件系统驱动程序可以指定缓存管理器在检测到第三次连续读取后，要将预读取大小增大多少百分比。例如，假设应用程序使用1MB的I/O大小读取一个大文
件。第十次读取后，应用程序已经读取了10MB（缓存管理器可能已经预取了其中的一些数据）。此时，智能预读取可以决定预读取I/O大小的增长幅度。如果
文件系统指定了60%的增长率，那么将使用下列公式：</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">(连续读取次数×最后一次读取的大小) × (增长百分率 /100)</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">因此，这意味着下一次预读取大小为6MB（不再是2MB，假设粒度为64KB且I/O大小为1MB）。如果任何缓存管理器客户端未进行修改，那么默认增长百分率是50%。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_207" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>8</b><b>.</b><b>3</b><b> </b><b>回</b><b>写</b><b>缓</b><b>存</b><b>和</b><b>惰</b><b>性</b><b>写</b><b>入</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存管理器通过惰性（延迟）写入实现了一种回写缓存。这意味着写入文件的数据首先会被存储在内存中的缓存页面内，然后才会写入磁盘。因此，写操作允许在短时间内进行积累，随后一次性刷新到磁盘，从而减少磁盘I/O的操作总量。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存管理器必须明确调用内
存管理器来刷新缓存页面，因为如果不这样做，内存管理器将只在对物理内存的需求超出供应量的情况下才会将内存中的内容写入磁盘。这对易失性数据来说是合适
的，然而，缓存的文件数据往往代表非易失性的磁盘数据。如果一个进程修改了缓存的数据，用户当然希望这些内容能尽快反映到磁盘中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，缓存管理器有能力否
决内存管理器的映射写入器线程。由于已修改列表（详见卷1第5章）不是按照逻辑块地址（LBA）顺序排序的，所以缓存管理器会试图将页面聚集在一起，以便
向磁盘发出更大的顺序I/O，但该操作并不总能成功，实际上会导致重复寻找。为了消除这种影响，缓存管理器可以积极地否决映射写入器线程，并以虚拟字节偏
移量（VBO）顺序进行写出，而这更贴近于磁盘上的LBA顺序。由于缓存管理器负责这些写入操作，因此，它也可以应用自己的调度和流量调节算法，以便尽可
能地使用预读取而非后写入，从而降低对系统的影响。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">多长时间刷新一次缓存，这
是一个重要的决策。如果缓存被刷新得太频繁，系统的性能就会因为不必要的I/O而下降。如果缓存刷新频率太低，那么当系统出现故障时，用户可能面临丢失已
修改文件数据的风险（这种丢失对用户来说非常难以接受，因为用户已经要求应用程序保存文件数据的改动了），并且可能面临物理内存不足的情况（因为大量已修
改页面会占用物理内存）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了平衡这些问题，缓存管理器的惰性写入器可以扫描系统工作线程所执行的函数，该扫描操作每秒钟会进行一次。惰性写入器的扫描具有不同的作用，如下。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·检查（属于当前分区的）平均可用页和脏页的数量，并酌情更新脏页阈值的上限和下限。阈值本身也会被更新，主要是基于上一个周期所写入的脏页的总数进行更新（详见下一段）。如果没有需要写入的脏页，则惰性写入器将会休眠。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
通过CcCalculatePagesToWrite内部例程计算写入磁盘的脏页的数量。如果脏页的数量超过256个（1MB数据），则缓存管理器会将总
脏页数的1/8放入队列等待刷新到磁盘。如果脏页的产生速率大于惰性写入器确定需要写入的速率，则惰性写入器将会计算并写入额外数量的脏页，以匹配脏页的
产生速率。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
在每个共享缓存映射（存储在属于当前分区的链表中）之间进行循环，并使用内部CcShouldLazyWriteCacheMap例程确定共享缓存映射描
述的当前文件是否需要刷新到磁盘。文件不应刷新到磁盘的原因有很多，例如I/O可能已经被另一个线程初始化，文件可能是一个临时文件，或更简单的情况：缓
存映射中可能不包含脏页。当该例程确定文件应当刷新时，延迟写入器会扫描检查是否有足够的可用页面以供写入，如果有，则向缓存管理器系统工作线程发出一个
工作项。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
惰性写入器扫描在确定被某个共享缓存映射，并且需要写入的脏页数量时会考虑一些例外情况（并不总是写入文件的所有脏页）：如果目标文件是元数据流并且包含
超过256KB的脏页，则缓存管理器将只写入总页面的1/8。如果脏页的总数超过延迟写入器扫描可以刷新的页面总数，也会采取一些额外的操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这些I/O操作实际是由来自系统级的关键工作线程池的延迟写入器系统工作线程执行的。惰性写入器可以得知内存管理器的映射页面写入器何时准备好执行刷新。在这种情况下，它会将自己的回写操作延迟到同一个数据流中，以避免向同一个文件同时进行两次刷新操作。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 缓存管理器为文件系统驱动程序提供了一种方法，借此可跟踪什么时候有多少数据被写入文件。当惰性写入器将脏页刷新到磁盘时，缓存管理器会通知文件系统，指示文件系统更新该文件有效数据长度的视图（缓存管理器和文件系统分别在内存中跟踪文件的有效数据长度）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>缓</b><b>存</b><b>管</b><b>理</b><b>器</b><b>的</b><b>工</b><b>作</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在这个实验中，我们将使用Process Monitor查看文件系统底层活动，包括使用Windows资源管理器将一个大文件（本例中使用了一个DVD镜像）从一个目录复制到另一个目录时的缓存管理器预读取和后写入操作。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">首
先配置Process 
Monitor过滤器以包含源和目标文件路径、Explorer.exe和System进程，以及ReadFile和WriteFile操作。本例要将
C:\Users\Andrea\Documents\Windows_10_RS3.iso文件复制到C:
\ISOs\Windows_10_RS3.iso，因此，可按照下图所示配置过滤器。</span></p><div style="display: block;text-align:center;">
	<img width="745" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/9c4e461c1945ba57b81ec4ae5e078a1b.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">复制文件后，应该可以看到类似下图所示的Process Monitor跟踪结果。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/29d9b1e7b066bd9c2856bfe897c51d49.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">前几项对应了复制引擎执行的初始I/O操作以及缓存管理器执行的第一个操作。我们应该可以看到以下这几个情况。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·第一项代表Explore执行的初始1MB已缓存读取。该读取的大小取决于根据文件大小使用一个内部矩阵计算而来的结果，实际大小可能介于128KB到1MB之间。因为该文件很大，因此复制引擎选择了1MB。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
上述1MB读取之后是另一个1MB的未缓存读取。未缓存读取通常代表着由于页面错误或缓存管理器访问而产生的活动。为了仔细观察这些事件的堆栈跟踪记录，
我们可以双击任一项并打开Stack选项卡，随后可以发现，确实是由NTFS驱动程序的读取例程调用了缓存管理器的CcCopyRead例程，进而导致内
存管理器通过页面错误将源数据复制到物理内存。</span></p><div style="display: block;text-align:center;">
	<img width="607" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/bfe9f9adaf400ca7098f8dd10184b77d.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
这个1MB的页面错误I/O之后，缓存管理器的预读取机制开始读取文件，其中也包括System进程随后在1MB偏移量处进行的未缓存1MB读取。考虑到
文件大小和Explorer的读取I/O大小，缓存管理器选择1MB作为最佳预读取大小。下图展示了一个预读取操作的堆栈跟踪结果，从中可以确认缓存管理
器的一个工作线程正在执行预读取。</span></p><div style="display: block;text-align:center;">
	<img width="607" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/df09512bc3da6a1ecc9b8843816c5974.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后，Explorer的1MB读取并没有产生页面错误，因为预读取线程始终领先于Explorer，通过1MB的未缓存读取操作预先获取了文件数据。然而每隔一段时间，预读取线程将无法及时获得足够的数据，此时汇总后的页面会发生页面错误，进而出现同步分页I/O。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/332df0299f7136544b6800fe4c1463fd.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">查看这些项的堆栈跟踪会发现，此时调用的并非MmPrefetchForCacheManager，而是MmAccessFault/MiIssueHardFault例程。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">一旦开始读取，Explorer就会开始向目标文件写入。这些写入操作均为连续的1MB缓存写入。在读取大约124MB数据后，System进程进行了第一次WriteFile操作，如下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e78d775f02640124411b841a306964f9.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">这
个写入操作的堆栈跟踪结果如下图所示。从图中可以发现，该写入操作实际是由内存管理器的映射页面写入器线程负责的。这是因为在最初几MB的数据中，缓存管
理器还没有开始执行后写入操作，因此，内存管理器的映射页面写入器开始刷新已修改的目标文件数据（有关映射页面写入器的详情请参阅第10章）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">为了更清楚地了解缓存管理器的操作，可以将Explorer从Process Monitor的过滤器中删除，这样即可只显示System进程的操作，如下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/f1173e9a6f11640fdc8fe2a6c2704168.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">通
过如图所示的内容，可以更清晰地看到缓存管理器的1MB后写入操作（客户端版本Windows的最大写入大小为1MB，服务器版本为32MB，该实验在客
户端版本中执行）。下图展示了其中一个后写入操作的堆栈跟踪结果，从中可以确认后写入操作是由缓存管理器工作线程实现的。</span></p><div style="display: block;text-align:center;">
	<img width="605" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/15a241f69e1f404a8880749eb81cd5ad.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">作为一个额外的实验，大家也可以尝试着通过远程复制（从一个Windows系统复制到另一个）重复该实验，并且可以尝试复制不同大小的文件，这样就会发现接收端和发送端的复制引擎和缓存管理器产生的不同行为。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_208" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>8</b><b>.</b><b>4</b><b> </b><b>为</b><b>某</b><b>个</b><b>文</b><b>件</b><b>禁</b><b>用</b><b>惰</b><b>性</b><b>写</b><b>入</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果在调用Windows
的CreateFile函数时通过指定FILE_ATTRIBUTE_TEMPORARY标记创建了一个临时文件，那么惰性写入器就不会将脏页写入磁盘，
除非物理内存严重不足或文件明确要求被刷新。惰性写入器的这一特性改善了系统性能：惰性写入器不会将最终可能被丢弃的数据立即写入磁盘。应用程序在关闭时
通常都会删除自己的临时文件。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_209" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>8</b><b>.</b><b>5</b><b> </b><b>强</b><b>制</b><b>缓</b><b>存</b><b>直</b><b>接</b><b>写</b><b>入</b><b>磁</b><b>盘</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于某些应用程序无法容
忍“写入文件”和“在磁盘上看到更新后的文件”这两个环节之间存在哪怕很短暂的延迟，因此缓存管理器还支持基于每个文件对象的直写缓存，在这种机制下，文
件内容会在产生改动的同时立即写入磁盘。若要开启直写缓存，可在调用CreateFile函数时设置FILE_FLAG_WRITE_THROUGH标
记。或者当一个线程需要将数据写入磁盘时，使用Windows的CreateFile函数明确刷新打开的文件。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_210" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>8</b><b>.</b><b>6</b><b> </b><b>刷</b><b>新</b><b>映</b><b>射</b><b>的</b><b>文</b><b>件</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果惰性写入器必须从一个
同时也被映射到另一个进程地址空间的视图中将数据写入磁盘，那么情况将变得有些复杂，因为缓存管理器只知道自己修改过的页面（被另一个进程修改的页面只有
该进程才会知道，因为已修改页面在页表项中的“已修改”位保存在进程的私有页表中）。为了解决这个问题，当用户映射文件时，内存管理器会向缓存管理器发出
通知。当这样的文件在缓存中刷新时（例如可能调用了Windows的FlushFileBuffers函数），缓存管理器会将脏页写入缓存，随后检查该文
件是否也被其他进程映射。如果发现该文件也被其他进程映射，缓存管理器将刷新该节的完整视图，以便写出第二个进程可能修改过的页面。如果用户映射的文件视
图也在其他缓存中打开，在视图被撤销映射后，则已修改页面会被标记为脏页，延迟写入器线程随后会刷新该视图，这些脏页将被写入磁盘。该过程会按照下列顺序
依次进行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）用户撤销对视图的映射。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）进程刷新文件缓冲区。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果不使用这样的顺序，就无法预测要将哪些页面写入磁盘。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>观</b><b>察</b><b>缓</b><b>存</b><b>的</b><b>刷</b><b>新</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们可以在性能监视器中使用Data Maps/sec和Lazy Write 
Flushes/sec计数器查看缓存管理器将视图映射至系统缓存，并将页面刷新到磁盘的过程（这些计数器位于“Cache”组中）。随后将大文件从一个
位置复制到另一个位置。下图中较高的那条线对应了Data Maps/sec，另一条线对应了Lazy Write 
Flushes/sec。在文件复制过程中，Lazy Write Flushes/sec的数值明显增加。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/0a573706fde42cac101f0ec13a4f7223.jpg" alt="" title=""></div>
</div><div class="header2"><h3><span id="sigil_toc_id_211" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>8</b><b>.</b><b>7</b><b> </b><b>写</b><b>入</b><b>限</b><b>流</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">文件系统和缓存管理器必须
确定缓存的写入请求是否会影响系统性能，随后安排可能需要的延迟写入。首先，文件系统通过使用CcCanIWrite函数询问缓存管理器是否可以在不影响
性能的前提下写入一定数量的数据，并且必要时还可阻止该写入。对于异步I/O，文件系统会向缓存管理器设置一个回调，以便再次允许写入时调用
CcDeferWrite自动写入这些数据。否则写入操作将被阻止，并等待CcCanIWrite以便继续。一旦收到有即将到来的写入操作的通知，缓存管
理器就会确定缓存中有多少脏页，以及有多少可用的物理内存。如果可用物理页面很少，则缓存管理器会暂时阻止发送给文件系统线程的向缓存写入数据的请求。缓
存管理器的延迟写入器会将一些脏页刷新到磁盘，随后让被阻止的文件系统线程继续执行。这种写入限流（write 
throttling）机制可防止在文件系统或网络服务器发出较大的写入操作信息时，因为缺乏内存而导致系统性能下降。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 写入限流的影响是卷感知的。假设一个用户正在RAID-0的SSD阵列上复制一个大文件，同时将另一个文档复制到U盘，对U盘的写入并不会导致SSD上的数据传输受到限流。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">脏页阈值是指在进行限流的
缓存写入操作前，系统缓存允许包含的脏页数量。这个值是在缓存管理器分区初始化时计算而来的（系统分区在NT内核启动的阶段1期间创建并初始化），并且与
产品类型（客户端或服务器）相关。正如上文所述，这部分还需要计算另外两个值：脏页阈值上限及脏页阈值下限。取决于内存用量和脏页的处理速度，延迟写入器
扫描可以调用内部函数CcAdjustThrottle，在服务器系统中，这可以根据计算出的上限和下限值动态调整当前阈值。进行这种调整是为了当存在较
重写入负载时保留读取缓存，因为较重的写入负载不可避免会导致缓存不足进而被限流。表11-1列出了用于计算脏页阈值的算法。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表11-1 计算脏页阈值的算法</span></p><div style="display: block;text-align:center;">
	<img width="499" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ec852159ee65abb98e53a0f8e33a2447.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">写入限制对于通过慢速通信
线路上传输数据的网络重定向器也非常有用。例如，假设本地进程通过一个640kbit/s的慢速线路向远程文件系统写入大量数据。在缓存管理器的延迟写入
器刷新缓存前，这些数据并不会写入远程磁盘。如果重定向器积累了大量同时刷新到磁盘的脏页，那么在数据传输完成前，接收方可能会收到网络超时。通过使用
CcSetDirtyPageThreshold函数，缓存管理器可以允许网络重定向器针对自己（对于每个数据流）可容忍的脏缓存页面数量设置一个限制，
进而可以避免产生上述情况。通过限制脏页的数量，重定向器可以保证缓存刷新操作不会导致网络超时。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_212" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>8</b><b>.</b><b>8</b><b> </b><b>系</b><b>统</b><b>线</b><b>程</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，缓存管理器通过将请求提交到通用关键系统工作线程池的方式执行惰性写入和预读取I/O操作。然而，通过限制，使用的这些线程的数量始终少于关键系统工作线程的总数量。在客户端系统中，共有5个关键系统工作线程，服务器系统中则有10个。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在内部，缓存管理器会将自己的工作请求整理成四个列表（所有列表都由同一组执行体的工作线程提供服务）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·快速队列（express queue），用于预读取操作。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·常规队列（regular queue），用于（刷新脏数据所需的）惰性写入扫描以及后写入和延迟关闭。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·快速销毁队列（fast teardown queue），用于内存管理器等待缓存管理器所拥有的数据节被释放，以便可以通过映像节打开文件，这会导致CcWriteBehind刷新整个文件并销毁共享的缓存映射。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·时钟周期后队列（post tick queue），可供缓存管理器在惰性写入器线程的每个时钟周期之后（即每次操作结束后）注册一个内部通知。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了跟踪工作线程需要执行
的工作项，缓存管理器会创建自己内部每个处理器的备用列表（look-aside 
list），这是一种包含工作队列条目结构的固定长度的列表（每个处理器一个）（备用列表详见卷1第5章）。工作队列项的数量取决于系统类型：客户端系统
为128个，服务器系统为256个。为提高跨处理器的性能，缓存管理器还分配了一个全局备用列表，其大小与上文介绍的列表大小相同。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_213" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>8</b><b>.</b><b>9</b><b> </b><b>激</b><b>进</b><b>的</b><b>后</b><b>写</b><b>入</b><b>和</b><b>低</b><b>优</b><b>先</b><b>级</b><b>惰</b><b>性</b><b>写</b><b>入</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">为提高缓存管理器的性能并实现对低速磁盘设备（如eMMC磁盘）的兼容，Windows 8.1和后续版本中的缓存管理器延迟写入器已经有了大幅改进。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，惰性写入器扫
描可调整脏页阈值及其上限和下限。通过分析可用页面总数的历史记录，可以对这些限制进行多种调整。此外，还可检查惰性写入器在上一次执行周期（每秒一次）
内是否写入了预期数量的页面，进而对脏页的阈值进行其他调整。如果上一个周期内写入的页面总数小于预期数量（由
CcCalculatePagesToWrite例程计算而来），这意味着底层磁盘设备无法支持所产生的I/O吞吐量，因此脏页的阈值会被调低（意味着将
执行更多的I/O限流，一些缓存管理器客户端在调用CcCanIWrite 
API时将会等待）。对于相反的情况，即上一个周期没有留下剩余页面，那么延迟写入器扫描就可以放心增大阈值。在这两种情况下，阈值都要保持在上限和下限
界定的范围内。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这方面最大的改进要归功于
Extra Write 
Behind（额外后写入）工作线程。在服务器版本的系统中，这类线程的最大数量为9个（关键系统工作线程总数减1），但客户端版本的系统中只有1个。当
缓存管理器请求系统惰性写入器扫描时，系统会检查脏页是否导致了内存压力（使用一个简单的公式来验证脏页总数是否少于脏页阈值的1/4，并且少于可用页面
数的一半）。如果造成了内存压力，则系统级缓存管理器线程池例程（CcWorkerThread）会使用一种复杂的算法来确定是否可以增加另一个惰性写入
器线程，让多个线程并行将脏页写入磁盘。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了正确理解是否可以在不
影响系统性能的前提下增加另一个发出额外I/O的线程，缓存管理器会计算之前的延迟写入周期内的磁盘吞吐量，并跟踪其性能。如果当前周期的吞吐量等于或大
于之前的周期，这意味着磁盘可以支持整体I/O水平，此时添加另一个延迟写入器线程（这种情况下，该线程可称为Extra Write 
Behind线程）就是一种合理的做法。另外，如果当前吞吐量低于上一个周期，这意味着底层磁盘不足以支撑额外的并行写入，因此Extra Write 
Behind线程会被取消。该功能名为“激进的后写入”（Aggressive Write Behind）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在客户端版Windows
中，缓存管理器会启用一种旨在应对低速磁盘的优化措施。在请求了惰性写入器扫描，并且文件系统驱动程序写入缓存后，缓存管理器会通过一种算法确定是否要以
较低优先级来执行惰性写入器线程（有关线程优先级的详细信息请参阅卷1第4章）。缓存管理器会在满足下列条件时为惰性写入器应用默认的低优先级（不满足
时，缓存管理器将使用常规优先级）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·调用方未在等待当前惰性扫描完成。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·分区的脏页总量少于32MB。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果上述两个条件都满足，缓存管理器会将惰性写入器的工作项加入低优先级队列中。惰性写入器将由一个系统工作线程启动，该线程以优先级6（最低优先级）执行。此外，惰性写入器在向相应的文件系统驱动程序发出实际I/O之前，会将自己的I/O优先级设置为最低。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_214" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>8</b><b>.</b><b>1</b><b>0</b><b> </b><b>动</b><b>态</b><b>内</b><b>存</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，脏页阈值是根据物理内存的可用数量动态计算而来的。缓存管理器会使用该阈值决定何时对传入的写入操作进行限流，以及是否执行更激进的后写入操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在系统引入分区这个概念
前，该计算由CcInitializeCacheManager例程（通过检查MmNumberOfPhysicalPages全局值）进行，这个例程会
在内核初始化的阶段1期间执行。现在，则由缓存管理器分区的初始化函数根据属于相关联内存分区的可用物理内存页执行该计算（有关缓存管理器分区的详细信
息，请参阅上文“内存分区支持”一节）。但这还不够，因为Windows还支持物理内存的热添加，Hyper-V大量借助该功能为子虚拟机的动态内存提供
支持。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在内存管理器初始化的阶段
0期间，MiCreatePfnDatabase将计算PFN数据库的最大可能大小。在64位系统中，内存管理器会假定已安装物理内存可能的最大值等于所
有可寻址的虚拟内存范围（例如，非LA57系统为256TB）。系统会要求内存管理器为整个地址空间中每个虚拟页面保留存储PFN所需的虚拟地址空间数量
（这个假设中的PFN数据库大小约为64GB）。随后MiCreateSparsePfnDatabase会在Winload检测到的每个有效物理内存范
围之间循环，将有效PFN映射至数据库。PFN数据库会使用稀疏内存。当MiAddPhysicalMemory例程检测到新的物理内存后，会在PFN数
据库中分配新区域，借此创建新的PFN。有关动态内存的详细信息请参阅第9章，下文将进一步介绍其中的一些细节。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存管理器需要检测新的热添加或热移除内存，并要适应新的系统配置，否则可能出现多种问题，如下。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·热添加了新内存的情况下，缓存管理器可能认为系统内存较少，导致脏页的阈值低于本应使用的值。这会导致缓存管理器缓存的脏页的数量少于本应缓存的数量，因此会更快速地对写入进行限流。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果大量可用内存被锁定或不再可用，在系统中执行缓存的I/O可能影响其他应用程序的响应性（即进行了热移除后，这些应用程序基本上已经没有更多内存可用）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了正确处理这些情况，缓
存管理器并不会向内存管理器注册回调，而是在惰性写入器扫描（LWS）线程中实现了一种自适应修正机制。除了扫描共享缓存映射列表并确定要写入哪些脏页
外，LWS线程还可以根据前台速率、自己的写入速率以及可用内存数更改脏页的阈值。LWS维护了分区的物理页面和脏页的平均可用数历史记录。每隔一秒，
LWS线程会更新这些列表并计算汇总值。借助这个汇总值，LWS就可以响应内存大小的变化，削弱峰值并逐渐修改阈值的上限和下限。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_215" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>8</b><b>.</b><b>1</b><b>1</b><b> </b><b>缓</b><b>存</b><b>管</b><b>理</b><b>器</b><b>的</b><b>磁</b><b>盘</b><b>I</b><b>/</b><b>O</b><b>记</b><b>账</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在Windows 8.1之前，系统无法精确判断一个进程执行的I/O数量。背后的原因有很多，如下：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
惰性写入和预读取并不是在产生I/O的进程/线程上下文中进行的。缓存管理器会以惰性方式写出数据，并在不同于最初写入文件线程（通常为System上下
文）的另一个上下文中完成写操作（实际的I/O甚至可能在进程终止后才发生）。同理，缓存管理器可以选择预读取，进而从文件中获得比实际请求数量更多的数
据。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·异步I/O依然由缓存管理器管理，但在某些情况下，缓存管理器完全不会参与，例如未缓存的I/O。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一些特殊应用程序可以使用磁盘堆栈中的底层驱动程序发出底层磁盘I/O。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows在IRP的
尾部存储了一个指向发出I/O的线程的指针。该线程并不总是最初发起I/O请求的那个线程。因此很多时候，I/O会被错误地计入System进程。
Windows 8.1通过引入PsUpdateDiskCounters 
API解决了这个问题，缓存管理器和文件系统驱动程序可以借助该API进行紧密的配合。该函数中存储了读取和写入的字节总数，以及NT内核中用于描述进程
的核心EPROCESS数据结构中的I/O操作数量（详见卷1第3章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存管理器会在执行缓存的
读取和写入操作（通过公开的文件系统接口）以及发出预读取I/O（通过CcScheduleReadAheadEx导出的API）时，更新进程的磁盘计数
器（通过调用PsUpdateDiskCounters函数实现）。NTFS和ReFS文件系统驱动程序可在执行未缓存和分页I/O时调用
PsUpdateDiskCounters。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与
CcScheduleReadAheadEx类似，多个缓存管理器API通过扩展已经可以接收指向发出I/O，并且需要向其“计费”的线程指针（例如
CcCopyReadEx和CcCopyWriteEx就是很好的例子）。借此，更新后的文件系统驱动程序甚至可以控制异步I/O中具体要向哪个线程计
费。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了每进程计数器，缓存管
理器还维持了一种全局磁盘I/O计数器，可全局跟踪文件系统向存储堆栈发出的所有I/O（在通过文件系统驱动程序发出未缓存I/O或分页I/O后，该计数
器都会更新一次）。因此，从特定磁盘设备发出的总I/O（应用程序可通过IOCTL_DISK_PERFORMANCE控制代码获得该值）减去这个全局计
数器的值，即可得到与任何特定进程无关的I/O数量（如已修改页面写入器发出的分页I/O，或微型过滤器驱动程序内部执行的I/O）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种新增的每进程磁盘计数
器由NtQuerySystemInformation 
API使用的SystemProcessInformation信息类公开。任务管理器或Process 
Explorer等诊断工具也会采用这种方式精确查询与系统中当前运行的进程有关的I/O数据。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>统</b><b>计</b><b>磁</b><b>盘</b><b>I</b><b>/</b><b>O</b><b>数</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">借
助性能监视器提供的不同计数器，我们可以看到整体系统I/O的精确计数。请打开性能监视器，并添加FileSystem Bytes 
Read和FileSystem Bytes Written这两个计数器，它们都位于FileSystem Disk 
Activity组中。此外，在本实验中，我们还需要添加Process组中的每进程磁盘I/O计数器：IO Read Bytes/sec和IO 
Write Bytes/sec。添加最后这两个计数器时，请务必在所选对象的实例选项下选中Explorer进程。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/094a1507559c12bdcef9dc1a1fced8ff.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后通过复制一个大文件即可看到，属于Explorer进程的计数器会不断增大，直到与全局文件系统磁盘活动的数值相等。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11_0009.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_216" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b> </b><b>文</b><b>件</b><b>系</b><b>统</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">本节将概括介绍
Windows可支持的文件系统格式。随后会介绍文件系统驱动程序的类型及其基本操作，包括它们如何与其他系统组件（如内存管理器和缓存管理器）交互。接
下来将详细介绍NTFS和ReFS这两个最重要文件系统的功能和数据结构。我们会分析它们的内部架构，介绍这两个文件系统的磁盘布局以及高级功能，如压
缩、可恢复性、加密、分层支持、文件快照等。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_217" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>1</b><b> </b><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>文</b><b>件</b><b>系</b><b>统</b><b>格</b><b>式</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows可支持下列文件系统格式。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·CDFS。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·UDF。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·FAT12、FAT16和FAT32。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·exFAT。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·NTFS。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·ReFS。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上述每种格式适合不同的环境，下文将分别进行介绍。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_218" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>2</b><b> </b><b>C</b><b>D</b><b>F</b><b>S</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">CDFS
（%SystemRoot%\System32\Drivers\Cdfs.sys）即CD-ROM文件系统，这是一种只读文件系统驱动程序，可支持
ISO-9660格式的超集以及Joliet磁盘格式的超集。虽然ISO-9660格式相对简单并且有一些限制，例如ASCII大写字母名称，以及最大
32个字符的长度，但Joliet更灵活，可支持任意长度的Unicode名称。如果磁盘上同时存在这两种格式的结构（为了提供最大限度的兼容性），则
CDFS将使用Joliet格式。CDFS有以下几个限制。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·最大文件大小为4GB。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·最大可包含65535个目录。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">CDFS已经是一种老旧的格式，业界开始采用通用磁盘格式（Universal Disk Format，UDF）作为光存储介质的标准。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_219" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>3</b><b> </b><b>U</b><b>D</b><b>F</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows通用磁盘格
式（Universal Disk Format，UDF）文件系统的实现符合OSTA（Optical Storage Technology 
Association）制定的UDF规范（UDF是ISO-13346格式的一个子集，是对CD-R和DVD-R/RW等格式进行的扩展）。OSTA于
1995年定义了UDF，将其作为取代ISO-9660格式的磁光存储介质格式（主要适用于DVD-ROM）。UDF已包含在DVD规范中，比CDFS更
灵活。UDF文件系统格式有以下特点。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·目录和文件名可以有254个ASCII字符或127个Unicode字符的长度。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·文件可以是稀疏文件（稀疏文件的具体定义请参阅下文“压缩和稀疏文件”一节）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·文件大小可用64位来指定。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·支持访问控制列表（ACL）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·支持备用数据流。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">UDF驱动程序最高可支持
2.60版本的UDF。UDF格式最初在设计时主要针对可复写的介质。Windows 
UDF驱动程序（%SystemRoot%\System32\Drivers\Udfs.sys）在使用UDF 
2.50版时，可为蓝光、DVD-RAM、CD-R/RW和DVD+-R/RW驱动器提供读/写支持，使用UDF 
2.60版时可提供只读支持。不过Windows并未实现对某些UDF功能的支持，例如命名数据流和访问控制列表。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_220" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>4</b><b> </b><b>F</b><b>A</b><b>T</b><b>1</b><b>2</b><b>、</b><b>F</b><b>A</b><b>T</b><b>1</b><b>6</b><b>和</b><b>F</b><b>A</b><b>T</b><b>3</b><b>2</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows对FAT文件系统的支持主要是为了在多重启动系统中实现与其他操作系统的兼容性，并作为闪存驱动器或内存卡的格式。Windows FAT文件系统驱动程序实现于%SystemRoot%\System32\Drivers\Fastfat.sys。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">FAT格式名称中包含的数字代表特定格式在磁盘上识别簇所用的位数。FAT12的12位簇标识符限制了一个分区最多可存储2<span style="font-size:13px;font-family:'PingFang SC';"><sup>1</sup><sup>2</sup></span>（4096）个簇。Windows允许的簇的大小介于512字节到8KB之间，因此FAT12卷最大只能达到32MB。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 所有FAT文件系统类型都会保留一个卷的前2个簇和最后16个簇，因此举例来说，FAT12卷可用簇的总数会略小于4096。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">FAT16使用了16位簇标识符，可寻址2<span style="font-size:13px;font-family:'PingFang SC';"><sup>1</sup><sup>6</sup></span>（65536）
个簇。在Windows上，FAT16簇的大小介于512字节（扇区的大小）和64KB（在扇区大小为512字节的磁盘上）之间，因此FAT16卷的最大
大小为4GB。扇区大小为4096字节的磁盘可实现256KB的簇。Windows所用簇的大小取决于卷的大小。各种大小详见表11-2。如果使用
format命令或磁盘管理控制台将小于16MB的卷格式化为FAT，Windows将使用FAT12格式而非FAT16格式。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">表11-2 Windows中默认FAT16簇大小</span></p><div style="display: block;text-align:center;">
	<img width="303" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/cc5716e9ac06b42dac3009753a3dee47.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">一个FAT卷可以分为多个
区域，如图11-14所示。文件分配表（File Allocation 
Table，这也是FAT文件系统格式名称的来源）中对卷上的每个簇都有一个条目。由于文件分配表对成功解读卷的内容至关重要，所以FAT格式会为该表保
持两个副本。这样，即使文件系统驱动程序或一致性检查程序（例如Chkdsk）无法访问其中一个分配表（例如因为产生了坏扇区），它也可以读取另一个分配
表。</span></p><div style="display: block;text-align:center;">
	<img width="732" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/52b43491e56ddf2882bd726870573da8.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-14 FAT格式的组织方式</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">文件分配表中的项定义了文
件和目录的文件分配链（见图11-15），链中的链接可以看成指向文件数据中下一个簇的索引。文件目录项存储了文件的起始簇。文件分配链中的最后一项是保
留值，FAT16为0xFFFF，FAT12为0xFFF。未使用簇的FAT项的值为0。在图11-15中可以看到：文件1分配了簇2、3和4；碎片化的
文件2分配了簇5、6和8；文件3仅使用了簇7。从FAT卷中读取一个文件可能需要读取文件分配表中的大部分内容来遍历文件的分配链。</span></p><div style="display: block;text-align:center;">
	<img width="787" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/355ecdf5c6166ec11c05e566ca79f71c.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-15 FAT文件分配链范例</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">FAT12和FAT16卷
的根目录在卷的开始位置已经预分配了足够保存256个目录项的空间，这就对根目录下可存储的文件和目录数量设置了一个上限（FAT32根目录没有这种预分
配空间或大小限制）。FAT目录项的大小为32字节，其中存储了文件名、大小、起始簇、时间戳（最后访问时间、创建时间等）信息。如果文件名使用了
Unicode的编码方式或未遵守MS-DOS的8.3命名约定，则需要分配额外的目录项来存储长文件名。这些补充的目录项位于文件的主项之前。图
11-16展示了一个名为“The quick brown 
fox.”的文件的目录项范例。系统为这个文件名创建了一个符合8.3格式的表达方式“THEQUI~1.FOX”（也就是说，目录项中看不到“.”，因
为这个点位于八个字符之后），并额外使用两个目录项来存储Unicode的长文件名。图11-16中每一行都包含16字节。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/5d233863f75195420d52650eb8e9fe32.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-16 FAT目录项</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">FAT32使用32位簇标
识符，但保留了高4位，因此，实际效果上等于使用了28位簇标识符。由于FAT32的簇的大小最大可达64KB，理论上FAT32最大可以寻址16TB的
卷。虽然Windows可以使用更大的现有FAT32卷（在其他操作系统中创建），但Windows可以新建的FAT32卷最大只能达到32GB。
FAT32可支持更多数量的簇，因此能比FAT16更高效地管理磁盘空间，它可以处理高达512字节的簇的最大128GB的卷。表11-3列出了
FAT32卷的默认簇的大小。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了对簇的数量有更多限制
外，FAT32相较于FAT12和FAT16的其他优势包括：FAT32根目录并不存储在卷中预定义的位置上，根目录的大小无限制，并且为保证可靠性，
FAT32还会为启动扇区保存第二个副本。但FAT32也沿袭了与FAT16相同的限制，即最大文件大小为4GB，因为目录会将文件大小存储为一个32位
的值。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表11-3 FAT32卷的默认簇的大小</span></p><div style="display: block;text-align:center;">
	<img width="295" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ca9de63b1093fda649902868e9251183.jpg" alt="" title=""></div>
</div><div class="header2"><h3><span id="sigil_toc_id_221" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>5</b><b> </b><b>e</b><b>x</b><b>F</b><b>A</b><b>T</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">由微软设计的可扩展文件分
配表文件系统（Extended File Allocation Table file 
system，exFAT，也叫FAT64）是对传统FAT文件系统的改进，专为闪存设备设计。exFAT的主要目标是在不产生元数据结构开销和元数据日
志操作的情况下提供NTFS所具备的一些高级功能，因为元数据结构和相关日志操作会产生不适合大部分闪存媒体设备的写入模式。表11-4列出了exFAT
的默认簇大小。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">表11-4 exFAT卷使用512字节扇区时的默认簇大小</span></p><div style="display: block;text-align:center;">
	<img width="280" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/5d89c9e6623517301362fd40ea0035cb.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如FAT64这个名称所暗示的那样，文件大小限制已扩大至2<span style="font-size:13px;font-family:'PingFang SC';"><sup>6</sup><sup>4</sup></span>，
最大可支持16EB的文件。这一变化也与簇大小的增量相匹配，目前最大可支持32MB的簇，但最多可达2255个扇区。exFAT还增加了一个用于跟踪空
闲簇的位图，借此可改善分配和删除操作的性能。最后，exFAT目录中可以包含超过1000个文件。这些特性不仅可以提高可扩展性，也可以支持更大的磁
盘。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">另外，exFAT还实现了一些原本仅NTFS具备的功能，例如支持访问控制列表（ACL）和事务（也叫事务安全FAT，即TFAT）。不过这些功能仅包含在Windows Embedded CE所实现的exFAT中，Windows的exFAT中并不包含。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> ReadyBoost（详见卷1第5章）可配合格式化为exFAT的闪存设备使用，进而支持大小超过4GB的缓存文件。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_222" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>6</b><b> </b><b>N</b><b>T</b><b>F</b><b>S</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如本章开篇所述，NTFS是Windows的原生文件系统格式之一。NTFS使用64位簇编号。这使得NTFS可以寻址最多16百亿亿（10<span style="font-size:13px;font-family:'PingFang SC';"><sup>1</sup><sup>8</sup></span>）个簇。但是Windows将NTFS卷的大小限制在32位簇的可寻址范围内，也就是略低于8PB（使用2MB的簇）。表11-5列出了NTFS卷的默认簇大小（格式化NTFS卷时可更改这些设置）。每个NTFS卷最多可保存2<span style="font-size:13px;font-family:'PingFang SC';"><sup>3</sup><sup>2</sup></span>–1个文件。NTFS格式最大支持大小为16EB的文件，但具体实现中将最大文件的大小限制为16TB。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表11-5 NTFS卷的默认簇大小</span></p><div style="display: block;text-align:center;">
	<img width="294" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/fab0bafef30d01b888ab31e72a58f893.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS包含很多高级功
能，例如文件和目录安全性、备用数据流、磁盘配额、稀疏文件、文件压缩、符号（软）链接和硬链接、支持事务型语义、交接点以及加密。其重要功能之一是可恢
复性。如果系统意外停止，FAT卷的元数据可能处于不一致状态，导致大量文件和目录数据损坏。NTFS以事务的方式记录对元数据进行的改动，因此文件系统
结构可以修复到一致的状态，不会丢失文件或目录的结构信息（除非使用下文将要介绍的TxF，否则文件数据依然可能会丢失）。此外，Windows中的
NTFS驱动程序还实现了自愈机制，通过这种机制无须重启系统，在Windows运行过程中对文件系统磁盘结构的大部分损坏执行细微的修复。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 截至撰写这部分内容，磁盘设备的常见物理扇区大小为4KB。但这些磁盘设备，即便出于兼容性方面的考虑，存储堆栈暴露给文件系统驱动程序的逻辑扇区大小依然是512字节。NTFS驱动程序会通过计算确定正确的簇大小，该计算使用了逻辑扇区的大小，而非实际的物理大小。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">从Windows 
10开始，NTFS原生支持DAX卷（DAX卷详见下文“DAX卷”一节）。NTFS驱动程序还支持使用大页面对此类卷发起I/O操作。使用大页面映射
DAX卷中的文件，这是通过两种方式实现的：NTFS可以自动将文件与2MB的簇边界对齐，或可以使用2MB的簇大小对DAX卷进行格式化。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_223" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>7</b><b> </b><b>R</b><b>e</b><b>F</b><b>S</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">复原文件系统
（Resilient File 
System，ReFS）是Windows原生支持的另一种文件系统。该文件系统主要针对大型存储服务器设计，目的是克服NTFS的某些局限，例如缺乏联
机自愈能力、卷修复能力，以及文件快照功能。ReFS是一种“写新”（write-to-new）的文件系统，这意味着卷的元数据将总是通过向底层介质写
入新数据，并将旧的元数据标记为“已删除”的方式进行更新。ReFS文件系统的底层（可理解为磁盘上的数据结构）使用了一种名为Minstore的对象存
储库，借此可为调用方提供一个键-值表接口。Minstore类似于现代数据库引擎，具备可移植性，相比NTFS，可使用不同的数据结构和算法
（Minstore使用B+树）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ReFS的重要设计目标之一在于能够支持巨大的卷（可通过“存储空间”创建）。与NTFS类似，ReFS也使用64位簇编号，最大可寻址16百亿亿个簇。ReFS对可寻址的值没有大小限制，因此，理论上ReFS可管理最大1YB的卷（使用64KB大小的簇）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与NTFS不同的地方在
于，Minstore无须通过一个中心位置存储自己在卷上的元数据（不过对象表也可以看成一种中心机制），对可寻址的值也没有任何限制，因此并不需要为众
多不同大小的簇提供支持。ReFS只支持4KB和64KB大小的簇。截至撰写这部分内容，ReFS还不支持DAX卷。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">下文将详细介绍NTFS和ReFS的数据结构及其高级功能。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_224" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>8</b><b> </b><b>文</b><b>件</b><b>系</b><b>统</b><b>驱</b><b>动</b><b>程</b><b>序</b><b>架</b><b>构</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">文件系统驱动程序
（File System 
Driver，FSD）负责管理文件系统格式。虽然FSD运行在内核模式，但与标准的内核模式驱动程序相比，其还有很多不同之处。其中最重要的差异也许
是：它们必须在I/O管理器中注册为FSD，并且与内存管理器的交互更广泛。为增强性能，文件系统驱动程序通常还需要依赖缓存管理器提供的服务。因此，它
们使用了标准驱动程序所用的导出的Ntoskrnl.exe函数的超集。与标准内核模式驱动程序类似，我们必须使用Windows驱动开发包（WDK）来
构建文件系统驱动程序（有关WDK的详细信息请参阅卷1第1章，以及http://www.microsoft.com/whdc/devtools/
wdk）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows使用了以下两种类型的FSD。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·本地FSD，管理直接连接到计算机的卷。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·网络FSD，可供用户访问连接到远程计算机的数据卷。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_225" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>9</b><b> </b><b>本</b><b>地</b><b>F</b><b>S</b><b>D</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">本地FSD包括
Ntfs.sys、Refs.sys、Refsv1.sys、Fastfat.sys、Exfat.sys、Udfs.sys、Cdfs.sys以及
RAW 
FSD（集成在Ntoskrnl.exe中）。图11-17展示了本地FSD与I/O管理器和存储设备驱动程序交互过程的简化示意图。本地FSD负责向
I/O管理器注册。当应用程序或系统首次访问卷时，I/O管理器即可调用已注册的FSD执行卷识别。卷识别需要检查卷的启动扇区，通常为了检查一致性还会
检查文件系统元数据。如果已注册的所有文件系统都无法识别一个卷，系统会为该卷分配RAW文件系统驱动程序，随后向用户展示一个对话框，询问是否要格式化
该卷。如果用户选择不进行格式化，则RAW文件系统驱动程序将提供对该卷的访问，但仅限扇区层面的访问。换句话说，用户只能读取或写入完整的扇区。</span></p><div style="display: block;text-align:center;">
	<img width="495" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/6e25d948bf309767fbad3a1ea5df9b5e.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-17 本地FSD</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">文件系统识别的目的是让系
统对于有效但未识别的文件系统获得RAW之外的另一个额外选项。为实现这个目的，系统定义了一种固定的数据结构类型
（FILE_SYSTEM_RECOGNITION_STRUCTURE），该类型会被写入卷的第一个扇区。如果存在该数据结构，则将被操作系统识别，随
后通知用户该卷包含有效但未识别的文件系统。系统依然会为该卷加载RAW文件系统，但不会提示用户格式化该卷。用户应用程序或内核模式驱动程序可能会使用
新的文件系统I/O控制代码FSCTL_QUERY_FILE_SYSTEM_RECOGNITION来要求获得一份
FILE_SYSTEM_RECOGNITION_STRUCTURE的副本。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows可支持的每种文件系统格式的第一个扇区都会保留为该卷的启动扇区（boot sector）。启动扇区包含足够的信息，本地FSD可以借此将该扇区所在的卷识别为包含FSD可管理的格式，并借此定位其他必要的元数据，进而识别元数据在卷上的保存位置。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当本地FSD（见图
11-17）识别一个卷后，会创建一个设备对象来表示挂载的文件系统格式。I/O管理器会通过卷参数块（Volume Parameter 
Block，VPB）在卷的设备对象（由存储设备驱动程序创建）和FSD创建的设备对象之间建立连接。VPB的连接会导致I/O管理器将以该卷设备对象为
目标的I/O请求重定向至FSD设备对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为改善性能，本地FSD通
常会使用缓存管理器来缓存文件系统数据，包括元数据。FSD还会与内存管理器集成，以正确实现文件的映射。例如，每当应用程序试图截断文件时，FSD必须
查询内存管理器，以验证是否有进程映射了文件中截断点以外的部分（内存管理器详见卷1第5章）。Windows不允许通过截断或删除文件的方式来删除被应
用程序映射的文件数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">本地FSD还支持文件系统
的卸载操作，这样系统可以将FSD与卷对象之间的连接断开。当应用程序需要对卷在磁盘上的内容进行原始（RAW）访问时，或与卷相关联的介质被改变时，就
需要进行卸载。卸载之后，当应用程序首次访问该介质时，I/O管理器会重新为该介质进行卷的挂载操作。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_226" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>1</b><b>0</b><b> </b><b>远</b><b>程</b><b>F</b><b>S</b><b>D</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">每个远程FSD都包含两个
组件：一个客户端和一个服务器。客户端远程FSD可供应用程序访问远程文件和目录。客户端FSD组件可接收来自应用程序的I/O请求，将其转换为网络文件
系统协议命令（如SMB），随后这些命令被FSD通过网络发送给服务器端组件（也是一种远程FSD）。服务器端FSD监听来自网络连接的命令，并向命令所
要访问的文件或目录所在卷对应的本地FSD发出I/O请求，进而完成这些命令。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows包含一个客
户端远程FSD，名为LANMan Redirector（通常可简称为重定向器）；以及一个服务器端远程FSD，名为LANMan 
Server（%SystemRoot%\System32\Drivers\Srv2.sys）。图11-18展示了客户端通过重定向器和服务器FSD
从服务器上远程访问文件时这几方之间的关系。</span></p><div style="display: block;text-align:center;">
	<img width="866" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e3032b288bffa094183251177c5d5a21.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-18 CIFS文件共享</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows依赖通用
Internet文件系统（Common Internet File 
System，CIFS）协议来调整重定向器和服务器间所交换消息的格式。CIFS是微软服务器消息块（Server Message 
Block，SMB）协议的一个版本（有关SMB的详情请访问https://docs.microsoft.com/windows/win32/
fileio/microsoft-smb-protocol-and-cifs-protocol-overview）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与本地FSD类似，客户端
远程FSD通常使用缓存管理器服务对属于远程文件和目录的数据创建本地缓存文件，这种情况下，双方必须在客户端和服务器端之间实现一种分布式锁定机制。
SMB客户端远程FSD实现了一种名为Oplock（Opportunistic 
Locking，机会锁）的分布式缓存一致性协议，这样，当一个应用程序访问远程文件时，它就能和另一端计算机上运行的应用程序访问同一个文件时看到的数
据相同。第三方文件系统可以选择使用Oplock协议，或者也可能实现自己的协议。尽管服务器端远程FSD参与了跨客户端的缓存一致性的维护工作，但并不
缓存来自本地FSD的数据，因为本地FSD会自行缓存自己的数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最基本的问题在于，只要一
个资源可以被多个访问者同时共享访问，就必须提供一种序列化机制来对资源的写入操作进行仲裁，进而保证对任意一个特定时间，只有一个访问者可以执行写入访
问。如果缺乏这种机制，那么资源就可能会损坏。所有实现SMB协议的文件服务器均会以Oplock（机会锁）和Lease（租约）作为锁定机制。具体使用
哪种机制取决于服务器端和客户端的能力，其中Lease是首选机制。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Oplock 
该功能实现于文件系统运行时库（FsRtlXxx函数）中，可被任何文件系统驱动程序使用。远程文件服务器的客户端可以使用Oplock动态地确定为最大
限度地减少网络流量，该使用哪种客户端缓存策略。当应用程序试图打开文件时，文件系统驱动程序或重定向器会代表该应用程序对共享中包含的这个文件请求一个
Oplock。授予Oplock后，客户端即可缓存文件，而不需要将每次读/写操作通过网络发送给文件服务器。例如，客户端能够以独占访问的方式打开一个
文件，这样该客户端即可缓存对这个文件的所有读/写，并在文件关闭后将更新发送给文件服务器。相反，如果服务器未向客户端授予Oplock，就必须将所有
读/写发送到服务器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">一旦授予Oplock，客
户端就可开始缓存文件，并通过Oplock的类型确定可进行哪些类型的缓存。Oplock并不一定要一直保持到客户端完成对文件的所有操作，如果服务器收
到一个与现有已授予Oplock不兼容的操作，那么已授予的Oplock也可以随时打破。这意味着客户端必须能够快速对Oplock的打破做出响应并动态
更改自己的缓存策略。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在SMB 2.1之前，Oplock共分为以下四种类型。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·1<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>级</b><b>，</b><b>独</b><b>占</b><b>式</b><b>访</b><b>问</b></span>。这种锁可供客户端以独占访问方式打开文件。客户端可执行预读取缓冲和读取或写入缓存。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·2<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>级</b><b>，</b><b>共</b><b>享</b><b>式</b><b>访</b><b>问</b></span>。这种锁可以支持一个文件的多个并发读取者，但不支持写入者。客户端可执行预读取缓冲并对文件数据和属性进行读取缓存。对文件执行写入操作将导致锁的持有者收到“锁已打破”的通知。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>批</b><b>处</b><b>理</b><b>，</b><b>独</b><b>占</b><b>式</b><b>访</b><b>问</b></span>。顾名思义，这种锁是一种用于处理批处理（.bat）文件的锁，文件中每行内容的处理都需要打开并关闭一次。客户端也许保持服务器上的文件处于打开状态，但应用程序可以（也许临时性地）关闭该文件。这种锁支持读取、写入和句柄缓存。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>过</b><b>滤</b><b>器</b><b>，</b><b>独</b><b>占</b><b>式</b><b>访</b><b>问</b></span>。这种锁为应用程序和文件系统过滤器提供了一种机制，以便在其他客户端试图访问同一个文件时放弃自己的锁，但与2级锁的不同之处在于，打开的文件无法进行删除访问，其他客户端也不会收到共享违规的通知。这种锁支持读取和写入缓存。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">以最简单的方式来说，如果
多个客户端系统全都在缓存某一个服务器上的同一个共享文件，那么只要（来自任何客户端或服务器的）每个应用程序访问该文件时都只进行读取操作，那么这些读
取操作都将能被每个系统的本地缓存所满足。这大幅减少了网络流量，因为并不需要服务器将文件内容发送给每个系统。此时依然需要在客户端系统和服务器之间交
换锁信息，但这只需要很少的网络带宽。然而，如果哪怕只有一个客户端以读/写访问（或独占写入）的方式打开文件，那么任何一个客户端都无法使用自己的本地
缓存，对文件执行的所有I/O操作必须立即发送到服务器，哪怕该文件从未被写入（锁定模式取决于文件的打开方式，而非具体的I/O请求）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图11-19所示的这个例
子可以帮助大家了解Oplock操作。服务器自动为打开并访问文件的第一个客户端授予了1级Oplock。客户端上的重定向器将文件数据的读/写操作都缓
存在客户端计算机上的文件缓存中。如果第二个客户端打开了同一个文件，该客户端也请求了一个1级Oplock。然而，由于目前有两个客户端在访问同一个文
件，所以服务器必须采取相应措施，以便为这两个客户端展示文件数据的一致视图。如果像图11-19中演示的那样，第一个客户端写入了文件，那么服务器会撤
销它的Oplock，并且不再向任何客户端授予Oplock。当第一个客户端的Oplock被撤销或打破后，该客户端会把自己为该文件缓存的所有数据刷新
到服务器端。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a8b329d7f85e77412ef373d0039cad09.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-19 Oplock范例</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果第一个客户端未写入文
件，那么第一个客户端的Oplock就会被“降级”为2级Oplock，服务器为第二个客户端授予的也是这种锁。这样两个客户端就可以对读取操作进行缓
存，但如果任一方写入了文件，那么服务器将撤销双方的Oplock，随后将只能在非缓存的情况下执行操作。一旦Oplock被打破，那么将无法再次授予打
开该文件的同一个实例。然而，如果客户端关闭并重新打开同一个文件，服务器将重新评估需要向客户端授予哪种级别的锁，该评估工作将考虑其他哪些客户端打开
了该文件，以及其中是否有至少一个客户端写入过该文件。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>已</b><b>注</b><b>册</b><b>文</b><b>件</b><b>系</b><b>统</b><b>列</b><b>表</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">当
I/O管理器将设备驱动程序载入内存时，通常会为自己创建的代表驱动程序的驱动程序对象命名，并将其放入对象管理器的\Driver目录下。I/O管理器
加载的任何驱动程序所对应的驱动程序对象，如果其Type特性值为SERVICE_FILE_SYSTEM_DRIVER 
(2)，则都会被I/O管理器放入\FileSystem目录下。因此使用诸如WinObj（来自Sysinternals）等工具即可看到系统中已注册
的文件系统，如下图所示。请注意，文件系统过滤器驱动程序也会出现在该列表中。过滤器驱动程序详见下文介绍。</span></p><div style="display: block;text-align:center;">
	<img width="748" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/21001e4fdd198c85596b3f65b3c8c661.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">另一种查看已注册文件系统的方法是使用系统信息查看器。从“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>开</b><b>始</b></span>”菜单的“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>运</b><b>行</b></span>”对话框中运行Msinfo32，选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>软</b><b>件</b><b>环</b><b>境</b></span>”下的“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>系</b><b>统</b><b>驱</b><b>动</b><b>程</b><b>序</b></span>”。随后点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>类</b><b>型</b></span>”列，列表将按照驱动程序进行排序，这样所有类型为SERVICE_FILE_SYSTEM_DRIVER的驱动程序就会显示在一起。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/6cd930a84bd899bfc7b8e22e41e6a476.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请注意，驱动程序即使注册为文件系统驱动程序，也并不一定意味着它是本地或远程FSD。例如，NPFS（命名管道文件系统）是一种通过类似文件系统的私有命名空间实现命名管道的驱动程序。如上文所述，该列表中也包含文件系统过滤器驱动程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Lease 在SMB 
2.1之前，SMB协议会假设客户端和服务器间的网络连接是不会出错的，因此无法容忍瞬时网络故障、服务器重启动或集群故障转移导致的网络断开。当客户端
收到网络断开事件时，会孤立所有受影响服务器上打开的句柄，并且对这些孤立句柄进行的所有后续I/O操作都将失败。类似地，服务器也会释放所有打开的句柄
以及与已断开用户会话相关的资源。这种行为会导致应用程序丢失状态，并产生不必要的网络流量。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SMB 2.1中引入了Lease（租约）的概念，这是一种与Oplock类似的全新客户端缓存机制类型。租约的目的与Oplock相同，但提供了更高灵活性和更好的性能。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>读</b><b>取</b><b>（</b><b>R</b><b>）</b><b>，</b><b>共</b><b>享</b><b>式</b><b>访</b><b>问</b></span>。允许一个文件拥有多个并发读取者，但没有写入者。这种租约允许客户端执行预读取缓冲和读取缓存。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>读</b><b>取</b><b>句</b><b>柄</b><b>（</b><b>R</b><b>H</b><b>）</b><b>，</b><b>共</b><b>享</b><b>式</b><b>访</b><b>问</b></span>。
与2级Oplock类似，但额外的好处是可以让客户端在服务器上保持一个文件处于打开状态，即便客户端访问者已关闭了该文件（缓存管理器会对未写入数据进
行延迟刷新，并根据可用内存状况清空未修改的缓存页）。这是一种比2级Oplock更好的做法，因为打开和关闭文件句柄期间无须破坏租约（这方面其实提供
了与批处理Oplock类似的语义）。此类租约适合需要反复打开和关闭的文件，因为文件关闭后缓存不会失效，文件再次打开后也无须重新填充缓存，这可有效
改善复杂的I/O密集型应用程序性能。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>读</b><b>取</b><b>-</b><b>写</b><b>入</b><b>（</b><b>R</b><b>W</b><b>）</b><b>，</b><b>独</b><b>占</b><b>式</b><b>访</b><b>问</b></span>。该租约可供客户端以独占访问方式打开文件。该租约允许客户端执行预读取缓冲和读取或写入缓存。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>读</b><b>取</b><b>-</b><b>写</b><b>入</b><b>-</b><b>句</b><b>柄</b><b>（</b><b>R</b><b>W</b><b>H</b><b>）</b><b>，</b><b>独</b><b>占</b><b>式</b><b>访</b><b>问</b></span>。此租约可供客户端以独占访问方式打开文件。该租约支持读取、写入和句柄缓存（类似于读取-句柄租约）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">相比Oplock，租约的
另一个优势在于，即便客户端上有多个打开的文件句柄，文件依然可以被缓存（对很多应用程序来说，这是一种很常见的行为）。这是通过使用一种租约密钥（通过
GUID实现）做到的，租约密钥可由客户端创建，并与缓存文件的文件控制块（File Control 
Block，FCB）相关联，这样，同一个文件的所有句柄即可共享相同的租约状态，进而实现按文件进行缓存，而非按句柄进行缓存的功能。在引入租约前，当
文件打开了新句柄时，哪怕是从同一个客户端打开，Oplock都会被打破。图11-20展示了Oplock行为，图11-21展示了新的租约行为。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4b0ad72d1b6200e02c8b854e3893e030.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">▲图11-20 同一个客户端打开多个句柄时的Oplock</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b66ec8d2d2fcb0592220d808cd4da107.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">▲图11-21 同一个客户端打开多个句柄时的租约</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在SMB 2.1之前，Oplock只能授予或打破，但租约还可以转换。例如，读取租约可转换为读取-写入租约，这样可以大幅减少网络流量，因为特定文件的缓存无须失效并重新填充，就像是（2级Oplock）在锁打破后请求并授予1级Oplock那样。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_227" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>1</b><b>1</b><b> </b><b>文</b><b>件</b><b>系</b><b>统</b><b>操</b><b>作</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">应用程序和系统能以两种方
式访问文件：通过文件I/O函数（如ReadFile和WriteFile）直接访问，以及通过读/写代表已映射文件节的一部分地址空间进行间接访问（映
射文件的详情请参阅卷1第5章）。图11-22是一个简化的示意图，展示了这些文件系统操作涉及的组件以及它们之间的交互方式。如图11-22所示，
FSD可通过多个路径调用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·从执行显式文件I/O的用户或系统线程调用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·从内存管理器的已修改和已映射页写入器调用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·从缓存管理器的惰性写入器间接调用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·从缓存管理器的预读取线程间接调用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·从内存管理器的页面错误处理程序调用。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/33a76435c5c454750c5937ba4d7ae010.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-22 文件系统I/O涉及的组件</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">下文将分别介绍上述每种情况，以及FSD应对每种情况所采取的操作，从中也可以看到FSD对内存管理器和缓存管理器的依赖程度。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_228" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>1</b><b>2</b><b> </b><b>显</b><b>式</b><b>文</b><b>件</b><b>I</b><b>/</b><b>O</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">应用程序访问文件最明显的
方式是调用Windows的I/O函数，例如CreateFile、ReadFile以及WriteFile。应用程序使用CreateFile打开一个
文件，随后即可将CreateFile返回的句柄传递给其他Windows函数，实现文件的读取、写入或删除功能。CreateFile函数实现于
Kernel32.dll这个Windows客户端DLL中，可调用原生函数NtCreateFile，为应用程序传递给自己的路径形成一个完整的根相对
路径名（会处理路径名中的“.”和“..”符号），并为路径添加“\??”的前缀（例如\??\C:\Daryl\Todo.txt）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NtCreateFile
系统服务使用ObOpenObjectByName来打开文件，它会解析以对象管理器根目录和路径名称的第一部分（“??”）开头的名称。第8章详细介绍
了对象管理器名称的解析及其对进程设备映射的使用，此处将简要回顾相关步骤，不过将重点关注卷盘符的查找。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对象管理器执行的第一步操
作是将“\??”转换为进程的每会话命名空间的目录，该目录是进程对象中设备映射结构中的DosDevicesDirectory字段所引用的（使用登录
会话令牌中的登录会话引用字段从第一个进程进行传播）。通常只有网络共享的卷名称以及Subst.exe工具映射的驱动器盘符会存储在每会话目录中，因此
在这些系统中，如果每会话目录中不存在某个名称（例如本例中的C:），对象管理器会在该每会话目录关联的设备映射的
GlobalDosDevicesDirectory字段所引用的目录中重新查找。GlobalDosDevicesDirectory字段始终指向
\GLOBAL??目录，Windows在这里存储了本地卷的盘符（详见第8章中的“会话命名空间”一节）。进程也可以有自己的设备映射，这是通过RPC
等协议进行模拟时的一个重要特征。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">卷盘符的符号链接会指向
\Device下的卷设备对象，因此，当对象管理器遇到卷对象时，它会将路径名称的其余部分交给I/O管理器为设备对象注册的解析函数
IopParseDevice（对于动态磁盘中的卷，符号链接会指向一个中间符号链接，这个中间符号链接最终指向卷设备对象）。图11-23展示了如何通
过对象管理器命名空间访问卷对象。图中展示了\GLOBAL??\C:这个符号链接是如何指向\Device\HarddiskVolume6这个卷设备
对象的。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/01da2b1460b67652b67373d7426db151.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-23 卷盘符的名称解析</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在锁定了调用方的安全上下
文并通过调用方的令牌获取了安全信息后，IopParseDevice会创建一个类型为IRP_MJ_CREATE的I/O请求包（IRP），并创建一个
文件对象来存储要打开的文件名称，以及用于查找卷的已挂载文件系统设备对象的卷设备对象VPB，随后会使用IoCallDriver将该IRP传递给拥有
该文件系统设备对象的文件系统驱动程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当FSD收到
IRP_MJ_CREATE 
IRP时，会查找指定的文件，执行安全验证，如果文件存在并且用户有权按照所请求的方式访问该文件，则会返回成功状态代码。对象管理器会在进程的句柄表中
为文件对象创建一个句柄，该句柄可通过调用链回传，最终作为CreateFile返回的参数抵达应用程序。如果文件系统的创建操作失败，I/O管理器会删
除其为文件创建的文件对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">我们跳过了FSD如何在卷
上定位要打开文件的方法细节，但ReadFile函数调用操作在很多方面与FSD和缓存管理器以及存储驱动程序的交互都是相同的。ReadFile和
CreateFile都是映射至I/O管理器函数的系统调用，但NtReadFile系统服务并不需要进行名称查找，它会调用对象管理器将
ReadFile传递来的句柄转换为文件对象指针。如果在打开文件时，句柄显示调用方获得了读取文件的权限，则NtReadFile会继续创建一个
IRP_MJ_READ类型的IRP，并将其发送给文件所在卷的FSD。NtReadFile会获取FSD的设备对象（存储在文件对象中），并调用
IoCallDriver，随后I/O管理器即可从设备对象中找到FSD并将IRP提供给FSD。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果正在读取的文件可被缓
存（即打开文件时未向CreateFile传递FILE_FLAG_NO_BUFFERING标记），则FSD会检查是否已经为该文件对象发起了缓存。如
果某个文件对象已经发起了缓存，则文件对象中的PrivateCacheMap字段会指向一种专用缓存映射结构（上文已有相关介绍）。如果FSD尚未发起
对某个文件对象的缓存（例如在首次读取或写入一个文件对象时），则PrivateCacheMap字段将为Null。FSD会调用缓存管理器的
CcInitializeCacheMap函数来初始化缓存，在这一过程中，缓存管理器会创建私有缓存映射，并且如果引用同一个文件的另一个文件对象没有
发起缓存，则创建一个共享缓存映射和节对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在验证了文件缓存已启用
后，FSD会将请求的文件数据从缓存管理器的虚拟内存复制到线程传递给ReadFile函数的缓冲区。文件系统会在Try/except块中执行复制操
作，这样就能捕捉到由于无效应用程序缓冲区而导致的所有错误。文件系统会使用缓存管理器的CcCopyRead函数来执行复制。CcCopyRead接受
一个文件对象、文件偏移量以及长度作为参数。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当缓存管理器执行
CcCopyRead时，会获取一个指向共享缓存映射的指针，该指针存储在文件对象中。上文曾经提到，共享缓存映射存储了指向虚拟地址控制块（VACB）
的指针，文件每256KB的块有一个对应的VACB项。如果文件中正被读取部分的VACB指针为Null，则CcCopyRead会分配一个VACB，在
缓存管理器的虚拟地址空间中保留一个256KB的视图，并使用MmMapViewInSystemCache将文件中的指定部分映射到该视图。随后
CcCopyRead会直接将文件数据从映射的视图复制到自己传递的缓冲区（即最开始传递给ReadFile的缓冲区）。如果文件数据不在物理内存中，则
复制操作会产生页面错误，随后将由MmAccessFault提供服务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当发生页面错误时，
MmAccessFault会检查造成错误的虚拟地址，并在造成错误的进程的VAD树中查找虚拟地址描述符（VAD）（有关VAD树的详细信息请参阅卷1
第5章）。这种情况下，VAD描述了缓存管理器对正被读取的文件创建的已映射视图，因此MmAccessFault会调用MiDispatchFault
来处理有效虚拟内存地址的页面错误。MiDispatchFault会定位VAD指向的控制区，并通过该控制区找到表示所打开文件的文件对象（如果文件被
打开多次，可能会有一个文件对象列表，并通过私有缓存映射中的指针链接在一起）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">得到文件对象后，
MiDispatchFault会调用I/O管理器的IoPageRead函数构建（IRP_MJ_READ类型的）IRP，并将该IRP发送给文件对象
指向的设备对象的拥有者FSD。这样即可重新进入文件系统以读取通过CcCopyRead请求的数据，但这次的IRP会被标记为未缓存和分页I/O。这些
标记会向FSD发出信号，让FSD直接从磁盘上获取文件数据，这是通过判断磁盘上的哪些簇包含所请求的数据（确切机制取决于文件系统），并向拥有文件所在
卷设备对象的卷管理器发送IRP实现的。FSD设备对象中的卷参数块（VPB）字段会指向卷设备对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内存管理器会等待FSD完
成IRP读取，随后将控制权返回给缓存管理器，并由缓存管理器继续执行之前被页面错误中断的复制操作。当CcCopyRead完成时，FSD会将控制权返
回给调用了NtReadFile的线程，并在缓存管理器和内存管理器的帮助下将所请求的文件数据复制到线程的缓冲区。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">WriteFile的路径
与上述情况类似，差别在于NtWriteFile系统服务会生成类型为IRP_MJ_WRITE的IRP，并且FSD会调用CcCopyWrite而非
CcCopyRead。CcCopyWrite与CcCopyRead类似，保证了文件中正被写入的部分可映射至缓存，随后将WriteFile传递的缓
冲区复制到缓存。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果文件的数据已经被缓存
（到系统工作集中），那么上述情况将会有几种变数。如果文件的数据已经存储在缓存中，则CcCopyRead将不产生页面错误。此外，在某些情况下，
NtReadFile和NtWriteFile会调用FSD的快速I/O入口点，而不是立即构建并发送IRP到FSD。其中的一些条件包括：文件被读取的
部分必须位于文件的前4GB范围内，文件不能有锁定，文件正在被读取或写入的部分必须在文件当前分配的大小范围内。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对大部分FSD来说，快速
I/O读取和写入的入口点可以调用缓存管理器的CcFastCopyRead和CcFastCopyWrite函数。这些标准复制例程的变体保证了在执行
复制操作之前，文件的数据已被映射至文件系统缓存。如果无法满足这个条件，CcFastCopyRead和CcFastCopyWrite则会认为无法实
现快速I/O。当快速I/O不可行时，NtReadFile和NtWriteFile会回退以创建IRP（有关快速I/O的详细介绍请参阅上文“快速I/
O”一节）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_229" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>1</b><b>3</b><b> </b><b>内</b><b>存</b><b>管</b><b>理</b><b>器</b><b>的</b><b>已</b><b>修</b><b>改</b><b>和</b><b>已</b><b>映</b><b>射</b><b>页</b><b>写</b><b>入</b><b>器</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">内存管理器的已修改和已映
射页写入器线程会被定期唤醒（以及在可用内存不足时被唤醒），并将已修改页面刷新到磁盘的后备存储中。这些线程会调用
IoAsynchronousPageWrite来创建类型为IRP_MJ_WRITE的IRP，并将页面写入分页文件，或写入映射后已被修改的文件。与
MiDispatchFault创建的IRP类似，这些IRP都会被标记为未缓存和分页I/O，因此，FSD可以绕过文件系统缓存直接向存储驱动程序发出
IRP，进而将内存写入磁盘。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_230" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>1</b><b>4</b><b> </b><b>缓</b><b>存</b><b>管</b><b>理</b><b>器</b><b>的</b><b>惰</b><b>性</b><b>写</b><b>入</b><b>器</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存管理器的惰性写入器线
程在已修改页面的写入方面也起到了一定作用，它会定期刷新映射至缓存中，并且已知变脏的文件节视图。缓存管理器执行的刷新操作会调用
MmFlushSection，这会触发内存管理器将正在刷新的部分中的任何修改过的页面写入磁盘。与已修改和已映射页面写入器类似，
MmFlushSection会使用IoSynchronousPageWrite将数据发送给FSD。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_231" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>1</b><b>5</b><b> </b><b>缓</b><b>存</b><b>管</b><b>理</b><b>器</b><b>的</b><b>预</b><b>读</b><b>取</b><b>线</b><b>程</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存的工作依赖程序引用代
码和数据时的两个特征：时间局部性（temporal locality）和空间局部性（spatial 
locality）。时间局部性背后的思想是，如果一个内存位置被引用，那么可能很快就会再次被引用。空间局部性背后的思想是，如果一个内存位置被引用，
那么可能很快就会引用该位置周围的其他位置。因此，缓存通常在为曾被访问过的内存位置进行访问加速时可取得不错的效果，但对未曾访问过的内存位置，其加速
效果就很糟糕（缓存几乎没有“前瞻性”）。为了将很快可能被用到的数据填充到缓存中，缓存管理器实现了两种机制，即预读取（read-ahead）线程和
Superfetch。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，缓存管理器包
含一个线程，该线程负责在应用程序、驱动程序或系统线程明确请求某些数据之前，尝试从文件中读取这些数据。这个预读取线程会借助针对文件执行读取操作的历
史记录（这些记录存储在文件对象的私有缓存映射中）来确定要读取多少数据。当该线程执行预读取操作时，会直接将自己希望读取的文件部分映射至缓存（并在必
要时分配VACB），随后直接处理映射的数据。由内存访问引起的页面错误会调用页面错误处理程序，并借此将页面读入系统工作集。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">预读取线程的一个局限在于
只适用于打开的文件。而Windows中随后增加的Superfetch可以在文件打开之前主动将其加入缓存中。具体来说，内存管理器会将页面使用信息发
送给Superfetch服务（%SystemRoot%\System32\Sysmain.dll），并由文件系统小型过滤器提供文件名称解析数据。
Superfetch服务会试图找出文件的使用模式，例如每周五12:00运行薪酬应用，每天早晨8:00运行Outlook。在得出这些模式后，相关信
息会存储在一个数据库中并会请求计时器。当文件最有可能被使用的时间即将到达时，计时器会启动并告诉内存管理器将相关文件（使用低优先级磁盘I/O）读入
低优先级内存。如果随后打开了这些文件，此时数据已经位于内存中，就无须等待数据从磁盘读取了。如果文件未被打开，低优先级内存将被系统回收。有关
Superfetch服务内部原理的完整介绍请参阅卷1第5章。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_232" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>1</b><b>6</b><b> </b><b>内</b><b>存</b><b>管</b><b>理</b><b>器</b><b>的</b><b>页</b><b>面</b><b>错</b><b>误</b><b>处</b><b>理</b><b>程</b><b>序</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">我们已经介绍了在显式文件
I/O和缓存管理器预读取情况下页面错误处理程序的使用方式，但当任何应用程序访问作为映射文件视图的虚拟内存，并遇到代表文件中尚不位于内存中的部分对
应的页面时，也会调用页面错误处理程序。内存管理器的MmAccessFault处理程序会执行与缓存管理器通过CcCopyRead或
CcCopyWrite生成页面错误时相同的操作，通过IoPageRead向文件所在的文件系统发送IRP。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_233" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>1</b><b>7</b><b> </b><b>文</b><b>件</b><b>系</b><b>统</b><b>过</b><b>滤</b><b>器</b><b>驱</b><b>动</b><b>程</b><b>序</b><b>和</b><b>微</b><b>过</b><b>滤</b><b>器</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">文件系统驱动程序之上的过滤器驱动程序称为文件系统过滤器驱动程序。Windows的I/O模型支持两种类型的文件系统过滤器驱动程序。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
传统的文件系统过滤器驱动程序：通常会创建一个或多个设备对象，并通过IoAttachDeviceToDeviceStack 
API将其附加到文件系统设备上。传统的过滤器驱动程序可拦截来自缓存管理器或I/O管理器的所有请求，必须同时实现标准IRP调度函数和快速I/O路
径。由于此类驱动程序的开发会涉及很多复杂问题（同步问题、未公开的接口、对原始文件系统的依赖性等），微软已经开发了一种统一的过滤器模型，该模型利用
了一种名为微过滤器（Minifilter）的特殊驱动程序，以及已经停用的传统的文件系统驱动程序
（IoAttachDeviceToDeviceStack API在为DAX卷调用时会失败）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
微过滤器驱动程序：它是文件系统过滤器管理器（Fltmgr.sys）的客户端。文件系统过滤器管理器是一种传统的文件系统过滤器驱动程序，为文件系统过
滤器的创建工作提供了丰富的文档化接口，隐藏了文件系统驱动程序和缓存管理器之间所有复杂的交互。微过滤器可通过FltRegisterFilter 
API与过滤器管理器注册。调用方通常只需指定一个实例设置例程以及不同的操作回调。对于文件系统管理的每个有效卷设备，过滤器管理器都会调用实例设置。
微过滤器有机会决定是否附加到卷。微过滤器可以为每个主要的IRP函数代码指定操作前回调和操作后回调，并能通过某些“伪操作”描述与文件系统访问模式有
关的内存管理器或缓存管理器内部语义。前回调会在文件系统驱动程序处理I/O之前执行，后回调会在I/O操作完成后执行。过滤器管理器还提供了自己的通信
设施，不同的微过滤器驱动程序以及相关用户模式应用程序可借此进行通信。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">查看所有文件系统请求并选
择性地修改或完成这些请求，这种功能使一系列应用成为可能，例如远程文件复制服务、文件加密、高效备份以及许可。每个反恶意软件产品通常至少包含一个微过
滤驱动程序，借此拦截应用程序的文件打开或修改操作。例如，在将IRP传播到命令所指向的文件系统驱动程序之前，恶意软件扫描器可以检查即将打开的文件，
以确保文件是安全的。如果文件是安全的，则恶意软件扫描器将继续传递IRP，但如果发现文件被感染，则恶意软件扫描器将隔离或清理该文件。如果文件无法清
理，那么驱动程序会让IRP失败（通常会显示访问被拒绝的错误），这样恶意软件就无法激活了。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">有关微过滤器和传统的过滤
器驱动程序架构的详细介绍已超出了本章范围。有关传统过滤器驱动程序架构的详情请参阅卷1第6章，有关微过滤器的详细信息请参阅MSDN
（https://docs.microsoft.com/windows-hardware/drivers/ifs/file-system-
minifilter-drivers）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>数</b><b>据</b><b>扫</b><b>描</b><b>节</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">从Windows 8.1开始，过滤器管理器开始与文件系统驱动程序配合，提供可供反恶意软件产品使用的数据扫描（Data-scan）节对象。数据扫描节对象与标准节对象类似（有关节对象的详情请参阅卷1第5章），但有下列差异。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·数据扫描节对象可通过微过滤器回调函数（主要是从管理IRP_MJ_CREATE函数代码的回调）创建。当应用程序打开或创建文件时，过滤器管理器会调用这些回调。反恶意软件扫描器可以创建数据扫描节，随后在完成回调前开始扫描。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
用于创建数据扫描节的FltCreateSectionForDataScan 
API可接收FILE_OBJECT指针。这意味着调用方无须提供文件句柄。文件句柄通常还不存在，因此需要使用FltCreateFile 
API来重新创建，随后还将创建其他文件创建IRP，并再次与低级别的文件系统过滤器以递归的方式进行交互。有了新的API，该过程会快很多，因为不再产
生这些额外的递归调用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">数据扫描节可以像普通节那
样使用传统的API进行映射。这样，反恶意软件应用程序就可以通过用户模式应用程序或内核模式驱动程序的形式来实现自己的扫描引擎。当数据扫描节被映射
时，微过滤器驱动程序依然会生成IRP_MJ_READ事件，但这并不会造成什么问题，因为微过滤器完全不需要包含读取回调。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_234" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>1</b><b>8</b><b> </b><b>过</b><b>滤</b><b>命</b><b>名</b><b>管</b><b>道</b><b>和</b><b>邮</b><b>件</b><b>槽</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">当属于用户应用程序的进程
需要与另一个实体（进程、内核驱动程序或远程应用程序）通信时，即可利用操作系统提供的各项设施。最传统的方式是命名管道和邮件槽，因为它们在其他操作系
统中也是可移植的。命名管道是管道服务器和一个或多个管道客户端之间产生的一种命名的单向通信渠道。同一个命名管道的所有实例共享相同的管道名称，但每个
实例都有自己的缓冲区和句柄，并为客户端/服务器通信提供单独的通道。命名管道是通过文件系统驱动程序NPFS驱动程序（Npfs.sys）实现的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">邮件槽则是一个邮件槽服务
器和一个或多个客户端之间的一种多向通信渠道。邮件槽服务器是一种通过CreateMailslot这个Win32 
API创建邮件槽的进程，它只能读取由一个或多个客户端生成的小消息（远程计算机之间发送时最大为424字节）。客户端则是可将消息写入邮件槽的进程。客
户端可通过标准的CreateFile 
API连接至邮件槽，随后可通过WriteFile函数发送消息。邮件槽通常主要用于在一个域内广播消息。如果一个域内的多个服务器进程每个都分别使用相
同的名称创建邮件槽，那么每条以该邮件槽为地址并且发送到该域的消息都会被接收方的进程收到。邮件槽是通过邮件槽文件系统驱动程序Msfs.sys实现
的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">邮件槽和NPFS驱动程序都实现了一种简单的文件系统。它们管理由文件和目录组成的命名空间，这些命名空间支持安全性，可以打开、关闭、读取、写入等。这两个驱动程序的详细介绍已超出了本书的内容范围。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">从Windows 
8开始，邮件槽和命名管道均由过滤器管理器提供支持。微过滤器也能通过在注册时指定的
FLTFL_REGISTRATION_SUPPORT_NPFS_MSFS标记附加至邮件槽和命名管道卷（\Device\NamedPipe和
\Device\Mailslot，它们并非真正的卷）。随后微过滤器即可拦截并修改本地和远程进程之间，以及用户应用程序与其内核驱动程序之间产生的所
有命名管道和邮件槽I/O。此外，微过滤器还可以通过FltCreateNamedPipeFile或FltCreateMailslotFile 
API，在不产生递归事件的前提下打开或创建命名管道或邮件槽。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 为何说命名管道和邮件槽文件系统驱动程序比NTFS和ReFS更简单？一个重要原因在于它们并不与缓存管理器产生太多的交互。命名管道驱动程序实现了快速I/O路径，但并不支持缓存读取或后写入。邮件槽驱动程序则完全不与缓存管理器交互。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_235" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>1</b><b>9</b><b> </b><b>控</b><b>制</b><b>重</b><b>分</b><b>析</b><b>点</b><b>的</b><b>行</b><b>为</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS支持重分析点
（reparse 
point）的概念，重分析点是一种由应用程序和系统定义的重分析数据组成的、18KB大小、可关联给单一文件的块（下文很多小节还将详细讨论）。某些类
型的重分析点（如卷挂载点或符号链接）包含作为占位符的原始文件（或空目录）与另一个文件（该文件甚至可以位于另一个卷中）之间的链接。当NTFS文件系
统驱动程序在路径上遇到重分析点后，会向设备堆栈的上级驱动程序返回一个错误代码。上级驱动程序（可能是另一个过滤器驱动程序）将会分析重分析点的内容，
如果发现这是一个符号链接，则会向正确的卷设备重新发出另一个I/O。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这个过程对于任何过滤器驱
动程序来说都是复杂烦琐的。微过滤器驱动程序可以拦截STATUS_REPARSE的错误代码并通过新的FltCreateFileEx2 
API重新打开重分析点，该API可接收一种额外的创建参数（Extra Create 
Parameter，ECP）列表，借此可进一步调整微过滤器上下文中目标文件的打开/创建进程的具体行为。一般来说，过滤器管理器支持不同的ECP，每
个ECP都可通过唯一的GUID加以识别。过滤器管理器提供了多种用于处理ECP和ECP列表的文档化API。通常，微过滤器会使用
FltAllocateExtraCreateParameter函数分配ECP，向其中填充内容，随后在调用过滤器管理器的I/O 
API之前，将其通过FltInsertExtraCreateParameter插入列表中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">FLT_CREATEFILE_TARGET这个额外创建的参数可以让过滤器管理器自动管理跨卷文件的创建（调用方需要指定标记）。微过滤器无须执行其他任何复杂操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了支持容器隔离，也可以
在非空目录上设置重分析点。同时，为了支持容器隔离，还可创建具备目录重分析点的新文件。在遇到非空目录重分析点后，文件系统的默认行为取决于该重分析点
是否应用于文件完整路径的最后一个组件。如果是，则文件系统将像处理空目录那样返回STATUS_REPARSE的错误代码；如果不是，则会继续沿路径向
下。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">过滤器管理器可以通过另一
个ECP（名为TYPE_OPEN_REPARSE）正确处理这种新的重分析点。该ECP包含一个描述符列表
（OPEN_REPARSE_LIST_ENTRY数据结构），其中每一项都（通过自己的重分析标记）描述了重分析点的类型，以及在解析路径时遇到这种类
型的重分析点后，系统应该采取的行为。在正确初始化描述符列表后，微过滤器即可通过不同的方式应用新的行为。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·使用FltCreateFileEx2函数对路径中任何一部分包含重分析点的文件发出新的打开（或创建）操作。该过程类似于FLT_CREATEFILE_TARGET这个ECP所执行的过程。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
对Pre-Create回调所拦截的任何文件，全局应用新的重分析点行为。FltAddOpenReparseEntry和
FltRemoveOpenReparseEntry 
API可用于在实际创建文件前，为目标文件设置重分析点行为（创建前的回调会在开始创建文件前拦截文件创建请求）。Windows容器隔离微过滤器驱动程
序（Wcifs.sys）使用了该策略。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_236" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>9</b><b>.</b><b>2</b><b>0</b><b> </b><b>进</b><b>程</b><b>监</b><b>视</b><b>器</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">本书中大量使用的Sysinternals系统活动监视工具进程监视器（Procmon）就用到了被动的微过滤器驱动程序。“被动”是指它不会修改应用程序和文件系统驱动程序之间的IRP流。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">进程监视器的工作原理：在
系统启动后首次运行时，从自己的可执行映像（以资源形式存储在Procmon.exe中）中提取一个文件系统微过滤器驱动程序，并将该驱动程序安装到内存
中，随后从磁盘上删除驱动程序的映像（除非配置了持久的启动时监视）。我们可以通过进程监视器的GUI指示该驱动程序监视分配了盘符的本地卷、网络共享、
命名管道，以及邮件槽上的文件系统活动。当驱动程序收到开始监视卷的命令时，它会向过滤器管理器注册过滤回调，而过滤器管理器会被附加至代表卷上所挂载文
件系统的设备对象。附加操作之后，I/O管理器会以底层设备对象为目标，将IRP重定向至拥有该附加设备的驱动程序，本例中是指过滤器管理器，它会将事件
发送至已注册的微过滤器驱动程序，也就是本例中的进程监视器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当进程监视器驱动程序拦截
了IRP时，会记录有关IRP命令的信息，包括目标文件名和与命令有关的其他参数（如读/写长度和偏移量），这些信息会被记录到非分页内核缓冲区中。每
500毫秒，进程监视器的GUI程序会向进程监视器的接口设备对象发送一个IRP，借此请求缓冲区中所包含最新活动信息的副本，随后将这些活动显示在自己
的输出窗口中。进程监视器会在发生那一刻显示出所有的文件活动，因此它很适合用于排查与文件系统相关的系统和应用程序故障。在系统上首次运行进程监视器
时，账户必须具备Load Driver和Debug特权。加载后，驱动程序将常驻，因此后续运行时只需要具备Debug特权。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在运行进程监视器时，它会以基本模式启动，只显示对排错工作最有价值的文件系统活动。处于基本模式的进程监视器会忽略（不显示）某些文件系统操作，包括：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·针对NTFS元数据文件的I/O。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·针对分页文件的I/O。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·System进程生成的I/O。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·进程监视器进程生成的I/O。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">基本模式下的进程监视器还
会使用更友好的名称（而不是表示名称的IRP类型）来报告文件的I/O操作。例如，IRP_MJ_WRITE和FASTIO_WRITE的操作都会显示为
WriteFile，而IRP_MJ_CREATE的操作则会显示为Open（如果代表打开操作）或Create（如果代表新建文件）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>进</b><b>程</b><b>监</b><b>视</b><b>器</b><b>的</b><b>微</b><b>过</b><b>滤</b><b>器</b><b>驱</b><b>动</b><b>程</b><b>序</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">要
查看已加载的文件系统微过滤器驱动程序，请以管理员身份启动命令提示符窗口，运行过滤器管理器控制程序（%SystemRoot%
\System32\Fltmc.exe）。然后启动进程监视器（ProcMon.exe）并再次运行Fltmc。这样将能看到进程监视器的过滤器驱动程
序（PROCMON20）已加载，且Instances列中显示有一个非0值。最后退出进程监视器并再次运行Fltmc。这次可以看到进程监视器的过滤器
驱动程序依然加载，但实例数为0。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/0a5bb00e83ce4a79baea384035af4eb8.jpg" alt="" title=""></div></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11_0010.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_237" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b> </b><b>N</b><b>T</b><b>文</b><b>件</b><b>系</b><b>统</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">本节将介绍NTFS（NT文件系统）的内部架构，首先将一起看看推动其设计的需求。此外还将介绍磁盘上的数据结构，并介绍NTFS提供的一些高级功能，如恢复支持、分层卷以及加密文件系统（EFS）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_238" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>1</b><b> </b><b>高</b><b>端</b><b>文</b><b>件</b><b>系</b><b>统</b><b>的</b><b>要</b><b>求</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">从一开始，NTFS在设计
上就包含了企业级文件系统所需的各种功能。为了在系统意外中断或崩溃时最大限度地避免数据丢失，文件系统必须在任何情况下都能确保其元数据的完整性；而为
了保护敏感数据不被未经授权访问，文件系统必须具备集成的安全模型。最后，文件系统必须支持基于软件的数据冗余，借此作为硬件冗余的解决方案的低成本替代
方案保护用户数据。本节将介绍NTFS是如何实现这些功能的。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_239" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>2</b><b> </b><b>可</b><b>恢</b><b>复</b><b>性</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了满足可靠的数据存储和
数据访问的要求，NTFS提供了基于原子性事务概念的文件系统恢复能力。原子性事务是一种数据库内容的修改处理技术，保证了系统故障不会影响到数据库的一
致性或完整性。原子性事务的基本原则是：名为事务（transaction）的数据库操作是一种全有或全无（all-or-nothing）的操作（事务
被定义为会更改文件系统数据或更改卷的目录结构的I/O操作）。构成事务的独立磁盘更新必须以原子性的方式执行，也就是说，一旦事务开始执行，所有磁盘更
新操作就必须完成。如果系统故障导致事务中断，那么已完成的部分必须撤销或回滚。回滚操作可将数据库返回至之前已知的一致状态，就好像事务从未执行过那
样。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS使用原子性事务来
实现自己的文件系统恢复功能。如果程序发起的I/O操作会改变NTFS卷结构（例如更改目录结构、扩展一个文件、为新文件分配空间等），NTFS就会将该
操作视为一种原子性事务。它会保证事务或能成功完成，或者如果在执行过程中系统出错也可成功回滚。下文“NTFS恢复支持”一节将详细介绍NTFS实现该
功能的细节。此外，NTFS会对重要文件系统信息使用冗余的存储，这样，即使磁盘上的一个扇区坏了，NTFS依然可以访问卷的关键文件系统数据。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_240" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>3</b><b> </b><b>安</b><b>全</b><b>性</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS的安全性直接源于
Windows对象模型。文件和目录会受到保护，无法被未经授权的用户访问（有关Windows安全性的详细信息，请参阅卷1第7章）。打开的文件是作为
一个文件对象实现的，其安全描述符存储在磁盘上的一个隐藏的$Secure元文件中，该文件位于一个名为$SDS（Security 
Descriptor 
Stream，安全描述符流）的流中。进程打开任何对象（包括文件对象）的句柄前，Windows安全系统会验证进程是否具备授权功能。安全描述符与用户
必须登录系统并提供密码的要求相结合，保证除非系统管理员或文件的所有者授予必要的权限，否则任何进程都无法访问文件（有关安全描述符的更多信息，请参阅
卷1第7章中的“安全描述符和访问控制”一节）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_241" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>4</b><b> </b><b>数</b><b>据</b><b>冗</b><b>余</b><b>和</b><b>容</b><b>错</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了文件系统数据的可恢复性，一些客户还希望自己的数据不因电源故障或灾难性磁盘故障而受到威胁。NTFS的恢复能力确保了卷上的文件系统能保持可访问性，但无法保证用户文件的完整恢复。为了向不能承受数据丢失风险的应用程序提供保护，我们可以采用数据冗余机制。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">用户文件的数据冗余是通过
Windows分层驱动程序实现的，这样为磁盘提供了容错支持。NTFS可以与卷管理器通信，卷管理器则与磁盘驱动器通信，借此将数据写入磁盘。卷管理器
可以将数据从一个磁盘镜像（或复制）到另一个磁盘中，这样数据就有了一个随时可用的冗余副本。这种支持通常也叫RAID级别1。卷管理器还可以通过三个或
更多的磁盘，以条带的方式写入数据，并使用相当于一个磁盘的容量来存储奇偶校验信息。如果一个磁盘上的数据丢失或不可访问，驱动程序即可通过异或运算
（exclusive-OR）重建磁盘内容，这种支持也叫RAID级别5。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在Windows 
7中，通过Windows分层驱动程序实现的NTFS数据冗余是由动态磁盘功能提供的。动态磁盘有很多局限，Windows 
8.1通过引入一种名为存储空间的全新存储硬件虚拟化技术克服了这些局限。存储空间可以创建已提供数据冗余和容错能力的虚拟磁盘。卷管理器并不区分虚拟磁
盘和真实磁盘（因此用户模式组件也看不出两者间的差异）。NTFS文件系统驱动程序与存储空间配合，可支持分层磁盘和RAID虚拟配置。下文还将详细介绍
存储空间和存储空间直通。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_242" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>5</b><b> </b><b>N</b><b>T</b><b>F</b><b>S</b><b>的</b><b>高</b><b>级</b><b>功</b><b>能</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS除了满足关键系统有关可恢复、安全、可靠以及高效等方面的要求外，还提供了下列这些高级功能，使其可以为广泛的应用程序提供支持。下列部分功能可通过API的方式供应用程序使用，一些则是内部功能。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·多数据流。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·基于Unicode的名称。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·通用索引设施。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·动态坏簇重映射。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·硬链接。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·符号（软）链接和交叉。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·压缩和稀疏文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·变更日志记录。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·每用户卷配额。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·链接跟踪。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·加密。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·POSIX支持。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·碎片整理。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·只读支持和动态分区。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·分层卷支持。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">下文将概括介绍这些功能。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_243" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>6</b><b> </b><b>多</b><b>数</b><b>据</b><b>流</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在NTFS中，每个与文件
相关联的信息单元（包括其名称、所有者、时间戳、内容等）都是作为文件属性实现的（NTFS对象属性）。每个属性都由一个单一的流（stream），即一
种简单的字节序列组成。这种通用的实现方式使得我们可以非常方便地向文件添加更多的属性（即添加更多的流）。由于文件的数据其实也只是文件的“另一个属
性”，并且可以添加新的属性，因此，NTFS文件（以及文件目录）可以包含多个数据流。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS文件有一个没有名
字的默认数据流。应用程序可以创建额外的命名数据流，并通过名称访问这些数据流。为避免改变Windows I/O 
API，该API可将一个字符串作为文件名参数，而数据流的名称是通过在文件名后附加一个冒号（:）来指定的。由于冒号是保留字符，因此可以作为文件名和
数据流名称之间的分隔符，例如：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">myfile.dat:stream2 </span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每个流都有单独的分配大小（定义为每个流保留多少磁盘空间）、实际大小（调用方已使用的字节数）以及有效数据长度（数据流有多少已被初始化）。此外，每个流有一个单独的文件锁，可用于锁定字节范围以进行并发访问。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows中有一个组
件使用了多数据流：附件执行服务（Attachment Execution 
Service），当Edge或Outlook等应用程序使用标准Windows 
API保存来自互联网的附件时就会调用该服务。取决于下载文件的来源区域（例如“我的电脑”区域、内网区域或不信任区域），Windows资源管理器可能
会警告用户该文件可能来自不可信的位置，甚至可能彻底禁止用户访问该文件。例如，当从Sysinternals网站下载并执行Process 
Explorer时，会看到如图11-24所示的对话框。此类数据流也叫$Zone.Identifier，也俗称为“Web标记”。</span></p><div style="display: block;text-align:center;">
	<img width="575" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/eab2c0fb678f577a88cd53d082d3f1c5.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-24 从互联网下载的文件在执行时显示的安全警报</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 如果反选“打开此文件前总是询问”选项，该文件的Zone identifier数据流将被移除。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">其他应用程序也可以使用多
数据流功能。例如备份工具，可以使用额外的数据流在文件上存储与备份有关的时间戳。或者归档工具可以借此实现具备层级的存储，从而将寿命超过某个日期的文
件，或者一定时间内未被访问过的文件移动至脱机存储位置。该工具可将文件复制到脱机存储位置，将文件的默认数据流设置为0，并添加一个数据流来指定文件的
存储位置。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>流</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">大部分Windows应用程序并未被设计用来处理备用命名流，但echo和more命令都支持。因此，查看流的最简单办法就是使用echo创建一个命名流，随后用more命令显示出来。下列的命令序列会创建一个名为test的文件，且该文件包含一个名为stream的流：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">c:\Test&gt;echo Hello from a named stream! &gt; test:stream </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">c:\Test&gt;more &lt; test:stream </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Hello from a named stream! </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">c:\Test&gt; </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如果列出目录内容，就会发现Test的文件大小并未反映出备用流中存储的数据，因为NTFS在文件查询（包括目录列出）操作中只返回未命名数据流的大小。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">c:\Test&gt;dir test</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> Volume in drive C is OS.</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> Volume Serial Number is F080-620F</span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> Directory of c:\Test </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">12/07/2018 05:33 PM                0 test </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">              1 File(s)             0 bytes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">              0 Dir(s) 18,083,577,856 bytes free </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">c:\Test&gt; </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以使用Sysinternals提供的Streams工具（见下方的输出结果）或使用dir命令的/r开关来确定系统中的哪些文件和目录包含备用数据流。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">c:\Test&gt;streams test </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">streams v1.60 - Reveal NTFS alternate streams. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright (C) 2005-2016 Mark Russinovich </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Sysinternals - www.sysinternals.com </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">c:\Test\test: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">          :stream:$DATA 29 </span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_244" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>7</b><b> </b><b>基</b><b>于</b><b>U</b><b>n</b><b>i</b><b>c</b><b>o</b><b>d</b><b>e</b><b>的</b><b>名</b><b>称</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">与Windows作为整体
一样，NTFS也支持使用16位Unicode 
1.0/UTF-16字符存储文件、目录和卷的名称。Unicode为全球每种主要语言的每个字符都提供了一种唯一的表达方式（Unicode甚至可以表
示表情符号或一些小型图画），这有助于数据在不同的地区轻松移动。传统国际化字符表示法中，需要使用双字节编码方案将一些字符以8位存储，将另一些字符以
16位存储，这种技术需要加载各种代码页来建立可用字符。而Unicode是这种技术的改进产物。由于Unicode对每个字符都有唯一的表示方法，因此
完全不需要考虑具体加载了什么代码页。路径中的每个目录和文件名最多可长达255个字符，其中可包含Unicode字符、嵌入式空格以及多个句点。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_245" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>8</b><b> </b><b>通</b><b>用</b><b>索</b><b>引</b><b>设</b><b>施</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS架构在结构上允许
使用B树结构对磁盘卷上的任意文件属性创建索引（但针对任意属性创建索引的功能并未提供给用户）。这种结构使得文件系统可以高效地找到符合某些条件的文
件，例如特定目录下的所有文件。作为对比，FAT文件系统只能索引文件名但无法排序，因此，在大目录中查找的速度会变得很慢。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS的多个功能利用了常规索引能力，包括合并安全描述符，借此可将卷中文件和目录的安全描述符存储在一个内部流中，进而消除重复项，并使用NTFS定义的内部安全标识符进行索引。这些功能对索引能力的运用详见下文“NTFS的磁盘结构”一节。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_246" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>9</b><b> </b><b>动</b><b>态</b><b>坏</b><b>簇</b><b>重</b><b>映</b><b>射</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">通常来说，如果程序试图从
坏的磁盘扇区读取数据，则读取操作将会失败，所分配簇中包含的数据将无法访问。然而，如果该磁盘被格式化为可容错的NTFS卷，则Windows卷管理器
（或存储空间，取决于数据冗余具体由哪个组件提供）会动态地检索坏扇区上所存储数据的良好副本，再向NTFS告警称该扇区已损坏。随后NTFS将分配一个
新的簇，取代坏扇区所在的簇，并将数据复制到新的簇中。NTFS还会将坏簇添加到该卷的坏簇列表（存储在一个名为$BadClus的隐藏元文件中）中，以
后将永不使用该簇。这种数据恢复和动态坏簇重映射对文件服务器和需要容错的系统，以及无法承受数据丢失后果的应用程序来说非常重要。如果是在未使用卷管理
器或存储空间的情况下遇到坏扇区（如系统启动的早期过程中），NTFS依然会替换簇并且不再继续使用，但无法恢复坏扇区中的数据。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_247" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>1</b><b>0</b><b> </b><b>硬</b><b>链</b><b>接</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">硬链接（hard 
link）可以让多个路径指向同一个文件（目录不支持硬链接）。如果创建一个名为C:\Documents\Spec.doc的硬链接并指向现有文件C:
\Users\Administrator\Documents\Spec.doc，则这两个路径将链接到磁盘上同一个文件，我们可通过任一路径更改文件
的内容。进程可通过Windows的CreateHardLink函数创建硬链接。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS通过保持对实际数
据的引用计数来实现硬链接，每次为文件创建硬链接时，都会对数据进行一个额外的数据名引用。这意味着，如果一个文件有多个硬链接，则可以删除引用该数据的
原始文件名（本例中为C:\Users\Administrator\Documents\Spec.doc），而其他硬链接（C:
\Documents\Spec.doc）依然会保留并指向该数据。然而，因为硬链接是对磁盘数据的本地引用（由文件记录号表示），因此只能存在于同一个
卷中，无法跨越卷或计算机使用。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>创</b><b>建</b><b>硬</b><b>链</b><b>接</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以通过两种方式创建硬链接：fsutil hardlink create命令，或mklink工具配合/H选项。在这个实验中，我们将使用mklink，因为随后还将用该工具创建符号链接。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">首先创建一个名为test.txt的文件并向其中添加一些内容，例如：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;echo Hello from a Hard Link &gt; test.txt </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后像这样创建一个名为hard.txt的硬链接：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;mklink hard.txt test.txt /H </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Hardlink created for hard.txt &lt;&lt;===&gt;&gt; test.txt </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">列出该目录的内容就会发现，这两个文件完全一致，创建日期、权限和文件大小都相同，仅文件名不同。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">c:\&gt;dir *.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> Volume in drive C is OS </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> Volume Serial Number is F080-620F</span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> Directory of c:\</span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">12/07/2018 05:46 PM               26 hard.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">12/07/2018 05:46 PM               26 test.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">              2 File(s)            52 bytes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">              0 Dir(s) 15,150,333,952 bytes free </span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_248" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>1</b><b>1</b><b> </b><b>符</b><b>号</b><b>（</b><b>软</b><b>）</b><b>链</b><b>接</b><b>和</b><b>交</b><b>叉</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了硬链接，NTFS还支
持另一类文件名别名，即符号链接（symbolic link）或软链接（soft 
link）。与硬链接不同，符号链接是一种动态解释的字符串，可包含相对路经或绝对路径，指向任意存储设备上的位置（包括不同的本地卷，甚至包括另一个系
统中的共享）。这意味着符号链接并不会让原始文件的引用计数增加，因而删除原始文件将导致数据丢失，最终只能留下一个指向不存在的文件的符号链接。最后，
与硬链接不同，符号链接不仅可以指向文件，还可以指向目录，这又带来了一些额外的优势。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">举例来说，如果路径C:
\Drivers是一个重定向至%SystemRoot%\System32\Drivers的目录符号链接，应用程序读取C:
\Drivers\Ntfs.sys时，实际上是在读取%SystemRoot%\System\Drivers\Ntfs.sys。目录符号链接可以将
一些原本处于较深层级中的目录“提升”到更易用的深度，同时不破坏原始目录树的结构或内容。上面这个例子就将Drivers目录提升到了卷根目录下，借此
在通过目录符号链接访问时，即可将Ntfs.sys的目录深度从三层减少到一层。文件符号链接的工作方式类似，我们可以将其看成一种快捷方式，只不过它们
是在文件系统上实现的，而不只是由Windows资源管理器所管理的.lnk文件。与硬链接类似，符号链接可以使用mklink工具（不使用/H选项）或
CreateSymbolicLink API创建。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于一些老旧的应用程序在
遇到符号链接的情况下可能表现得不够安全，跨越计算机使用时尤其如此，因此符号链接的创建需要具备SeCreateSymbolicLink特权，该特权
通常只授予Administrators组的成员。从Windows 10开始，并且在启用了开发者模式（Developer 
Mode）的情况下，CreateSymbolicLink 
API的调用方还可以额外指定SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE标记来打破这个局限（让标准用
户也能通过命令提示符窗口创建符号链接）。文件系统还提供了一个名为SymLinkEvaluation的行为选项，可通过下列命令配置：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fsutil behavior set SymLinkEvaluation </span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">默认情况下，Windows的默认符号链接评估策略只允许“本地到本地”和“本地到远程”的符号链接，不允许相反的情况，如下所示：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">D:\&gt;fsutil behavior query SymLinkEvaluation </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Local to local symbolic links are enabled </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Local to remote symbolic links are enabled. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Remote to local symbolic links are disabled. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Remote to Remote symbolic links are disabled. </span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">符号链接是通过NTFS中
一种名为重分析点的机制实现的（重分析点的详细信息请参阅下文“重分析点”一节）。重分析点是一个文件或目录，其中关联了一个名为“重分析数据”的数据
块。重分析数据是用户定义的，关于文件或目录的数据，例如其状态或位置，可由创建数据的应用程序、文件系统过滤器驱动程序或I/O管理器通过重分析点读
取。在NTFS在查找文件或目录过程中遇到重分析点后，将会返回STATUS_REPARSE状态代码，该代码向附加到卷的文件系统过滤器驱动程序以及
I/O管理器发送信号，以便检查重分析数据。每个重分析点类型都有唯一的重分析标签。这些重分析标签可以让负责解读重分析数据的组件在无须检查重分析数据
的情况下识别重分析点。重分析标签的所有者（无论是文件系统过滤器驱动程序或是I/O管理器）在识别重分析数据时可选择下列一个选项。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·重分析标记的所有者可以操作跨越重分析点的文件I/O操作中指定的路径名称，并让I/O操作以更改后的路径名重新发出。例如，交叉（Junction，下文很快会介绍）就通过这种方式对目录查找进行重定向。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·重分析标记的所有者可以从文件中移除重分析点，以某种方式修改文件，随后重新发出文件I/O操作通知。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows未提供创建
重分析点的函数。进程必须将FSCTL_SET_REPARSE_POINT文件系统控制代码与Windows的DeviceIoControl函数配合
使用。进程可以使用FSCTL_GET_REPARSE_POINT文件系统控制代码来查询重分析点的内容。重分析点的文件属性中可设置
FILE_ATTRIBUTE_REPARSE_POINT标记，这样应用程序就可以使用Windows的GetFileAttributes函数检查重
分析点。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS支持的另一类重分
析点称为交叉（也称卷挂载点）。交叉是NTFS中一个比较老的概念，工作方式几乎与目录符号链接完全相同，唯一的区别在于交叉只能在卷本地使用。相对于目
录符号链接，交叉并未提供任何额外优势，只不过交叉可以兼容较老版本的Windows，而目录符号链接并不能兼容。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，现代版本的
Windows已经可以创建指向非空目录的重分析点。系统行为（可通过微过滤器驱动程序控制）取决于重分析点在目标文件完整路径中的位置。过滤器管理器、
NTFS以及ReFS文件系统驱动程序均可使用导出的FsRtlIsNonEmptyDirectoryReparsePointAllowed 
API来检测是否允许在非空目录上使用重分析点的类型。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>创</b><b>建</b><b>符</b><b>号</b><b>链</b><b>接</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">本实验将展示符号链接和硬链接之间的主要差异（即便是在处理同一个卷上的文件时）。创建一个名为soft.txt的符号链接，将其指向上一个实验中创建的test.txt文件：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;mklink soft.txt test.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">symbolic link created for soft.txt &lt;&lt;===&gt;&gt; test.txt </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">显示目录内容会发现，该符号链接不显示文件大小，并标识为&lt;SYMLINK&gt;类型。此外还会看到，创建时间对应于符号链接，而非目标文件的创建时间。符号链接还可以使用与目标文件不同的安全权限。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;dir *.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> Volume in drive C is OS </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> Volume Serial Number is 38D4-EA71 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> Directory of C:\</span></p>
</div><div class="header0"><h1><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h1></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">05/12/2012 11:55 PM                 8 hard.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">05/13/2012 12:28 AM    &lt;SYMLINK&gt;      soft.txt [test.txt] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">05/12/2012 11:55 PM                 8 test.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">              3 File(s)             16 bytes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">              0 Dir(s)  10,636,480,512 bytes free </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">最后，如果删除了源文件test.txt，则可以看到硬链接和符号链接都还存在，但符号链接已经不再指向有效的文件，而硬链接依然指向文件数据。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_249" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>1</b><b>2</b><b> </b><b>压</b><b>缩</b><b>和</b><b>稀</b><b>疏</b><b>文</b><b>件</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS支持文件数据压缩。NTFS会以透明的方式执行压缩和解压缩，应用程序无须任何改动即可使用该功能。目录也可以压缩，这样，以后在目录中创建的任何文件都会被压缩。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了压缩和解压缩文件，应
用程序可向DeviceIoControl传递文件系统控制代码FSCTL_SET_COMPRESSION。该控制代码可利用文件系统控制代码
FSCTL_GET_COMPRESSION查询文件或目录的压缩状态。被压缩的文件或目录会在属性中设置
FILE_ATTRIBUTE_COMPRESSED标记，因此，应用程序也可以使用GetFileAttributes来确定文件或目录的压缩状态。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">第二类压缩称为稀疏文件
（sparse 
file）。如果文件被标记为稀疏，则NTFS将不为文件中被应用程序指定为空的区域在卷上分配空间。当应用程序从稀疏文件的空区域中读取时，NTFS将
返回用0填充的缓冲区。此类压缩很适合通过实施循环缓冲区来记录日志的客户端/服务器应用程序，这种情况下，服务器会将信息记录到一个文件中，客户端以异
步方式读取日志信息。由于服务器写入的信息在客户端读取之后不再需要，因此无须将信息存储在文件中。通过让这种文件成为稀疏文件，客户端可将自己从文件中
读取过的部分指定为“空”，这样即可释放卷的空间。服务器可以继续向文件中追加新信息，而不用担心文件增长过大消耗了卷上的所有可用空间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与压缩文件类似，NTFS
会以透明的方式管理稀疏文件。应用程序通过向DeviceIoControl传递文件系统控制代码FSCTL_SET_SPARSE来指定一个文件的稀疏
状态。要将文件的范围设置为空，应用程序可以使用FSCTL_SET_ZERO_DATA代码，并可使用控制代码
FSCTL_QUERY_ALLOCATED_RANGES向NTFS要求描述文件中的哪些部分是稀疏的。下文即将介绍的NTFS变更日志就是稀疏文件的
一种应用。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_250" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>1</b><b>3</b><b> </b><b>变</b><b>更</b><b>日</b><b>志</b><b>记</b><b>录</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">很多类型的应用程序需要监
控卷中文件和目录的变化。例如，自动备份程序可能会执行一个初始的完整备份，随后根据文件改动执行增量备份。应用程序监视卷中的变化情况最显而易见的一种
做法就是扫描整个卷，记录所有文件和目录的状态，并在后续扫描中检测两次扫描之间产生的差异。但这种方法会严重拖累系统性能，如果计算机中包含成千上万个
文件，则情况将更为严重。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">作为一种替代方案，应用程
序可以使用Windows的FindFirstChangeNotification或ReadDirectoryChangesW函数注册目录通知。应
用程序只需以输入参数的方式指定自己要监视的目录名称，只要目录的内容发生变化，函数就会返回结果。虽然这种方式比全卷扫描更高效，但要求应用程序随时处
于运行状态。使用这些函数同样要求应用程序扫描目录，因为FindFirstChangeNotification只能告知应用程序目录中发生了变更，但
无法告知具体发生了什么变更。应用程序可以向ReadDirectoryChangesW传递一个缓冲区，这样文件系统驱动程序就可以负责将变更记录填入
其中。然而，如果缓冲区溢出，应用程序就必须准备退而求其次地对整个目录进行扫描。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了克服上述两种方式的不
足，NTFS还提供了第三种方法：应用程序可以使用DeviceIoControl函数的FSCTL_CREATE_USN_JOURNAL（USN是指
更新序列号）文件系统控制代码来配置NTFS变更日志（Change 
Journal）设施。这样，NTFS便会将有关文件和目录变更的信息记录到一个名为变更日志的内部文件中。变更日志通常足够大，几乎可以保证应用程序总
是有机会处理变更，而不会错过任何信息。应用程序可以使用FSCTL_QUERY_USN_JOURNAL文件系统控制代码从变更日志中读取记录，并可指
定在有可用新记录的情况下，DeviceIoControl函数始终不允许完成。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_251" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>1</b><b>4</b><b> </b><b>每</b><b>用</b><b>户</b><b>卷</b><b>配</b><b>额</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统管理员通常需要跟踪或
限制用户在共享存储卷上使用的磁盘空间，因此，NTFS提供了配额管理功能。NTFS的配额管理可以为每个用户强制指定配额，借此可以方便地跟踪用量并了
解用户何时会触及警报阈值和限制阈值。经过配置，如果用户超过了自己的警报限制，NTFS还可以向系统事件日志中记录一条代表这种情况的事件。类似地，如
果用户试图使用超过配额限制的存储容量，NTFS也可以在系统事件日志中记录事件，并且可以让导致配额超限的应用程序文件I/O因为“磁盘已满”的错误而
失败。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS依赖创建文件和目
录的用户的安全标识符（SID）来跟踪用户使用的容量（SID的详细信息请参阅卷1第7章）。用户所拥有的文件和目录的逻辑大小会被统计到管理员为用户定
义的配额限制中。因此，用户无法通过创建一个大于配额限制的稀疏文件，随后用非零数据填充该文件的方式规避配额限制。类似地，虽然50KB的文件可能压缩
到10KB，但在计算配额时将会记作完整的50KB。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">默认情况下，卷并未启用配
额跟踪。我们需要使用卷属性对话框的配额选项卡（见图11-25）来启用配额，指定默认的警报和限制阈值，并配置用户达到警报或限制配额后的NTFS行
为。从该对话框中打开的配额项工具可供管理员为每个用户指定不同的限制和行为。应用程序如果需要与NTFS配合管理机制交互，则可使用COM配额接口，包
括IDiskQuotaControl、IDiskQuotaUser以及IDiskQuotaEvents。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4db247d4f889a9b6593d438c3fba5f51.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-25 通过卷属性对话框打开的配额设置对话框</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_252" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>1</b><b>5</b><b> </b><b>链</b><b>接</b><b>跟</b><b>踪</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">外壳（Shell）快捷方
式可以让用户将文件放置在自己的外壳命名空间（如自己的桌面上），再将其链接至文件系统命名空间中的文件。Windows开始菜单就大量使用了外壳的快捷
方式。类似地，对象链接和嵌入（OLE）链接可以将来自一个应用程序的文档以透明的方式嵌入另一个应用程序的文档中。微软Office办公套件中的
PowerPoint、Excel和Word等都使用了OLE链接。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然外壳链接和OLE链接
提供了一种将不同的文件相互连接，以及将文件与外壳命名空间相互连接的简单方法，但如果用户移动了外壳或OLE链接源（链接源是指链接指向的文件或目
录），最终可能会变得非常难以管理。Windows中的NTFS支持一种名为分布式链接跟踪的服务应用程序，借此可在目标移动后维持外壳和OLE链接的完
整性。借助对NTFS链接跟踪的支持，如果位于NTFS卷上的链接目标移动到原始卷域内任何其他的NTFS卷上，链接跟踪服务可以透明地跟踪移动操作，并
更新链接以反映变化。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS链接跟踪支持基于
一种可选文件属性：对象ID。应用程序可以使用FSCTL_CREATE_OR_GET_OBJECT_ID（借此在未分配的情况下分配ID）和
FSCTL_SET_OBJECT_ID文件系统控制代码向文件分配对象ID。对象ID可使用
FSCTL_CREATE_OR_GET_OBJECT_ID和FSCTL_GET_OBJECT_ID文件系统控制代码查询。
FSCTL_DELETE_OBJECT_ID文件系统控制代码可以让应用程序从文件中删除对象ID。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_253" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>1</b><b>6</b><b> </b><b>加</b><b>密</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">企业用户通常会在计算机上
存储敏感信息。虽然存储在公司服务器上的数据通常会使用适当的网络安全设置和物理访问控制机制加以妥善保护，但笔记本电脑中存储的数据在笔记本电脑丢失或
被盗后往往会面临风险。此时无法通过NTFS文件权限获得所需的保护，因为只要用非Windows平台的NTFS文件读取软件，就可以忽略这些安全设置而
完整访问NTFS卷中的文件。此外，如果使用另一个Windows系统以管理员账户访问这些文件，NTFS文件权限也将失去作用。卷1第6章曾经提到，管
理员账户具备“获取所有权”和“备份”特权，这两项特权使得管理员只需覆盖对象的安全设置，即可访问任何可保护对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS包含了一项名为加
密文件系统（Encrypting File 
System，EFS）的设施，用户可以借此加密敏感数据。EFS的操作与文件压缩的类似，对应用程序完全透明，这意味着当使用获得授权的用户账户运行的
应用程序需要读取数据时，文件数据可以自动解密，在获得授权的应用程序更改数据后，数据也可以自动加密。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
NTFS不允许加密位于系统卷根目录或\Windows目录中的文件，因为这里的很多文件是系统启动过程必需的，而启动阶段EFS尚未激活。如果希望加密
这些文件，BitLocker是一种更适合的技术，它可以支持全卷加密。下文将会提到，BitLocker可以与NTFS配合实现文件加密。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">用户模式下的EFS依赖于Windows提供的加密服务，因此，它既包含与NTFS紧密集成的内核模式组件，也包含负责与本地安全机构子系统（LSASS）和加密DLL通信的用户模式DLL。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">被加密的文件只能通过账户EFS私钥/公钥对中的私钥来访问，私钥则会使用账户的密码锁定。对于丢失或被盗的笔记本电脑中的EFS加密文件，如果无法得知具备授权账户的密码，则将无法通过任何手段查看（除非暴力破解攻击）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">应用程序可使用
Windows的EncryptFile和DecryptFile 
API函数来加密与解密文件，并使用FileEncryptionStatus检索与文件或目录EFS有关的属性，例如，文件或目录是否被加密。被加密的
文件或目录会在属性中设置FILE_ATTRIBUTE_ENCRYPTED标记，因此，应用程序也可以通过GetFileAttributes判断文件
或目录的加密状态。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_254" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>1</b><b>7</b><b> </b><b>P</b><b>O</b><b>S</b><b>I</b><b>X</b><b>风</b><b>格</b><b>的</b><b>删</b><b>除</b><b>语</b><b>义</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">POSIX子系统已被废
弃，无法在Windows操作系统中使用。Windows Subsystem for 
Linux（WSL）取代了最初的POSIX子系统。NTFS文件系统驱动程序已经通过更新统一了Windows和Linux中在对I/O的操作支持方面
存在的一些差异。例如，Linux的unlink（或rm）命令，可以删除文件或文件夹。在Windows中，应用程序无法删除正在被其他应用程序使用的
文件（文件有打开的句柄）；相反，Linux通常支持这种做法：在源文件已被删除的情况下，其他进程依然可以正常运行。为了支持WSL，Windows 
10中的NTFS文件系统驱动程序支持一种新操作，即POSIX Delete。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Win32 
DeleteFile 
API实现了标准的文件删除。目标文件将被打开（新建一个句柄），再通过NtSetInformationFile这个原生API为文件附加一个处置标
签。该标签只是告诉NTFS文件系统驱动程序该文件即将被删除。文件系统驱动程序会检查对FCB（文件控制块）的引用数量是否等于1，这意味着该文件没有
其他未处理的打开句柄。如果等于1，则文件系统驱动程序会将文件标记为“关闭时删除”并返回。只有在文件句柄关闭之后，IRP_MJ_CLEANUP调度
例程才会从底层介质中将该文件物理删除。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">但类似的架构无法兼容
Linux的unlink命令。WSL子系统需要删除文件时，会采用POSIX风格的删除：使用新增的
FileDispositionInformationEx信息类调用NtSetInformationFile的原生API，指定一个标记
（FILE_DISPOSITION_POSIX_SEMANTICS）。NTFS文件系统驱动程序通过在CCB（上下文控制块，一种代表磁盘上对象的打
开实例的数据结构）中插入一个标记的方式将文件标记为“POSIX删除”。随后它会用一个特殊的内部例程重新打开该文件，将新句柄（可以称为
PosixDeleted句柄）附加给SCB（流控制块）。在原始句柄关闭后，NTFS文件系统驱动程序会检测是否存在PosixDeleted句柄，并
将关闭该句柄的工作项加入队列。该工作项完成后，清理例程检测到该句柄已标记为“POSIX删除”，随后将该文件从物理上移至隐藏目录“\
$Extend\$Deleted”。其他文件依然可以对源文件执行操作，但该文件已不再位于原始的命名空间中，只有当最后一个句柄关闭后，该文件才会被
删除（第一个删除请求已将FCB标记为“关闭时删除”）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果因任何不寻常原因导致系统无法删除目标文件（例如有缺陷的内核驱动造成了悬空引用，或突然断电），当NTFS文件系统下次有机会挂载该卷时，会检查\$Extend\$Deleted目录，并使用标准文件删除例程删除其中的所有文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 从2019年5月更新（19H1）开始，Windows 10已经使用POSIX delete作为默认文件删除方法。这意味着DeleteFile API也将表现出全新的行为。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>观</b><b>察</b><b>P</b><b>O</b><b>S</b><b>I</b><b>X</b><b>删</b><b>除</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
这个实验中，我们将借助本书随附资源中包含的FsTool工具观察POSIX删除的运作。该实验需要在Windows Server 
2019（RS5）版本中进行。实际上，更新的客户端版本Windows已经默认实现了POSIX删除。首先打开一个命令提示符窗口，使用FsTool的
命令行参数/touch生成一个被应用程序独占使用的txt文件：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">D:\&gt;FsTool.exe /touch d:\Test.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">NTFS /ReFS Tool v0.1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright (C) 2018 Andrea Allievi (AaLl86) </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Touching "d:\Test.txt" file... Success. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   The File handle is valid... Press Enter to write to the file. </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">看到上述提示后，不要按下回车键，打开另一个命令提示符窗口，然后试着打开并删除该文件：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">D:\&gt;type Test.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">The process cannot access the file because it is being used by another process. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">D:\&gt;del Test.txt </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">D:\&gt;dir Test.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> Volume in drive D is DATA </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> Volume Serial Number is 62C1-9EB3 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> Directory of D:\</span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">12/13/2018  12:34 AM                 49 Test.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">               1 File(s)             49 bytes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">               0 Dir(s)  1,486,254,481,408 bytes free </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">毫
不意外，在被FsTool独占访问时，我们无法打开该文件。试图删除该文件时，系统会将其标记为删除，但系统无法将其从文件系统命名空间中移除。如果尝试
通过文件资源管理器再次删除该文件，也将遇到类似的行为。当我们在第一个命令提示符窗口中按下回车键并退出FsTool工具时，该文件实际上已经被
NTFS文件系统驱动程序删掉了。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">下一步是使用POSIX删除来处理该文件。为此可以为FsTool工具指定命令行参数/pdel。在第一个命令提示符窗口中使用命令行参数/touch重启动FsTool（源文件已标记为删除，无法再次删除）。按下回车键之前，切换至第二个窗口并执行下列命令：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">D:\&gt;FsTool /pdel Test.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">NTFS /ReFS Tool v0.1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright (C) 2018 Andrea Allievi (AaLl86) </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Deleting "Test.txt" file (Posix semantics)... Success. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Press any key to exit... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">D:\&gt;dir Test.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> Volume in drive D is DATA </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> Volume Serial Number is 62C1-9EB3 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> Directory of D:\</span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File Not Found </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">这次Test.txt文件已完全从文件系统的命名空间中删除，但依然有效。如果在第一个命令提示符窗口中按下回车键，FsTool依然可以向文件写入数据。这是因为在内部，该文件已被移入\$Extend\$Deleted隐藏系统目录。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_255" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>1</b><b>8</b><b> </b><b>碎</b><b>片</b><b>整</b><b>理</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然NTFS在分配块进而
扩展文件时会尽可能地保持文件的连续，但随着时间的推移，卷上的文件不可避免地会变得碎片化，尤其是当文件被多次扩展或可用空间较为有限时。如果一个文件
的数据占据了不连续的簇，那么该文件就是碎片化的。例如，图11-26展示了一个包含五个片段的碎片化文件。不过与大部分文件系统（包括Windows中
的FAT）一样，除了为主文件表（MFT）预留一块名为MFT的磁盘空间区域外，NTFS在保持文件连续性方面并没有做太多的工作（而是由系统自带的碎片
整理工具负责）（卷的可用空间不足时，NTFS可以让其他文件从MFT区域分配空间）。为MFT保留可用区域有助于让它保持连续，但MFT依然不可避免地
会变得碎片化（有关MFT的详细信息请参阅下文“主文件表”一节）。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/28666e39447fefa79d02c05f71244cb2.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-26 碎片化文件和连续文件</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了促进第三方磁盘碎片整
理工具的开发，Windows提供了碎片整理API，此类工具可通过这些API移动文件数据，并让文件分布在连续的簇上。该API由文件系统控件组成，可
让应用程序获得卷的可用和已用簇分布图（FSCTL_GET_VOLUME_BITMAP），获得文件的簇使用情况图
（FSCTL_GET_RETRIEVAL_POINTERS），并移动文件（FSCTL_MOVE_FILE）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows自带一个碎
片整理工具，可通过驱动器优化工具（%SystemRoot%\System32\Dfrgui.exe）访问，如图11-27所示；该工具提供了命令行
接口（%SystemRoot%\System32\Defrag.exe），这样即可以非交互式方式或计划方式运行，但命令行接口无法提供丰富的报告或
控制选项（例如排除某些文件或目录）。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b7cda9919bf7d583f7513bee4b67e9de.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-27 驱动器优化工具</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS中实现的碎片整理
机制唯一的局限在于：无法整理分页文件和NTFS日志文件的碎片。驱动器优化工具是磁盘碎片整理工具的改进版本，最早出现在Windows 
7中。该工具通过更新，已经可以支持分层卷、SMR磁盘以及SSD固态硬盘。其优化引擎实现于驱动器优化服务（Defragsvc.dll）中，公开了图
形化工具和命令行接口所用的IDefragEngine COM接口。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于固态硬盘，该工具也实
现了重新修剪（Retrim）操作。为了理解重新修剪操作，首先需要简要介绍固态硬盘的结构。固态硬盘将数据存储在闪存单元中，这些闪存单元被分组为
4KB～16KB的页，通常每128～512个页组合成一个块。只有空的闪存单元可被直接写入。如果其中包含数据，则必须先清除现有数据才能执行写入操
作。固态硬盘的写入操作可以在单个页上进行，但由于硬件本身的限制，清除命令将作用于整个块。因此，向固态硬盘的空页中写入数据是一种很快速的操作，但如
果要向已经包含内容的页写入新数据，速度将变得非常慢（这种情况下，需要首先将整个块的内容存储到缓存中，随后将整个块的内容清除，被覆盖的页被写入缓存
的块中，最终将更新后的整个块重新写入闪存介质）。为了解决此问题，NTFS文件系统驱动程序会在每次删除磁盘簇（这些簇可能部分属于或完全属于同一个文
件）时向SSD控制器发送TRIM命令。作为对TRIM命令的回应，SSD会在可能的情况下开始异步清除整个块。值得注意的是，如果被删除的区域只对应了
块中的部分页，那么SSD控制器将无法执行任何操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">重新修剪操作会分析固态硬盘并开始向可用空间中的每个簇发送TRIM命令（以1MB大小的块为单位）。这样做的背后有不同的动机。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·TRIM命令并非总能成功发出（文件系统对修剪的要求并不是非常严格）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·NTFS文件系统会对页（而非SSD块）发送TRIM命令。磁盘优化工具在执行重新修剪操作时，会搜索碎片化的块。对于这些块，首先会将有效数据移动到一些临时块中，对原始块进行碎片整理甚至插入属于其他碎片化块的偶数页，并最终针对清理后的原始块发送TRIM命令。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
磁盘优化工具对可用空间发送TRIM命令的方式有些巧妙：磁盘优化工具会分配一个空的稀疏文件并搜索一块可用空间（大小在128KB～1GB之间）。随后
它会通过FSCTL_MOVE_FILE控制代码调用文件系统，并将数据从稀疏文件（大小为1GB，但实际上不包含任何有效数据）移动到空区域。底层文件
系统实际上会清除一个或多个SSD块的内容（不包含有效数据的稀疏文件在读取时会产生归零的数据块）。这就是SSD固件中实现的TRIM命令。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于分层磁盘和SMR磁
盘，驱动器优化工具支持两个补充操作：Slabify（也叫Slab合并）和分层优化（Tier 
Optimization）。存储在分层卷上的大文件可由位于不同层的区域（Extent）组成。Slab合并操作不仅可对文件的区域表（Extent 
Table）整理碎片（这个过程称为合并），而且可将文件内容移动到叠合的Slab中（Slab是精简配置磁盘中的分配单位，详见下文“存储空间”一
节）。Slab的最终目标是让文件使用较少数量的Slab。分层优化可将频繁访问的文件（包括已被明确固定的文件）从容量层移动到性能层，以及将不频繁访
问的数据从性能层移动到容量层。为此，优化引擎需要查询分层引擎，分层引擎会根据用户访问每个文件的热度图，告诉优化引擎该将哪些文件区域移动到容量层，
以及将哪些移动到性能层。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 分层磁盘和分层引擎将在下文中详细介绍。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>重</b><b>新</b><b>修</b><b>剪</b><b>S</b><b>S</b><b>D</b><b>卷</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以使用defrag.exe /L命令针对高速SSD或NVMe的卷执行重新修剪：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">D:\&gt;defrag /L c: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Microsoft Drive Optimizer </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright (c) Microsoft Corp. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Invoking retrim on (C:)... </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">The operation completed successfully. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Post Defragmentation Report:</span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Volume Information: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">               Volume size              = 475.87 GB </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                Free space              = 343.80 GB</span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Retrim: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                 Total space trimmed      = 341.05 GB </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在上述例子中，卷的大小为475.87GB，可用空间343.80GB，仅341GB被擦除和修剪了。很明显，如果对传统机械硬盘上的卷执行上述命令将会收到错误信息（备份卷的硬件不支持请求的操作）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_256" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>1</b><b>9</b><b> </b><b>动</b><b>态</b><b>分</b><b>区</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS驱动程序允许用户动态调整任何分区（包括系统分区）的大小，借此收缩
	<sup><img width="11" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="此处的“收缩”（Shrinking）在简体中文版Windows中称为“压缩”，但因易与NTFS文件压缩（Compression）功能的“压缩”以及Zip压缩格式等“压缩”混淆，因而此处使用“收缩”。——译者注" title="此处的“收缩”（Shrinking）在简体中文版Windows中称为“压缩”，但因易与NTFS文件压缩（Compression）功能的“压缩”以及Zip压缩格式等“压缩”混淆，因而此处使用“收缩”。——译者注" class="epub-footnote"></sup>或
扩展（前提是有足够的可用空间）分区。如果磁盘上有足够的空间，扩展分区实际上非常容易，只需FSCTL_EXPAND_VOLUME文件系统控制代码即
可实现。分区收缩则是一个较为复杂的过程，因为要把希望减去的区域中目前存储的文件系统数据移动到收缩结束后依然保留的区域内（为此会采用一种类似碎片整
理的机制）。收缩是通过两个组件实现的：收缩引擎和文件系统驱动程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">收缩引擎实现于用户模式
下。它会与NTFS通信以确定可回收的最大字节数，即有多少数据可以从即将被减去的区域中移动至收缩之后依然保留在卷中的区域内。收缩引擎会使用上文提到
的标准碎片整理机制，因此无法支持重新定位正在使用中的分页文件碎片以及其他任何已经被FSCTL_MARK_HANDLE文件系统控制代码标记为不可移
动的文件（如休眠文件）。主文件表的备份（$MftMirr）、NTFS元数据事务日志（$LogFile）以及卷标文件（$Volume）无法移动，这
也限制了卷收缩后的最小大小，进而导致了空间的浪费。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">文件系统驱动程序收缩代码负责保证卷在整个收缩过程中保持一致的状态。为此它公开了一个接口，可使用三个请求描述当前操作，这些请求会通过FSCTL_SHRINK_VOLUME控制代码发出。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·ShrinkPrepare
请求，必须先于其他任何操作发出。该请求能以扇区为单位获取所需的新卷的大小，这样文件系统就可以阻止在新卷边界之外的后续分配。
ShrinkPrepare请求并不会验证卷是否可以按照指定的容量缩小，但它保证了该容量在数值上是有效的，并保证没有正在进行中的其他收缩操作。请注
意，准备操作结束后，卷的文件句柄会与收缩请求相关联。如果文件句柄被关闭，则操作会认定为被中止。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·ShrinkCommit
请求，由收缩引擎在ShrinkPrepare请求之后发出。这种状态下，文件系统会尝试删除最近一次准备请求中所请求数量的簇（如果有多个准备请求设置
了不同的大小，则以最后一个请求的大小为准）。ShrinkCommit请求会假设收缩引擎已完成运行，如果要减去的区域内还存在任何已分配块，则意味着
失败。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·ShrinkAbort请求，可由收缩引擎发出，或由某些事件（如卷的文件句柄被关闭）产生。该请求可将分区还原为最初的大小并再次允许在原本需要减去的区域内重新进行分配，借此撤销ShrinkCommit操作。不过收缩引擎做的碎片整理工作依然会保留。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果系统在收缩过程中重启动，NTFS会通过本章下文即将介绍的元数据恢复机制将文件系统恢复到一致的状态。由于实际的收缩操作是在所有其他操作都完成之后才执行的，因此卷会保持自己的原始大小，只有已经刷新到磁盘的碎片整理结果会被永久保留。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后，收缩卷操作会对卷的
卷影复制（shadow 
copy）机制产生一些影响。上文曾经提过，“写入时复制”机制可以让VSS只保留文件中实际被修改的部分，但同时依然链接到原始文件数据。对于已删除的
文件，其文件数据将不与任何可见文件相关联，而是以可用空间的形式呈现出来，这些可用空间很可能位于即将被收缩的区域中。因此，收缩引擎会与VSS通信，
使其参与到收缩过程中。总之，VSS机制的作用是将已删除文件的数据复制到自己的差分区域，并根据需要扩大差分区域以容纳更多数据。这个细节很重要，因为
它对卷可收缩的大小产生了另一个限制，即便有充足的可用空间的卷也会受到该限制的影响。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_257" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>0</b><b>.</b><b>2</b><b>0</b><b> </b><b>N</b><b>T</b><b>F</b><b>S</b><b>对</b><b>分</b><b>层</b><b>卷</b><b>的</b><b>支</b><b>持</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">分层卷是由不同类型的存储
设备和底层存储介质构成的。分层卷通常是在单个物理或虚拟磁盘的基础上创建的。存储空间提供的虚拟磁盘可由多个物理磁盘组成，这些磁盘可以使用不同的类型
（以及不同的性能表现）：高速NVMe磁盘、SSD以及传统机械硬盘。此类虚拟磁盘就称为分层磁盘（存储空间中使用的术语是“存储层”）。另外，分层卷可
以在物理SMR磁盘的基础上创建，这类SMR磁盘包含传统的“随机访问”高速区域和“严格顺序访问”容量区域。所有分层卷都有一个共同特点：它们由支持高
速随机I/O的“性能”层，以及可能支持或不支持随机I/O、速度更慢，但容量更大的“容量”层共同组成。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> SMR磁盘、分层卷和存储空间的详细信息请参阅本章下文。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS文件系统驱动程序通过多种方式为分层卷提供了支持。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·卷被拆分为两个区域，分别对应于分层的磁盘区域（容量区域和性能区域）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·新增的$DSC特性（类型为$LOGGED_UTILITY_STREAM）指定了要将文件存储到哪一层。NTFS公开了一个新增的“固定”接口，借此可将文件锁定到指定的层（“固定”这种说法由此而来），同时可防止文件被分层引擎移动到其他层。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
存储层管理服务在支持分层卷中起着核心的作用。每当读写文件流时，NTFS文件系统驱动程序会记录ETW“热度”事件。分层引擎可使用这些事件，通过累积
（为1MB的块）并定期将其记录至一个JET数据库中（每小时记录一次）。这样每隔4小时，分层引擎会处理热度数据库一次，并通过一种复杂的“热度老
化”算法来决定哪些文件是新的（热文件），哪些是旧的（冷文件）。分层引擎会根据计算而来的热度数据在性能和容量层间移动文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，NTFS分配器通过更新，已经可以根据$DSC特性指定的分层区域来分配文件簇。NTFS分配器可使用特定算法来决定要将卷的簇分配到哪一层。该算法的操作将按照以下顺序进行检查。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）如果文件是卷USN日志，则始终从容量层分配。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）MFT项（文件记录）和系统元数据文件始终从性能层分配。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）如果文件曾被明确“固定”（意味着文件具备$DSC特性），则从指定的存储层分配。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）如果系统为客户端版Windows，则始终优先选择性能层；否则会从容量层分配。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">5）如果性能层没有空间，则从容量层分配。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">应用程序可以使用
NtSetInformationFile 
API配合FileDesiredStorageClassInformation信息类为文件指定期望的存储层。该操作也称文件固定，如果在新创建文件
的句柄上执行该操作，中央分配器就会在指定的存储层中分配新的文件内容。否则，如果文件已经存在并且位于错误的存储层中，分层引擎会在下次运行时将文件移
动到正确的存储层（该操作也叫分层优化，可由分层引擎计划任务或SchedulerDefrag任务发起）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 需要注意的是，此处介绍的NTFS分层卷与ReFS文件系统驱动程序所提供的分层功能是截然不同的概念。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>分</b><b>层</b><b>卷</b><b>中</b><b>的</b><b>文</b><b>件</b><b>固</b><b>定</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如上文所述，NTFS分配器使用一种特定算法来决定要从哪个层分配。在这个实验中，我们会将一个大文件复制到分层卷，并观察文件固定操作的影响。复制完成后，请以管理员身份打开PowerShell窗口（右击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>开</b><b>始</b></span>”按钮，选择“Windows PowerShell<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>（</b><b>管</b><b>理</b><b>员</b><b>）</b></span>”），随后使用Get-FileStorageTier命令获取文件的分层信息：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PS E:\&gt; Get-FileStorageTier -FilePath 'E:\Big_Image.iso' | FL FileSize, </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">DesiredStorageTierClass, FileSizeOnPerformanceTierClass, FileSizeOnCapacityTierClass,</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PlacementStatus, State </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">FileSize                       : 4556566528 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">DesiredStorageTierClass        : Unknown </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">FileSizeOnPerformanceTierClass : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">FileSizeOnCapacityTierClass    : 4556566528 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PlacementStatus                : Unknown </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">State                          : Unknown </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">上
述例子显示，Big_Image.iso文件已经从容量层获得了分配（该例是在Windows 
Server系统上执行得到的）。为了确认这一点，可以将该文件从分层磁盘复制到一个高速SSD卷。可以看到传输速率很慢（取决于机械硬盘速度，通常在
160～250MB/s之间）：</span></p><div style="display: block;text-align:center;">
	<img width="570" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/731c2782470b14291788c5c968b8ea14.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后即可通过Set-FileStorageTier命令执行“固定”操作，例如：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PS E:\&gt; Get-StorageTier -MediaType SSD | FL FriendlyName, Size, FootprintOnPool, UniqueId </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">FriendlyName    : SSD </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Size            : 128849018880 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">FootprintOnPool : 128849018880 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">UniqueId        : {448abab8-f00b-42d6-b345-c8da68869020} </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PS E:\&gt; Set-FileStorageTier -FilePath 'E:\Big_Image.iso' -DesiredStorageTierFriendlyName</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">'SSD' </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PS E:\&gt; Get-FileStorageTier -FilePath 'E:\Big_Image.iso' | FL FileSize, </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">DesiredStorageTierClass, FileSizeOnPerformanceTierClass, FileSizeOnCapacityTierClass,</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PlacementStatus, State </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">FileSize                       : 4556566528 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">DesiredStorageTierClass        : Performance </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">FileSizeOnPerformanceTierClass : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">FileSizeOnCapacityTierClass    : 4556566528 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PlacementStatus                : Not on tier </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">State                          : Pending </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">从上述范例可知，该文件已被正确固定到性能层，但它的内容依然在容量层中。当分层引擎计划任务开始运行后，会将文件区域从容量层移动到性能层。我们可以通过系统自带的defrag.exe /g工具运行驱动器优化工具，强制进行分层优化：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PS E:&gt; defrag /g /h e: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Microsoft Drive Optimizer </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright (c) Microsoft Corp. </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Invoking tier optimization on Test (E:)... </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Pre-Optimization Report: </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Volume Information: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                Volume size               = 2.22 TB </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                Free space                = 1.64 TB </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                Total fragmented space    = 36% </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                Largest free space size   = 1.56 TB </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Note: File fragments larger than 64MB are not included in the fragmentation statistics.</span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">The operation completed successfully. </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Post Defragmentation Report: </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Volume Information: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                Volume size               = 2.22 TB </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                Free space                = 1.64 TB </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Storage Tier Optimization Report: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                % I/Os Serviced from Perf Tier Perf Tier Size Required </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                100%                           28.51 GB * </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                95%                            22.86 GB </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                20%                            2.44 GB </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                15%                            1.58 GB </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                10%                            873.80 MB </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                5%                             361.28 MB </span></p>
</div><div class="header0"><h1><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h1></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        * Current size of the Performance tier: 474.98 GB </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">          Percent of total I/Os serviced from the Performance tier: 99% </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Size of files pinned to the Performance tier: 4.21 GB </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Percent of total I/Os: 1% </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Size of files pinned to the Capacity tier: 0 bytes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Percent of total I/Os: 0% </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">驱动器优化工具确认了文件已被“固定”。随后可再次执行Get-FileStorageTier命令查看其“固定”状态，或再次将该文件复制到SSD卷。这次传输速率将会提高很多，因为文件内容已完全位于性能层中。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PS E:\&gt; Get-FileStorageTier -FilePath 'E:\Big_Image.iso' | FL FileSize, Desire-</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> dStorageTierClass, FileSizeOnPerformanceTierClass, FileSizeOnCapacityTierClass,</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PlacementStatus, State</span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">FileSize                       : 4556566528 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">DesiredStorageTierClass        : Performance </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">FileSizeOnPerformanceTierClass : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">FileSizeOnCapacityTierClass    : 4556566528 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PlacementStatus                : Completely on tier </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">State                          : OK </span></p><div style="display: block;text-align:center;">
	<img width="598" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/d55485bd59122f16840659f16393ec73.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们可以在客户端版本的Windows 10中将文件固定到容量层，并重复该实验（客户端版Windows 
10默认会从性能层分配文件的簇）。相同的“固定”功能也包含在本书随附工具所提供的FsTool应用程序中，大家可以使用该工具直接将文件复制到希望使
用的存储层。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11_0011.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_258" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>1</b><b> </b><b>N</b><b>T</b><b>F</b><b>S</b><b>驱</b><b>动</b><b>程</b><b>序</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如卷1第6章所述，在
Windows I/O系统框架中，NTFS和其他文件系统其实是运行在内核模式下的可加载设备驱动程序。使用Windows或其他I/O 
API的应用程序可以间接调用这些驱动程序。如图11-28所示，Windows环境子系统调用Windows系统服务，后者随后找到适当的已加载驱动程
序并进行调用（有关系统服务调度的详细信息，请参阅第8章的“系统服务处理”一节）。</span></p><div style="display: block;text-align:center;">
	<img width="827" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4046e1b66a78848fb7dad19210f7fd9f.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-28 Windows I/O系统组件</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">分层驱动程序通过调用
Windows执行体的I/O管理器向彼此传递I/O请求。通过以I/O管理器作为中介，每个驱动程序可以保持独立，可在不影响其他驱动程序的情况下加载
或卸载。此外，NTFS驱动程序还与其他三个Windows执行体组件进行交互，如图11-29所示，这些组件均与文件系统密切相关。</span></p><div style="display: block;text-align:center;">
	<img width="848" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/22afb99546bbda4015314a2a0a7031ce.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-29 NTFS和相关组件</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">日志文件服务（LFS）是NTFS的一部分，为维护磁盘写入日志提供服务。LFS写入的日志文件可用于在系统故障后恢复NTFS格式的卷（详见下文“日志文件服务”一节）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，缓存管理器是
Windows执行体组件，负责为NTFS和其他文件系统驱动程序（包括网络文件系统驱动程序的服务器和重定向器）提供系统级缓存服务。所有为
Windows实现的文件系统都通过映射至系统地址空间，随后访问虚拟内存的方式来访问缓存的文件。为此，缓存管理器为Windows内存管理器提供了一
个专门的文件系统接口。当程序试图访问文件中尚未载入缓存的部分（缓存缺失）时，内存管理器会调用NTFS来访问磁盘驱动程序，进而从磁盘上获取文件内
容。缓存管理器为了优化磁盘I/O，还会使用自己的惰性写入器线程调用内存管理器，以通过后台活动的方式将缓存内容刷新至磁盘（异步磁盘写入）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与其他文件系统类似，NTFS也通过将文件实现为对象的方式参与了Windows的对象模型。这种实现使得文件可以被对象管理器共享和保护，而Windows的对象管理器组件管理了所有执行体级别的对象（详见第8章的“对象管理器”一节）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">应用程序创建与访问文件的
方式与对待其他Windows对象的方式相同：使用对象句柄。当I/O请求到达NTFS时，Windows对象管理器和安全系统已经验证了调用方的进程在
尝试访问文件对象的方式上具有权限。安全系统已经对比了调用方的访问令牌以及文件对象的访问控制列表项（访问控制列表详见卷1第7章）。I/O管理器也已
将文件句柄转换为指向文件对象的指针。NTFS会使用文件对象中的这些信息来访问磁盘上的文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图11-30展示了将文件句柄链接至文件系统的磁盘结构的数据结构。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/397dbf64719de89257385556e9bb1551.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-30 NTFS数据结构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS会根据几个指针从
文件对象获取磁盘上文件的对应位置。如图11-30所示，文件对象表示对“打开文件”系统服务的一次调用，文件对象指向调用方试图读/写的文件特性的流控
制块（SCB）。在图11-30中，一个进程同时打开了一个文件的未命名数据属性和命名流（备用数据属性）。SCB代表文件的每个属性，其中包含如何在文
件中找到特定属性所需的信息。文件的所有SCB都指向一个名为文件控制块（FCB）的通用数据结构。FCB中包含一个指针（实际上这是MFT中的索引，详
见下文“文件记录号”一节），该指针指向文件在基于磁盘的主文件表（MFT）中的记录，下文将详细介绍MFT。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11_0012.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_259" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b> </b><b>N</b><b>T</b><b>F</b><b>S</b><b>的</b><b>磁</b><b>盘</b><b>结</b><b>构</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">本节介绍了NTFS卷的磁盘结构，包括如何划分磁盘空间并将其整理成簇、如何将文件整理成目录、如何将文件数据和特性信息存储到磁盘中，还将介绍NTFS数据压缩的工作原理。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_260" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>1</b><b> </b><b>卷</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS的结构以卷
（volume）开始。卷对应磁盘上的一个逻辑分区，是在我们将部分或全部磁盘格式化为NTFS的过程中创建的。我们也可以使用存储空间功能创建涵盖多个
物理磁盘的RAID虚拟磁盘，为此可以使用控制面板中的“管理存储空间”管理单元，或使用Windows 
PowerShell中的存储空间相关命令（如New-StoragePool命令，可新建存储池。存储空间功能的完整PowerShell命令列表可访
问：https://docs.microsoft.com/powershell/module/storagespaces/）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">一个磁盘上可以包含一个或多个卷。NTFS对每个卷的处理都独立于其他卷。图11-31展示了一个总容量为2TB的磁盘包含三种不同磁盘配置的范例。</span></p><div style="display: block;text-align:center;">
	<img width="892" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/0a3dea38fa7a1f95ef208259ccad24ba.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-31 磁盘配置范例</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">卷是由一系列文件以及磁盘分区中剩余的未分配空间组成的。在所有FAT文件系统中，卷也包含了专门格式化并供文件系统使用的区域。不过NTFS卷或ReFS卷会将所有文件系统数据（如位图和目录，甚至系统自举程序）存储为普通文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 在Windows 10和Window Server 2019中，NTFS卷的磁盘格式为3.1版，该版本自Windows XP和Windows Server 2003时就在使用。卷的版本号存储在$Volume元数据文件中。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_261" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>2</b><b> </b><b>簇</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">当用户使用format命
令或磁盘管理控制台MMC插件格式化卷时，NTFS卷上的簇（cluster）大小（也叫簇因子，cluster 
factor）就确定了。默认簇因子随着卷的不同大小而变化，但它始终是物理扇区的整数倍，并且总是2的幂（1个扇区、2个扇区、4个扇区、8个扇区，以
此类推）。簇因子以簇中的字节数来表示，例如512B、1KB、2KB等。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在内部，NTFS只引用簇
（不过NTFS会塑造底层卷I/O操作，使簇始终与扇区对齐，并且长度是扇区大小的倍数）。NTFS使用簇作为分配单元，以维持相对于物理扇区大小的独立
性。这种独立性使得NTFS可以通过使用更大的簇因子更高效地支持大容量磁盘，或者支持扇区大小超过512B的新磁盘。在更大的卷上，使用更大的簇因子有
助于降低碎片化程度并加速分配，但代价是会浪费一定的磁盘空间（如果簇大小为64KB，而文件大小仅为16KB，那么将有48KB被浪费）。命令行下的
format命令和磁盘管理控制台“操作”菜单中“所有任务”选项下的格式化菜单项都会根据卷大小选择默认的簇因子，但我们可以更改这个大小。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS通过逻辑簇编号
（Logical Cluster 
Number，LCN）引用磁盘上的物理位置。LCN可以理解为从卷首到卷尾的所有簇的编号。为了将LCN转换为物理磁盘地址，当磁盘驱动程序接口进行查
询时，NTFS会将LCN与簇因子相乘，得到卷上的物理字节偏移量。NTFS会通过虚拟簇编号（Virtual Cluster 
Number，VCN）的方式引用文件中的数据。VCN是指对属于特定文件的所有簇进行的编号，从0到m。不过VCN在物理上未必是物理连续的，它们可以
映射到卷上任意数量的LCN。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_262" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>3</b><b> </b><b>主</b><b>文</b><b>件</b><b>表</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在NTFS中，卷上存储的
所有数据（包括用于定位和检索文件的数据结构、自举数据，以及记录整个卷的分配状态的位图，即NTFS元数据）都包含在文件里。将一切存储在文件中，使得
文件系统可以轻松定位并维护数据，并用安全描述符为每个文件提供保护功能。此外，如果磁盘的某个部分损坏，NTFS也可以重新定位元数据文件，防止磁盘变
得无法访问。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">MFT（Master 
File 
Table，主文件表）是NTFS卷结构的核心。MFT可以实现为一个文件记录数组，每条文件记录的大小可以是1KB或4KB，这是在格式化卷时定义的，
取决于底层物理介质的类型：具备4KB原生扇区大小的新物理磁盘以及分层磁盘通常使用4KB的文件记录，具备512B扇区的老磁盘使用1KB的文件记录。
每个MFT项的大小并不取决于簇的大小，并可在格式化时使用Format 
/l命令更改（文件记录的具体结构请参阅下文“文件记录”一节）。从逻辑上来看，卷上的每个文件都在MFT中有一条对应的记录，甚至MFT本身也有一条记
录。除了MFT，每个NTFS卷还包含一系列元数据文件，其中保存了实现文件系统结构所需的信息。每个NTFS元数据文件的名称均以美元符号（$）开头，
都是隐藏文件。例如，MFT的文件名为$MFT。NTFS卷上的其他文件都是普通的用户文件和目录，如图11-32所示。</span></p><div style="display: block;text-align:center;">
	<img width="852" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/89a6996ba4da62a4be44567bea03042a.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-32 NTFS元数据文件在MFT中的文件记录</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">通常来说，每个MFT记录都对应一个不同的文件。然而，如果文件包含大量属性或变得高度碎片化，那么一个文件可能就需要多个记录。此时，存储了其他记录位置信息的第一个MFT记录往往称为基本文件记录（base file record）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当首次访问一个卷时，
NTFS必须首先挂载卷，也就是说，从磁盘读取元数据并构建内部数据结构，随后才能处理应用程序对文件系统的访问。为了挂载卷，NTFS会在卷启动记录
（Volume Boot Record，VBR，位于LCN 0中）中查找，VBR包含一种名为启动参数块（Boot Parameter 
Block，BPB）的数据结构，借此可以找到MFT的物理磁盘地址。MFT的文件记录是表中的第一项，第二条文件记录则指向磁盘中间位置一个名为MFT
镜像（文件名$MFTMirr）的文件，其中包含MFT中前四行内容的副本。如果MFT因某种原因无法读取，就可以使用这个不完整的MFT副本来定位元数
据文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS找到MFT的文件
记录后，就会在文件记录的数据属性中获取从VCN至LCN的映射信息，并将其保存在内存中。每次运行（有关“运行”的详细信息请参阅下文“常驻和非常驻属
性”一节）都会获得一个从VCN到LCN的映射和运行长度，因为任何VCN定位LCN都离不开这些信息。这个映射信息可以告诉NTFS包含MFT的运行在
磁盘上的位置。随后NTFS会处理其他几个元数据文件的MFT记录，并打开这些文件。接下来NTFS会执行文件系统恢复操作（详见下文“恢复”一节），并
最终打开其余元数据文件。至此，卷可供用户访问了。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 为保持简洁，本章的文字和图表将“运行”表示为一个VCN、一个LCN以及一个运行长度。实际上，NTFS会在磁盘上将这些信息压缩为一个“LCN/next-VCN”对。给定一个起始VCN后，NTFS就可以从下一个VCN中减去这个VCN，进而确定一个运行长度。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当系统运行时，NTFS会
向另一个重要的元数据文件，即日志文件（文件名$LogFile）写入数据。NTFS使用日志文件记录会对NTFS卷结构产生影响的所有操作包括可能改变
目录结构的文件创建或任何其他命令，例如复制。系统故障后，可以使用该日志文件恢复NTFS卷，详见下文“恢复”一节。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">MFT中还有一项是为根目
录（也叫“\”，例如“C:\”）保留的。它的文件记录中包含一个存储在NTFS根目录结构下的文件和目录的索引。当NTFS首次被要求打开一个文件时，
它会在根目录的文件记录中搜索该文件。打开文件后，NTFS会存储该文件的MFT记录号，这样读/写文件时就可以直接访问文件的MFT记录。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS会使用一个位图文件（文件名$BitMap）记录卷的分配状态。位图文件的数据属性包含一个位图，其中每一位都代表卷上的一个簇，借此即可识别每个簇是空闲还是已经分配给文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全文件（文件名
$Secure）存储了整个卷的安全描述符数据库。NTFS文件和目录都有可单独设置的安全描述符，但为了节约空间，NTFS会将这些设置存储在一个公共
文件中，这样使用相同安全设置的文件和目录就可以引用同一个安全描述符。在大部分环境中，整个目录树都会使用相同的安全设置，因此这项优化措施可大幅节约
磁盘空间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于系统卷，则会通过另一
个系统文件：启动文件（文件名$Boot）存储Windows的自举代码。如果试图从非系统卷启动，则这些代码会在屏幕上显示错误信息。为了让系统顺利启
动，自举代码必须位于特定磁盘地址，这样才能被启动管理器（Boot 
Manager）找到。在格式化过程中，format命令会通过为其创建文件记录的方式将这块区域定义为一个文件。所有文件都在MFT中，所有簇或者是空
闲的，或者已经分配给某个文件，NTFS中不存在隐藏的文件或簇，不过一些文件（元数据）对用户不可见。启动文件以及NTFS元数据文件也可以使用其他
Windows对象所用的安全描述符进行保护。而这种“磁盘上一切皆文件”的模型也意味着可以通过常规的文件I/O修改自举代码，不过启动文件会因受到保
护而禁止修改。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS还维持了一个坏簇
文件（文件名$BadClus），其中记录了磁盘卷上的所有已经故障的区域；此外还有一个名为卷文件的文件（文件名$Volume），其中包含了卷名称、
格式化卷所用的NTFS版本信息，以及代表卷状态和健康度的一系列标记位，例如会用一个位代表卷已损坏，必须使用Chkdsk工具修复（Chkdsk工具
详见下文）。大写字母文件（文件名$UpCase）包含了大写字母和小写字母之间的转换表。NTFS还维护了一个包含特性定义表的文件（文件名
$AttrDef），其中定义了卷支持的属性类型，以及这些属性是否可被索引，是否可在系统恢复操作中恢复信息等。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
图11-32展示了一个NTFS卷的主文件表，并标出了元数据文件对应的项。需要注意的是，第16条之前的文件记录，其顺序是可以保证固定不变的。第16
条之后的元数据文件，其顺序受制于NTFS创建这些记录的顺序。实际上，第16条之后的元数据文件都不是格式化工具创建的，而是由NTFS驱动程序在（格
式化完成后）首次挂载该卷时创建的。文件系统驱动程序生成的这些元数据文件的排列顺序无法保证。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS会将很多元数据文
件存储到扩展（目录名$Extend）元数据目录中，包括对象标识符文件（文件名$ObjId）、配额文件（文件名$Quota）、变更日志文件（文件名
$UsnJrnl）、重分析点文件（文件名$Reparse）、Posix删除目录（$Deleted）以及默认资源管理器目录（目录名
$RmMetadata）。这些文件存储了与NTFS扩展功能有关的信息。对象标识符文件存储了文件对象ID，配额文件存储了启用配额功能的卷的配额限制
和行为信息，变更日志文件记录了文件和目录产生的变更，重分析点文件存储了卷中哪些文件和目录包含重分析点数据的相关信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Posix删除目录
（$Deleted）包含已经使用新的Posix语义删除，对用户不可见的文件。当应用程序最初请求的文件删除操作关闭了文件句柄后，使用Posix语义
删除的文件会被移动至该目录。虽然文件的名称已经从命名空间中删除了，但其他应用程序如果对该文件具备有效的引用，此时依然可以正常运行。有关Posix
删除的详细信息请参阅上文。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">默认资源管理器目录包含与
事务型NTFS（TxF）支持有关的目录，例如，事务日志目录（目录名$TxfLog）、事务隔离目录（目录名$Txf）以及事务修复目录（文件名
$Repair）。事务日志目录包含TxF基础日志文件（文件名$TxfLog.blf）以及任意数量的日志容器文件，这主要取决于事务日志的大小，但始
终至少包含两个容器文件：一个适用于内核事务管理器（KTM）日志流（文件名
$TxfLogContainer00000000000000000001），另一个适用于TxF日志流（文件名
$TxfLogContainer00000000000000000002）。事务日志目录还包含TxF旧页流（文件名$Tops），下文将详细介绍。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>N</b><b>T</b><b>F</b><b>S</b><b>信</b><b>息</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以使用系统自带的Fsutil.exe命令行工具查看有关NTFS卷的信息，包括MFT与MFT区域的放置和大小：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">d:\&gt;fsutil fsinfo ntfsinfo d: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">NTFS Volume Serial Number :       0x48323940323933f2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">NTFS Version :                    3.1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">LFS Version :                     2.0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Number Sectors :                  0x000000011c5f6fff </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Total Clusters :                  0x00000000238bedff </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Free Clusters :                   0x000000001a6e5925 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Total Reserved :                  0x00000000000011cd </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Bytes Per Sector :                512 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Bytes Per Physical Sector :       4096 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Bytes Per Cluster :               4096 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Bytes Per FileRecord Segment    : 4096 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Clusters Per FileRecord Segment : 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Mft Valid Data Length :           0x0000000646500000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Mft Start Lcn :                   0x00000000000c0000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Mft2 Start Lcn :                  0x0000000000000002 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Mft Zone Start :                  0x00000000069f76e0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Mft Zone End :                    0x00000000069f7700 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Max Device Trim Extent Count :    4294967295 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Max Device Trim Byte Count :      0x10000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Max Volume Trim Extent Count :    62 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Max Volume Trim Byte Count :      0x10000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource Manager Identifier :     81E83020-E6FB-11E8-B862-D89EF33A38A7 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在本例中，D:卷在4KB原生扇区磁盘（模拟旧式512B扇区）上使用了4KB的文件记录（MFT项），并使用了4KB的簇。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_263" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>4</b><b> </b><b>文</b><b>件</b><b>记</b><b>录</b><b>号</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS卷上的文件可以使
用一种名为文件记录号（file record 
number）的64位值来识别，该值中包含一个文件号和一个序号。文件号对应于文件的文件记录在MFT中的位置减1（如果文件有多个文件记录，则对应基
本文件记录的位置减1）。序号在每次MFT文件记录被重复使用时都会增加，这样NTFS就可以执行内部一致性检查。文件记录号如图11-33所示。</span></p><div style="display: block;text-align:center;">
	<img width="383" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/c672d0021dc9c2edd14324ff4c7fada5.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-33 文件记录号</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_264" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>5</b><b> </b><b>文</b><b>件</b><b>记</b><b>录</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS并不仅仅将文件视
为一种文本或二进制数据的存储库，而是将文件视为一种属性/值对的集合，而其中的一个属性（名为“未命名数据属性”）恰好保存了文件本身的数据内容。构成
文件的其他属性包括文件名、时间戳信息，甚至其他命名数据属性。图11-34演示了一个小文件的MFT记录。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每个文件的属性都作为一个
单独的字节流存储在文件中。严格来说，NTFS并不读/写文件，它读/写的是属性流。NTFS提供了这些与属性有关的操作，即创建、删除、读取（字节范
围）、写入（字节范围）。读/写服务通常会在文件的未命名数据属性上执行操作，不过调用方可以使用命名数据流语法指定不同的数据属性。</span></p><div style="display: block;text-align:center;">
	<img width="708" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/18cae56967138b878d5aa24b06388299.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-34 一个小文件的MFT记录</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">表11-6列出了NTFS
卷上文件的属性（并非每个文件都包含所有这些属性）。NTFS的每个属性可以是未命名的，也可以是命名的。例如
$LOGGED_UTILITY_STREAM就是一个命名特性，该属性被NTFS的不同组件用于多种用途。表11-7列出了
$LOGGED_UTILITY_STREAM属性可能的名称以及各自的用途。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">▼表11-6 NTFS卷上文件的属性</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/6f93034b8bad5591e4f84bb8c0917c7b.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/05cd642646f3b5b9c3c357e7d325a1f9.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/56993b759ac0844ca21ba23d993a1464.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">▼表11-7 $LOGGED_UTILITY_STREAM属性</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/5ce1e79a48b5c29619a68f0a6a57e3d6.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">表11-6列出了属性名
称，然而，这些属性实际上对应于数字类型代码，NTFS用这些代码来排列文件记录中的属性。MFT记录中的文件属性是按照这些类型代码（以数字升序的顺
序）排序的，有些属性类型可能不止出现一次，例如一个文件可能有多个数据属性，或有多个文件名。所有可能的属性类型（及其名称）都位于$AttrDef元
数据文件中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">文件记录中的每个属性都可以用属性类型代码区分，并有一个值和一个可选的名称。属性的值是组成该属性的字节流。例如，$FILE_NAME属性的值就是文件的名称，$DATA属性的值就是用户在文件中存储的数据字节。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">大多数属性并没有名称，但
与索引有关的属性和$DATA属性通常都有名称。名称区分了一个文件可以包含同一类型的多个属性。例如，一个包含命名数据流的文件有两个$DATA属性：
一个未命名的$DATA属性存储了默认的未命名数据流，另一个命名的$DATA属性存储了备用命名数据流所包含的命名流数据。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_265" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>6</b><b> </b><b>文</b><b>件</b><b>名</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS和FAT都允许路
径中的每个文件名最长达到255个字符。文件名可以包含Unicode字符以及多个句点和嵌入的空格。然而，MS-DOS提供的FAT文件系统文件名被限
制为8个（非Unicode）字符，后跟一个句点以及三个字符的扩展。图11-35直观演示了Windows可支持的不同文件命名空间以及它们的交叉情
况。</span></p><div style="display: block;text-align:center;">
	<img width="876" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/27c12bad11a596140e96faaf6cbf772e.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-35 Windows文件命名空间</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在Windows可支持的
所有应用程序执行环境中，Windows Subsystem for 
Linux（WSL）需要最大的命名空间，因此NTFS命名空间等同于WSL命名空间。WSL可以创建对Windows和MS-DOS应用程序不可见的名
称，包括尾部带有句点和空格的名称。通常来说，使用更大的POSIX命名空间创建文件并不会造成什么问题，因为只有当我们需要让WSL应用程序使用这种文
件时才会这样做。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">然而，32位
Windows应用程序与MS-DOS和16位Windows应用程序之间的关系更密切。图11-35中的Windows区域代表Windows子系统可
以在NTFS卷上创建，但MS-DOS和16位Windows应用程序不可见的文件名。这一组中包含比MS-DOS的8.3格式名称更长的文件名，包含
Unicode（国际）字符的名称、多个句点或在开头处使用句点的名称，以及嵌入空格的名称。出于兼容性考虑，使用这样的名称创建文件时，NTFS会自动
为该文件生成一个替代的、MS-DOS风格的文件名。如果为dir命令使用/x选项，Windows就会显示这种短名称。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">MS-DOS文件名是NTFS文件的全功能别名，与长文件名存储在同一个目录下。图11-36显示了一个具备自动生成的MS-DOS文件名属性的MFT文件记录。</span></p><div style="display: block;text-align:center;">
	<img width="667" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e81e103932ac9f5ed49dd8bee1582e97.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-36 具备自动生成的MS-DOS文件名属性的MFT文件记录</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS名称和生成的
MS-DOS名称存储在同一个文件记录中，因此可以代表同一个文件。MS-DOS名称可用于打开、读取、写入或复制文件。如果用户使用长文件名或短文件名
对文件执行更名操作，那么新名称将同时替代长短两个原有名称。如果新名称不是有效的MS-DOS名称，则NTFS会为文件生成另一个MS-DOS名称（请
注意，NTFS只为第一个文件名生成MS-DOS风格的文件名）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
硬链接也是以类似方式实现的。当为一个文件创建硬链接时，NTFS会在文件的MFT文件记录中添加另一个文件名属性，并在新链接所在目录的索引分配特性中
添加一个项。不过这两种情况在一方面有所差异：当用户删除一个有多个名称（硬链接）的文件时，文件记录和文件将保留在原位。只有在最后一个名称（硬链接）
删除后，文件及其记录才会被删除。然而，如果文件同时具备NTFS名称和自动生成的MS-DOS名称，用户可以使用任何一个名称删除该文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS会使用下列算法从长文件名中生成MS-DOS名称。该算法实际上是在内核函数RtlGenerate8dot3Name中实现的，未来版本的Windows中可能出现变化。这个函数也可被其他驱动程序使用，如CDFS、FAT以及第三方文件系统。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）从长名称中删除对MS-DOS名称来说非法的所有字符，包括空格和Unicode字符。删除开头和结尾的句点。删除嵌入的所有其他句点，但最后一个句点除外。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）将句点（如果存在）之
前的字符串截断为6个字符（可能已经是6个或更少的字符了，因为当名称中存在任何MS-DOS非法字符时都会使用该算法）。如果剩下2个或更少的字符，则
生成并连接一个4字符的十六进制校验字符串。附加字符串~n（其中n是一个从1开始的数字，用于区分截断后依然同名的多个文件）。将句点（如果存在）之后
的字符截断为3个字符。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）将结果转换为大写字母。MS-DOS是不区分大小写的，该步骤保证了NTFS不会生成一个和旧名称只有字母大小写这唯一差异的新名称。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）如果生成的名称与目录中原有的名称重复，则会增大~n字符串。如果n大于4并且还没有连接校验值，则将句点前的字符串截断为2个字符，随后生成并连接一个4字符的十六进制校验字符串。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">表11-8列出了图11-35中的长Windows文件名以及相应的NTFS生成的MS-DOS版本名称。当前的算法和图11-35中列举的例子应该可以帮助大家概括了解NTFS生成的MS-DOS风格的文件名是什么样的。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 从Windows 
8.1开始，默认情况下，所有NTFS不可启动卷的短名称生成功能已被禁用。如果希望在老版本的Windows中禁用短名称的生成功能，可将注册表中
HKLM\SYSTEM\CurrentControlSet\Control\FileSystem\NtfsDisable8dot3NameCreation
这个DWORD值的数据设置为1并重启系统。但这可能会破坏与老应用程序的兼容性。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表11-8 NTFS生成的文件名</span></p><div style="display: block;text-align:center;">
	<img width="478" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/2aca5b4d44e2e1a8bd5c5c43eb27ce9c.jpg" alt="" title=""></div>
</div><div class="header2"><h3><span id="sigil_toc_id_266" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>7</b><b> </b><b>隧</b><b>道</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS使用隧道
（Tunneling）的概念实现与旧式应用程序的兼容，这些应用程序会依赖文件系统来缓存某些文件元数据，甚至在文件消失（例如被删除或更名后）一段时
间后依然会维持这样的缓存。借助隧道功能，任何与原文件使用相同名称创建的新文件，在一定时间内都将保持与原文件相同的元数据。这种机制开始是为了使用
Safe 
save编程方法复制MS-DOS程序的预期行为，借此将修改后的数据复制到一个临时文件中，原文件被删除，随后将临时文件更名为原文件的名称。这种情况
下，预期的行为是：更名后的临时文件应该看起来与原文件完全相同，否则创建时间应该在每次修改后持续更新（这也是“已修改时间”的用法）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS使用了隧道技术，这样在从目录中删除一个文件名时，其长名称和短名称以及创建时间信息都会保存在缓存中。在向目录添加新文件后，可以搜索缓存查看是否有可还原的隧道数据。因为这些操作会应用给目录，而每个目录实例都有自己的缓存，因此，目录删除后缓存也会被删除。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果所使用的名称会导致删除并重建同名文件，NTFS将为下列一系列操作使用隧道。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·删除 + 创建。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·删除 + 更名。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·更名 + 创建。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·更名 + 更名。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">默认情况下，NTFS会将
隧道缓存保留15秒，不过我们可以修改HKLM\SYSTEM\CurrentControlSet\Control\FileSystem注册表键下的
MaximumTunnelEntryAgeInSeconds值来更改默认的超时值。新建一个名为MaximumTunnelEntries的值并将其
设置为0也可以彻底禁用隧道功能，不过这可能导致依赖该功能的老旧应用程序无法运行。在禁用短名称生成（参见上一节）功能的NTFS卷上，隧道默认已被禁
用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">我们可以在命令提示符下通过下列实验看到隧道的作用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）创建一个名为file1的文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）等待15秒以上（隧道缓存的默认超时值）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）新建一个名为file2的文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）执行dir /TC，请留意创建时间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">5）将file1更名为file。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">6）将file2更名为file1。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">7）执行dir /TC，留意完全相同的创建时间。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_267" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>8</b><b> </b><b>常</b><b>驻</b><b>和</b><b>非</b><b>常</b><b>驻</b><b>属</b><b>性</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果一个文件非常小，就可
以将所有属性和值（例如其数据）都放入描述该文件的文件记录中。如果属性的值存储在MFT（可能是文件的主文件记录或MFT中其他位置下的扩展记录）中，
这样的属性就称为常驻属性（例如图11-37中的所有属性都是常驻属性）。有几个属性始终被定义为常驻属性，这样NTFS就可以定位非常驻属性了。例如，
标准信息和索引根属性就始终是常驻属性。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每个属性都以一个标准的头
部（Header）开始，其中包含有关该属性的信息，NTFS会使用这些信息以一种通用的方式管理各种属性。这个头部始终是常驻的，记录了属性的值是常驻
的还是非常驻的。对于常驻属性，头部还包含从头部到属性值的偏移量信息，以及属性值的长度，例如图11-37就展示了文件名属性。</span></p><div style="display: block;text-align:center;">
	<img width="701" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/985d535a31f8ceeb7ee4a4b5dffcebb3.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-37 常驻属性的头部和值</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当一个属性的值直接存储在MFT中时，NTFS访问该值所需的时间将大幅减少。此时不需要在表中查找文件，然后读取连续分配的单元来找到文件的数据（FAT文件系统就是这样做的），NTFS只需访问磁盘一次即可立即检索到数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如图11-38所示，小目录和小文件的属性都可以常驻在MFT中。对于小目录，索引根属性包含了该目录内文件（和子目录）的文件记录号索引（整理为B树形式）。</span></p><div style="display: block;text-align:center;">
	<img width="686" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a1701ef91c7b01186b193ad2f3a00dd7.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-38 小目录的MFT文件记录</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当然，很多文件和目录无法
完全装入1KB或4KB固定大小的MFT记录中。如果特定属性的值（例如文件的数据属性）太大，无法完全由MFT文件记录容纳，NTFS会在MFT之外为
该属性的值分配簇。一组连续的簇称为一个“运行”（或一个“范围”）。如果属性的值随后继续增长（例如用户向文件中附加了数据），那么NTFS将为额外的
数据分配另一个运行。如果属性的值存储在运行中（而非MFT中），这种属性就称为非常驻属性。文件系统会决定特定属性是常驻的或是非常驻的，数据实际位置
对访问数据的应用程序是完全透明的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于非常驻属性，就像大文件的数据属性那样，其头部包含了NTFS在磁盘上定位属性值所需的信息。图11-39展示了两个“运行”中存储的非常驻数据属性。</span></p><div style="display: block;text-align:center;">
	<img width="674" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/776f57333cf92f876f6b060a3817a4e6.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-39 包含两个数据运行的大文件的MFT文件记录</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在所有的标准属性中，只有可增长的属性会成为非常驻属性。对于文件，可增长的属性包括数据和属性列表（图11-39中未展示）。标准信息和文件名属性始终是常驻的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">大目录也可以有非常驻属性
（或部分属性），如图11-40所示。在本例中，MFT文件记录没有足够的空间来存储包含该大目录中所有文件索引的B树。因此，该索引的一部分内容被存储
到索引根特性中，其余部分则存储到名为“索引分配”的非常驻运行中。这里显示的索引根、索引分配以及位图属性都是简化后的效果，下一节还将详细介绍这些概
念。标准信息和文件名属性始终是常驻的。对该大目录来说，头部和索引根属性中的至少一部分值也是常驻的。</span></p><div style="display: block;text-align:center;">
	<img width="672" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a9958417e7929491e0fd29677ea07144.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-40 使用非常驻文件名索引的大目录的MFT文件记录</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当一个属性的值无法纳入MFT文件记录而需要单独分配时，NTFS会通过VCN到LCN的映射对来跟踪运行。LCN代表整个卷上从0到n的簇序列，VCN则对属于特定文件的簇从0到m进行编号。例如，图11-41展示了非常驻数据属性的“运行”中簇的编号方式。</span></p><div style="display: block;text-align:center;">
	<img width="788" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/05e480233283d704017d37ae771685a4.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-41 非常驻数据属性的VCN</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果该文件有两个以上的运行，那么第三个运行的编号将从VCN 8开始。如图11-42所示，数据属性头部包含此处这两个运行的VCN到LCN映射，借此NTFS可以轻松找到在磁盘上分配的位置。</span></p><div style="display: block;text-align:center;">
	<img width="747" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/10388e135386d5c60a78d40d919a3a43.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-42 非常驻数据属性的VCN到LCN映射</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然图11-41只显示了
数据运行，但如果MFT文件记录中没有足够空间来容纳，其他属性也可以存储在运行中。如果特定文件有太多属性无法容纳在MFT记录中，还可以使用第二条
MFT记录来包含额外的属性（或非常驻属性的属性头部）。这种情况下，将会添加一个名为“属性列表”的属性。属性列表属性包含每个文件属性的名称和类型代
码，以及属性在MFT记录中的文件号。属性列表属性是为这些情况提供的：文件的所有属性无法容纳在文件的文件记录中，或文件增长过大或过于碎片化以至于一
个MFT记录无法包含查找文件的所有运行所需的多个VCN至LCN映射。包含超过200个运行的文件通常就需要属性列表。总的来说，属性头部会始终包含在
MFT文件记录中，但属性的值可能会在MFT之外的一个或多个范围里。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_268" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>9</b><b> </b><b>数</b><b>据</b><b>压</b><b>缩</b><b>和</b><b>稀</b><b>疏</b><b>文</b><b>件</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS支持针对每个文
件、每个目录或每个卷，使用LZ77算法的变体（LZNT1）进行压缩（NTFS压缩只适用于用户数据，不适用于文件系统元数据）。在Windows 
8.1和后续版本中，还可以使用新的算法套件来压缩文件，该套件包含LZX（最紧凑）和XPRESS（分别使用4KB、8KB或16KB的块大小，速度各
异）。此类压缩可以通过命令使用，例如，外壳命令compact（以及File Provder API），它利用了Windows Overlay 
Filter（WOF）文件系统过滤器驱动程序（Wof.sys）来操作NTFS备用数据流和稀疏文件，但严格来说并非NTFS驱动程序的一部分。WOF
的介绍已超出了本书范围，详见https://devblogs.microsoft.com/oldnewthing/20190618-00/?
p=102597。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">我们可以使用
Windows的GetVolumeInformation函数查看一个卷是否被压缩。要查看一个文件实际压缩后的大小，可使用Windows的
GetCompressedFileSize函数。最后，要查看或更改文件/目录的压缩设置，可使用Windows的DeviceIoControl函数
（查看FSCTL_GET_COMPRESSION和FSCTL_SET_COMPRESSION这两个文件系统控制代码）。另外需要注意，虽然设置文件
的压缩状态即可立即压缩（或解压缩）该文件，但设置目录或卷的压缩状态无法立即发起压缩和解压缩的操作。该操作实际上是在为该目录或卷中以后新创建的文件
和子目录设置默认压缩状态（不过如果是在资源管理器中使用目录的属性对话框来压缩该目录，则整个目录树中的内容将被立即压缩）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">下文将通过一个稀疏数据的压缩用例来介绍NTFS压缩。随后还将讨论传统文件和稀疏文件的压缩。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> DAX卷或EFS加密文件不支持NTFS压缩。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_269" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>1</b><b>0</b><b> </b><b>压</b><b>缩</b><b>稀</b><b>疏</b><b>数</b><b>据</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">稀疏数据通常很大，但相对
于其大小来说，通常只包含少量非零数据。稀疏矩阵就是稀疏数据的一个例子，如上文所述，NTFS使用从0到m的VCN来枚举文件的簇。每个VCN映射至一
个对应的LCN，LCN标识了簇在磁盘上的位置。图11-43展示了一个常规的、未压缩文件的运行（磁盘分配）及其VCN和映射到的LCN。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/0098eea8507f7b0167981e8863160a5f.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-43 未压缩文件的运行</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">该文件存储在3个运行中，
每个运行的长度为4个簇，因此共有12个簇。图11-44显示了该文件的MFT记录。如上文所述，为节约空间，MFT记录的数据属性（包括VCN到LCN
的映射）只为每个运行记录一个映射，而非为每个簇记录一个映射。不过要注意，从0到11的每个VCN都有相关的LCN与之对应。第一项从VCN 
0开始，涵盖4个簇；第二项从VCN 4开始，涵盖4个簇，以此类推。这种项格式通常是典型的未压缩文件。</span></p><div style="display: block;text-align:center;">
	<img width="715" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/9849fa72e785a3e3e99b57c127989e41.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-44 未压缩文件的MFT记录</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当用户在NTFS卷上选择一个要压缩的文件后，NTFS的一种压缩技术会将文件中一长串由零组成的字符串删除。如果文件数据是稀疏的，经此操作后通常文件将只占用原本所需磁盘空间的一小部分。如果随后对文件执行写入操作，则NTFS只需要为包含非零数据的运行分配空间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图11-45描述了一个包含稀疏数据的压缩文件所对应的运行。请注意，文件VCN的某些范围（16～31以及64～127）是没有分配磁盘的。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/c6e372f5f42e4e9acaa2858aba4598f4.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-45 包含稀疏数据的压缩文件所对应的运行</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">该压缩文件的MFT记录省略了包含零的VCN块，因此也没有为其分配物理存储。例如，图11-46中的第一个数据项从VCN 0开始，涵盖16个簇；第二个项跳转到VCN 32，涵盖16个簇。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当程序从压缩文件中读取数
据时，NTFS会检查MFT记录以确定VCN到LCN的映射是否涵盖了被读取的位置。如果程序是从文件中一个尚未分配的“空洞”读取，这意味着文件中那部
分数据由零组成，因此NTFS无须进一步访问磁盘就会返回零。如果程序向“空洞”写入非零数据，则NTFS会悄悄分配磁盘空间并写入数据。对于包含大量零
数据的稀疏文件来说，这是一种非常高效的技术。</span></p><div style="display: block;text-align:center;">
	<img width="669" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/581de55dc5e3e08ea7a38d6688cf6527.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-46 包含稀疏数据的压缩文件所对应的MFT记录</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_270" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>1</b><b>1</b><b> </b><b>非</b><b>稀</b><b>疏</b><b>数</b><b>据</b><b>的</b><b>压</b><b>缩</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">上述稀疏文件压缩的例子其实有些“刻意”，这个例子描述了一种当文件的整个节都被零填充时的“压缩”，但文件中的其余数据并未受到压缩的影响。大部分文件中的数据并非稀疏的，但依然可以使用压缩算法来压缩。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在NTFS中，用户可以压
缩特定的文件或一个目录中的所有文件（被压缩的目录中以后新建的文件也会被自动压缩，如果以编程的方式使用FSCTL_SET_COMPRESSION来
启用对目录的压缩，则目录中现有的文件需要单独进行压缩）。压缩文件时，NTFS会将文件中尚未处理的数据分成长度为16个簇的压缩单元（例如簇的大小为
8KB时，压缩单元大小就为128KB）。文件中的某些数据序列可能无法大幅压缩，甚至可能完全无法压缩。因此，对于文件中的每个压缩单元，NTFS会判
断压缩该单元是否可以节约至少1个簇的容量。如果压缩后无法释放出至少1个簇的容量，那么NTFS会分配一个16个簇的运行，将该单元中的数据直接写入磁
盘，不进行压缩。如果16个簇单元中的数据可以压缩至15个簇或更少的簇，NTFS将只分配包含压缩后数据所需数量的簇，随后将其写入磁盘。图11-47
展示了一个包含4个运行的文件的压缩。图中未填充阴影的区域代表压缩之后该文件实际占用的存储位置。第1、2和4个运行都已被压缩，第3个运行未压缩。虽
然包含1个未压缩的运行，压缩该文件也节约了26个簇的磁盘空间（41%）。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e89e70ea024f9bc754ee15fa31e46bd8.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-47 压缩文件包含的数据运行</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 尽管本章的图表都展示了连续的LCN，但压缩单元并不需要存储在物理上连续的簇中。占用非连续簇的运行，其MFT记录会比图11-47所示的记录略为复杂一些。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在将数据写入压缩文件后，
NTFS会确保每个运行都从虚拟的16簇边界开始。因此，每个运行的起始VCN都是16的倍数，并且运行不会超过16个簇。当访问压缩文件时，NTFS每
次至少读/写一个压缩单元。不过在写入压缩后的数据时，NTFS会试图将压缩单元存储在物理连续的位置，这样就可以通过一个I/O操作完全读取。NTFS
压缩单元大小为16个簇，选择这个大小主要是为了避免产生内部碎片：压缩单元越大，存储数据所需的总体磁盘空间就越小。这16个簇的压缩单元大小实际上是
在“产生尽量小的压缩文件”和“降低随机访问文件的程序读取操作速度”之间进行权衡后的结果。每次缓存缺失都必须对相当于16个簇的数据解压缩（缓存缺失
更可能出现在随机访问时）。图11-48显示了图11-47中压缩文件的MFT记录。</span></p><div style="display: block;text-align:center;">
	<img width="669" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/2b4b1238f9527fdbaa1e0b795bfda303.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-48 压缩文件的MFT记录</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这个压缩文件和上文包含稀
疏数据的压缩文件两个例子最主要的差别在于：该文件中的三个压缩运行的长度都小于16个簇。从文件的MFT文件记录中读取这些信息后，NTFS可以知道文
件中的数据是否被压缩。如果任何不超过16个簇的运行中包含压缩数据，NTFS在首次将数据读入缓存时必须解压缩。恰巧16个簇长度的运行不包含压缩数
据，因此不需要解压缩。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果运行中的数据已被压
缩，则NTFS会将数据解压缩到从头开始的缓冲区，随后将其复制到调用方的缓冲区。NTFS还会将解压缩后的数据载入缓存，因此，同一个运行的后续读取就
会和其他缓存读取操作一样快。NTFS会将文件的更新写入缓存，利用惰性写入器以异步的方式将修改后的数据压缩并写入磁盘。该策略确保了向压缩文件执行写
入操作不会比非压缩文件的写入操作产生更明显的延迟。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS会尽可能保持压缩
文件磁盘分配的连续性。正如LCN所示，在图11-47中，压缩文件的前两个运行在物理上是连续的，后两个也是连续的。如果两个或更多运行是连续的，
NTFS就会像处理其他文件数据那样执行磁盘预读取。由于连续文件数据的读取和解压缩可在程序请求数据之前以异步方式进行，所以后续读取操作将直接从缓存
中获得数据，这大幅改善了读取操作的性能。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_271" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>1</b><b>2</b><b> </b><b>稀</b><b>疏</b><b>文</b><b>件</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">稀疏文件（sparse 
file，NTFS文件类型，与上文描述的包含稀疏数据的文件不是一回事）实际上是一种压缩文件，但NTFS不会对文件中的非稀疏数据应用压缩。NTFS
管理稀疏文件MFT记录运行数据的方式，与管理由稀疏数据和非稀疏数据组成的压缩文件的方式完全相同。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_272" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>1</b><b>3</b><b> </b><b>变</b><b>更</b><b>日</b><b>志</b><b>文</b><b>件</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">变更日志文件（\$Extend\$UsnJrnl）是一种稀疏文件，NTFS在其中存储了文件和目录的变更记录。诸如Windows文件复制服务（FRS）和Window搜索服务等应用程序可以使用该日志响应文件和目录发生的变化。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">日志将变更项存储在$J数据流中，日志的最大大小存储在$Max数据流中。项是可以包含版本信息的，其中包含有关文件或目录变更的如下信息。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·变更时间。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·变更原因（参阅表11-9）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·文件或目录的属性。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·文件或目录的名称。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·文件或目录的MFT文件记录号。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·文件的父目录的文件记录号。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·安全ID。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·记录的更新序列号（USN）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·有关变更来源的额外信息（用户、FRS等）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表11-9 变更日志的变更原因</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/c22b7de2c1517357592515b3aa9e5388.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/5a61a33d4f5d95427c67dc8361570b16.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/815aac32b955258d944e9ed95ec01fc6.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>读</b><b>取</b><b>变</b><b>更</b><b>日</b><b>志</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以使用系统自带的%SystemRoot%\System32\Fsutil.exe工具创建、删除或查询日志信息：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">d:\&gt;fsutil usn queryjournal d: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Usn Journal ID   : 0x01d48f4c3853cc72 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">First Usn        : 0x0000000000000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Next Usn         : 0x0000000000000a60 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Lowest Valid Usn : 0x0000000000000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Max Usn          : 0x7fffffffffff0000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Maximum Size     : 0x0000000000a00000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Allocation Delta : 0x0000000000200000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Minimum record version supported : 2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Maximum record version supported : 4 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Write range tracking: Disabled </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">从上述输出结果中可知，卷上变更日志的最大大小（10MB）及其当前状态。作为一个简单的实验，我们可以看看NTFS如何记录日志中的变化，为此请在当前目录下创建一个名为Usn.txt的文件，将其更名为UsnNew.txt，随后使用Fsutil转储日志：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">d:\&gt;echo Hello USN Journal! &gt; Usn.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">d:\&gt;ren Usn.txt UsnNew.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">d:\&gt;fsutil usn readjournal d: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">... </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Usn               : 2656 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File name         : Usn.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File name length  : 14 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Reason            : 0x00000100: File create </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Time stamp        : 12/8/2018 15:22:05 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File attributes   : 0x00000020: Archive </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File ID           : 0000000000000000000c000000617912 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Parent file ID    : 00000000000000000018000000617ab6 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Source info       : 0x00000000: *NONE* </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Security ID       : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Major version     : 3 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Minor version     : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Record length     : 96 </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Usn               : 2736 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File name         : Usn.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File name length  : 14 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Reason            : 0x00000102: Data extend | File create </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Time stamp        : 12/8/2018 15:22:05 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File attributes   : 0x00000020: Archive </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File ID           : 0000000000000000000c000000617912 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Parent file ID    : 00000000000000000018000000617ab6 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Source info       : 0x00000000: *NONE* </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Security ID       : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Major version     : 3 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Minor version     : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Record length     : 96 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Usn               : 2816 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File name         : Usn.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File name length  : 14 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Reason            : 0x80000102: Data extend | File create | Close </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Time stamp        : 12/8/2018 15:22:05 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File attributes   : 0x00000020: Archive </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File ID           : 0000000000000000000c000000617912 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Parent file ID    : 00000000000000000018000000617ab6 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Source info       : 0x00000000: *NONE* </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Security ID       : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Major version     : 3 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Minor version     : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Record length     : 96 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Usn               : 2896 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File name         : Usn.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File name length  : 14 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Reason            : 0x00001000: Rename: old name </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Time stamp        : 12/8/2018 15:22:15 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File attributes   : 0x00000020: Archive </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File ID           : 0000000000000000000c000000617912 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Parent file ID    : 00000000000000000018000000617ab6 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Source info       : 0x00000000: *NONE* </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Security ID       : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Major version     : 3 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Minor version     : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Record length     : 96 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Usn               : 2976 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File name         : UsnNew.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File name length  : 20 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Reason            : 0x00002000: Rename: new name </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Time stamp        : 12/8/2018 15:22:15 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File attributes   : 0x00000020: Archive </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File ID           : 0000000000000000000c000000617912 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Parent file ID    : 00000000000000000018000000617ab6 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Source info       : 0x00000000: *NONE* </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Security ID       : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Major version     : 3 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Minor version     : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Record length     : 96 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Usn               : 3056 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File name         : UsnNew.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File name length  : 20 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Reason            : 0x80002000: Rename: new name | Close </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Time stamp        : 12/8/2018 15:22:15 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File attributes   : 0x00000020: Archive </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File ID          : 0000000000000000000c000000617912 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Parent file ID   : 00000000000000000018000000617ab6 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Source info      : 0x00000000: *NONE* </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Security ID      : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Major version    : 3 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Minor version    : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Record length    : 96 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">这些项反映了命令行操作基础上所涉及的各种修改操作。如果卷没有启用变更日志（这种情况常见于非系统卷，因为没有应用程序请求文件变更通知或创建USN日志），也可以通过下列命令轻松启用（本例中请求了一个10MB的日志）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">d:\&gt;fsutil usn createJournal d: m=10485760 a=2097152 </span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">日志是稀疏的，因此永远不
会溢出，当磁盘上的日志大小超出文件定义的最大值后，NTFS会将变更信息窗口之前的文件数据清零，使其大小等于日志文件的最大值，如图11-49所示。
为防止应用程序不断超过日志大小时频繁调整大小，NTFS只在日志大小超过应用程序定义最大尺寸的两倍后开始收缩日志。</span></p><div style="display: block;text-align:center;">
	<img width="646" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/486118d147791ece6b8338bae022c9c5.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-49 变更日志（$UsnJrnl）的空间分配</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_273" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>1</b><b>4</b><b> </b><b>索</b><b>引</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在NTFS中，文件目录只是文件名的一个索引，也就是说，文件名（连同其文件记录号）的集合会被组织为B树。要创建目录，NTFS会对目录中文件的文件名属性创建索引。卷根目录的MFT记录如图11-50所示。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">从概念上来说，目录的
MFT项在其索引根属性中包含一个该目录中文件排序后的列表。不过对于较大的目录，文件名实际上存储在固定4KB大小的索引缓冲区（索引分配属性的非常驻
值）中，借此包含并整理文件名。索引缓冲区实现了一种B树数据结构，可最大限度减少寻找特定文件所需的磁盘访问次数，尤其是在大型目录中。索引根属性包含
B树的第一层（根子目录），并指向包含下一层（也许是更多子目录或文件）的索引缓冲区。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/1713efb264b04dfd3aeecd96657140ec.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-50 卷根目录的文件名索引</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图11-50只展示了索引
根属性和索引缓冲区中的文件名（如file6），其实索引中的每个项也包含描述该文件的MFT中的记录号以及文件的时间戳和文件大小信息。NTFS会从文
件的MFT记录复制时间戳和文件大小信息。这种被FAT和NTFS使用的技术需要将更新后的信息写入两个地方。即便如此，这也可以大幅加快目录浏览速度，
因为文件系统无须打开目录中的每个文件，即可显示每个文件的时间戳和大小信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">索引分配属性会将索引缓冲
区运行的VCN映射到LCN，而该LCN指向索引缓冲区在磁盘上的位置，位图属性则可用于跟踪索引缓冲区中哪些VCN已被使用，哪些空闲。图11-50展
示了每个VCN（即每个簇）的一个文件项，但文件名项实际上已经打包到每个簇中。每个4KB的索引缓冲区通常会包含大约20到30个文件名项（取决于目录
中文件名的长度）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">B树数据结构是一种平衡
树，是用于组织磁盘中所存储数据的最佳选择，因为可以最大限度减少寻找项所需的磁盘访问次数。在MFT中，目录的索引根属性包含多个文件名，这些名称可作
为B树的第二级索引。索引根属性中的每个文件名都有一个与之相关的可选指针以指向索引缓冲区。该索引缓冲区会指向词典分类顺序
（Lexicographic）值小于自己的文件名。例如在图11-50中，file4是B树中的第一级项，它指向词典分类顺序上所包含文件名小于自己的
索引缓冲区，即文件名file0、file1和file3。请注意，本例中使用的文件名file1、file3等并非字面意义上的文件名，而是为了展现文
件的相对位置，按照显示过程中的词典分类顺序排序的名称。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">将文件名存储在B树中有多个好处：目录查找速度更快，因为文件名已经以排序后的方式存储好了；当高层软件枚举目录中的文件时，NTFS将返回排序后的名称；由于B树更倾向于在宽度而非深度方向上增长，因此NTFS的查找速度并不会因为目录增长而下降。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS还提供了对文件名之外其他索引数据的常规支持，而一些NTFS功能（如对象ID、配额跟踪以及整合的安全性）也需要使用索引来管理内部数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">B树索引是NTFS的一种通用能力，可用于整理安全描述符、安全ID、对象ID、磁盘配额记录以及重分析点。目录也叫文件名索引，其他类型的索引则可称为视图索引。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_274" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>1</b><b>5</b><b> </b><b>对</b><b>象</b><b>I</b><b>D</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了将分配给文件或目录的
对象ID存储在MFT记录的$OBJECT_ID属性中，NTFS还会在\$Extend\$ObjId元数据文件的$O索引中保存对象ID和文件记录号
之间的对应关系。该索引可按照对象ID（一种GUID）整理所有项，借此NTFS可以快速根据ID定位文件。该功能可供应用程序使用
NtCreateFile原生API以及FILE_OPEN_BY_FILE_ID标记，通过对象ID打开文件或目录。图11-51展示了MFT记录中
$ObjId元数据文件和$OBJECT_ID属性之间的关系。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/7edf52cdaf94047523b50d0392629edd.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-51 $ObjId和$OBJECT_ID的关系</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_275" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>1</b><b>6</b><b> </b><b>配</b><b>额</b><b>跟</b><b>踪</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS将配额信息存储在
\$Extend\$Quota元数据文件中，其中包含命名索引根属性$O和$Q。图11-52展示了这些索引的组织方式。就像NTFS会为每个安全描述
符分配一个唯一内部安全ID一样，NTFS也会为每个用户分配一个唯一用户ID。当管理员为用户定义配额时，NTFS会分配一个与该用户的SID对应的用
户ID。在$O索引中，NTFS会创建一个项，借此将SID映射至用户ID，并使用SID对该索引排序；在$Q索引中，NTFS会创建配额控制项。配额控
制项包含用户的配额限制值，以及用户在卷上已使用的磁盘空间总量信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当应用程序创建文件或目录
时，NTFS会获取应用程序用户的SID并在$O索引中查找相关的用户ID。NTFS会将用户ID记录到新文件或目录的
$STANDARD_INFORMATION属性中，借此将分配给该文件或目录的所有磁盘空间计入该用户的配额中。随后NTFS会在$Q索引中查找配额
项，并确定新分配是否会导致用户超出自己的警报或限制阈值。如果新分配会导致用户超出阈值，则NTFS会执行相应的措施，如在系统事件日志中记录事件，或
不允许用户创建文件或目录。随着文件或目录大小的更改，NTFS会更新$STANDARD_INFORMATION属性中存储的、与用户ID相关的配额控
制项。NTFS会使用NTFS通用B树索引将用户ID与账户SID高效关联在一起，并借此通过用户ID快速找出用户的配额控制信息。</span></p><div style="display: block;text-align:center;">
	<img width="658" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/7616ab02aad8fd573fc260c9ae522d33.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-52 $Quota索引</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_276" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>1</b><b>7</b><b> </b><b>综</b><b>合</b><b>安</b><b>全</b><b>性</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS始终支持安全性，借此管理员可以指定哪个用户可以或不可以访问特定的文件和目录。为了优化安全描述符的磁盘利用率，NTFS会使用一个名为$Secure的中心元数据文件，从而只存储每个安全描述符的一个实例。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如图11-53所
示，$Secure文件包含两个索引属性：$SDH（安全描述符哈希）和$SII（安全ID索引），此外还包含一个名为$SDS（安全描述符流）的数据流
属性。NTFS为卷上每个唯一安全描述符分配一个内部NTFS安全ID（和Windows SID不是一回事，Windows 
SID用于标识唯一的计算机和用户账户），并用一种简单的哈希算法为安全描述符创建哈希。哈希可以看成描述符的一种潜在的、非唯一的速记表达。$SDH索
引项将安全描述符哈希映射至安全描述符在$SDS数据属性中的存储位置，$SII索引项将NTFS安全ID映射至安全描述符在$SDS数据属性中的位置。</span></p><div style="display: block;text-align:center;">
	<img width="739" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/bdd1f42af8234861801c28ccaf2d4c15.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-53 $Secure索引</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当将安全描述符应用给文件
或目录时，NTFS会获取描述符的哈希，并在$SDH索引中查找匹配项。NTFS会根据相应的安全描述符的哈希对$SDH索引项排序，并将项存储在B树
中。如果在$SDH索引中找到匹配的描述符，则NTFS会通过该项的偏移量值找出安全描述符项的偏移量，并从$SDS属性读取安全描述符。如果哈希匹配但
安全描述符不匹配，则NTFS会在$SDH索引中查找另一个匹配项。在NTFS找到严格的匹配项后，想要应用安全描述符的文件或目录即可直接引用$SDS
特性中的现有安全描述符。NTFS在进行引用时，会从$SDH项读取NTFS安全标识符，将其存储在文件或目录的
$STANDARD_INFORMATION属性中。所有文件和目录都具备NTFS的这个属性，其中存储了有关文件的基本信息，如属性、时间戳信息、安全
描述符。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果NTFS在$SDH索
引中没有找到与想要应用的安全描述符相符的项，这意味着该安全描述符在这个卷上是唯一的，NTFS会为描述符分配一个新的内部安全ID。NTFS内部安全
ID是一种32位值，SID通常会比它大几倍，因此，用NTFS的安全ID代替SID还可节约$STANDARD_INFORMATION属性占用的空
间。随后，NTFS会将该安全描述符添加到$SDS数据属性的尾部，并在$SDH和$SII索引中添加表示该描述符在$SDS数据中偏移量的项。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当应用程序试图打开文件或
目录时，NTFS会使用$SII索引查找文件或目录的安全描述符。NTFS会从MFT项的$STANDARD_INFORMATION属性中读取文件或目
录的内部安全ID，随后使用$Secure文件的$SII索引在$SDS数据属性中定位该ID。对$SDS属性的偏移量使得NTFS可以顺利读取安全描述
符并完成安全检查。NTFS会将最近访问过的32个安全描述符及其$SII索引项存储在缓存中，这样就只需要在$SII未缓存时才会访问$Secure文
件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS不会删除$Secure文件中的项，哪怕卷中的文件和目录都不再引用。保留这些项并不会导致磁盘空间的浪费，因为大部分卷，哪怕已经使用了很长时间，也只会产生很少量的唯一安全描述符。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS对通用B树索引的
使用使得具备相同安全设置的文件和目录最终可以共享安全描述符。$SII索引可以帮助NTFS在$Secure文件中快速查找安全描述符并执行安全检
查，$SDH索引可以帮助NTFS快速确定应用给文件或目录的安全描述符是否已经存储在$Secure文件中并且可以被共享。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_277" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>1</b><b>8</b><b> </b><b>重</b><b>分</b><b>析</b><b>点</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，重分析点是一
块由应用程序定义的、最大16KB的重分析数据。另外，还有一个32位重分析标签会存储在文件或目录的$REPARSE_POINT属性中。当应用程序创
建或删除重分析点时，NTFS会更新\$Extend\$Reparse元数据文件，NTFS在其中存储的项标识了包含重分析点的文件和目录的文件记录
号。在一个中心位置存储这些记录使得NTFS能够为应用程序提供接口，借此枚举卷上的所有重分析点或指定类型的重分析点，例如挂载点。\$Extend\
$Reparse文件使用了NTFS的通用B树索引设施，根据重分析点标签和文件记录号整理文件的项（在一个名为$R的索引中）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>不</b><b>同</b><b>的</b><b>重</b><b>分</b><b>析</b><b>点</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">文件或目录重分析点可包含任意类型的任意数据。这个实验将使用系统自带的fsutil.exe工具，使用类似第8章介绍的方法，分析符号链接和现代应用程序AppExecutionAlias的重分析点内容。首先创建一个符号链接：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;mklink test_link.txt d:\Test.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">symbolic link created for test_link.txt &lt;&lt;===&gt;&gt; d:\Test.txt </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后即可使用fsutil reparsePoint query命令查看重分析点内容：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;fsutil reparsePoint query test_link.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Reparse Tag Value : 0xa000000c </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Tag value: Microsoft </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Tag value: Name Surrogate </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Tag value: Symbolic Link </span></p>
</div><div class="header0"><h1><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h1></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Reparse Data Length: 0x00000040 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Reparse Data: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0000:  16 00 1e 00 00 00 16 00 00 00 00 00 64 00 3a 00 ............d.:. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0010:  5c 00 54 00 65 00 73 00 74 00 2e 00 74 00 78 00 \.T.e.s.t...t.x. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0020:  74 00 5c 00 3f 00 3f 00 5c 00 64 00 3a 00 5c 00 t.\.?.?.\.d.:.\. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0030:  54 00 65 00 73 00 74 00 2e 00 74 00 78 00 74 00 T.e.s.t...t.x.t. </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">毫不意外，内容是一种简单的数据结构（REPARSE_DATA_BUFFER，详见Microsoft Docs网站），其中包含符号链接目标和所显示的文件名。我们甚至可以使用fsutil reparsePoint delete命令删除这个重分析点：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;more test_link.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">This is a test file! </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;fsutil reparsePoint delete test_link.txt </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;more test_link.txt </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如果删除该重分析点，文件将变成0字节。这是设计特性，因为链接文件的未命名数据流（$DATA）是空的。我们可以针对已安装现代应用程序（下文例子中使用了Spotify）的AppExecutionAlias重复该实验：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;cd C:\Users\Andrea\AppData\Local\Microsoft\WindowsApps </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\Users\andrea\AppData\Local\Microsoft\WindowsApps&gt;fsutil reparsePoint query Spotify.exe</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Reparse Tag Value : 0x8000001b </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Tag value: Microsoft </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Reparse Data Length: 0x00000178 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Reparse Data: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0000:  03 00 00 00 53 00 70 00 6f 00 74 00 69 00 66 00  ....S.p.o.t.i.f. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0010:  79 00 41 00 42 00 2e 00 53 00 70 00 6f 00 74 00  y.A.B...S.p.o.t. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0020:  69 00 66 00 79 00 4d 00 75 00 73 00 69 00 63 00  i.f.y.M.u.s.i.c. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0030:  5f 00 7a 00 70 00 64 00 6e 00 65 00 6b 00 64 00 _.z.p.d.n.e.k.d. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0040:  72 00 7a 00 72 00 65 00 61 00 30 00 00 00 53 00  r.z.r.e.a.0...S </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0050:  70 00 6f 00 74 00 69 00 66 00 79 00 41 00 42 00  p.o.t.i.f.y.A.B. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0060:  2e 00 53 00 70 00 6f 00 74 00 69 00 66 00 79 00  ..S.p.o.t.i.f.y. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0070:  4d 00 75 00 73 00 69 00 63 00 5f 00 7a 00 70 00  M.u.s.i.c._.z.p. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0080:  64 00 6e 00 65 00 6b 00 64 00 72 00 7a 00 72 00  d.n.e.k.d.r.z.r. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0090:  65 00 61 00 30 00 21 00 53 00 70 00 6f 00 74 00  e.a.0.!.S.p.o.t. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">00a0:  69 00 66 00 79 00 00 00 43 00 3a 00 5c 00 50 00  i.f.y...C.:.\.P. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">00b0:  72 00 6f 00 67 00 72 00 61 00 6d 00 20 00 46 00  r.o.g.r.a.m. .F. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">00c0:  69 00 6c 00 65 00 73 00 5c 00 57 00 69 00 6e 00  i.l.e.s.\.W.i.n. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">00d0:  64 00 6f 00 77 00 73 00 41 00 70 00 70 00 73 00  d.o.w.s.A.p.p.s. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">00e0:  5c 00 53 00 70 00 6f 00 74 00 69 00 66 00 79 00  \.S.p.o.t.i.f.y. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">00f0:  41 00 42 00 2e 00 53 00 70 00 6f 00 74 00 69 00  A.B...S.p.o.t.i. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0100:  66 00 79 00 4d 00 75 00 73 00 69 00 63 00 5f 00  f.y.M.u.s.i.c._. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0110:  31 00 2e 00 39 00 34 00 2e 00 32 00 36 00 32 00  1...9.4...2.6.2. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0120:  2e 00 30 00 5f 00 78 00 38 00 36 00 5f 00 5f 00  ..0._.x.8.6._._. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0130:  7a 00 70 00 64 00 6e 00 65 00 6b 00 64 00 72 00  z.p.d.n.e.k.d.r. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0140:  7a 00 72 00 65 00 61 00 30 00 5c 00 53 00 70 00  z.r.e.a.0.\.S.p. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0150:  6f 00 74 00 69 00 66 00 79 00 4d 00 69 00 67 00  o.t.i.f.y.M.i.g. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0160:  72 00 61 00 74 00 6f 00 72 00 2e 00 65 00 78 00  r.a.t.o.r...e.x. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0170:  65 00 00 00 30 00 00 00                          e...0... </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">从上述输出结果中可以看到另一种类型的重分析点：被现代应用程序使用的AppExecutionAlias。详细信息请参阅第8章。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_278" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>1</b><b>9</b><b> </b><b>存</b><b>储</b><b>保</b><b>留</b><b>和</b><b>N</b><b>T</b><b>F</b><b>S</b><b>预</b><b>留</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows 
Update和Windows安装程序必须能正确应用重要的安全更新，哪怕系统卷已经快要装满（需要确保此时也有足够的可用空间）。为了实现这种目标，
Windows 10引入了存储保留（storage 
reserve）。在介绍存储保留前，首先需要了解何谓NTFS预留（reservation）以及为何需要这样的功能。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当NTFS文件系统挂载一
个卷时，会计算该卷的已用和可用空间。然而，没有哪种磁盘属性可以直接记录这两个数值；NTFS会在磁盘上维持并存储卷位图，借此代表卷上所有簇的状态。
NTFS挂载代码会扫描该位图并统计已用簇的数量（已用簇在位图中对应的位会被设置为“1”），随后通过一个简单的公式（卷中簇的总数减去已用簇的总数）
就可以得到可用簇的数量。计算得到的这两个计数器会存储在卷控制块（VCB）的数据结构中，代表已挂载的卷，只会在卷被卸载之前存在于内存中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在常规的卷I/O活动中，NTFS必须维持保留簇的总数，该计数器的存在主要出于下列原因。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·写入压缩文件和稀疏文件时，系统必须确保整个文件都是可写入的，因为打开此类文件的应用程序可能会在整个文件中存储未压缩的有效数据。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·首次创建一个可写入的映像支撑节时，文件系统必须为整个节大小预留足够的可用空间，哪怕并未在卷上分配任何物理空间。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·USN日志和TxF会使用该计数器来保证USN日志与NTFS事务可以获得足够的空间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS还会在常规I/O活动中维持另一个计数器——总可用空间，这是用户可以看到并用来存储新文件或数据的最终空间量。这三个概念都是NTFS预留的一部分。NTFS预留最重要的特点是：计数器只是内存中的易失性表示，会在卷卸载时销毁。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">存储保留则是一种基于NTFS预留的功能，允许文件拥有分配的存储保留区域。存储保留定义了15个不同的保留区域（其中2个由操作系统保留），它们被定义并存储在内存和NTFS磁盘数据结构中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">要使用新增的磁盘保留功
能，应用程序需使用文件系统控制代码FSCTL_QUERY_STORAGE_RESERVE定义卷的存储保留区域，借此通过一种数据结构指定要保留的空
间总量和区域ID。这会导致VCB中多个计数器被更新（存储保留区域维持在内存中），并在$Bitmap元数据文件的$SRAT命名数据流中插入一个新的
数据流。$SRAT数据流中包含的数据结构可跟踪每个保留区域，包括保留簇和已用簇的数量。应用程序可通过文件系统控制代码
FSCTL_QUERY_STORAGE_RESERVE查询有关存储保留区域的信息，并使用FSCTL_DELETE_STORAGE_RESERVE
代码删除存储保留。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">定义了存储保留区域后，应
用程序就可以保证该空间不会被任何其他组件使用。随后应用程序可以使用NtSetInformationFile原生API以及
FileStorageReserveIdInformationEx信息类将文件和目录分配到存储保留区域。NTFS文件系统驱动程序会管理请求，为此
需要更新保留区域内存中的保留和已用簇计数器，并更新卷中属于NTFS预留的已保留簇总数。此外还会存储并更新目标文件在磁盘上的
$STANDARD_INFO属性。后者通过4位来存储保留区域ID，借此系统只需解析MFT项即可快速枚举属于一个保留的每个文件（NTFS在
FSCTL_QUERY_FILE_LAYOUT代码的调度函数中实现了该枚举）。用户可以使用fsutil storageReserve 
findByID命令枚举属于存储保留的文件，只需指定感兴趣的卷路径名和存储保留ID即可。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">存储保留为一些基本文件操
作（如文件创建和更名）造成了新的副作用。新创建的文件或目录会自动继承父目录的存储保留ID，重命名（移动到）新父目录位置的文件或目录也面临这种情
况。由于更名操作会更改文件或目录的存储保留ID，这意味着该操作也可能因为空间不足而失败。将非空目录移动至新父目录位置，意味着新的存储保留ID会以
递归的方式应用至所有文件和子目录。在存储保留所保留的空间耗尽后，系统开始使用卷上的可用空间，因此无法总是保证该操作可以成功。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>观</b><b>察</b><b>存</b><b>储</b><b>保</b><b>留</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">从Windows 10的2019年5月的更新（19H1）开始，我们可以通过自带的fsutil.exe工具查看现有的NTFS保留：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;fsutil storagereserve query c: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Reserve ID:       1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">flags:            0x00000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Space Guarantee:  0x0                (0 MB) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Space Used:       0x0                (0 MB) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Reserve ID:       2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">flags:            0x00000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Space Guarantee:  0x0                (0 MB) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Space Used:       0x199ed000         (409 MB) </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">Windows
安装程序定义了两个NTFS保留：一个硬保留（ID 1），被安装程序用于存储自己的文件，无法被其他应用程序删除或替换；另一个软保留（ID 
2），用于存储临时文件，例如系统日志和Windows 
Update下载的文件。在上述范例中，安装程序已经可以安装自己的所有文件（无须执行Windows 
Update），因此硬保留为空，软保留已经分配了自己的所有保留空间。我们可以使用fsutil storagereserve 
findById命令枚举一个保留中包含的所有文件（注意输出内容很长，因此可以考虑使用 &gt; 符号将输出重定向为文件）。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;fsutil storagereserve findbyid c: 2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">... </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">********* File 0x0002000000018762 ********* </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File reference number   : 0x0002000000018762 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File attributes         : 0x00000020: Archive </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File entry flags        : 0x00000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Link (ParentID: Name)   : 0x0001000000001165: NTFS Name   : </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Windows\System32\winevt\Logs\OAlerts.evtx </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Link (ParentID: Name)   : 0x0001000000001165: DOS Name    : OALERT~1.EVT </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Creation Time           : 12/9/2018 3:26:55 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Last Access Time        : 12/10/2018 0:21:57 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Last Write Time         : 12/10/2018 0:21:57 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Change Time             : 12/10/2018 0:21:57 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">LastUsn                 : 44,846,752 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">OwnerId                 : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">SecurityId              : 551 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">StorageReserveId        : 2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Stream                  : 0x010 ::$STANDARD_INFORMATION </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Attributes          : 0x00000000: *NONE* </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    flags               : 0x0000000c: Resident | No clusters allocated </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Size                : 72 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Allocated Size      : 72 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Stream                  : 0x030 ::$FILE_NAME </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Attributes          : 0x00000000: *NONE* </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    flags               : 0x0000000c: Resident | No clusters allocated </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Size                : 90 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Allocated Size      : 96 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Stream                  : 0x030 ::$FILE_NAME </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Attributes          : 0x00000000: *NONE* </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    flags               : 0x0000000c: Resident | No clusters allocated </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Size                : 90 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Allocated Size      : 96 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Stream                  : 0x080 ::$DATA </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Attributes          : 0x00000000: *NONE* </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    flags               : 0x00000000: *NONE* </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Size                : 69,632 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Allocated Size      : 69,632 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Extents             : 1 Extents </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                        : 1: VCN: 0 Clusters: 17 LCN: 3,820,235 </span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_279" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>2</b><b>0</b><b> </b><b>事</b><b>务</b><b>支</b><b>持</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">借助内核对内核事务管理器
（KTM）的支持，以及通用日志文件系统提供的必要设施，NTFS实现了一种名为事务型NTFS（也叫TxF）的事务模型。TxF提供了一系列用户模式
API，应用程序可以借此对自己的文件和目录执行事务型操作，并通过文件系统控制（FSCTL）接口管理自己的资源管理器。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 作为向Windows引入原子性事务的一种方式，Windows 
Vista引入了对TxF的支持。NTFS驱动程序也因此进行了一些修改，但实际上并未改变NTFS数据结构的格式，所以自Windows 
XP和Windows Server 
2003起，NTFS格式版本就始终为3.1。TxF重新使用原本只为支持EFS而使用的属性类型（$LOGGED_UTILITY_STREAM），并
未增加新的属性类型，借此实现了向后兼容性。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">TxF是一个强大的API，但因为过于复杂，开发者需要考虑很多问题，因此只有少数应用程序用到了该功能。截至撰写这部分内容，微软正考虑在后续版本的Windows中弃用TxF API。但考虑到内容的完整性，本书依然会概括介绍TxF的架构。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">TxF的整体架构如图11-54所示，其中包含以下多个组件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·实现于Kernel32.dll库中的事务API。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个读取TxF日志的库（%SystemRoot%\System32\Txfw32.dll）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个用于实现TxF日志功能的COM组件（%SystemRoot\System32\Txflog.dll）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·NTFS驱动程序内部的事务型NTFS库。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·用于读/写日志记录的CLFS基础架构。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/48d70855871c2ea545bb1f86b8116885.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-54 TxF架构</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_280" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>2</b><b>1</b><b> </b><b>隔</b><b>离</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然事务型文件操作是可选
的，但正如第10章介绍的事务型注册表（TxR）操作那样，TxF也会对无法感知事务的常规应用程序产生一定影响，因为它可以保证实现隔离的事务型操作。
举例来说，如果杀毒软件正在扫描的文件被其他应用程序通过事务型操作修改了，则TxF必须确保扫描器能读取到执行事务型操作前的数据，而在事务型操作中访
问文件的应用程序必须能读取到修改后的数据。这种模型也叫读取-提交隔离（read- committed isolation）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">读取-提交隔离涉及事务写
入者和事务读取者的概念。写入者始终能看到文件最新版本的视图，包括当前与该文件相关事务做出的所有改动。任何时候，一个文件只能有一个事务写入者，这意
味着这种写入是独占式的写入。另外，事务读取者在打开文件时只能访问该文件提交后的版本，因此读取者与写入者所做的改动是相互隔离的。这样读取者就可以对
文件获得一致的视图，哪怕此时还有写入者正在提交改动。要查看更新后的数据，事务读取者必须打开一个指向修改后的文件新句柄。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">事务写入者和事务读取者还
会禁止非事务型写入者打开文件，因此，除非执行事务型操作，否则将无法更改文件。非事务型读取者的行为与事务型读取者的行为类似，只能看到文件句柄打开时
最后一次提交后的文件内容。不过与事务型读取者不同的是，非事务型读取者无法实现读取-提交隔离，因此无须打开新句柄，也可以始终获得事务型操作的文件最
近一次提交后的最新版本视图。这样无法感知事务的应用程序才能表现出符合预期的行为。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">总而言之，TxF的读取-提交隔离模型具备下列特征：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·变更会与事务型读取者相互隔离。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果相关事务因为计算机崩溃或卷被强行卸载而回滚，变更也会回滚（撤销）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果相关事务成功提交，变更也会刷新到磁盘。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_281" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>2</b><b>2</b><b> </b><b>事</b><b>务</b><b>型</b><b>A</b><b>P</b><b>I</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">TxF实现了Windows文件I/O API的事务型版本，它们均使用“Transacted”作为后缀。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Create API：CreateDirectoryTransacted、CreateFileTransacted、CreateHardLinkTransacted、CreateSymbolicLinkTransacted。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Find API：FindFirstFileNameTransacted、FindFirstFileTransacted、FindFirstStreamTransacted。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Query API：GetCompressedFileSizeTransacted、GetFileAttributesTransacted、GetFullPathNameTransacted、GetLongPathNameTransacted。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Delete API：DeleteFileTransacted、RemoveDirectoryTransacted。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Copy和Move/Rename API：CopyFileTransacted、MoveFileTransacted。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Set API：SetFileAttributesTransacted。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，当所传递的文件句柄是事务的一部分时，一些API会自动参与到事务型操作中，例如，由CreateFileTransacted API创建的事务。表11-10列出了在处理事务型文件句柄时，默认行为有变化的Windows API。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表11-10 被TxF改变的API行为</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/0891d118984ae981cbf5a8162d38ad5a.jpg" alt="" title=""></div>
</div><div class="header2"><h3><span id="sigil_toc_id_282" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>2</b><b>3</b><b> </b><b>磁</b><b>盘</b><b>上</b><b>的</b><b>实</b><b>现</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如表11-7所示，TxF
使用$LOGGED_UTILITY_STREAM特性类型来存储事务中当前或曾经涉及的文件和目录的额外数据。该属性也叫$TXF_DATA，其中包含
的重要信息可供TxF为与事务相关的文件保存活跃的脱机数据。该特性会永久保存在MFT中，也就是说，即使文件不再与事务相关，数据流依然会存在，具体原
因见下文。该属性的主要组件如图11-55所示。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图11-55所示的第一个
字段是资源管理器根的文件记录号，主要负责与文件有关的事务。默认资源管理器的文件记录号为5，这也是MFT中根目录（\）的文件记录号，如图11-31
所示。TxF在为文件创建FCB时需要这些信息，这样才可以将其与正确的资源管理器链接在一起；NTFS收到事务文件请求时，也需要为事务创建登记
（Enlistment）。</span></p><div style="display: block;text-align:center;">
	<img width="390" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/47e0f2798a31eefa2b071fdcf0a42cbf.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-55 $TXF_DATA属性</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">$TXF_DATA属性中
存储的另一个重要数据是TxF文件的ID，即TxID，这也解释了为何$TXF_DATA属性永远不会被删除。因为NTFS在写入事务日志时会将文件名写
入记录，因此需要通过一种具备唯一性的方式来识别同一目录下可能使用相同名称的文件。举例来说，如果在一个事务中从某个目录里删除了
sample.txt，随后在同一个目录中创建了一个同名的新文件（都在同一个事务中进行），TxF就需要通过某种具备唯一性的方式区分
sample.txt的两个实例。这种区分由一个64位的唯一数字（TxID）实现，当新文件（或文件的一个实例）关联事务之后，TxF会增大这个数字。
由于永远不能重复使用，所以TxID具备永久性，$TXF_DATA属性永远不会从文件中移除。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">同样重要的是，事务涉及的
每个文件都会存储三个CLFS（Common Logging File 
System，通用日志文件系统）LSN。每当事务被激活（如创建、更名或写入操作过程中）时，TxF会向其CLFS日志写入一条日志记录，每条记录都会
分配一个LSN，而该LSN会被写入$TXF_DATA属性的相应字段。第一个LSN所存储的日志记录可标识出与该文件有关的NTFS元数据变化。举例来
说，如果事务操作改变了文件的标准属性，TxF必须更新相关的MFT文件记录，并存储用于描述该变化的日志记录的LSN。在文件的数据被修改后，TxF将
使用第二个LSN。最后，当目录的文件名索引需要更改文件所涉及的事务，或参与事务的目录收到TxID时，TxF将使用第三个LSN。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">$TXF_DATA属性还
存储了内部标记，借此向TxF以及提交时应用到文件的USN记录描述状态信息。一个TxF事务可以跨越多个USN记录，这些记录的部分内容可能已经被
NTFS的恢复机制（见下文）更新了，因此，索引可以告诉TxF在恢复之后还需要应用多少个USN记录。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">TxF会对每个卷使用默认
资源管理器来跟踪其事务状态，不过TxF也支持额外的资源管理器（名为辅助资源管理器）。这些资源管理器可由应用程序写入者定义，可将元数据保存在应用程
序选择的任何目录中，并为撤销、备份、还原和重做操作定义自己的事务工作单元。默认资源管理器和辅助资源管理器均可包含一定数量的元数据文件和目录，借此
描述自己的当前状态。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·$Txf目录，位于$Extend\$RmMetadata目录下，文件被事务操作删除或覆盖写入后，会在这里进行链接。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·$Tops，
即TxF Old Page 
Stream（TOPS，TxF旧页流）文件，其中包含默认数据流和一个名为$T的备用数据流。TOPS文件的默认流包含与资源管理器有关的元数据，如
GUID、CLFS日志策略以及恢复工作起始位置的LSN。$T流包含部分被事务写入器覆盖写入的文件数据（而非完整覆盖写入，完整覆盖写入会将文件移动
至$Txf目录）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·TxF
日志文件，即存储事务记录的CLFS日志文件。对于默认资源管理器，这些文件是$TxfLog目录的一部分，但辅助资源管理器可将其存储在任何位置。
TxF使用了一种名为$TxfLog.blf的复用基础日志文件。文件\$Extend\$RmMetadata\$TxfLog\$TxfLog包含两
个流：用于保存内核事务管理器元数据记录的KtmLog流，以及保存TxF日志记录的TxfLog流。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>询</b><b>资</b><b>源</b><b>管</b><b>理</b><b>器</b><b>信</b><b>息</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以使用系统自带的Fsutil.exe命令行工具查询与默认资源管理器有关的信息，或借此创建、启动和停止辅助资源管理器，并配置其日志策略和行为。下列命令可查询根目录（\）的默认资源管理器的相关信息：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">d:\&gt;fsutil resource info \</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Resource Manager Identifier :     81E83020-E6FB-11E8-B862-D89EF33A38A7 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">KTM Log Path for RM: \Device\HarddiskVolume8\$Extend\$RmMetadata\$TxfLog\$TxfLog::</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  KtmLog </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Space used by TOPS:   1 Mb </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">TOPS free space:      100% </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">RM State:             Active </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Running transactions: 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">One phase commits:    0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Two phase commits:    0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">System initiated rollbacks: 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Age of oldest transaction: 00:00:00 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Logging Mode:         Simple </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Number of containers: 2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Container size:       10 Mb</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Total log capacity:   20 Mb</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Total free log space: 19 Mb</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Minimum containers:   2</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Maximum containers:   20</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Log growth increment: 2 container(s)</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Auto shrink:          Not enabled</span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">RM prefers availability over consistency.</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如
上文所述，fsutil 
resource命令针对Txf资源管理器提供了多种配置选项，甚至可以在我们自选的任意目录下创建辅助资源管理器。例如，可以使用fsutil 
resource create c:\rmtest命令在Rmtest目录下创建辅助资源管理器，随后使用fsutil resource start
 
c:\rmtest命令将其启动。请注意，随后该文件夹下会出现$Tops和$TxfLogContainer*文件，以及TxfLog和$Txf目录。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_283" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>2</b><b>.</b><b>2</b><b>4</b><b> </b><b>日</b><b>志</b><b>记</b><b>录</b><b>的</b><b>实</b><b>现</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在因为持续的事务而更改了
磁盘内容后，TxF都会将改动记录写入自己的日志。TxF使用多种日志记录类型来跟踪事务变化，但无论哪种类型，所有TxF日志记录都有一个通用的头部，
其中包含的信息可用于识别记录类型、与记录有关的操作、记录应用到的TxID，以及与其相关的KTM事务的GUID。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">重做（Redo）记录指定
了在事务没有实际从缓存刷新到磁盘的情况下，应该如何将已提交的改动重新应用到卷。另外，撤销（Undo）记录则指定了在需要进行回滚时，如何撤销尚未提
交的事务中涉及的改动。一些记录仅适用于重做，这意味着其中不包含任何等价的撤销信息，而一些记录可能同时包含了重做和撤销信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">TxF通过TOPS文件维
护两个关键数据：基础LSN（Base LSN）和重启动LSN（Restart 
LSN）。基础LSN决定了日志中第一条有效记录的LSN，重启动LSN则表明启动资源管理器时应从哪个LSN开始恢复。TxF写入重启动记录时会更新这
两个值，代表改动已应用给卷并刷新到磁盘，这意味着文件系统已与最新的重启动LSN完全一致。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">TxF还会写入补偿性日志
记录（Compensating Log 
Record，CLR），这些记录存储了事务回滚过程中执行的操作。CLR主要用于存储“Undo-next”（撤销下一个）LSN，借此让恢复过程跳过
已被处理的撤销记录，而不会重复执行撤销操作（这种情况多见于系统在恢复阶段失败，但已经执行了部分撤销操作的情况）。最后，TxF还需要处理准备
（Prepare）、中止（Abort）以及提交（Commit）记录，这些记录描述了与TxF有关的KTM事务状态。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11_0013.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_284" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>3</b><b> </b><b>N</b><b>T</b><b>F</b><b>S</b><b>恢</b><b>复</b><b>支</b><b>持</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS恢复支持保证了在
发生断电或系统故障的情况下，不会让任何文件系统操作（事务）处于未完成的状态，并且无须运行磁盘的修复工具亦可保持磁盘卷结构的完整。NTFS 
Chkdsk工具可用于修复因I/O错误（如磁盘坏扇区、电气异常或磁盘故障）或软件Bug导致的灾难性磁盘损坏。但在NTFS恢复功能的支持下，已经很
少需要使用Chkdsk了。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文“可恢复性”一节所
述，NTFS借助事务处理方案来实现可恢复性。这种策略保证，即使非常大的磁盘，也可以用非常快的速度（在几秒内）实现全磁盘恢复。NTFS的恢复过程仅
限文件系统数据，这确保了用户不会因为文件系统错误而丢失整个卷，除非应用程序采取特定操作（例如将缓存文件刷新到磁盘），NTFS的恢复支持无法保证用
户数据在崩溃后可以完整更新，这项工作是由事务型NTFS（TxF）负责的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">下文详细介绍了NTFS用于记录文件系统数据结构改动的事务日志方案，并将介绍NTFS如何在系统故障后恢复卷。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_285" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>3</b><b>.</b><b>1</b><b> </b><b>设</b><b>计</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS实现了可恢复文件
系统的设计。可恢复文件系统通过使用最初为事务处理开发的日志记录技术（也叫Journal）保证了卷的一致性。如果操作系统崩溃，可恢复文件系统将执行
恢复过程以访问存储在日志文件中的信息，进而恢复一致性。由于文件系统已将磁盘写入记录到日志中，无论多大的卷，恢复过程都可以在几秒内完成（不像FAT
文件系统，恢复时间与卷的大小密切相关）。可恢复文件系统的恢复过程是精确的，可保证卷被恢复至一致的状态。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">可恢复文件系统所实现的安
全性需要付出一定的代价。每个会改变卷结构的事务，都需要为该事务的每个子操作将一条记录写入日志文件中。这种日志记录所造成的开销可通过文件系统的日志
批处理操作得以改善，即通过一个I/O操作将多条记录写入日志文件。此外，可恢复文件系统还可以使用惰性写入文件系统这种优化措施，甚至可以延长两次缓存
刷新操作的间隔时间，因为如果在将缓存的变化刷新到磁盘之前系统就已崩溃，文件系统元数据依然可以恢复。这种缓存性能提升机制与惰性写入文件系统相互配
合，可有效弥补甚至完全抵消可恢复文件系统日志记录活动所产生的性能开销。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">无论是慎重写入操作还是惰性写入文件系统，都无法保证为用户文件数据提供保护。如果系统在应用程序写入文件的过程中崩溃，文件可能丢失或损坏。更糟的是，崩溃可能导致惰性写入文件系统出错，进而破坏原有文件，甚至让整个卷处于不可访问的状态。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为实现比传统文件系统更高
的可恢复性，NTFS可恢复文件系统实现了多种策略。首先，NTFS可恢复性保证了卷结构不会损坏，因此系统出现故障后，所有文件依然是可以访问的。其
次，尽管NTFS无法保证在系统崩溃后依然保护用户数据（一些改动可能会从缓存中丢失），但应用程序可以利用NTFS的直写和缓存刷新能力保证以适当的时
间间隔将文件改动记录到磁盘上。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存直写（强制将写操作立
即记录到磁盘上）和缓存刷新（强制将缓存内容写入磁盘）都是很高效的操作。NTFS无须执行额外的磁盘I/O即可将改动刷新到多种不同的文件系统数据结
构，因为对数据结构的改动均已通过一个写操作记录至日志文件，如果出现故障导致缓存内容丢失，则可从日志中恢复文件系统的改动。此外，与FAT文件系统不
同，即便系统随后遇到故障，NTFS也能保证用户数据在直写操作或缓存刷新后处于一致、立即可用的状态。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_286" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>3</b><b>.</b><b>2</b><b> </b><b>元</b><b>数</b><b>据</b><b>日</b><b>志</b><b>记</b><b>录</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS使用与TxF相同
的日志技术提供文件系统的可恢复性，同样需要将文件系统元数据的所有修改操作记录到日志文件中。不过与TxF的不同之处在于，NTFS内置的文件系统恢复
支持并未使用CLFS，而是通过使用一种名叫日志文件服务（并非第10章介绍的后台服务进程）的内部日志记录实现。另一个不同之处在于，TxF只在调用方
选择执行事务操作时使用，NTFS则会记录所有元数据改动，这样文件系统即可在系统故障后继续保持一致。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_287" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>3</b><b>.</b><b>3</b><b> </b><b>日</b><b>志</b><b>文</b><b>件</b><b>服</b><b>务</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">日志文件服务（Log 
File 
Service，LFS）是NTFS驱动程序中的一系列内核模式例程，NTFS借此来访问日志文件。NTFS会向LFS传递一个打开的文件对象的指针，以
此指定要访问的日志文件。LFS会初始化新的日志文件，或调用Windows缓存管理器通过缓存访问现有日志文件，具体过程如图11-56所示。请注意，
虽然LFS和CLFS的名字听起来类似，但它们代表了适合不同用途的不同日志实现，只不过在很多方面有着类似的操作。</span></p><div style="display: block;text-align:center;">
	<img width="812" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ff7095bfa0e4dcf6fc5a436084262ee9.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-56 日志文件服务</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">LFS会将日志文件拆分为两个区域：一个是重启动区域，另一个是“无限”日志记录区域，如图11-57所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/9b47d9aaa1bb4009024b8cb7043b7445.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-57 日志文件的区域</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS调用LFS来读/
写重启动区域。NTFS使用重启动区域来存储上下文信息，例如系统故障后的恢复过程中，NTFS在日志记录区域中开始读取的位置。LFS还会对重启动区域
数据维持第二个副本，以免第一个副本出错或因为其他原因无法访问。日志文件的其余部分均为日志记录区域，其中包含NTFS在系统故障后为了恢复卷而写入的
事务记录。LFS会以循环的方式使用日志文件（并保证不会覆盖自己需要的信息），这使得日志文件看起来似乎有着无限的空间。与CLFS类似，LFS也会使
用LSN来区分写入日志文件的记录。当LFS在文件中循环记录时，会增加LSN的数值。NTFS使用64位值来表示LSN，因此可用LSN的数量非常大，
几乎是无限的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS永远不会直接向日
志文件读/写事务记录，而是会调用LFS提供的服务打开日志文件，写入日志记录，以向前或向后的顺序读取日志记录，将日志记录刷新至特定的LSN，或将日
志文件的开头位置设置为更高的LSN。恢复过程中，NTFS会调用LFS来执行与TxF恢复相同的操作：为未刷新的已提交改动执行重做操作，随后为未提交
的改动执行撤销操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统是通过以下流程保证卷可恢复的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）NTFS首先调用LFS，在缓存的日志文件中记录所有即将修改卷结构的事务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）NTFS修改卷（依然在缓存中）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）缓存管理器提示LFS将日志文件刷新到磁盘（LFS通过调用缓存管理器实现刷新，并会告知缓存管理器要刷新哪些内存页。可参考图11-56所示的调用序列）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）缓存管理器将日志文件刷新到磁盘，进而将卷改动（元数据操作本身）刷新到磁盘。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这些步骤确保了如果文件系统改动最终不成功，可从日志文件检索相应事务，并在文件系统恢复过程中重做或撤销。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当系统重启动后首次使用一个卷时，即可自动开始文件系统恢复过程。NTFS会检查崩溃之前记录到日志文件中的事务是否已被应用到卷上，如果还没，则会重做。NTFS还保证了崩溃前没有完整记录的事务会被撤销，使其不会出现在卷中。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_288" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>3</b><b>.</b><b>4</b><b> </b><b>日</b><b>志</b><b>记</b><b>录</b><b>类</b><b>型</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS的恢复机制使用了
与TxF恢复机制类似的日志记录类型：更新（Update）记录，对应于TxF所用的重做和撤销记录；检查点（Checkpoint）记录，类似于TxF
的重启动记录。图11-58展示了日志文件中的三个更新记录。每个记录代表事务的一个子操作，会创建一个新文件。每个更新记录中的“重做”项会告诉
NTFS如何将子操作重新应用给卷，而“撤销”项则会告诉NTFS如何回滚（撤销）子操作。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ea2201a7bc6fe090d86da99485ed0bf1.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-58 日志文件中的更新记录</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在记录了一个事务（例如本
例中调用LFS向日志文件写入三条更新记录）后，NTFS会在缓存中针对卷本身执行子操作。缓存更新完毕后，NTFS会向日志文件写入另一条记录，借此将
整个事务标记为已完成，这个子操作也称为事务提交。事务提交完毕后，NTFS即可保证哪怕操作系统随后故障，整个事务也会出现在卷上。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在从系统故障中恢复时，
NTFS会读取日志文件并重做每个已提交的事务。虽然NTFS已在系统故障前完成了已提交事务，但它并不知道缓存管理器是否已将对卷的改动及时刷新到磁
盘。当系统出现故障时，这些更新可能已从缓存中丢失。因此NTFS会再次执行已提交事务，以确保磁盘上的内容是最新的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在文件系统恢复过程中重做
了已提交事务后，NTFS会在日志文件中查找故障时尚未提交的所有事务，并对每个已记录的子操作进行回滚。在图11-58中，NTFS将首先撤销T1c子
操作，随后跟随向后的指针到达T1b并撤销该子操作。NTFS还将继续跟随向后的指针撤销所有子操作，直到抵达事务中的第一个子操作。通过跟随指针进行处
理，NTFS可以知道必须撤销多少个更新记录，以及撤销哪些更新记录才能将一个事务彻底回滚。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">重做和撤销信息可以用物理
或逻辑的方式来表达。作为维护文件系统结构的最底层软件，NTFS所写入的更新记录包含了物理描述，其中指定了磁盘上需要对卷进行更改、移动等操作的特定
字节范围。这一点与TxF有所不同，TxF使用逻辑描述表达了要执行的更新操作，例如“删除文件A.dat”。NTFS会为下列每种事务写入更新记录（通
常会包含多条记录）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·创建文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·删除文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·扩展文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·截断文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·设置文件信息。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·重命名文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·更改应用给文件的安全性设置。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">更新记录中的重做和撤销信
息必须经过精心设计，因为尽管NTFS可以撤销事务，从系统故障中恢复，甚至能够正常运行，但它可能依然会尝试重做一个已经完成的事务，或者撤销一个从未
发生或已被撤销的事务。类似地，NTFS可能尝试重做或撤销包含多个更新记录的事务，但其中部分记录已经在磁盘上完成了。因此，更新记录的格式必须保证重
复执行相同的重做或撤销操作可以实现幂等的结果（即中性效果）。例如，设置一个已经设置过的位，将不会产生任何影响；但开关一个已经切换过的位，将会产生
影响。文件系统还必须能正确处理中间卷状态。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了更新记录，NTFS还会定期向日志文件中写入检查点记录，如图11-59所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/956924875e7f32590c97fbfcdc967562.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-59 日志文件中的检查点记录</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">检查点记录可以帮助
NTFS确定在突然发生崩溃的情况下，需要执行怎样的处理方式才能恢复卷。NTFS可以借助检查点记录中存储的信息获知很多情况，例如，必须抵达日志文件
中多远的位置才能开始恢复。在写入检查点记录后，NTFS会将该记录的LSN存储到重启动区域，这样，当系统崩溃需要恢复文件系统时，就可以快速找到最新
写入的检查点记录，这与TxF使用重启动LSN的原因是相同的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">尽管LFS向NTFS呈现
的日志文件似乎是无限大的，但其实并非如此。日志文件本身就足够大，并且检查点记录的写入频率足够高（该操作通常可释放日志文件空间），这些因素使得日志
文件几乎不会被填满。尽管如此，LFS也会像CLFS那样跟踪下列多个运行参数来确定日志文件被填满的可能性。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·可用日志空间。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·写入一条传入的日志记录和撤销该写入操作（如果必要）所需的空间量。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·回滚所有活动（未提交）事务（如果必要）所需的空间量。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果日志文件不具备可容纳上述最后两项所需的总空间，LFS会返回“日志文件已满”错误，NTFS会发出异常。NTFS异常处理程序将回滚当前事务，并将其放入队列中以便稍后重新启动。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了释放日志文件的空间，
NTFS必须暂时阻止针对文件进一步执行的事务。为此，NTFS会阻止文件创建和删除的操作，随后请求以独占的方式访问所有系统文件，并以共享方式访问所
有的用户文件。借此，活跃事务将会逐渐成功完成，或收到“日志文件已满”的异常。NTFS会回滚收到异常的事务并将其放入队列。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">一旦按照上文介绍的方式阻
止了针对文件执行的事务活动，NTFS会调用缓存管理器将未写入的数据（包括未写入的日志文件数据）刷新到磁盘。在将一切都安全地刷新到磁盘后，NTFS
就不再需要日志文件中的数据了。随后它会将日志文件的开头重设为当前位置，让日志文件“变空”。接着，NTFS会重启动队列中的事务。除了I/O处理会短
暂地暂停外，日志文件已满错误不会对程序的执行产生任何影响。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上述场景只是NTFS使用日志文件的一个例子，日志文件不仅可用于文件系统的恢复，而且可用于正常运行过程中的错误恢复。下文将进一步介绍错误恢复过程。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_289" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>3</b><b>.</b><b>5</b><b> </b><b>恢</b><b>复</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统启动后，当程序首次访
问NTFS卷时，NTFS会自动执行磁盘恢复（如果无须恢复，则该过程将被忽略）。恢复取决于NTFS在内存中维护的两个表：一个事务表，其作用类似
TxF维护的表；以及一个脏页表，其中记录了缓存中的哪些页包含对文件系统结构的改动但尚未写入磁盘。恢复过程中必须将这些数据刷新到磁盘。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS每隔5秒向日志文
件中写入一次检查点记录。在此之前，它会调用LFS将事务表和脏页表的当前副本存储到日志文件。随后NTFS会在检查点记录中包含日志记录的LSN，该日
志记录包含了复制的表。当系统故障后开始恢复时，NTFS会调用LFS来定位包含最新检查点记录和事务以及脏页表最新副本的日志记录，随后将这些表复制到
内存中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">日志文件通常包含最后一个检查点记录后产生的后续更新记录，这些更新记录代表最后一次写入检查点记录之后对卷进行的改动。NTFS必须更新事务和脏页表，将新的操作包含在内。更新这些表后，NTFS会使用表和日志文件的内容来更新卷本身。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了执行卷恢复，NTFS会将日志文件扫描三次。为了最大限度地减少磁盘I/O，还会在第一次扫描时将文件内容载入内存。每次扫描都是为了实现不同的目的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）分析。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）重做事务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）撤销事务。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_290" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>3</b><b>.</b><b>6</b><b> </b><b>分</b><b>析</b><b>扫</b><b>描</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如图11-60所示，在分
析扫描过程中，NTFS会从日志文件开头处最后一次检查点操作开始位置向前扫描，借此查找更新记录，并用这些记录来更新已经复制到内存的事务和脏页表。请
注意图中的内容，检查点操作在日志文件中存储了三条记录，更新记录可能穿插在这些记录中。因此，NTFS必须在检查点操作起始位置开始自己的扫描。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e7cae4a33fd528cf1ee084fe90408c22.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-60 分析扫描</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">日志文件中的检查点操作之后出现的大部分更新记录都代表对事务表或脏页表的改动。举例来说，如果某条更新记录为“事务已提交”记录，那么该记录所代表的事务必须从事务表中移除。同理，如果更新记录为修改文件系统数据结构的页更新记录，那么必须更新脏页表以反映这一变化。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内存中的表处于最新状态之
后，NTFS会扫描这些表来确定所有尚未应用到磁盘的操作中最早的更新记录所对应的LSN。事务表包含未提交（未完成）事务的LSN，脏页表包含缓存中尚
未刷新到磁盘的记录的LSN。而NTFS在这两个表中找到的最早更新记录的LSN决定了重做操作的起始位置。然而，如果最后的检查点记录更早，则NTFS
将从这里直接开始重做。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> TxF恢复模型并不存在明显的分析过程，相反，正如上文所述，TxF会在重做过程中执行与分析类似的操作。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_291" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>3</b><b>.</b><b>7</b><b> </b><b>重</b><b>做</b><b>扫</b><b>描</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如图11-61所示，在重做阶段，NTFS会从分析阶段确定的最早更新记录对应的LSN处开始，向前扫描日志文件内容。NTFS会寻找页更新记录，其中包含系统故障前已经写入，但尚未刷新到磁盘的卷改动。NTFS会在缓存中重做这些更新。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a0341feba4912f6709b949a95fcbca91.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-61 重做扫描</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当NTFS抵达日志文件结尾时，已经使用必要的卷改动更新了缓存，而缓存管理器的惰性写入器可以开始在后台将缓存内容写入磁盘了。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_292" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>3</b><b>.</b><b>8</b><b> </b><b>撤</b><b>销</b><b>扫</b><b>描</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">完成重做扫描后，NTFS开始执行撤销操作，借此回滚系统故障时所有未提交的事务。图11-62展示了日志文件中的两个事务：事务1已在系统故障前提交，但事务2未提交。NTFS必须撤销事务2。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/35218728a33d2f2abe5794573a0597e3.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-62 撤销扫描</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">假设事务2创建了一个文件，这个操作包含三个子操作，每个子操作都有自己的更新记录。在日志文件中，事务的更新记录是由后向指针链接的，因为它们通常并不连续。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS事务表会列出每个未提交事务最后记录下来的更新记录的LSN。在本例中，事务表将LSN 4049确认为事务2记录下来的最后一条更新记录。按照图11-63从右到左的顺序，NTFS对事务2进行了回滚。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">找到LSN 
4049后，NTFS会查找并执行撤销信息，并将分配位图中的第3～9位清除。随后，NTFS会跟随后向指针抵达LSN 
4048，根据指示将新文件名从相应的文件名索引中删除。最后，NTFS会跟随后向指针抵达LSN 
4046，并根据指示撤销为该文件保留的MFT文件记录。这样事务2就成功回滚了。如果还有其他未提交的事务需要撤销，则NTFS会按照上述过程进行回
滚。由于撤销事务会影响到卷的文件系统结构，所以NTFS必须将撤销操作记录到日志文件中。毕竟恢复过程中可能再次遭遇断电，此时NTFS将不得不重新执
行撤销操作！</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/c3a6972d8c0fb6a7196664ee0cc146b8.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-63 撤销事务</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在恢复过程的撤销操作都完
成后，卷已经被还原为一致的状态。此时，NTFS已经准备好将缓存中的变动刷新到磁盘上，以确保卷的内容保持最新状态。然而在此之前，NTFS必须执行
TxF注册的回调，借此发出LFS刷新的通知。由于TxF和NTFS都使用了提前写入日志的机制，为保证自己元数据的一致性，在刷新NTFS日志前，
TxF必须通过CLFS首先刷新自己的日志（类似地，TOPS文件必须先于CLFS管理的日志文件进行刷新）。随后NTFS会写入一个“空的”LFS重启
动区域，以代表卷已经处于一致的状态，如果系统立即再次出现故障，此时无须进行恢复。恢复完成。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS能够保证通过恢复
过程将卷还原为某种预先存在的一致状态，但该状态未必恰巧是系统崩溃前那一刻的状态。NTFS无法提供这样的保证，因为出于性能方面的考虑，它使用了惰性
提交的算法，这意味着日志文件并不会在每次写入了事务已提交记录之后就立即刷新到磁盘。相反，众多事务已提交记录会分批次一起写入，例如当缓存管理器调用
LFS将日志文件刷新到磁盘时写入，或LFS将检查点记录写入日志文件（每5秒一次）时写入。导致恢复后的卷并不一定为最新状态的另一个原因在于，系统崩
溃时，很多并行执行的事务可能还处于活动状态，其中一些事务已提交记录可能已经写入磁盘，但也有些记录可能尚未写入。恢复之后处于一致状态的卷会包含所有
已写入磁盘的事务已提交记录对应的更新，但不可能包含尚未写入磁盘的事务已提交记录对应的更新。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统故障后，NTFS使用
日志文件来恢复卷，但这过程中也利用了日志事务自身所实现的其他重要机制。文件系统必然包含大量代码，这些代码专门用于恢复常规文件I/O过程中所产生的
文件系统错误。由于NTFS会将每个更改了卷结构的事务记录到日志中，因此，当遇到文件系统错误后，也可以使用日志文件进行恢复，进而大幅简化自己的错误
处理代码。上述日志文件已满错误就是使用日志文件进行错误恢复的一个例子。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">程序收到的大部分I/O错
误并非文件系统错误，因此无法完全由NTFS来解决。例如，当被调用以创建一个文件时，NTFS可能首先会在MFT中创建文件记录，随后在目录索引中录入
新文件的名称。然而当NTFS尝试在位图中为该文件分配空间时，可能发现磁盘已满，文件创建请求无法完成。这种情况下，NTFS会使用日志文件中的信息撤
销自己已经完成的操作，并取消为该文件保留的数据结构。随后，NTFS会向调用方返回磁盘已满的错误信息，而调用方必须对该错误做出适当的反应。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_293" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>3</b><b>.</b><b>9</b><b> </b><b>N</b><b>T</b><b>F</b><b>S</b><b>坏</b><b>簇</b><b>恢</b><b>复</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows中包含的卷
管理器（VolMgr）可以从容错卷上的坏扇区中恢复数据，但如果硬盘无法执行坏扇区重映射，或备用扇区已耗尽，则卷管理器将无法通过坏扇区来替换坏掉的
扇区。当文件系统读取这样的扇区时，卷管理器将无法恢复数据，而是会向文件系统发出警报，称该数据只有一个副本。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">FAT文件系统不响应卷管
理器的这种警报。此外，FAT和卷管理器都无法跟踪坏扇区，因此，为了防止卷管理器为文件系统重复恢复数据，用户必须运行Chkdsk或Format工
具。Chkdsk和Format工具在阻止使用坏扇区方面的效果都不理想。Chkdsk工具需要花费较长时间找到并移除坏扇区，而Format工具只是直
接清空自己格式化的分区中的所有数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了支持类似卷管理器坏扇
区替换这样的功能，NTFS可以动态替换包含坏扇区的簇，并持续跟踪坏簇，以避免坏簇被重复使用（上文曾经提过，NTFS通过对逻辑簇而非物理扇区进行寻
址来维持自己的可移植性）。当卷管理器无法替换坏扇区时，NTFS将执行这些功能。当卷管理器返回坏扇区警报，或当硬盘驱动器返回坏扇区错误时，NTFS
会分配新的簇来替换包含坏扇区的簇。NTFS还会将卷管理器恢复的数据复制到新簇，以重建数据冗余。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图11-64展示了一个用
户文件的MFT记录，该文件在数据运行中包含一个坏簇，因为该数据运行在坏簇出现之前就已经存在。在收到坏扇区的错误信息后，NTFS会将包含该扇区的簇
重新分配到自己的坏簇文件$BadClus。这样就可以防止该坏簇被重新分配给其他文件。随后，NTFS会为文件分配一个新簇，并更改文件的VCN到
LCN的映射，指向新的簇。这种坏簇重映射（上文进行过介绍）如图11-64所示。编号1357的簇包含坏扇区，必须替换为一个好的簇。</span></p><div style="display: block;text-align:center;">
	<img width="761" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/f7aa4b8fb15483163961e8420e52f34e.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-64 包含坏簇的用户文件的MFT记录</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">没人希望收到坏扇区错误信息，但在错误真正出现后，NTFS和卷管理器的组合能够提供可行的最佳解决方案。如果坏扇区位于冗余卷上，那么卷管理器可以恢复数据并在可能的情况下替换该扇区。如果无法替换该扇区，则会向NTFS发出警报，NTFS可以替换包含坏扇区的簇。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果卷未配置为冗余卷，则
坏扇区中的数据将无法恢复。如果卷被格式化为FAT文件系统并且卷管理器无法恢复数据，那么读取坏扇区将得到不确定的结果。如果文件系统的某些控制结构位
于坏扇区中，则整个文件或文件组（甚至整个磁盘）都可能丢失。在最好的情况下，受影响文件中的一些数据（往往是坏扇区之外的所有文件数据）也会丢失。此
外，FAT文件系统很可能将坏扇区重新分配给卷上的同一个或另一个文件，并导致问题再次出现。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与其他文件系统一样，如果
没有卷管理器的帮助，NTFS也无法从坏扇区恢复数据。不过NTFS最大限度遏制了坏扇区可能造成的损害。如果NTFS在读取操作过程中发现坏扇区，它会
重映射包含该扇区的簇，如图11-65所示。如果该卷未配置为冗余卷，NTFS会向调用程序返回一个数据读取错误。尽管坏簇中的数据丢失，但文件的其余部
分（以及整个文件系统）依然完好无损，发出调用的程序可以酌情对数据丢失做出响应，并且坏簇也不会再用于以后的分配。如果在写入（而非读取）操作中发现了
坏簇，NTFS将重映射簇，随后才写入，这可以避免数据丢失，也不会产生错误。</span></p><div style="display: block;text-align:center;">
	<img width="756" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a4c6eabe8f8e76302fd74364da16a361.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-65 坏簇重映射</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果包含文件系统数据的扇
区出错，也会执行类似的恢复过程。如果坏扇区位于冗余卷上，NTFS会使用卷管理器提供的恢复数据动态地替换簇。如果卷不是冗余的，那么数据将无法恢复，
此时NTFS会在$Volume元数据文件中设置一位来表示卷有损坏。系统下次重启动时，NTFS 
Chkdsk工具会检查该位，如果该位已设置，Chkdsk将开始执行，通过重建NTFS元数据来修复文件系统中的错误。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在一些极罕见的情况下，甚
至可容错的磁盘配置也可能会出现文件系统损坏。这种双重错误会导致文件系统数据和重建文件系统数据的机制同时失效。如果系统在NTFS正写入MFT文件记
录（例如文件名索引或日志文件）的镜像副本时崩溃，那么这些文件系统数据的镜像副本可能无法完整更新。如果系统重启动并且主磁盘上恰巧在磁盘镜像的不完整
写入位置出现了坏扇区，NTFS将无法从磁盘镜像中恢复正确的数据。NTFS实现了一种特殊的方案来检测文件系统数据遇到的此类情况。如果发现不一致，
NTFS会在卷文件中设置损坏位，这会导致系统下次重启动时Chkdsk重建NTFS元数据。由于容错磁盘配置中很少出现文件系统错误，因此也就很少需要
用到Chkdsk。它是作为一种安全预防措施提供的，而不是为了实现第一手数据恢复策略。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Chkdsk在NTFS上
的使用与FAT文件系统中的使用有很大差异。在向磁盘写入任何内容前，FAT会设置卷的脏位，然后在改动操作完成后重置该位。如果系统崩溃时存在正在进行
中的I/O操作，则这个脏位将维持已设置的状态，系统重启动时将运行Chkdsk。但在NTFS上，Chkdsk只会在发现意外或遇到不可读的文件系统数
据时才会运行，而NTFS不能从冗余卷或单个卷的冗余文件系统结构中恢复数据（系统启动扇区会在卷的最后一个扇区保存一个副本，启动系统和运行NTFS恢
复过程所需的MFT内容（$MftMirr）也有类似副本，这种冗余确保了NTFS总能启动和恢复自己）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">表11-11总结了当格式化为Windows可支持的不同文件系统的卷上存在坏扇区时，根据上文介绍将会发生的情况。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表11-11 NTFS数据恢复场景总结</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/5445bd1a7ecd1483c9f6fc0064bc7c84.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">①容错卷是指镜像集（RAID-1）或RAID-5集。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">②写入操作的数据不会丢失：NTFS会在写入前重映射簇。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果出现坏扇区的卷是容错卷（RAID-1镜像卷或RAID-5/RAID-6卷），并且硬盘支持坏扇区替换（同时空闲扇区还没耗尽），那么无论使用什么文件系统（FAT或NTFS）都没关系，卷管理器可以在无须用户或文件系统介入的情况下替换坏扇区。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果出现坏扇区的硬盘不支
持坏扇区替换，则由文件系统负责替换（重映射）坏扇区，或（对于NTFS）替换坏扇区所在的簇。FAT文件系统未提供扇区或簇的重映射功能。NTFS簇重
映射的好处在于，文件中损坏的部分可在不损坏文件（或不损坏文件系统，视具体情况而定）的情况下修复，而坏簇将永远不再被使用。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_294" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>3</b><b>.</b><b>1</b><b>0</b><b> </b><b>自</b><b>治</b><b>愈</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">面对如今容量高达数TB的
存储设备，将卷脱机进行一致性检查可能会导致重要服务中断长达数小时。鉴于很多磁盘损坏仅局限于一个文件或元数据的一小部分，NTFS实现了一种自治愈功
能，可以在卷保持联机的状态修复损坏。在NTFS检测到损坏后，会阻止访问已损坏的文件并创建一个系统工作线程，借此对损坏的数据结构执行类似
Chkdsk的修复，并在修复完成后恢复文件的访问。在上述过程中，依然可以正常访问其他文件，借此最大限度避免服务中断。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">我们可以使用fsutil repair set命令查看并设置卷的修复选项，具体选项如表11-12所示。Fsutil工具使用FSCTL_SET_REPAIR文件系统控制代码设置这些选项，这些选项会保存在卷的VCB中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">表11-12 NTFS自治愈行为</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/45249d63e07f029086af3f6952dccc91.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在所有情况，包括可视化警报被禁用（默认设置）的情况下，NTFS会将自己执行的所有自治愈操作记录到System事件日志中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了定期自动进行自治愈，
NTFS还支持通过FSCTL_INITIATE_REPAIR和FSCTL_WAIT_FOR_REPAIR控制代码手动发起自治愈过程（此类自治愈操
作也叫主动自治愈），该过程可通过fsutil repair initiate命令和fsutil repair 
wait命令启动。这样，用户即可强制修复特定的文件，并等待文件修复操作执行完毕。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">要检查自治愈机制的状态，可使用FSCTL_QUERY_REPAIR控制代码或使用fsutil repair query命令：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;fsutil repair query c: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Self healing state on c: is: 0x9</span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> Values: 0x1 - Enable general repair. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">         0x9 - Enable repair and warn about potential data loss. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        0x10 - Disable repair and bugcheck once on first corruption. </span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_295" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>3</b><b>.</b><b>1</b><b>1</b><b> </b><b>联</b><b>机</b><b>磁</b><b>盘</b><b>检</b><b>查</b><b>和</b><b>快</b><b>速</b><b>修</b><b>复</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在一些罕见的情况下，磁盘
损坏不受NTFS驱动程序（通过自治愈、日志文件服务等机制）的管理，需要系统运行Windows磁盘检查工具并让卷脱机。造成磁盘损坏的原因有很多：硬
盘的存储介质出错以及瞬时内存错误等，文件系统的元数据可能会因此而损坏。对于装有多个TB级容量硬盘的大型文件服务器，完整运行磁盘检查工具可能需要数
天的时间。在这种环境中，让卷长时间脱机往往是不可接受的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在Windows 
8之前，NTFS实现了一种更简单的健康模型，其中文件系统卷或者是健康的，或者是不健康的（通过存储在$VOLUME_INFORMATION属性中的
脏位来识别）。在该模型中，只要需要，就会将卷脱机，直到修复损坏的文件系统，随后将卷重新恢复到健康状态为止。脱机时间与卷中存储的文件数量成正比。为
了减少或避免因文件系统损坏而导致的停机，Windows 8重新设计了NTFS的健康模型和磁盘检查机制。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">新模型引入了新的组件，这
些组件相互配合提供了联机磁盘检查工具，可大幅缩短文件系统严重损坏所造成的停机时间。NTFS驱动程序可以在常规的系统I/O过程中识别出多种类型的损
坏。如果检测到损坏，则NTFS会试图进行自治愈（参见上一节）。如果不成功，则NTFS驱动程序会在\$Extend\$RmMetadata\
$Repair文件的$Verify流中写入一个新的损坏记录。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种损坏记录是一种通用数据结构，NTFS可借此描述内存中和磁盘上的元数据损坏。损坏记录由一个固定大小的头部来表示，其中包含版本信息、标记、通过GUID代表的唯一记录类型、可变大小的损坏类型描述，以及可选的上下文。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">损坏记录项正确添加后，NTFS会通过自己的事件提供程序（名为Microsoft-Windows- Ntfs-UBPM）发出一条ETW事件。该ETW事件由服务控制管理器使用，借此启动Spot Verifier服务（有关触发启动服务的详情请参阅第10章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Spot 
Verifier服务（实现于Svsvc.dll库中）会验证发出的损坏信号是否是误报（一些损坏是内存问题导致的间歇性损坏，可能并非磁盘真的损坏
了）。Spot Verifier进行验证的同时会删除$Verify流中的项。如果项所描述的损坏并非误报，则Spot 
Verifier会触发卷$VOLUME_INFORMATION属性中的主动扫描位（Proactive Scan 
Bit，P-bit），进而触发对文件系统的联机扫描。联机扫描由主动式扫描程序（Proactive 
Scanner）执行，是作为一种维护任务由Windows任务计划程序在适当的时候运行的（该任务位于
Microsoft\Windows\Chkdsk下，如图11-66所示）。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/9c03135943bef62b3ce2351da6563cae.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-66 主动式扫描维护任务</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">主动式扫描程序实现于
Untfs.dll库中，会被Windows磁盘检查工具（Chkdsk.exe）导入。当主动式扫描程序运行时，它会通过卷影复制服务为目标卷创建快
照，并针对影子卷完整运行磁盘检查工具。影子卷是只读的，磁盘检查代码可以识别出这一点，因此不会直接修复找到的错误，而是会尝试使用NTFS的自治愈功
能自动修复错误。如果修复失败，则它会向文件系统驱动程序发送FSCTL_CORRUPTION_HANDLING代码，进而在元数据文件\
$Extend\$RmMetadata\$Repair的$Corrupt流中创建一个项，并设置该卷的脏位。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与之前版本的
Windows相比，脏位的含义略有不同。NTFS根命名空间的$VOLUME_INFORMATION属性依然包含脏位，也包含P位，借此可要求进行主
动式扫描；此外还包含F位，可用于对出现严重损坏的卷执行完整的磁盘检查。如果P位或F位被启用，或$Corrupt流包含一条或多条损坏记录，那么文件
系统驱动程序会将该脏位设置为1。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果损坏依然未能解决，那
么在卷已脱机的情况下，已经无法通过其他方法来修复了（但未必需要立即卸载该卷）。Spot 
Fixer是一个新增组件，被磁盘检查工具和Autocheck工具所共享。Spot 
Fixer可以使用由主动式扫描程序插入$Corrupt流的记录。启动时，Autocheck原生应用程序检测到卷是脏的，但此时并不进行完整的磁盘检
查，而是只修复$Corrupt流中的损坏项，这个操作只需要几秒。图11-67展示了上文介绍过的NTFS各组件实现的不同修复方法。</span></p><div style="display: block;text-align:center;">
	<img width="577" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4363fa39e951f97cc00916918e4c567a.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-67 多种组件为NTFS卷的联机磁盘检查和快速故障修复提供的不同方案</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">主动式扫描可通过chkdsk /scan命令手工启动。通过类似的方式，我们也可以使用命令行参数/spotfix让磁盘检查工具执行Spot Fixer。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>测</b><b>试</b><b>联</b><b>机</b><b>磁</b><b>盘</b><b>检</b><b>查</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以通过一个简单的实验来测试联机磁盘检查。假设要针对D:卷执行联机磁盘检查，可以先从D盘播放一个较大的视频流。同时以管理员身份打开命令提示符窗口，并通过下列命令启动联机磁盘检查：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;chkdsk d: /scan </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">The type of the file system is NTFS. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Volume label is DATA. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Stage 1: Examining basic file system structure ... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  4041984 file records processed. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File verification completed. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  3778 large file records processed. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  0 bad file records processed. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Stage 2: Examining file name linkage ... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Progress: 3454102 of 4056090 done; Stage: 85%; Total: 51%; ETA: 0:00:43 .. </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随
后会发现，视频流不会停止，依然可以流畅播放。如果联机磁盘检查发现了故障并且无法在卷挂载的情况下修复，它会在系统文件$Repair的
$Corrupt流中插入记录。为修复错误，需要卸载卷，但修复过程的速度非常快。在这种情况下，只需重启动计算机或通过命令行手动执行Spot 
Fixer即可：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;chkdsk d: /spotfix </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如果选择执行Spot Fixer，此时视频流的播放会被中断，因为卷需要卸载。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11_0014.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_296" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>4</b><b> </b><b>加</b><b>密</b><b>文</b><b>件</b><b>系</b><b>统</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows包含一种名
为Windows 
BitLocker驱动器加密的全卷加密功能。BitLocker可加密并保护卷免受脱机攻击，可一旦系统已成功启动，BitLocker的工作就完成
了。此时可由加密文件系统（Encrypting File 
System，EFS）保护特定文件和目录不被系统中其他已通过身份验证的用户访问。当为数据选择保护方法时，BitLocker和EFS之间并不是“非
此即彼”的选择，这两种技术都针对一些具体，但并不重叠的威胁提供保护。通过配合使用，BitLocker和EFS可以联手为系统中的数据提供“深度防
御”。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">EFS使用对称加密（文件
的加密和解密使用同一个密钥）的范式加密文件和目录。随后，这个对称加密密钥会使用获得授权可访问文件的每位用户所持有的非对称加密（一个密钥用于加密，
称为公钥；另一个密钥用于解密，称为私钥）密钥进行加密。这些加密方法的细节和背后的理论已超出了本书范围，相关入门知识可参阅：https://
docs.microsoft.com/windows/desktop/SecCrypto/cryptography-essentials。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">EFS能够与
Windows下一代加密技术（Cryptography Next 
Generation，CNG）API配合工作，因此可配置为使用CNG所能支持（或加入其中）的任何算法。默认情况下，EFS将使用高级加密标准
（Advanced Encryption 
Standard，AES）进行对称加密（256位密钥），并使用Rivest-Shamir-Adleman（RSA）公钥算法进行非对称加密
（2048位密钥）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">用户可以通过
Windows资源管理器来加密文件，为此需要打开文件的“属性”对话框，点击“高级”，随后选中“加密内容以便保护数据”选项，如图11-68所示（文
件可以被加密或压缩，但无法同时被加密和压缩）。用户也可以通过命令行工具Cipher（%SystemRoot%
\System32\Cipher.exe）加密文件，或以编程的方式使用Windows 
API，例如使用EncryptFile和AddUsersToEncryptedFile来加密文件。</span></p><div style="display: block;text-align:center;">
	<img width="580" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/451c0eee7d472ba72baf6294dc8e3903.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-68 使用<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>高</b><b>级</b><b>属</b><b>性</b></span>对话框加密文件</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于设置为加密的目录，
Windows会自动加密目录中包含的所有文件。当文件被加密时，EFS会为该文件生成一个随机数，EFS将其称为文件加密密钥（File 
Encryption 
Key，FEK）。EFS会使用FEK通过对称加密方法加密文件的内容，随后EFS会使用该用户的非对称公钥加密FEK，并将加密后的FEK存储在文件的
$EFS备用数据流中。公钥的来源可以由管理员通过分配X.509证书或智能卡的方式指定，也可以随机生成。生成的证书会被加入用户的证书存储中，随后即
可使用证书管理器（%SystemRoot%\System32\Certmgr.msc）查看。EFS完成这些步骤后，文件即可受到保护。其他用户没有
文件的解密FEK，因而无法解密数据；同时因为没有该用户的私钥，自然也就无法解密FEK。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对称加密算法通常速度很
快，因此很适合用于加密大量数据，如文件数据。然而对称加密算法也有弱点：只要获得了密钥，即可绕过它的安全保护。如果多个用户希望共享只使用对称加密算
法保护的加密文件，那么每个用户都需要访问该文件的FEK。不对FEK加密这明显是一个安全问题；但如果只对FEK进行一次加密，这需要所有用户共享同一
个FEK解密密钥，这也是一种潜在的安全问题。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">确保FEK的安全是一个棘
手的难题，而EFS通过加密架构中基于公钥的这部分机制解决了这个问题。为需要访问文件的每个用户分别加密文件的FEK，这样即可让多个用户共享同一个加
密文件。EFS可以用每个用户的公钥加密文件的FEK，随后将每个用户加密后的FEK存储在文件的$EFS数据流中。任何人都可以访问用户的公钥，但任何
人都无法使用公钥来解密这个公钥所加密的数据。用户只能使用自己的私钥来解密文件，而操作系统必须能访问这些私钥。用户的私钥可以成功解密文件中该用户对
应的加密FEK副本。基于公钥的算法通常速度很慢，但EFS只使用这些算法加密FEK。将密钥管理工作拆分为公钥和私钥两部分，使得密钥管理工作相比对称
加密算法更容易一些，同时也解决了FEK安全保护的难题。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">EFS的架构如图
11-69所示，其中包含多个组件。对EFS的支持已经被并入NTFS驱动程序中。当NTFS遇到加密文件时，它会执行文件中包含的EFS函数。当应用程
序访问加密文件时，由EFS函数对文件数据进行加密和解密。虽然EFS会将FEK与文件数据存储在一起，但FEK会使用用户的公钥进行加密。若要加密或解
密文件数据，EFS必须先借助驻留在用户模式下的CNG密钥管理服务解密文件的FEK。</span></p><div style="display: block;text-align:center;">
	<img width="884" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ee71c11b309aae5c5ce0116aa4dd8169.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-69 EFS的架构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">本地安全机构子系统
（LSASS，%SystemRoot%\System32\Lsass.exe）负责管理登录会话，同时也承载了EFS服务（Efssvc.dll）。
例如，当EFS需要解密FEK以便解密用户想要访问的文件数据时，NTFS会向LSASS内部的EFS服务发出请求。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_297" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>4</b><b>.</b><b>1</b><b> </b><b>首</b><b>次</b><b>加</b><b>密</b><b>文</b><b>件</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在遇到加密文件后，
NTFS驱动程序会调用EFS辅助函数。文件的属性中记录了该文件是被加密的，同时还可通过这种方式记录文件是被压缩的（详见上文）。NTFS有一个专门
的接口，可以将文件从非加密状态转换为加密状态，但该过程很大程度上是由用户模式组件驱动的。如上文所述，Windows可以让用户通过两种方式来加密文
件：使用命令行工具cipher，或在Windows资源管理器的“高级属性”对话框中选中“加密内容以便保护数据”选项。这两种方式都用到了
Windows的EncryptFile API。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">EFS只在加密文件中存储
一个信息块，共享该文件的每个用户都在这个信息块中有一个对应的项。这些项称为密钥项（Key 
Entry），EFS会将其存储在文件的EFS数据的数据解密字段（Data Decryption 
Field，DDF）中。多个密钥项的集合则被称为密钥环（Key Ring），正如上文所述，EFS可供多个用户共享同一个加密文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图11-70展示了文件的
EFS的信息和密钥项的格式。EFS在密钥项的第一部分存储了精确描述用户公钥所需的足够信息。这些数据包括用户的安全ID（SID）（请注意，SID无
法保证一定存在）、存储密钥的容器名称、加密提供程序的名称，以及非对称密钥对的证书哈希。解密过程只会用到非对称密钥证书哈希。密钥项的第二部分包含
FEK的加密版本。EFS会通过CNG使用所选的非对称加密算法和用户的公钥来加密FEK。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/63ae837902efed38f07c10ffa18c4e7f.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-70 EFS的信息和密钥项的格式</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">EFS在文件的数据恢复字
段（Data Recovery 
Field，DRF）中存储了有关恢复密钥项的信息。DRF项的格式与DDF项的完全相同。DRF的用途是，当管理工作必须访问用户的数据时，让指定的账
户或恢复代理解密用户文件。例如，当公司员工忘记自己的登录密码时，管理员可以重置用户密码，但如果不借助恢复代理，用户加密的数据将无法恢复。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">恢复代理是通过本地计算机
或域的加密数据恢复代理安全策略定义的。该策略可通过图11-71所示的本地安全策略MMC控制台配置。当使用添加恢复代理向导（右键点击“加密文件系
统”并点击“添加数据恢复代理”）时，可以添加恢复代理并指定恢复代理使用哪个私钥/公钥对（通过证书来指定）进行EFS恢复。Lsasrv（本地安全机
构服务，详见卷1第7章）会在初始化及收到有关恢复策略已更改的通知时解释恢复策略。EFS会使用为EFS恢复注册的加密提供程序为每个恢复代理创建
DRF密钥项。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b31ef7bd537902a730ad334248f3350e.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-71 加密数据恢复代理组策略</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">用户可以使用cipher /r命令创建自己的数据恢复代理（Data Recovery Agent，DRA）证书。借此生成的私钥证书文件可通过恢复代理向导导入，也可以通过域控制器或管理员解密文件所用的计算机的“证书”控制台导入。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">作为为文件创建EFS信息
的最后一步，Lsasrv会使用Cryptographic Provider 
1.0的MD5哈希设施计算DDF和DRF的校验值。Lsasrv将校验值计算结果存储在EFS信息头部。EFS会在解密过程中参考这些校验值，以确保文
件的EFS信息内容不被损坏或不被篡改。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>加</b><b>密</b><b>文</b><b>件</b><b>数</b><b>据</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当用户加密现有文件时，会发生下列操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）EFS以独占访问的方式打开目标文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）文件中的所有数据流被复制到系统临时目录下一个明文的临时文件中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）随机生成一个FEK，并使用该FEK通过AES-256算法加密文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）创建一个DDF，其中包含使用用户的公钥加密后的FEK。EFS可以从用户的X.509版本3文件加密证书中自动获取用户的公钥。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">5）如果通过组策略指定了恢复代理，则会创建一个DRF，其中包含使用RSA和恢复代理的公钥加密后的FEK。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">6）EFS从恢复代理的X.509版本3证书中自动获取恢复代理的公钥，而该证书存储在EFS策略中。如果有多个恢复代理，则会使用每个代理的公钥加密一个FEK副本，并分别创建DRF来存储每个加密后的FEK。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 证书中的File Recovery（文件恢复）属性是增强型密钥使用（Enhanced Key 
Usage，EKU）字段的一个用例。EKU拓展和拓展属性决定并限制了证书的有效用途。作为微软公钥基础架构（PKI）的一部分，File 
Recovery是微软定义的一个EKU字段。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">7）EFS将加密后的数据以及DDF和DRF重新写回文件。由于对称加密不会增加额外数据，因此文件加密后的体积只会有很小的变化。元数据主要由加密后的FEK组成，通常大小不会超过1KB。因此，加密前后文件大小的字节数通常不会有变化。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">8）明文临时文件被删除。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在用户将文件保存到已被加密的文件夹之后，也将发生类似上述过程的操作，只不过不会创建临时文件。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_298" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>4</b><b>.</b><b>2</b><b> </b><b>解</b><b>密</b><b>过</b><b>程</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">当应用程序访问被加密的文件时，将发生如下解密过程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）NTFS识别到文件被加密，向EFS驱动程序发出一个请求。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）EFS驱动程序检索DDF并将其传递给EFS服务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）EFS服务从用户配置文件检索用户的私钥，并用私钥解密DDF以获得FEK。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）EFS服务将FEK回传给EFS驱动程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">5）EFS驱动程序使用FEK解密文件中应用程序需要访问的部分。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 当应用程序打开文件时，只会对文件中应用程序需要的那部分数据进行解密，因为EFS使用了加密块链接（Cipher Block Chaining）。如果用户移除文件的加密特性，此时的行为将有所不同，那么整个文件都会被解密并重写为明文形式。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">6）EFS驱动程序将解密后的数据返回给NTFS，NTFS将其发送给发出请求的应用程序。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_299" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>4</b><b>.</b><b>3</b><b> </b><b>备</b><b>份</b><b>加</b><b>密</b><b>的</b><b>文</b><b>件</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">任何文件加密设施在设计上
都有一个重要的问题需要注意：除了通过加密设施访问文件的应用程序之外，文件数据永远不能以未加密的形式出现。这种限制会对使用存档介质存储文件的备份工
具产生较大影响。EFS通过为备份工具提供一种专用设施解决了该问题，借此备份工具可以备份并恢复处于加密状态的文件。同时，备份工具无须解密文件数据，
也不需要在自己的备份过程中重新加密文件数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">备份工具可以使用EFS 
API的OpenEncryptedFileRaw、ReadEncryptedFileRaw、WriteEncryptedFileRaw和
CloseEncryptedFileRaw函数访问文件加密后的内容。在备份过程中，当备份工具以原始访问（raw 
access）的形式打开一个文件时，将能调用ReadEncryptedFileRaw来获取文件数据。所有EFS备份工具API都可以向NTFS发出
FSCTL。例如，ReadEncryptedFileRaw 
API首先会向NTFS驱动程序发出FSCTL_ENCRYPTION_FSCTL_IO控制代码以读取$EFS流，随后即可读取文件的所有流（包括
$DATA流和可选的备用数据流）。如果流被加密，则可通过ReadEncryptedFileRaw 
API使用FSCTL_READ_RAW_ENCRYPTED控制代码向文件系统驱动程序请求加密后的流数据。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>E</b><b>F</b><b>S</b><b>信</b><b>息</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">EFS
还提供其他一些可供应用程序操作加密后的文件的API函数。例如，应用程序可使用AddUsersToEncryptedFile 
API函数允许其他用户访问加密文件，并使用RemoveUsersFromEncryptedFile撤销其他用户对加密文件的访问。应用程序可使用
QueryUsersOnEncryptedFile函数获取文件相关DDF和DRF密钥字段的信息，或使用
QueryUsersOnEncryptedFile返回SID、证书哈希值，并显示所包含的每个DDF和DRF密钥字段的相关信息。下列输出结果来自
Sysinternals的EFSDump工具，在通过命令行参数指定加密文件后，该工具将输出下列内容：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\Andrea&gt;efsdump Test.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">EFS Information Dumper v1.02 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright (C) 1999 Mark Russinovich </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Systems Internals - http://www.sysinternals.com </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\Andrea\Test.txt: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">DDF Entries: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    WIN-46E4EFTBP6Q\Andrea: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Andrea(Andrea@WIN-46E4EFTBP6Q) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Unknown user: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Tony(Tony@WIN-46E4EFTBP6Q) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">DRF Entry: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Unknown user: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        EFS Data Recovery </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">从以上内容中可知，Test.txt文件有两个DDF项，分别对应用户Andrea和Tony，有一个DRF项对应EFS数据恢复代理，这也是当前系统中注册的唯一的一个恢复代理。我们可以使用Cipher工具添加或移除文件DDF项中的用户。例如：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">cipher /adduser /user:Tony Test.txt</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">上述命令可以允许用户Tony访问加密文件Test.txt（向文件的DDF中添加一项）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_300" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>4</b><b>.</b><b>4</b><b> </b><b>复</b><b>制</b><b>加</b><b>密</b><b>的</b><b>文</b><b>件</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在复制加密的文件时，系统
并不会首先解密文件，随后在目标位置重新加密该文件，而是会直接将加密后的数据和EFS备用数据流复制到目标位置。然而，如果目标位置不支持备用数据流，
也就是说，目标位置并非是NTFS卷（例如是FAT卷），或目标位置是网络共享（哪怕该共享承载于NTFS卷上），此时将无法照常进行复制操作，因为备用
数据流将会丢失。如果是通过Windows资源管理器执行复制操作，此时会出现一个对话框提示用户目标卷不支持加密，并询问用户是否继续将文件以不加密形
式复制到目标位置。如果用户同意，则文件会被解密并复制到指定位置。如果在命令行下进行复制，则Copy命令将直接失败并返回错误信息“无法加密指定的文
件”。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_301" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>4</b><b>.</b><b>5</b><b> </b><b>B</b><b>i</b><b>t</b><b>L</b><b>o</b><b>c</b><b>k</b><b>e</b><b>r</b><b>加</b><b>密</b><b>卸</b><b>载</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS文件系统驱动程序
可以使用加密文件系统（EFS）提供的服务来执行文件加密和解密操作。这些内核模式的服务可以与通过回调提供给NTFS的用户模式加密文件服务
（Efssvc.dll）通信。当用户或应用程序首次加密文件时，EFS服务会向NTFS驱动程序发送FSCTL_SET_ENCRYPTION的控制代
码。NTFS文件系统驱动程序可以使用EFS的“写入”回调对原始文件中的数据执行内存中加密。实际的加密过程始终会对文件内容进行拆分，通常会将2MB
大小的文件块（Block）拆分为512B的小块（Chunk）。EFS库会使用BCryptEncrypt 
API加密拆分后的小块。如上文所述，加密引擎由内核CNG驱动程序（Cng.sys）提供，该引擎支持EFS所使用的AES或3DES算法（以及其他一
些算法）。EFS会对每个512B的小块（这也是标准硬盘扇区上最小的物理尺寸）进行加密，每一轮加密操作还会使用当前块的字节偏移量更新IV
（Initialization Vector，初始化向量，也叫盐值（salt value），这是一种128位的数字，用于为加密方案实现随机化）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在Windows 
10中，BitLocker加密卸载（Offload）进一步改善了加密性能。在启用BitLocker的情况下，存储堆栈已经包含一个由全卷加密驱动程
序（Fvevol.sys）创建的设备，如果卷已被加密，那么可在物理磁盘扇区上进行实时加密/解密；否则将直接通过I/O请求加以处理。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS驱动程序可以使用
IRP扩展来延后文件的加密操作。IRP扩展由I/O管理器提供（有关I/O管理器的详细信息，请参阅卷1第6章），可借此在IRP中存储不同类型的额外
信息。当创建文件时，EFS驱动程序会探测设备堆栈，借此使用IOCTL_FVE_GET_CDOPATH控制代码检查是否存在BitLocker控制设
备对象（Control Device Object，CDO）。如果存在，则会在SCB中设置一个标记，代表该流可支持加密卸载。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每当读取或写入加密文件，
或文件被首次加密时，NTFS驱动程序会根据之前设置的标记来判断是否需要加密/解密每个文件块。在启用加密卸载的情况下，NTFS会跳过对EFS的调
用，直接在IRP中添加一个IRP扩展，该扩展将被发送到相关卷设备以便执行物理I/O。在IRP扩展中，NTFS驱动程序存储了即将读取或写入文件块的
起始虚拟字节偏移量、其大小，以及一些标记。最终，NTFS驱动程序会使用IoCallDriver API将I/O发送给相关卷设备。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">卷管理器将解析IRP并将
其发送给正确的存储驱动程序。BitLocker驱动程序可以识别IRP扩展，并使用自己的例程加密NTFS发送到设备堆栈的数据，这些操作会针对物理扇
区执行（作为一种卷过滤器驱动程序，BitLocker中并未实现文件和目录的概念）。一些存储驱动程序，例如逻辑磁盘管理器驱动程序
（VolmgrX.sys，为动态磁盘提供了支持）则是附加到卷设备对象的过滤器驱动程序。这些驱动程序位于卷管理器之下，但位于BitLocker驱动
程序之上，可以提供数据冗余、条带或存储虚拟化功能，这些特征通常是将原始IRP拆分为多个次级IRP实现的，这些次级IRP会被发送到不同的物理磁盘设
备。在这种情况下，次级I/O在被BitLocker驱动程序拦截后，将使用不同的盐值对数据进行加密，从而导致文件数据被损坏。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">IRP扩展也支持IRP传
播的概念，每当原始IRP被拆分时，都会自动修改存储在IRP扩展中的文件虚拟字节偏移量。通常，EFS驱动程序会在512字节的边界上加密文件块，但
IRP无法在小于扇区大小的对齐情况下拆分。因此，BitLocker可以正确加密和解密数据，确保不会导致文件被损坏。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">BitLocker驱动程
序的很多例程无法承受内存故障。然而，因为IRP扩展是在拆分IRP时从非分页池中动态分配的，因此该分配可能失败。I/O管理器会通过
IoAllocateIrpEx例程解决此问题。内核驱动程序可通过该例程分配IRP（例如传统的IoAllocateIrp）。但新例程分配了一个额外
的堆栈位置，并将所有IRP扩展存储在其中。在新API分配的IRP上请求IRP扩展的驱动程序将不再需要通过非分页池来分配新的内存。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
无论是否需要向多个物理设备发出多个I/O，存储驱动程序均可出于不同原因决定拆分IRP。例如卷影复制驱动程序（Volsnap.sys）当需要从“写
入时复制”的卷影副本中读取文件时，如果文件驻留在不同区域，例如一部分文件位于实时卷中，另一部分文件位于卷影副本（该副本则位于隐藏目录System
 Volume Information中）的差分文件中，此时就会拆分I/O。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_302" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>4</b><b>.</b><b>6</b><b> </b><b>联</b><b>机</b><b>加</b><b>密</b><b>支</b><b>持</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">当加密或解密文件流时，文件流会被NTFS驱动程序以独占形式锁定。这意味着在加密或解密操作进行期间，其他应用程序无法访问该文件。对于较大的文件，这个限制会让文件在数秒钟甚至数分钟内无法使用。很明显，对于大规模文件服务器环境，这种问题是无法接受的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了解决此问题，新版本的
Windows 
10引入了对联机加密的支持。通过适当的同步，NTFS驱动程序可以在无须独占式访问的情况下加密或解密文件。只有在目标加密流是（命名或未命名）非常驻
数据流的情况下，EFS才会启用联机加密（否则将继续通过标准加密过程来处理）。如果所有条件均满足，EFS服务会向NTFS驱动程序发送
FSCTL_SET_ENCRYPTION的控制代码，借此设置启用联机加密的标记。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">联机加密的可行要归功
于“$EfsBackup”属性（$LOGGED_UTILITY_STREAM类型）和范围锁（range 
lock）的引入。范围锁是一个新的功能，可以让文件系统驱动程序（以独占或共享访问的方式）锁定文件中的部分区域。启用联机加密后，内部函数
NtfsEncryptDecryptOnline通过创建$EfsBackup属性（及其SCB）并针对文件的前2MB范围获取共享锁，借此启动加密或
解密过程。共享锁意味着多个读取者依然可以从文件的这个范围中读取，但其他写入者需要等待加密或解密操作完成后才能向其中写入新数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS驱动程序会从非分
页池中分配一个2MB的缓冲区，并在卷上保留一些簇，这些簇是代表2MB的可用空间所必需的（簇的总数取决于卷的簇大小）。联机加密函数从物理磁盘读取原
始数据，并将其存储到分配的缓冲区中。如果未启用BitLocker加密卸载（详见上文），该缓冲区将使用EFS服务加密；如果已启用，则由
BitLocker驱动程序在将数据写入之前保留的簇对数据进行加密。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在这个阶段，NTFS只将
整个文件锁定很少一段时间：在锁定期间，NTFS会将包含未加密数据的簇从原始流的范围表中移除，将其分配给非常驻属性$EfsBackup，并使用包含
加密后新数据的簇替换原始流范围表中被移除的范围。在释放独占锁之前，NTFS驱动程序会计算一个新的高水位线（high 
watermark）的值，并将其同时存储在原始文件的内存SCB中，以及$EFS备用数据流的EFS载荷中。随后，NTFS会释放独占锁。包含原始数据
的簇会首先被清零，随后如果没有更多的块需要处理，则这些簇将被释放。如果还有其他块要处理，则会针对下一个2MB的块重新启动联机加密处理的过程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">高水位线值存储了代表加密
和非加密数据之间边界的文件偏移量。任何针对水位线以上位置执行的并发写入都能够以原始的未加密形式进行，但对水位线以下的位置执行的并发写入需要首先加
密，随后才能实际写入。不允许对当前锁定的范围进行写入操作。图11-72展示了对一个16MB大小的文件持续进行联机加密的范例。前两个块（2MB大
小）已经被加密，高水位线值被设置为4MB，这条线将文件分为加密数据和未加密数据两部分。在高水位线之后的2MB块上设置了范围锁。应用程序依然可以读
取该块，但无法向其中写入任何新数据（如果要写入，则必须先等待）。该块的数据被加密并存储在保留簇中。在获取了独占的文件所有权后，原始块的簇被重映射
至$EfsBackup流（为此可移除或拆分它们在原始文件范围表中的项，并在$EfsBackup属性中插入一个新项），而新的簇会被插入之前的簇的位
置。借此，高水位线值将增大，文件锁被释放，联机加密过程继续从6MB偏移量处开始进行下一步处理。$EfsBackup流中原先的簇被清零，继续被下一
阶段的处理重复使用。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/d8406fd46a4ee6d16b5b222191637acb.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-72 一个16MB文件的持续联机加密范例</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种新的实现方式使得
NTFS可以原地进行加密或解密，而无须使用临时文件（详见“加密文件数据”一节）。更重要的是，这使得NTFS在执行文件加密或解密操作的过程中，其他
应用程序依然可以使用甚至修改目标文件流（独占锁的持续时间很短，并不会被试图使用该文件的应用程序所察觉）。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11_0015.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_303" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>5</b><b> </b><b>直</b><b>接</b><b>访</b><b>问</b><b>磁</b><b>盘</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">持久性内存（persistent memory）是固态硬盘技术的一种演进：这是一种新型的非易失性存储介质，具备类似于RAM的性能特征（低延迟、高带宽），驻留在内存总线（DDR）上，但可以像标准磁盘设备那样使用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows操作系统使
用直接访问磁盘（Direct Access Disk，DAX）这个术语代表此类持久性内存技术（另一个常用术语为存储类内存，Storage 
Class 
Memory，缩写为SCM）。图11-73所示的非易失性双列直插内存模块（NVDIMM）就是这种全新存储类型的一个例子。NVDIMM是一种在断电
后依然可以维持内容的内存类型，“双列直插”标志着该内存使用DIMM封装方式。截至撰写这部分内容，共有三种类型的NVDIMM：只包含闪存存储的
NVIDIMM-F；最常见的，在同一模块上同时包含闪存存储和传统DRAM芯片的NVDIMM-N；使用持久性DRAM芯片，在断电后也不会丢失数据的
NVDIMM-P。</span></p><div style="display: block;text-align:center;">
	<img width="474" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/0b0e1686f25d6a6edac04258e39aeb66.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-73 一个包含DRAM和闪存芯片的NVDIMM。需要连接电池或板载超级电容器来维持DRAM芯片中的数据</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">DAX的主要特点之一是支持对持久性内存进行零复制访问，而这也是实现高性能的关键。这意味着很多组件（如文件系统驱动程序和内存管理器）需要更新才能支持DAX，毕竟这是一种颠覆性技术。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows 
Server 
2016是首款支持DAX的Windows操作系统：这种新的存储模式可兼容大部分现有应用程序，因此，这些应用程序无须改动即可在DAX磁盘上运行。为
实现最高性能，DAX卷上的文件和目录需要使用内存映射API映射至内存，而卷也需要使用一种特殊的DAX模式进行格式化。截至撰写这部分内容，仅
NTFS支持DAX卷。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">下文将介绍直接访问磁盘的
运作方式和全新驱动程序模型的架构细节，以及对负责支持DAX卷的下列主要组件所进行的修改：NTFS驱动程序、内存管理器、缓存管理器，以及I/O管理
器。此外，系统内置的以及第三方文件系统过滤器驱动程序（包括微型过滤器）同样需要更新，才能充分利用DAX。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_304" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>5</b><b>.</b><b>1</b><b> </b><b>D</b><b>A</b><b>X</b><b>驱</b><b>动</b><b>程</b><b>序</b><b>模</b><b>型</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了支持DAX卷，
Windows需要引入一种全新的存储驱动程序模型。SCM总线驱动程序（Scmbus.sys）是一种全新的总线驱动程序，它可以枚举系统中的物理和逻
辑持久性内存（Persistent Memory，PM）设备，而这些设备会连接到内存总线（枚举的执行通过NFIT 
ACPI表进行）。该总线驱动程序并非I/O路径的一部分，而是一种由ACPI枚举器管理的主总线驱动程序，由HAL（硬件抽象层）通过硬件数据库注册表
键（HKLM\SYSTEM\CurrentControlSet\Enum\ACPI）提供。有关即插即用设备枚举的详细信息请参阅卷1第6章。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图11-74展示了SCM存储驱动程序模型的架构。SCM总线驱动程序会创建两个不同类型的设备对象。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
代表物理PM设备的物理设备对象（Physical Device 
Object，PDO）。NVDIMM设备通常包含一个或多个相互交错的NVDIMM-N模块，如果只有一个模块，则SCM总线驱动程序将只创建表示这个
NVDIMM单元的一个物理设备对象；如果包含多个模块，则会创建两个不同设备，借此代表每个NVDIMM-N模块。所有的物理设备都由微型端口驱动程序
Nvdimm.sys管理，它可以控制物理NVDIMM并监视其健康状况。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
代表单一DAX磁盘的功能设备对象（Functional Device 
Object，FDO），该对象由持久性内存驱动程序Pmem.sys管理。该驱动程序控制所有可由字节寻址的交错集，并负责针对DAX卷执行的所有的
I/O。持久性内存驱动程序是每个DAX磁盘的类驱动程序（取代了传统存储堆栈中的Disk.sys）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SCM总线驱动程序和
NVDIMM微型端口驱动程序都公开了一些可用于与PM类驱动器通信的接口。这些接口是通过IRP_MJ_PNP主函数使用
IRP_MN_QUERY_INTERFACE请求公开的。接收到请求后，SCM总线驱动程序会知道应该公开自己的通信接口，因为调用方指定了
{8de064ff-b63042e4-ea88-6f24c8641175}这个接口GUID。同样，持久性内存驱动程序需要通过
{0079c21b-917e-405e-cea9-0732b5bbcebd}这个GUID与NVDIMM设备通信。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/94abe73e6af25a65a0e4c7073ad1191f.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-74 SCM存储驱动程序模型</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">新的存储驱动程序模型实现
了明确的责任划分：PM类驱动程序管理逻辑磁盘功能（打开、关闭、读取、写入、内存映射等），而NVDIMM驱动程序管理物理设备及其运行状况。未来，只
需更新Nvdimm.sys驱动程序即可增加对新类型NVDIMM的支持（无须更改Pmem.sys）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_305" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>5</b><b>.</b><b>2</b><b> </b><b>D</b><b>A</b><b>X</b><b>卷</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">DAX存储驱动程序模型引
入了一种新类型的卷，即DAX卷。当用户使用Format工具首次格式化一个分区时，可以在命令行中指定/DAX参数。如果底层介质是使用GPT分区格式
的DAX磁盘，在创建NTFS所需的基本磁盘数据结构前，该工具会在目标卷的GPT分区项（对应于编号58的位）中写入
GPT_BASIC_DATA_ATTRIBUTE_DAX标记。有关GUID分区表的参考资料可访问：https://
en.wikipedia.org/wiki/GUID_Partition_Table。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当NTFS驱动程序随后挂
载该卷时，会识别出该标记并向底层存储驱动程序发送STORAGE_QUERY_PROPERTY控制代码。该IOCTL可被SCM总线驱动程序识别，
SCM会用另一个标记响应文件系统驱动程序，借此指定底层磁盘为DAX磁盘。只有SCM总线驱动程序可以设置该标记。验证过这两个条件后，只要没有通过注
册表
HKLM\System\CurrentControlSet\Control\FileSystem\NtfsEnableDirectAccess键
禁用对DAX的支持，NTFS就会启用对DAX卷的支持。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">DAX卷与标准卷不同，主
要是因为DAX卷支持对持久性内存进行零复制访问。内存映射文件使得应用程序可以通过映射视图直接访问底层硬件磁盘扇区，这意味着没有任何中间组件会拦截
任何I/O，这种特征实现了极高的性能（如上文所述，可能会对包括微型过滤器在内的文件系统过滤器驱动程序产生一定的影响）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当应用程序创建由驻留在
DAX卷上的文件支撑的内存映射节时，内存管理器会询问文件系统是否应该以DAX模式创建该节，但只有在卷被格式化为DAX模式时才会创建这样的节。当这
样的文件通过MapViewOfFile 
API映射时，内存管理器会向文件系统询问该文件中特定范围数据对应的物理内存范围。文件系统驱动程序会将所请求的文件范围转换为一个或多个卷的相对范围
（扇区偏移量和长度），并要求PM磁盘类驱动程序将卷的范围转换为物理内存范围。内存管理器在收到物理内存范围后，将更新目标进程页表中的节，借此直接映
射至持久性存储。这是一种真正的零复制存储访问方式：应用程序将能直接访问持久性内存，完全不需要读取或写入分页文件。这一点很重要：这种情况下，缓存管
理器无须介入。下文将介绍这一特点的实际意义。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">应用程序可以使用
GetVolumeInformation 
API来识别DAX卷。如果该API返回的标记包含FILE_DAX_VOLUME，就意味着卷被格式化为可兼容DAX的文件系统（目前仅NTFS）。应
用程序也可以借助相同的方式使用GetVolumeInformationByHandle API来识别一个文件是否驻留在DAX磁盘上。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_306" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>5</b><b>.</b><b>3</b><b> </b><b>D</b><b>A</b><b>X</b><b>卷</b><b>上</b><b>缓</b><b>存</b><b>和</b><b>未</b><b>缓</b><b>存</b><b>的</b><b>I</b><b>/</b><b>O</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">尽管DAX卷的内存映射
I/O为底层存储提供了零复制访问方式，DAX卷依然支持通过标准方式（使用传统的ReadFile和WriteFile 
API）执行的I/O。正如开头所述，Windows支持两种类型的常规I/O：缓存的和未缓存的。针对DAX卷执行这两种类型的I/O所产生的效果有很
大区别。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存I/O依然需要缓存管
理器介入，当为文件创建共享的缓存映射时，缓存管理器会要求内存管理器创建直接映射至PM硬件的节对象。NTFS可以通过新增的
CcInitializeCacheMapEx例程告知缓存管理器目标文件处于DAX模式。随后缓存管理器即可将数据从用户缓冲区复制到持久性内存，也就
是说，缓存I/O会对持久性存储执行“一次复制”访问操作。请注意，缓存I/O依然会与其他内存映射I/O保持一致（缓存管理器使用了同一个节）；与内存
映射I/O的情况类似，此时依然不需要读取或写入分页文件，因此无须启用延迟写入器线程和智能预读取。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种直接映射的含义在于：
一旦NtWriteFile函数完成，缓存管理器就直接写入DAX磁盘。这意味着缓存I/O本质上是未缓存的。因此未缓存I/O请求会被文件系统直接转换
为缓存I/O，这样缓存管理器就依然可以在用户缓冲区和持久性内存之间直接执行复制操作。此类I/O与缓存I/O以及内存映射I/O依然保持了一致。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS在处理与元数据文
件有关的更新时依然会使用标准I/O。每个文件的DAX模式I/O是在创建流的时候决定的，为此需要在流控制块中设置一个标记。系统元数据文件永远不会设
置该属性，因此当映射此类文件时，缓存管理器会创建标准的非DAX文件支撑的节，并使用标准存储堆栈来执行分页文件读写I/O（最终，每个I/O都会像块
卷那样由Pmem驱动程序处理，并会使用扇区原子性算法。详见“块卷”一节）。这种行为是兼容预写入日志记录功能所必需的。在刷新相应日志之前，元数据不
能被持久保存到磁盘上。因此，如果元数据文件被DAX映射，预写入日志记录的相关要求就会被打破。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>对</b><b>文</b><b>件</b><b>系</b><b>统</b><b>功</b><b>能</b><b>的</b><b>影</b><b>响</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于不执行常规分页I/O，并且应用程序能够直接访问持久性内存，这些特征使得文件系统和相关过滤器用来实现多种功能所需的传统挂钩点（hook point）不复存在。DAX卷无法支持多个功能，例如文件加密、压缩文件、稀疏文件、快照及USN日志支持。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在DAX模式下，文件系统
已经无法得知可写入的内存映射文件何时被修改。当首次创建内存节时，NTFS文件系统驱动程序会更新文件的修改和访问时间，并在USN变更日志中将该文件
标记为已修改。同时，NTFS驱动程序会发出一个代表目录更改的通知信号。DAX卷已经无法兼容任何类型的传统过滤器驱动程序，并且对微型过滤器（过滤器
管理器客户端）产生了巨大的影响。诸如BitLocker和卷影副本驱动程序（Volsnap.sys）等组件无法作用于DAX卷，因此会从设备堆栈中移
除。由于微型过滤器已经无法得知文件是否已被修改，因此，诸如上文描述的那种反恶意软件文件访问扫描程序也将无法得知自己是否需要对某个文件执行病毒扫
描。此时它只能假设任何句柄关闭时都意味着文件内容发生了更改。因而也会对性能产生较大的不利影响，为了支持DAX卷，微型过滤器必须以手动的方式选择性
启用。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_307" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>5</b><b>.</b><b>4</b><b> </b><b>可</b><b>执</b><b>行</b><b>映</b><b>像</b><b>的</b><b>映</b><b>射</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows加载器将可
执行映像载入内存时，会用到内存管理器提供的内存映射服务。加载器会向NtCreateSection 
API提供SEC_IMAGE标记以创建内存映射映像节。该标记会指定加载器将这个节映射为映像，应用所有必要的修复。但在DAX模式下不会发生这样的操
作，否则所有重定位和修复操作都会应用给PM磁盘上的原始映像文件。为了正确处理这个问题，内存管理器在映射存储于DAX模式卷的可执行映像时，将应用以
下策略：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果已经有一个代表二进制文件数据节的控制区域（意味着应用程序已经打开了该映像并读取了二进制数据），内存管理器会创建一个空的、由内存支撑的映像节，并将数据从现有数据节复制到新创建的映像节，随后对这个映像节应用必要的修复。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果该文件没有数据节，则内存管理器会创建一个常规的非DAX映像节，从而创建出标准的无效原型PTE（详见卷1第5章）。在这种情况下，当属于映像支撑的节的地址上发生无效访问的页面错误时，内存管理器会使用Pmem驱动程序的标准读取和写入例程将数据读入内存。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">截至撰写这部分内容，Windows 10还不支持原地执行，这意味着加载器无法直接从DAX存储中执行映像。不过这并不是问题，因为DAX模式的卷最初在设计时就是为了存储需要极高访问速度的数据。不过未来版本的Windows将会支持DAX卷的原地执行。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>使</b><b>用</b><b>进</b><b>程</b><b>监</b><b>视</b><b>器</b><b>观</b><b>察</b><b>D</b><b>A</b><b>X</b><b> </b><b>I</b><b>/</b><b>O</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们可以使用Sysinternals提供的进程监视器和FsTool.exe工具观察DAX 
I/O，这些工具都包含在本书的随附资源中。当应用程序从驻留在DAX模式卷上的内存映射文件读取或写入时，系统不会产生任何分页I/O，因此NTFS驱
动程序或附加在其上或其下的微型过滤器将看不到任何操作。为了观察到这样的行为，我们需要打开进程监视器，假设有两个卷分别挂载为P:盘和Q:盘，可按照
类似下图的方式设置过滤器（Q:盘为DAX卷）。</span></p><div style="display: block;text-align:center;">
	<img width="727" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/69e931fec3f6843f0edbc7dcfc06c948.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">为了让DAX卷产生I/O，可以使用FsTool工具模拟一次DAX复制。在下列范例内容中，我们将位于P:盘这个DAX块模式卷（即便普通磁盘上创建的标准卷也可以用来完成本实验）上的一个ISO映像文件复制到DAX模式的Q:盘：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">P:\&gt;fstool.exe /daxcopy p:\Big_image.iso q:\test.iso </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">NTFS /ReFS Tool v0.1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright (C) 2018 Andrea Allievi (AaLl86) </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Starting DAX copy... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Source file path: p:\Big_image.iso. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Target file path: q:\test.iso. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Source Volume: p:\- File system: NTFS - Is DAX Volume: False. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Target Volume: q:\- File system: NTFS - Is DAX Volume: True. </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Source file size: 4.34 GB </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Performing file copy... Success! </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Total execution time: 8 Sec. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Copy Speed: 489.67 MB/Sec </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Press any key to exit... </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">进程监视器捕获到了DAX复制操作的踪迹，确认实现了我们预期的结果。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/2ed073831c595b08d19c6c4e775ca8ba.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">从
上述结果中可以看到，对于目标文件（Q:\test.iso），只有CreateFileMapping操作被拦截了，完全没有可见的WriteFile
事件。在复制执行过程中，进程监视器只检测到对源文件执行的分页I/O。这些分页I/O是由内存管理器产生的，它需要从源卷中读回数据，因为应用程序在访
问内存映射文件时产生了页面错误。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">要看到内存映射I/O和标准缓存I/O之间的差异，我们需要使用标准文件复制操作再次复制该文件。要查看源文件数据上产生的分页I/O，则还需要重启动系统，因为原始数据依然遗留在缓存中：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">P:\&gt;fstool.exe /copy p:\Big_image.iso q:\test.iso </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">NTFS /ReFS Tool v0.1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright (C) 2018 Andrea Allievi (AaLl86) </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copying "Big_image.iso" to "test.iso" file... Success. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Total File-Copy execution time: 13 Sec - Transfer Rate: 313.71 MB/s. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Press any key to exit... </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如果将进程监视器获得的跟踪结果与上一次结果比较，就可以确认缓存I/O是一种“一次复制”操作。缓存管理器依然会在应用程序提供的缓冲区（直接映射至DAX磁盘的）和系统缓存之间复制内存块。事实再次证明：目标文件并未产生任何分页I/O。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/639b67d6021a6f766ad30ecacd215d42.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">作为最后一个实验，我们可以试着在位于同一个DAX卷上的两个文件之间，或在位于不同DAX卷上的两个文件之间执行DAX复制操作：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">P:\&gt;fstool /daxcopy q:\test.iso q:\test_copy_2.iso </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">TFS /ReFS Tool v0.1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright (C) 2018 Andrea Allievi (AaLl86) </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Starting DAX copy... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Source file path: q:\test.iso. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Target file path: q:\test_copy_2.iso. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Source Volume: q:\- File system: NTFS - Is DAX Volume: True. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Target Volume: q:\- File system: NTFS - Is DAX Volume: True. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Great! Both the source and the destination reside on a DAX volume. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Performing a full System Speed Copy! </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Source file size: 4.34 GB </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Performing file copy... Success! </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Total execution time: 8 Sec. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Copy Speed: 501.60 MB/Sec </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Press any key to exit... </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">最后一个实验捕获的结果证明了DAX卷上的内存映射I/O不会产生任何分页I/O。无论源文件或目标文件，都不会产生任何WriteFile或ReadFile事件。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ab28112548ef600031066908a66943f1.jpg" alt="" title=""></div>
</div><div class="header2"><h3><span id="sigil_toc_id_308" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>5</b><b>.</b><b>5</b><b> </b><b>块</b><b>卷</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在某些情况下，DAX卷的
一些局限是不可接受的。Windows通过块模式卷（block-mode 
volume）为PM硬件提供向后兼容性，传统I/O堆栈会像对待机械硬盘和SSD硬盘上的普通卷那样管理这种块卷。块卷还沿用了原有的存储语义：所有
I/O操作都需要经由存储堆栈抵达PM磁盘类驱动程序（不过不存在微型过滤器驱动程序，因为不需要）。块卷完全兼容所有现有应用程序、传统过滤器以及微型
过滤器驱动程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">持久性内存存储能够以字节
级别的粒度执行I/O。更确切地说，I/O是以缓存行的粒度执行的，具体大小取决于架构，但通常为64字节。不过块模式卷会被公开为标准卷，以扇区为粒度
（通常为512字节或4KB）执行I/O。如果正在写入DAX卷但设备突然遭遇断电，那么数据块（扇区）中将同时包含新老数据。应用程序并未针对这种情况
做好准备。在块模式下，扇区的原子性是由PM磁盘类驱动程序实现的块转换表（Block Translation Table，BTT）算法保证的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">BTT算法由英特尔开发，
将可用磁盘分割成最高可达512GB的块（称为“竞技场”）。该算法对每个竞技场维护一个BTT，并通过一种简单的“指示/查找”将LBA映射到属于该竞
技场的内部块。对于映射中的每个32位项，算法会使用两个最重要的位（MSB）存储块的状态（共有有效、归零、错误三种状态）。尽管该表维持了每个LBA
的状态，但BTT算法会提供一种包含nfree块数组的Flog区域来保证扇区的原子性。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">nfree块包含算法提供
扇区原子性所需的全部数据。数组中共有256个nfree项，每个nfree项的大小为32字节，因此Flog区域将占用8KB空间。每个nfree项被
一个CPU使用，因此nfree的总数用于描述一个竞技场可以并发处理的原子性I/O的数量。图11-75展示了格式化为块模式的DAX磁盘的布局。
BTT算法所使用的数据结构对文件系统驱动程序是不可见的。BTT算法消除了可能出现的子扇区撕裂式写入，如上文所述，为了支持文件系统写入元数据，即使
格式化为DAX的卷，也需要这种算法。</span></p><div style="display: block;text-align:center;">
	<img width="431" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a4377c37279f64193d7a4afb7b36fde7.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-75 支持原子性扇区（BTT算法）的DAX磁盘布局</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">块模式卷的分区项中不存在
GPT_BASIC_DATA_ATTRIBUTE_DAX标记。NTFS会像处理普通卷那样依靠缓存管理器来执行缓存I/O，并通过PM磁盘类驱动程序
处理未缓存I/O。Pmem驱动程序公开的读取和写入函数可以为用户缓冲区和设备物理块地址构建内存描述符列表（MDL，详见卷1第5章），借此执行直接
内存访问（DMA）传输。BTT算法提供了扇区原子性。图11-76展示了传统卷、DAX卷以及块卷的I/O堆栈。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4adb48b3f37524a340bea1da35278bb2.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-76 传统卷、块模式卷和DAX卷的设备I/O堆栈对比</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_309" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>5</b><b>.</b><b>6</b><b> </b><b>文</b><b>件</b><b>系</b><b>统</b><b>过</b><b>滤</b><b>器</b><b>驱</b><b>动</b><b>程</b><b>序</b><b>和</b><b>D</b><b>A</b><b>X</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">传统的过滤器驱动程序和微
型过滤器无法作用于DAX卷。此类驱动程序通常可增强文件系统的功能，经常需要与文件系统驱动程序管理的所有操作进行交互。不同类型的过滤器可以为文件系
统驱动程序提供新的功能，或修改现有功能的行为，例如反病毒、加密、复制、压缩、分层存储管理（Hierarchical Storage 
Management，HSM）等。DAX驱动程序模型大幅更改了DAX卷与这些组件的交互方式。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，文件被映射到
内存后，无论是DAX模式下的文件系统，或是位于文件系统驱动程序之上或之下的所有过滤器驱动程序，都无法收到任何读取或写入的I/O请求。这意味着依赖
数据拦截的过滤器驱动程序将会失效。为最大限度减少可能的兼容性问题，在挂载了DAX卷后，现有的微型过滤器将无法通过InstanceSetup回调收
到通知。如果依然希望作用于DAX卷，则新开发的或更新后的微型过滤器驱动程序在通过FltRegisterFilter这个内核API与过滤器管理器注
册时，需要指定FLTFL_REGISTRATION_SUPPORT_DAX_VOLUME标记。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">决定支持DAX卷的微型过
滤器还会面临一个限制：无法拦截任何形式的分页I/O。数据转换过滤器（提供加密或压缩功能）完全无法正确处理内存映射文件；反恶意软件过滤器会受到上文
提及的影响，因为必须针对每个打开和关闭操作执行扫描，因此无法判断写入操作是否真正发生（该影响主要涉及对文件最后一次更新时间的检测方面）。传统过滤
器已无法兼容：如果驱动程序调用IoAttachDeviceToDevice堆栈API（或类似的函数），I/O管理器会直接让请求失败（并记录一条
ETW事件）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_310" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>5</b><b>.</b><b>7</b><b> </b><b>刷</b><b>新</b><b>D</b><b>A</b><b>X</b><b>模</b><b>式</b><b>的</b><b>I</b><b>/</b><b>O</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">传统硬盘（HDD、
SSD、NVme）始终包含一个意在提高整体性能的缓存。当存储驱动程序发出写入I/O时，实际上首先会将数据传输到缓存中，随后才会被写入持久性介质。
操作系统提供了正确的刷新机制，保证了数据最终能被写入存储设备，并通过时间顺序保证数据可以按照正确的顺序写入。对于常规的缓存I/O，应用程序可以调
用FlushFileBuffers 
API来确保数据以可证明的方式存储到磁盘中（这将产生一个IRP，其主函数代码为NTFS驱动程序实现的IRP_MJ_FLUSH_BUFFERS）。
未缓存I/O会被NTFS直接写入磁盘，因此无须考虑排序和刷新的问题。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">DAX模式的卷就无法做到
上述这一切了。文件被映射到内存后，NTFS驱动程序对将要写入磁盘的数据一无所知。如果应用程序正在将一些关键数据结构写入DAX卷，但写入过程中断电
了，那么应用程序将无法保证所有数据结构都能正确写入底层介质。此外，它也无法保证数据能够按照请求的顺序进行写入。这是因为从CPU的角度来看，PM存
储被实现为一种经典的物理内存。处理器使用了CPU缓存机制，但在读/写DAX卷时使用了自己的缓存机制。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">因此新版Windows 
10不得不为DAX映射区域引入新的刷新API，以便借此执行必要的工作优化从CPU缓存刷新PM内容的过程。这些API同时适用于用户模式的应用程序和
内核模式的驱动程序，会根据CPU架构进行高度优化（例如标准x64系统会使用CLFLUSH和CLWB操作码）。希望对DAX卷执行I/O排序和刷新的
应用程序，可以针对PM映射的区域调用RtlGetNonVolatileToken函数，该函数会返回一个非易失性令牌，随后即可配合
RtlFlushNonVolatileMemory或RtlFlushNonVolatileMemoryRanges 
API使用。这些API将执行从CPU缓存到底层PM设备的实际数据刷新工作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">内存复制操作将使用标准的
操作系统函数来执行，默认将执行时间性复制（temporal 
copy）操作，这意味着数据总是会通过CPU缓存，并维持执行顺序。另外，非时间性复制操作会使用专门的处理器操作码（具体同样取决于CPU架构，
x64 
CPU使用MOVNTI操作码）来绕过CPU缓存。这种情况下将无法维持顺序，但执行速度更快。RtlWriteNonVolatileMemory可公
开针对非易失性内存的双向内存复制操作。默认情况下，该API会执行传统的时间性复制操作，但应用程序可以通过
WRITE_NV_MEMORY_FLAG_NON_TEMPORAL标记请求执行非时间性复制操作，从而加快复制操作的速度。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_311" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>5</b><b>.</b><b>8</b><b> </b><b>大</b><b>型</b><b>页</b><b>和</b><b>巨</b><b>型</b><b>页</b><b>的</b><b>支</b><b>持</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在DAX模式的卷上通过内
存映射节读/写文件时，内存管理器的处理方式与非DAX节的处理方式类似：如果在映射时指定了MEM_LARGE_PAGES标记，则内存管理器会检测到
一个或多个文件范围指向了足够多的已对齐连续物理空间（NTFS分配的文件范围），并使用大型页（2MB）或巨型页（1GB）来映射物理DAX空间（有关
内存管理器和大型页的详情请参阅卷1第5章）。与传统的4KB页相比，大型页和巨型页有很多优势，尤其是可大幅改善DAX文件的性能，因为可减少在处理器
页表结构中进行查找的次数，同时减少了要在处理器的地址转换后备缓冲区（Translation Lookaside 
Buffer，TLB）中存储的项的数量。对于内存占用量大并且需要随机访问内存的应用程序，CPU可能需要花费大量时间查找TLB项，并在TLB缺失的
情况下读/写页表层次结构。此外，使用大型/巨型页还可以大幅节约提交开销，因为只需要为页面目录的父项和页目录（只针对大文件，不针对巨型文件）进行记
账。页表空间（每2MB的叶VA空间对应4KB）无须记账。因此举例来说，对于一个2TB的文件映射，系统使用大型页和巨型页即可节约4GB的已提交内
存。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS驱动程序会与内存管理器合作，在映射DAX卷上文件时对大型页和巨型页提供支持。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·默认情况下，每个DAX分区都以2MB的边界对齐。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·NTFS支持2MB大小的簇。以2MB簇格式化的DAX卷可以保证只为卷上存储的文件使用大型页。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·NTFS不支持1GB大小的簇。如果DAX卷上存储的文件大小超过1GB，并且有一个或多个文件范围存储在足够的持续物理空间，则内存管理器将使用巨型页映射该文件（巨型页使用两个页面映射级别，大型页使用三个）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如卷1第5章所述，对于常
规的、由内存支撑的节，只有当描述PM页的范围未在DAX卷上正确对齐时，内存管理器才会使用大型页和巨型页（这个对齐是相对于卷的LCN而不是相对于文
件的VCN而言的）。对于大型页，这意味着范围需要从2MB的边界开始，而巨型页则需要从1GB的边界开始。如果DAX卷上的文件并未完全对齐，则内存管
理器将只能为对齐的块使用大型页或巨型页，并会继续对其他块使用标准的4KB页。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了促进并增加大型页的使
用，NTFS文件系统提供了FSCTL_SET_DAX_ALLOC_ALIGNMENT_HINT的控制代码，应用程序可以借此针对新的文件范围设置自
己首选的对齐方式。该I/O控制代码接收的值规定了首选对齐方式、起始偏移量（可用于指定对齐需要从何处开始）以及其他一些标记。通常来说，应用程序在创
建了一个全新的文件，但尚未映射该文件时，可以向文件系统驱动程序发送该IOCTL。这样，在为文件分配空间的同时，NTFS就可以拿到落在首选对齐方式
范围内的可用簇。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果所请求的对齐方式不可
用（例如卷的碎片化程度极高），则该IOCTL可以指定文件系统应当使用的回退（Fallback）行为：让请求失败，或转而求其次地使用备用对齐方式
（备用方式可通过参数指定）。该IOCTL甚至可以作用于已经存在的文件，借此为文件指定新扩展的对齐方式。应用程序可以使用
FSCTL_QUERY_FILE_REGIONS控制代码或fsutil dax 
queryfilealignment命令查询文件的所有范围所使用的对齐方式。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>操</b><b>作</b><b>D</b><b>A</b><b>X</b><b>的</b><b>文</b><b>件</b><b>对</b><b>齐</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们可以使用本书随附资源提供的FsTool工具观察不同类型的DAX文件对齐。要完成该实验，计算机上需要具备DAX卷。打开命令提示符窗口，使用该工具
将一个大文件（建议最少4GB）复制到DAX卷。在下列范例中，两个DAX磁盘挂载为P:盘和Q:盘。Big_Image.iso文件会使用FsTool
工具通过标准操作复制到Q:盘这个DAX卷上：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">D:\&gt;fstool.exe /copy p:\Big_DVD_Image.iso q:\test.iso </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">NTFS /ReFS Tool v0.1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright (C) 2018 Andrea Allievi (AaLl86) </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copying "Big_DVD_Image.iso" to "test.iso" file... Success.</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Total File-Copy execution time: 10 Sec - Transfer Rate: 495.52 MB/s. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Press any key to exit... </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以使用FsTool.exe工具的/queryalign命令行参数查看新的test.iso文件的对齐方式，或者也可以使用Windows内置工具fsutil.exe的queryFileAlignment参数：</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b9a6732aad1b5c812cecdda2b7fb462b.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如
以上输出结果所示，文件的第一个块存储在4KB的对齐簇中。该工具显示的偏移量并非相对于卷的偏移量（即LCN），而是相对于文件的偏移量（即VCN）。
这个差别很重要，因为大型页和巨型页映射所需的对齐是相对于卷页的偏移量。随着不断地增长，文件的一些簇将从卷中2MB或1GB边界对齐的偏移量分配。这
样，内存管理器就可以使用大型页或巨型页来映射文件中的这些部分。接下来和前面的实验类似，我们试试通过指定目标对齐提示来执行DAX复制：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">P:\&gt;fstool.exe /daxcopy p:\Big_DVD_Image.iso q:\test.iso /align:1GB </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">NTFS /ReFS Tool v0.1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright (C) 2018 Andrea Allievi (AaLl86) </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Starting DAX copy...</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Source file path: p:\Big_DVD_Image.iso.</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Target file path: q:\test.iso.</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Source Volume: p:\- File system: NTFS - Is DAX Volume: True. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Target Volume: q:\- File system: NTFS - Is DAX Volume: False. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Source file size: 4.34 GB </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Target file alignment (1GB) correctly set. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Performing file copy... Success! </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Total execution time: 6 Sec. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Copy Speed: 618.81 MB/Sec </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Press any key to exit... </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">P:\&gt;fsutil dax queryFileAlignment q:\test.iso </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  File Region Alignment: </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part"><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/eac34b70c83d549aab680d6e8994847c.jpg" alt="" title=""></div>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
后一种情况下，文件被立即分配到下一个1GB对齐的簇中。文件内容的前4GB（0x100000000字节）被存储在连续的空间中。当内存管理器映射文件
的这部分内容时，将只需要使用4个页目录指针表（Page Directory Pointer 
Table，PDPT）项，而不需要使用2048个页表。这有助于节约物理内存空间，并显著提高CPU访问DAX节数据时的性能。为确认复制操作确实是使
用大型页进行的，我们可以向计算机连接内核调试器（本地内核调试器足矣），并为FsTool工具使用/debug开关：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">P:\&gt;fstool.exe /daxcopy p:\Big_DVD_Image.iso q:\test.iso /align:1GB /debug </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">NTFS /ReFS Tool v0.1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright (C) 2018 Andrea Allievi (AaLl86) </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Starting DAX copy... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Source file path: p:\Big_DVD_Image.iso. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Target file path: q:\test.iso. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Source Volume: p:\- File system: NTFS - Is DAX Volume: False. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Target Volume: q:\- File system: NTFS - Is DAX Volume: True. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Source file size: 4.34 GB </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Target file alignment (1GB) correctly set. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Performing file copy... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> [Debug] (PID: 10412) Source and Target file correctly mapped. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">         Source file mapping address: 0x000001F1C0000000 (DAX mode: 1). </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">         Target file mapping address: 0x000001F2C0000000 (DAX mode: 1). </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">         File offset : 0x0 - Alignment: 1GB. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Press enter to start the copy... </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';"> [Debug] (PID: 10412) File chunk’s copy successfully executed. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Press enter go to the next chunk /flush the file... </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以使用调试器的!pte扩展查看最终生效的内存映射。首先需要使用.process命令移动至适当的进程上下文，随后即可分析FsTool显示的已映射的虚拟地址：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">8: kd&gt; !process 0n10412 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Searching for Process with Cid == 28ac </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PROCESS ffffd28124121080 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    SessionId: 2 Cid: 28ac    Peb: a29717c000 ParentCid: 31bc </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    DirBase: 4cc491000 ObjectTable: ffff950f94060000 HandleCount: 49. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">    Image: FsTool.exe </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">8: kd&gt; .process /i ffffd28124121080 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">You need to continue execution (press 'g' &lt;enter&gt;) for the context </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">to be switched. When the debugger breaks in again, you will be in </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">the new process context. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">8: kd&gt; g </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Break instruction exception - code 80000003 (first chance) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">nt!DbgBreakPointWithStatus: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fffff804`3d7e8e50 cc              int     3 </span></p>
</div><div class="header0"><h1><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h1></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">8: kd&gt; !pte 0x000001F2C0000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                          VA 000001f2c0000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PXE at FFFFB8DC6E371018   PPE at FFFFB8DC6E203E58   PDE at FFFFB8DC407CB000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">contains 0A0000D57CEA8867 contains 8A000152400008E7 contains 0000000000000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">pfn d57cea8  ---DA--UWEV  pfn 15240000 --LDA--UW-V  LARGE PAGE pfn 15240000 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PTE at FFFFB880F9600000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">contains 0000000000000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">LARGE PAGE pfn 15240000 </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">通
过调试器命令!pte可以证实，DAX文件的前1GB空间是使用巨型页映射的。实际上，页目录和页表都不存在。FsTool工具还可用于为已存在的文件设
置对齐方式。FSCTL_SET_DAX_ALLOC_ALIGNMENT_HINT控制代码虽然不实际移动任何数据，但可以为新分配的文件范围提供提
示，因为文件在以后可能会继续增大：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">D:\&gt;fstool e:\test.iso /align:2MB /offset:0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">NTFS /ReFS Tool v0.1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright (C) 2018 Andrea Allievi (AaLl86) </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Applying file alignment to "test.iso" (Offset 0x0)... Success. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Press any key to exit... </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">D:\&gt;fsutil dax queryfileAlignment e:\test.iso </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  File Region Alignment: </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part"><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/f469fbcf5800795ac5b30c70f1b111df.jpg" alt="" title=""></div>
</div><div class="header2"><h3><span id="sigil_toc_id_312" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>5</b><b>.</b><b>9</b><b> </b><b>虚</b><b>拟</b><b>P</b><b>M</b><b>磁</b><b>盘</b><b>和</b><b>存</b><b>储</b><b>空</b><b>间</b><b>支</b><b>持</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">持久性内存是专为服务器系
统和关键业务应用程序（如巨型SQL数据库）设计的，这类系统需要极快的响应速度，每秒可能需要处理数千条查询。一般来说，此类服务器会通过Hyper-
V提供的虚拟机来运行应用程序。Windows Server 
2019支持一种新的虚拟硬盘：虚拟PM磁盘。虚拟PM由VHDPMEM文件提供支持，截至撰写这部分内容，只能通过Windows 
PowerShell创建此类文件（或对普通的VHD文件进行转换）。虚拟PM磁盘可通过VHDPMEM文件直接映射位于主机中真实DAX磁盘上的空间
块，而该文件必须位于DAX卷上。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在连接到虚拟机后，
Hyper-V会向客户机系统公开一个虚拟PM设备（VPMEM）。这个虚拟PM设备是由位于虚拟UEFI 
BIOS中的NVDIMM固件接口表（NVDIMM Firmware Interface 
Table，NFIT）描述的（有关NVFIT表的详细信息请参阅ACPI 
6.2规范）。SCM总线驱动程序读取该表并创建代表虚拟NVDIMM设备以及PM磁盘的常规设备对象。Pmem磁盘类驱动程序会像管理常规PM磁盘那样
管理虚拟PM磁盘，并在此基础上创建虚拟卷。有关Windows虚拟机监控程序及其组件的详细信息请参阅第9章。图11-77展示了使用虚拟PM设备的虚
拟机所使用的PM堆栈。其中深灰色组件是虚拟化堆栈的组成部分，浅灰色组件在客户机和主机分区中完全相同。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b5d65792f131c3d3738a7e99a7c8479b.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-77 虚拟PM架构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟PM设备可公开连续地
址空间，该空间是从主机中虚拟的（意味着主机上的VHDPMEM文件并不需要连续）。虚拟PM设备可同时支持DAX和块模式，但与主机中的情况类似，模式
必须在格式化卷的时候确定。此外还能支持大型页和巨型页，具体使用方式和主机系统的相同。仅第2代虚拟机支持虚拟PM设备以及映射VHDPMEM文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows 
Server 
2019中的存储空间直通功能也支持在虚拟存储池中使用DAX磁盘。不同类型磁盘组成的混合阵列可以包含一个或多个DAX磁盘。阵列中的PM磁盘可配置为
针对大容量的分层式虚拟磁盘提供容量层或性能层的存储容量，或者也可以配置为充当高性能缓存。有关存储空间的详细介绍请参阅下文。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>创</b><b>建</b><b>并</b><b>挂</b><b>载</b><b>V</b><b>H</b><b>D</b><b>P</b><b>M</b><b>E</b><b>M</b><b>映</b><b>像</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我
们可以使用PowerShell创建、转换虚拟PM磁盘并将其分配给Hyper-V虚拟机。在这个实验中，我们需要一个DAX磁盘和运行Windows 
10于10月更新（RS5或后续版本）的第2代虚拟机（创建虚拟机的方法介绍已超出了本实验范围）。请以管理员身份打开Windows 
PowerShell提示符窗口，进入DAX模式的磁盘，随后创建虚拟PM磁盘（本例中的DAX磁盘为Q:盘）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PS Q:\&gt; New-VHD VmPmemDis.vhdpmem -Fixed -SizeBytes 256GB -PhysicalSectorSizeBytes 4096 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ComputerName            : 37-4611k2635 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Path                    : Q:\VmPmemDis.vhdpmem </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">VhdFormat               : VHDX </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">VhdType                 : Fixed </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">FileSize                : 274882101248 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Size                    : 274877906944 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">MinimumSize             : </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">LogicalSectorSize       : 4096 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PhysicalSectorSize      : 4096 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">BlockSize               : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">ParentPath              : </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">DiskIdentifier          : 3AA0017F-03AF-4948-80BE-B40B4AA6BE24 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">FragmentationPercentage : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Alignment               : 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Attached                : False </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">DiskNumber              : </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">IsPMEMCompatible        : True </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">AddressAbstractionType  : None </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Number                  : </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">虚拟PM磁盘可使用固定大小，这意味着所有空间需要预先分配，这是设计使然。第二步要创建虚拟PM控制器并将其连接到虚拟机。请先确认虚拟机已经关机，随后运行下列命令。请将“TestPmVm”替换为虚拟机实际名称：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PS Q:\&gt; Add-VMPmemController -VMName "TestPmVm" </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">最后，我们需要将创建好的虚拟PM磁盘连接到虚拟机的PM控制器：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PS Q:\&gt; Add-VMHardDiskDrive "TestVm" PMEM -ControllerLocation 1 -Path 'Q:\VmPmemDis.vhdpmem'</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以使用Get-VMPmemController命令来验证该操作的结果：</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ccb3646668cea032cfe7d111a8c5a6e9.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">启动虚拟机，可以看到Windows检测到新的虚拟磁盘。在虚拟机中打开磁盘管理控制台（diskmgmt.msc），随后使用GPT分区格式初始化该磁盘。接着创建一个简单卷，为其分配盘符，但不要格式化。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a89baa0dd054efd13ff7ffe3a0a405b7.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们需要将该虚拟PM磁盘格式化为DAX模式。在虚拟机中以管理员身份打开命令提示符，假设虚拟PM磁盘为E:盘，需要执行下列命令：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;format e: /DAX /fs:NTFS /q </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">The type of the file system is RAW. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">The new file system is NTFS. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">WARNING, ALL DATA ON NON-REMOVABLE DISK </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">DRIVE E: WILL BE LOST! </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Proceed with Format (Y/N)? y </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">QuickFormatting 256.0 GB </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Volume label (32 characters, ENTER for none)? DAX-In-Vm </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Creating file system structures. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Format complete. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     256.0 GB total disk space. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">     255.9 GB are available. </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后可使用系统内置的fsutil.exe工具配合fsinfo volumeinfo命令行参数确认该虚拟磁盘已格式化为DAX模式：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;fsutil fsinfo volumeinfo C: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Volume Name : DAX-In-Vm </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Volume Serial Number : 0x1a1bdc32 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Max Component Length : 255 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">File System Name : NTFS </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Is ReadWrite </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Not Thinly-Provisioned </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Supports Case-sensitive filenames </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Preserves Case of filenames </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Supports Unicode in filenames </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Preserves &amp; Enforces ACL’s </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Supports Disk Quotas </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Supports Reparse Points </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Returns Handle Close Result Information </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Supports POSIX-style Unlink and Rename </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Supports Object Identifiers </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Supports Named Streams </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Supports Hard Links </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Supports Extended Attributes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Supports Open By FileID </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Supports USN Journal </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Is DAX Volume </span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11_0016.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_313" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>6</b><b> </b><b>复</b><b>原</b><b>文</b><b>件</b><b>系</b><b>统</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows 
Server 2012 R2引入了一种名为复原文件系统（Resilient File 
System，ReFS）的高级文件系统。该文件系统是一种名为存储空间的全新存储架构的一部分，这种架构提供了多种功能，包括同时使用固态硬盘和传统机
械硬盘创建一种分层的虚拟存储卷（下文将简要介绍存储空间及其分层存储功能）。ReFS是一种“写新”（write-to-new）文件系统，这意味着文
件系统元数据永远不会在原地更新，更新后的元数据会被写入新位置，旧的元数据则被标记为已删除。这个属性很重要，也是能保证数据完整性的重要功能之一。
ReFS最初的设计目标包括以下几方面。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）自治愈、联机卷检查和修复（几乎可完全消除因文件系统出错导致的数据不可用）以及直写（write-through）支持（下文将详细介绍直写）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）所有用户数据的数据完整性（硬件和软件层面）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）高效快速的文件快照（块克隆）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）支持极大容量的卷（EB级别）和文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">5）数据和元数据自动分层，支持SMR（叠瓦式磁记录）和未来的固态磁盘。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ReFS已经发展出不同的
版本。本书介绍的是ReFS v2，该版本最初是在Windows Server 
2016中实现的。图11-78展示了ReFS和NTFS的高层实现方面的差异。ReFS并没有完全重写NTFS，而是采用另一种方法将NTFS通过两个
部分来实现：一部分可以理解磁盘上的格式，另一部分则无法理解。</span></p><div style="display: block;text-align:center;">
	<img width="814" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a9d356db2a402861e9f46b9fe8a180ae.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-78 ReFS和NTFS的高层实现对比</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ReFS用
Minstore取代了磁盘上的存储引擎。Minstore是一种可恢复的对象存储库，能为其调用方提供一个键-值表接口，并为针对这些表的修改操作实现
了一种分配写入语义，同时可与Windows缓存管理器相互集成。从本质上来看，Minstore是一种库，实现了可扩展的现代化写入时复制文件系统应有
的核心能力。ReFS利用Minstore来实现文件、目录等。要理解ReFS，首先要理解Minstore，因此下面来看看Minstore到底是什
么。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_314" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>6</b><b>.</b><b>1</b><b> </b><b>M</b><b>i</b><b>n</b><b>s</b><b>t</b><b>o</b><b>r</b><b>e</b><b>架</b><b>构</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Minstore中的所有
内容都是表（table）。表由多个行（row）组成，每个行则由键-值对组成。存储在磁盘上的Minstore表可使用B+树来表示。当存储在易失性内
存（RAM）中时，Minstore表可以使用哈希表来表示。B+树也叫平衡树，有很多重要属性，如下。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）通常每个节点包含大量子节点。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）只在叶上存储数据指针（指向包含键值的磁盘文件块的指针），而不在内部节点上存储。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）从根节点到叶节点的每个路径长度均相同。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">其他文件系统（如NTFS）通常会使用B树（另一种数据结构，用于描述“二进制搜索树”，但这与“二进制树”是两回事）将数据指针和键存储在树的每个节点上。这种技术大幅减少了B树中每个节点可装入的项的数量，从而导致B树的层数增多，因此，导致记录的搜索时间变长。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图11-79展示了一个B+树的范例。在图中所示的树上，根和内部节点只包含键，通过这些键可以正确地访问位于叶节点中的数据。叶节点都位于同一个层级，通常会链接在一起。因此，无须发出大量I/O操作即可找到树上的元素。</span></p><div style="display: block;text-align:center;">
	<img width="649" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/8be2e4bbef92b076f15cf3f15d100e71.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-79 B+树范例。仅叶节点包含数据指针，引导者节点只包含到子节点的链接</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">举例来说，假设
Minstore需要访问键20对应的节点。根节点中包含的键可以充当索引。值大于或等于13的键存储在被右侧指针索引的子节点中，而值小于13的键存储
在左侧指针索引的子节点中。当Minstore抵达包含实际数据的叶节点后，即可轻松访问键16和键25所对应的节点中包含的数据，而无须扫描整个树。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，叶节点通常会使用链
表链接在一起。这意味着对于非常巨型的树，举例来说，Minstore只需要访问根节点和中间节点一次，就可以查询一个文件夹中的所有文件，当然前提假设
是类似图11-79中所示，所有文件都由存储在叶节点中的值所表示的。如上文所述，Minstore通常使用B+树来表示文件或目录之外的其他对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在本书中，我们使
用“B+树”和“B+表”代表同一个概念。Minstore定义了不同种类的表，表可以创建，可以向其中添加或删除行，或更新其中的行。外部实体可以枚举
表，或在其中查找某一行。Minstore的核心是由对象表所表示的。对象表是一种索引，包含卷上每个根（非嵌入式）B+树的位置。B+树可以嵌入其他树
中，子树的根会存储在父树的行中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Minstore中的每个
表都是由一个复合体（Composite）和一种模式（Schema）定义的。复合体其实是一组规则，描述了根节点（有时甚至子节点）的行为以及如何寻找
并操作B+表中的每个节点。Minstore支持两种类型的根节点，这些节点分别由不同的复合体所管理。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>写</b><b>入</b><b>时</b><b>复</b><b>制</b><b>（</b><b>C</b><b>o</b><b>p</b><b>y</b><b> </b><b>o</b><b>n</b><b> </b><b>W</b><b>r</b><b>i</b><b>t</b><b>e</b><b>，</b><b>C</b><b>o</b><b>W</b><b>）</b></span>：当树被修改时，此类根节点的位置会产生变动。这意味着如果进行了修改，则会写入一个全新的B+树，原来的树会被标记为删除。为了处理这些节点，相应的复合体需要维持一种对象ID，并在写入表时使用该ID。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>嵌</b><b>入</b><b>式</b><b>（</b><b>E</b><b>m</b><b>b</b><b>e</b><b>d</b><b>d</b><b>e</b><b>d</b><b>）</b></span>：此类根节点会存储在另一个B+树的索引项的数据部分（叶节点的值）。嵌入式复合体维持了对索引项的引用，而该索引项存储了嵌入式根节点。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">创建表时指定的模式可以告
诉Minstore该使用什么类型的键，表的根节点和叶节点应该有多大，以及表中的行该如何布局。ReFS为文件和目录使用了不同的模式。目录是由对象表
引用的B+表对象，其中可包含三个不同的行（Files、Links和File 
IDs，分别对应文件、链接和文件ID）。在ReFS中，每一行的键代表了文件名称、链接或文件ID。文件则是一种表，其中的每一行包含各种属性（属性代
码和值两两成对）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">针对表执行的每一种操作
（关闭、修改、写入磁盘、删除）都由一个Minstore事务表示。Minstore事务类似于数据库中的事务，是一种工作单元，有时候可能由多个事务组
成，只能以原子性的方式执行或成功或失败。表则是通过一种名为“更新树”的过程写入磁盘的。在请求对树进行更新后，事务会从树上排空，更新完成前不允许启
动新的事务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">嵌入式表是ReFS中的另
一个重要的概念，对于这种表，其B+树的根节点会位于另一个B+树的行中。ReFS大量使用了嵌入式表。例如，每个文件都是一个B+树，这种树的根会被嵌
入目录对应的行。嵌入式表也支持改变父表的移动操作。根节点的大小是固定的，具体大小由表的模式所决定。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_315" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>6</b><b>.</b><b>2</b><b> </b><b>B</b><b>+</b><b>树</b><b>的</b><b>物</b><b>理</b><b>布</b><b>局</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Minstore中的
B+树由桶（Bucket）组成。这种桶类似于常规的B+树节点。叶桶包含树正在存储的数据，中间桶称为引导者（Director）节点，只用于直接查找
树的下一级（在图11-79中，每个节点都是一个桶）。由于引导者节点只用于将流量引导至子桶，因此无须具备子桶中键的相同副本，只需要在两个桶中选择一
个值来使用（在ReFS中，键通常是压缩后的文件名）。中间桶的数据则包含逻辑簇号（LCN）和所指向的桶的校验值（校验值使得ReFS能够实现自治愈功
能）。Minstore表的中间节点可以视为一种默克尔树（Merkle 
Tree），其中每个叶节点都以数据块的哈希值作为标签，而每个非叶节点都以自己的子节点标签的哈希值作为标签。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每个桶都由一个索引头和一
个索引脚组成，其中索引头描述了该桶，而索引脚则是一个按照正确的顺序指向索引项的偏移量数组。在索引头和索引脚之间则是索引项。一个索引项代表B+表中
的一行；每一行都是一种简单的数据结构，提供了键和数据的位置和大小信息（位于同一个桶中）。图11-80展示了一个包含三行的叶桶的范例，这些行都使用
位于索引脚的偏移量进行索引。在叶页中，每一行都包含了键和实际数据（或另一个嵌入式树的根节点）。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/8956cfb6d8c50c2a11fdcc4e392a6c78.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-80 包含三个索引项的叶桶，按照索引脚中的偏移量数组进行排序</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_316" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>6</b><b>.</b><b>3</b><b> </b><b>分</b><b>配</b><b>器</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">当文件系统要求
Minstore分配一个桶时（B+表会使用一种名为“桶固定”的过程请求桶），Minstore需要通过某种方法持续跟踪底层介质的可用空间。第一版
Minstore使用了一种具备层级结构的分配器，这意味着会使用多个分配器对象，每个对象从自己的父分配器中分配空间。当根分配器映射了整个卷的空间
后，每个分配器将变成一个使用lcn-count表方案的B+树。该方案会将行的键描述为分配器从其父节点获得的LCN范围，并将行的值描述为一个分配器
区域。在最初的实现中，分配器区域描述了该区域中每个块相对于其子节点的状态（可用或已分配），以及拥有自己对象的所有者ID。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图11-81展示了这种层级式分配器最初实现结果的简化版本。在图中，一个大型分配器只包含一个分配单元：相应的位所代表的空间已经被分配给中型分配器，目前该空间是空的。此时，该中型分配器是大型分配器的子分配器。</span></p><div style="display: block;text-align:center;">
	<img width="759" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/39c48305c42c522943f022c491b37ea7.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-81 早前的层级式分配器</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">B+表深度依赖分配器来获
得新桶，并借此为现有桶的写入副本寻找空间（从而实现“写新”策略）。最新版Minstore使用策略驱动的分配器取代了层级式分配器，这样做的目的在于
在文件系统中构建一种“中心位置”，进而为存储分层提供支持。每一个存储层都是一种类型的存储设备（如SSD、NVMe或传统机械硬盘）。存储分层详见下
文介绍，简单来说，该功能可为磁盘提供快速随机访问的存储区域，不过这种区域一般比只能顺序访问的区域容量小很多。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">新增的策略驱动的分配器进
行了大量优化（每秒可支持更多的分配），可以根据请求的存储层（底层存储设备类型）定义不同的分配区域。当文件系统为新数据请求空间时，中心分配器将通过
策略驱动引擎决定从哪个区域开始进行分配。该策略引擎可感知存储层（意味着元数据始终可以写入性能层，绝不会写入SMR容量层，因为元数据本质上是随机写
入的），支持ReFS带（Band），并实现了延迟分配逻辑（Deferred Allocation 
Logic，DAL）。延迟分配逻辑依赖于这样一个事实：当文件系统创建一个文件时，通常也会为文件内容分配所需空间。Minstore并不会向底层文件
系统返回LCN范围，而是会返回一个令牌，其中包含了预留的空间，因此可保证该分配不会因为磁盘已满而失败。当最终写入文件时，分配器会为文件内容分配
LCN并更新元数据。这就解决了SMR磁盘可能遇到的问题（详见下文），并使得ReFS可以在不到1秒的时间里创建非常大的文件（64TB甚至更大）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">策略驱动的分配器由三个中
心分配器组成，它们在磁盘上都实现为全局B+表。不过在载入内存后，分配器会使用AVL树来表示。AVL树是另一种可以自我平衡的二叉树，本书不详细介
绍。尽管B+表中的每一行均由范围索引，但这些行的数据部分依然包含一个位图，或作为一项优化措施，只包含已分配簇的数量（如果所分配的空间连续）。这三
个分配器会用于不同目的。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·中型分配器（Medium Allocator，MAA）是命名空间中每个文件的分配器，但由其他分配器分配的某些B+表除外。中型分配器自身就是一个B+表，因此需要为自己的元数据更新（依然遵循“写新”策略）寻找空间，而这也是小型分配器（SAA）的作用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
小型分配器（Small Allocator，SAA）可以为自己、中型分配器，以及另外两个表分配空间。另外两个表分别是Integrity 
State表（完整性状态表，ReFS借此可支持完整性流）和Block Reference 
Counter表（块引用计数器表，ReFS借此可支持文件的块克隆）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·容器分配器（Container Allocator，CAA）会在为容器表分配空间时使用，这种基础表为ReFS提供了簇的虚拟化能力，同时也被大量用于容器压缩（详见下文）。此外，容器分配器包含一个或多个描述自身所用空间的项。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当使用Format工具为
ReFS创建初始的基本数据结构时，会创建三个分配器。中型分配器最开始描述了卷的所有簇。SAA和CAA元数据（均为B+表）空间是从MAA中分配的
（该操作只会在卷的整个生命周期中发生一次）。SAA中会被插入一个项，该项描述了中型分配器所使用的空间。分配器创建完毕后，就不再需要从MAA分配额
外的SAA和CAA项了（除非ReFS发现分配器本身已损坏）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了对文件执行“写新”操
作，ReFS必须首先咨询MAA分配器以找到可以写入的空间。在分层存储配置中，该操作可感知不同存储层的存在。成功找到可写入的空间后，ReFS会更新
文件的流范围表，以反映该范围的新位置，并更新文件的元数据。随后，新的B+树会被写入磁盘上的可用空间块中，原先的表则会被转换为可用空间。如果该写入
操作被标记为“直写”，则意味着发生崩溃后，该写入操作必须能被重新发现，为此ReFS会写入一条日志记录来记录该“写新”操作（详见下文“ReFS直
写”一节）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_317" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>6</b><b>.</b><b>4</b><b> </b><b>页</b><b>表</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">当Minstore更新
B+树中的桶时（也许是因为需要移动子节点，或向表中添加一行），通常还需要更新父（或引导者）节点（更确切地说，Minstore会使用不同的链接指向
每个节点新的和原来的子桶）。这是因为，如上文所述，每个引导者节点都包含其下所有叶节点的校验值，此外，叶节点可能已被移动甚至被删除。这会导致同步问
题，例如，假设一个线程正在读取B+树，而同时有一行被删除了。如果锁定该树并等待针对物理介质的每个修改操作，则会造成极大的性能开销。
Minstore需要通过一种更方便、快捷的方法来跟踪有关树的信息。Minstore页表（与CPU的页表没有任何关系）是一种内存中的哈希表，由每个
Minstore的根表（通常为目录和文件表）专用，借此可以跟踪哪些桶是脏的、可用的，或者已被删除的。这个表绝对不会存储到磁盘上。在
Minstore中，“桶”和“页”这两个术语往往是可以互换使用的，页通常驻留在内存中，而桶存储在磁盘上，但它们都代表了同一个上层概
念。“树”和“表”一般也可以互换使用，这也解释了“页表”这个名字的由来。页表中的行由目标桶的LCN（作为键）和一个数据结构（作为值）组成，该数据
结构可跟踪页的状态并协助B+树实现同步。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当首次读取或创建一个页时，代表页表的哈希表中会插入一个新项。只有在满足下列所有条件的情况下，才能删除页表中的项。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·没有正在访问该页的活动事务。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·页是干净的，没有任何修改。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·页并不是原有页执行“写入时复制”操作产生的新页。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在这些规则的限制下，干净
的页才能反复进入页表，然后被删除，而脏页则会始终停留在页表中，直到B+树被更新并最终写入磁盘。将树写入持久介质的过程在很大程度上取决于页表在任何
特定时间的状态。如图11-82所示，页表被Minstore用作内存中的缓存，进而产生一种隐含的状态机来描述每个页的状态。</span></p><div style="display: block;text-align:center;">
	<img width="609" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/9e8f0858f387cfcebdc911b51a41f448.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-82 该图展示了页表中的脏页（桶）的状态。在对原有页执行写入复制操作时，或因B+树增长而需要更多的空间来存储桶时，就会产生新页</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_318" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>6</b><b>.</b><b>5</b><b> </b><b>M</b><b>i</b><b>n</b><b>s</b><b>t</b><b>o</b><b>r</b><b>e</b><b> </b><b>I</b><b>/</b><b>O</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Minstore会以不同
的方式读/写最终物理介质中的B+树：读取操作通常会针对树的不同部分分段进行，这意味着读取操作可能只包含一些叶桶，例如，作为事务型访问的一部分或抢
占式预读取操作来进行。将桶读入缓存（详见上文“缓存管理器”一节）后，Minstore依然无法解读自己的数据，因为还需要先验证桶校验值。预期校验值
存储在父节点中：在ReFS驱动程序（位于Minstore之上）拦截了读取到的数据后，就会知道节点依然需要验证。此时父节点已经位于缓存中（已经在树
中进入子节点位置），并且包含了子节点的校验值。Minstore已经具备了验证桶中所含有效数据需要的全部信息。请注意，页表中可能包含一些从未被访问
过的页面，这是因为其校验值依然需要验证。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Minstore在执行树
的更新操作时，会将整个B+树作为单一事务进行写入。树更新过程会将B+树的脏页写入物理磁盘。导致树需要更新的原因有很多：应用程序明确刷新了自己的变
更、系统在内存不足或其他类似条件下运行、缓存管理器将缓存的数据刷新到磁盘等。值得注意的是，Minstore通常会使用惰性写入器线程来惰性写入更新
后的树。如上文所述，有多个触发器可以触发惰性写入器（例如脏页数量达到某一阈值）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Minstore并不了解
树更新请求背后的原因。Minstore要做的第一件事是确保没有其他事务在同时修改树（为此将使用一些复杂的同步基元）。初始同步完成后，
Minstore会开始写入脏页并删除旧页面。在这种“写新”的实现中，新页面代表已被修改，因而需要替换内容的桶；释放的页面则是需要与父节点断开链接
的旧页面。如果事务需要修改叶节点，则会（在内存中）复制根桶和叶页面，随后Minstore会在不修改任何链接的前提下，在页表中创建相应的页表项。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">树更新算法枚举了页表中的每个页。然而页表对页面在B+树的哪个层级上完全没有概念，因此该算法会从更外部的节点（通常为叶节点）开始检查B+树，直到抵达根节点。对于每个页面，算法将执行下列步骤。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）检查页面状态。如果是已释放的页面，则会跳过该页。如果是脏页，则会更新其父指针和校验值，并将该页面放入一个由等待写入页面组成的内部列表。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）丢弃旧页面。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当算法抵达根节点时，会直
接在对象表中更新根节点的父指针和校验值，并最终将根桶放置在等待写入页面的列表中。至此，Minstore就可以在底层卷上的可用空间中写入新树，并将
旧树保留在原来的位置。旧树只会被标记为已释放，但依然存在于物理介质中。这是一个重要特性，算得上是“写新”策略的精髓，可以让Minstore基础之
上的ReFS文件系统支持高级联机恢复功能。图11-83展示了一个包含两个新叶页（A'和B'）的B+表的更新过程。如图所示，位于页表中的页为浅灰
色，旧页面则为深灰色。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/6f0f90b6c457e807c3cc3b18b7e15521.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-83 Minstore树的更新过程</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在树更新的过程中，对树维
持独占式访问可能造成一些性能问题，并且其他方无法对独占锁定的树执行任何读取或写入操作。在最新版的Windows 
10中，Minstore中的B+树已经具备了世代（Generational）的概念，每个B+树都被附加了一个世代编号。这意味着树中的某个页面可能
在某个世代看来是脏页。如果某个页面最开始只对某个特定世代的树是脏的，那么即可直接更新，无须进行写入时复制，因为最终的树还没有写入磁盘上。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在新模型中，树更新的过程通常可分为两个阶段。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>可</b><b>失</b><b>败</b><b>阶</b><b>段</b></span>：Minstore获得树独占锁，增大树的世代编号，计算并分配树更新需要的内存，将锁转为共享锁。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>不</b><b>可</b><b>失</b><b>败</b><b>阶</b><b>段</b></span>：
该阶段使用共享锁执行（意味着其他I/O可以读取该树），Minstore会更新引导者节点的链接和所有树的校验值，并将最终的树写入底层磁盘。如果在写
入磁盘的过程中有其他事务需要更改树，则Minstore会检测到树的世代编号增大，随后会对树再次进行写入时复制操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在这种新模式下，Minstore只在可失败阶段持有独占锁。这意味着树更新可以与其他Minstore事务并行执行，这可以大幅改善系统整体性能。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_319" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>6</b><b>.</b><b>6</b><b> </b><b>R</b><b>e</b><b>F</b><b>S</b><b>架</b><b>构</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，ReFS（复原文件系统）是NTFS实现与Minstore的结合体，其中每个文件和目录都是配置为某种方案的B+树。文件系统卷是一种扁平的目录命名空间。此外，上文也曾提到，NTFS由不同的组件组成，如下。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>核</b><b>心</b><b>文</b><b>件</b><b>系</b><b>统</b><b>支</b><b>持</b></span>：描述文件系统和其他系统组件（如缓存管理器和I/O子系统）之间的接口，并公开文件的创建、打开、读取、写入、关闭等概念。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>高</b><b>级</b><b>文</b><b>件</b><b>系</b><b>统</b><b>功</b><b>能</b><b>支</b><b>持</b></span>：描述现代文件系统的一些高级功能，如文件压缩、文件链接、配额跟踪、重分析点、文件加密、恢复支持等。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>依</b><b>赖</b><b>于</b><b>磁</b><b>盘</b><b>的</b><b>组</b><b>件</b><b>和</b><b>数</b><b>据</b><b>结</b><b>构</b></span>：MFT和文件记录、簇、索引包、驻留和非驻留属性等（详见上文“NT文件系统”一节）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ReFS在很大程度上保持了前两部分不变，但使用Minstore取代了依赖于磁盘的组件，如图11-84所示。</span></p><div style="display: block;text-align:center;">
	<img width="798" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e5a3038f7bd8beb2ff5a8f9111fb5cde.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-84 ReFS架构方案</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在“NTFS驱动程序”一
节我们介绍了将文件句柄与文件系统的磁盘结构链接在一起的实体。在ReFS文件系统驱动程序中，这些数据结构（代表调用方试图读取的NTFS属性的流控制
块，以及包含指向磁盘MFT中文件记录指针的文件控制块）依然有效，但在底层的持久存储方面略有差异。对这些对象的更改需要通过Minstore进行，而
不能直接转换为针对磁盘上MFT的更改。如图11-85所示，在ReFS中：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个文件控制块（FCB）代表一个文件或目录，因此，其中包含一个指向Minstore B+树的指针，以及一个对父目录的流控制块和键（目录名）的引用。FCB是由文件对象通过FsContext2字段指向的。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个流控制块（SCB）代表文件对象打开的流。ReFS所用的数据结构是NTFS数据结构简化后的版本。当代表目录时，SCB会包含一个指向目录索引的链接，该链接位于代表该目录的B+树中。SCB会通过FsContext字段指向文件对象。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
一个卷控制块（VCB）代表当前挂载并格式化为ReFS的卷。当ReFS驱动程序识别出一个正确格式化的卷后，将创建VCB数据结构，附加到卷设备对象扩
展，并链接到一个位于全局数据结构中的列表，该列表是ReFS文件系统驱动程序在初始化时分配的。VCB包含卷上当前已打开的所有目录FCB的表，其中的
内容会通过引用ID进行索引。</span></p><div style="display: block;text-align:center;">
	<img width="850" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4a04f9ac5c923e70552e02f833bdcc65.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-85 ReFS文件和目录内存中的数据结构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在ReFS中，每个打开的
文件都在内存中有一个FCB，该FCB可被不同的SCB指向（取决于打开的流数量）。NTFS中的FCB只需要知道文件的MFT项就可以正确更改文件属
性，而ReFS中的FCB需要指向代表文件记录的B+树。文件B+树中的每一行都代表文件的一个属性，例如ID、全名、范围表等。每一行的键都是属性代码
（一个整数值）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">文件记录是文件所在目录中
包含的项。代表文件的B+树根节点会被嵌入至目录项的值数据中，永远不会出现在对象表内。文件数据流由范围表所表示，会嵌入文件记录的B+树中。范围表可
通过范围进行索引，这意味着范围表中的每一行都有一个作为行键的VCN范围，文件范围的LCN则可作为行的值。在ReFS中，范围表可能会变得非常大（毕
竟这只是一种普通的B+树），这样ReFS就可以支持非常大的文件，甚至超出了NTFS的支持上限。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图11-86展示了对象表、文件、目录和文件范围表，ReFS使用B+树代表它们，并借此提供文件系统命名空间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">目录是一种Minstore B+树，负责单一的扁平命名空间。ReFS目录可以包含以下几方面：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·到目录的链接。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·到其他文件（文件ID）的链接。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/8803a99f6e5fb3bbfda756af19421703.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-86 ReFS中的文件和目录</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">目录B+树中的行由
&lt;键, 
&lt;类型,值&gt;&gt;对组成，其中键是项的名称，值取决于目录项的类型。为了支持查询和其他高级语义，Minstore还在不可见目录行中存
储了一些内部数据。此类不可见行的键以Unicode零字符开头。另外还有一行值得一提，那就是目录的文件行。每个目录都有一条记录，在ReFS中，该文
件记录会作为一个文件行，使用一个众所周知的“零键”存储在自己的目录中。这会对ReFS为目录维持内存中的数据结构产生一些影响。在NTFS中，目录实
际上是文件记录的一种属性（通过Index Root和Index 
Allocation属性实现）；但在ReFS中，目录是一种存储在目录本身中的文件记录（名为目录索引记录）。因此，当ReFS操作目录或向目录插入文
件时，必须确保目录索引已打开并驻留在内存中。为了能够更新目录，ReFS会在已打开的流控制块中存储一个指向目录索引记录的指针。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上述ReFS B+树的配置并没有解决一个重要问题。当系统枚举目录中所有文件时，都需要打开并解析每个文件的B+树。这意味着需要对底层存储介质的不同位置发出大量I/O请求。如果介质是机械硬盘，那么此时的性能将会相当糟糕。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了解决这个问题，
ReFS在文件嵌入表的根节点中（而非子文件B+树的行中）存储了一种STANDARD_INFORMATION数据结构。
STANDARD_INFORMATION数据结构包含枚举文件所需的全部信息（如文件的访问时间、大小、属性、安全描述符ID、更新序列号等）。文件的
嵌入根节点会被存储在父目录的B+树的叶桶中。通过将这种数据结构放在文件的嵌入根节点中，当系统枚举目录中的所有文件时，只需要解析目录B+树中的项，
而无须访问描述每个文件的B+表。代表目录的B+树已经位于页表中，因此枚举速度会非常快。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_320" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>6</b><b>.</b><b>7</b><b> </b><b>R</b><b>e</b><b>F</b><b>S</b><b>在</b><b>磁</b><b>盘</b><b>上</b><b>的</b><b>结</b><b>构</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">与上文有关NTFS的小节类似，本节介绍了ReFS卷的磁盘结构。本节将专注于NTFS和ReFS之间的差异，不再涉及上文已经介绍过的概念。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与NTFS类似，ReFS
卷的引导扇区也包含一个小型数据结构，其中包含基础的卷信息（如序列号、簇大小等）、文件系统标识符（ReFS 
OEM字符串和版本），以及ReFS容器大小（详见下文“叠瓦式磁记录卷”一节）。卷中最重要的数据结构是卷超级块（Volume Super 
Block），其中包含最新卷检查点记录的偏移量，会被复制到三个不同的簇中。当挂载卷时，ReFS会读取其中一个卷检查点，验证并解析其内容（检查点记
录包含校验值），最终得到每个全局表的偏移量。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">卷挂载过程会打开对象表，
获得读取根目录所需的信息，其中包含构成卷命名空间的所有目录树。对象表和容器表是最关键的数据结构之一，同时也是所有卷元数据的起点。容器表公开了虚拟
化命名空间，如果没有它，ReFS将无法正确识别任何簇的最终位置。作为一种可选功能，Minstore可以让客户端在自己的对象表行中存储一些信息。对
象表行的值如图11-87所示，其中包含两个不同部分：被Minstore拥有的部分，以及被ReFS拥有的部分。ReFS还会存储一些父信息，以及目录
中高水位线的USN编号（详见下文“安全性和变更日志”一节）。</span></p><div style="display: block;text-align:center;">
	<img width="470" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/89e0c1c2bee224bc4289a4397141ea9e.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-87 由ReFS部分（下方矩形框）和Minstore部分（上方矩形框）组成的对象表项</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_321" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>6</b><b>.</b><b>8</b><b> </b><b>对</b><b>象</b><b>I</b><b>D</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">ReFS还需要解决与文件
ID有关的另一个问题。出于各种原因（主要是为了有效跟踪并存储文件元数据，而不要将这些信息与命名空间绑定到一起），ReFS需要为通过文件ID打开文
件（例如使用OpenFileById 
API）的应用程序提供支持。NTFS是通过$Extend\$ObjId文件（使用$0索引根属性，详见上文有关NTFS的章节）实现这一目标的。在
ReFS中，为每个目录分配一个ID是一种微不足道的操作，实际上，Minstore会将目录的对象ID存储在对象表中。但问题在于，当系统需要为文件分
配ID时，ReFS不像NTFS那样有一个中心的文件ID存储库。为了正确找到目录树中的文件ID，ReFS将文件ID空间分为两部分：目录部分和文件部
分。目录ID使用目录部分，并使用对象表中行的键进行索引。文件部分则从目录的内部文件ID空间进行分配。代表目录的ID通常在其文件部分有一个“零”，
但该目录中的所有文件会共享同一个目录部分。通过在目录的B+树中添加一个单独的行（由&lt;文件ID, 
文件名&gt;对组成），ReFS为文件ID的概念提供了支持，借此可将文件ID映射至目录中的文件名。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当系统需要使用文件ID打开ReFS卷中的文件时，ReFS会通过下列方式满足请求。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）打开由目录部分指定的目录。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）查询文件部分的键在目录B+树中对应的FileId行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）在目录B+树中查询最后一次所找到的文件名。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">细心的读者可能已经注意
到，该算法并未解释当文件被更名或移动后会发生什么。更名后的文件的ID应当与之前的ID的位置相同，即使新目录的ID与文件ID的目录部分并不相同。
ReFS的解决方法是：使用新的“墓碑”（tombstone）项取代旧目录B+树中的原始文件ID项，这个“墓碑”项的值并未指定目标文件名，而是包含
为更名后的文件新分配的ID（其中的目录部分和文件部分均已改变）。新目录的B+树中也会分配另一个新的文件ID项，这样即可将新的本地文件ID分配给更
名后的文件。如果该文件随后被移动到另一个目录，则第二个目录的ID项会被删除，因为已经不再需要了，对于任何特定文件，一个文件最多只需要一个“墓
碑”项。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_322" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>6</b><b>.</b><b>9</b><b> </b><b>安</b><b>全</b><b>性</b><b>和</b><b>变</b><b>更</b><b>日</b><b>志</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">在文件系统中，为
Windows对象安全提供支持的机制主要包含在文件系统部分所实现的一些高级组件中，这一点自NTFS以来始终如此。为了支持同一套语义集，底层磁盘实
现已经进行了更新。在ReFS中，对象安全描述符被存储在卷的全局安全描述符B+树中。表中的每个安全描述符会计算出一个哈希值（使用一种专有算法，该算
法只用于与自己有关的安全描述符），同时每个描述符还会分配一个ID。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当系统为文件附加新的安全
描述符时，ReFS驱动程序会计算安全描述符的哈希值，并检查该哈希值是否已经存在于全局安全表中。如果已存在，则ReFS会解析其ID，并将其存储在文
件B+树嵌入根节点中的STANDARD_INFORMATION数据结构内。如果全局安全表中不存在该哈希值，则ReFS会执行一个类似的过程，但首先
会将新安全描述符添加到全局B+树，随后生成新的ID。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">全局安全表中的行使用了
&lt;&lt;哈希, ID&gt;, &lt;安全描述符, 
引用计数&gt;&gt;的格式，其中哈希和ID的含义如上文所述，安全描述符内容是安全描述符本身的原始字节载荷，而引用计数是对卷上有多少个对象正在
使用该安全描述符的粗略估算结果。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NTFS实现了一种变更日
志功能，借此应用程序和服务可以查询对卷上文件过去进行的改动。ReFS实现了与NTFS兼容，但存在略微差异的变更日志功能。ReFS日志会将变更项存
储在另一个卷的全局Minstore 
B+树中的变更日志文件（元数据目录表）内。ReFS只在卷挂载时才会打开并解析卷的变更日志文件。日志的最大大小存储在日志文件的$USN_MAX属性
中。在ReFS中，每个文件和目录都在父目录嵌入根节点的STANDARD_INFORMATION数据结构中包含自己的最后一个USN（更新序列号）。
借助日志文件和每个文件与目录的USN编号，ReFS即可提供用于读取和枚举卷日志文件的如下三个FSCTL。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·FSCTL_READ_USN_JOURNAL：直接读取USN日志。调用方需指定自己要读取的日志ID以及预计要读取的USN记录的编号。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·FSCTL_READ_FILE_USN_DATA：检索指定文件或目录的USN变更日志信息。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·FSCTL_ENUM_USN_DATA：
扫描所有的文件记录，只枚举在调用方指定的USN记录范围内最后更新的USN。ReFS可以扫描对象表，随后扫描对象表引用的每个目录，最后返回这些目录
中位于指定时间范围内的文件，借此满足查询要求。这个过程比较慢，因为需要打开并检查每个目录（目录的B+树可能分散在整个磁盘上）。ReFS对此的优化
措施是：将一个目录中所有文件的最高USN存储在该目录的对象表项中，这样ReFS只需要访问自己确定在指定范围内的目录，就能满足查询的要求。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11_0017.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_323" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>7</b><b> </b><b>R</b><b>e</b><b>F</b><b>S</b><b>高</b><b>级</b><b>功</b><b>能</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">本节将介绍ReFS的高级功能，这些功能证明了为何ReFS更适合大型服务器系统，例如Azure云平台基础设施所使用的大型服务器系统。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_324" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>7</b><b>.</b><b>1</b><b> </b><b>文</b><b>件</b><b>块</b><b>克</b><b>隆</b><b>（</b><b>快</b><b>照</b><b>支</b><b>持</b><b>）</b><b>和</b><b>稀</b><b>疏</b><b>V</b><b>D</b><b>L</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">传统上，存储系统会在卷层
面上实现快照和克隆功能（例如动态卷）。在现代数据中心，当数以百计的虚拟机通过独立的卷来运行并存储数据时，这种方式在可扩展性方面已经无法满足要求
了。ReFS最初的设计目标之一就是支持文件层面的快照以及可扩展的克隆功能（虚拟机通常映射至底层主机存储中的一个或几个文件），这意味着ReFS需要
能通过某种方法非常快速地克隆整个文件，或者只克隆文件中的几个块。将一个文件中一定范围的块克隆至另一个文件的块，这不仅可以实现文件层面的快照，还能
为只需要访问一个或多个文件中特定几个块的应用程序实现更细化的克隆。VHD差分磁盘合并就是一个很好的例子。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ReFS公开了全新的
FSCTL_DUPLICATE_EXTENTS_TO_FILE，借此可将一个文件中的块范围复制到同一个文件或不同文件的块范围中。克隆操作完成后，
对任何一个文件中被克隆的块范围执行的写入操作都会以“写新”的方式进行，借此即可保留被克隆的块。当被克隆的块只剩下一个引用时，即可进行原地写入。源
文件和目标文件的句柄，克隆文件块的所有细节，从源文件克隆哪些块，以及目标范围是什么，这些都可以作为参数。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上一节所述，ReFS会
将构成文件数据流的LCN索引到范围索引表中，这是一种嵌入式B+树，位于文件记录的行中。为了支持块克隆操作，Minstore使用了一种全新的全局索
引B+树（名为块计数引用表），借此跟踪被克隆的每个块范围的引用计数。最开始该索引是空的。第一次成功的克隆操作会在该表中添加一行或多行记录，代表该
块目前的引用计数为2。如果这些块的某个视图被删除，则对应的行也会被移除。写入操作会查询该索引来判断是否要进行“写新”，或进行原地写入。在分配器中
标记空闲块时也会查询该索引。如果被释放的簇属于某个文件，则该簇范围的引用计数将会减小。如果表中的引用计数归零，那么对应的空间将被标记为已释放。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图11-88展示了一个文件克隆范例。在克隆了整个文件（图中的文件1和文件2）后，这两个文件具备完全相同的范围表，Minstore块计数引用表显示了对两个卷范围的两种引用方式。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/61f0aec67a1f1dc47785bb06463176ce.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-88 克隆ReFS文件</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了减小表的大小，Minstore会尽可能地自动合并块引用计数表中的行。在Windows Server 2016中，Hyper-V使用了新增的克隆FSCTL，因此，虚拟机的复制以及多个快照的内容合并速度非常快。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与NTFS类似，ReFS
还支持文件有效数据长度（Valid Data 
Length，VDL）的概念。ReFS可使用$$ZeroRangeInStream文件数据流来跟踪文件每个已分配数据块的有效或无效状态。对文件请
求的所有新分配都处于无效状态，对文件执行的首次写入操作则会让该分配变得有效。ReFS对无效文件范围的读取请求会返回为零的内容。该技术与上文介绍过
的DAL类似。应用程序可以使用文件系统控制代码FSCTL_SET_ZERO_DATA，在逻辑上将文件的一部分归零，而无须实际写入任何数据
（Hyper-V会通过该功能快速创建固定大小的VHD）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>通</b><b>过</b><b>H</b><b>y</b><b>p</b><b>e</b><b>r</b><b>-</b><b>V</b><b>观</b><b>察</b><b>R</b><b>e</b><b>F</b><b>S</b><b>的</b><b>快</b><b>照</b><b>支</b><b>持</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在这个实验中，我们将使用Hyper-V来测试ReFS的卷快照支持。我们需要使用Hyper-V管理器创建一个虚拟机并在其中安装操作系统。当首次启动时，右键点击虚拟机，并选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>检</b><b>查</b><b>点</b></span>”菜单项，为该虚拟机创建一个检查点。随后在虚拟机中安装一些应用程序（本例我们在Windows Server 2012中安装了Office）并再次创建检查点。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/dbce1dc8faee2d6e8159611bd6c14af0.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">关闭该虚拟机，并使用Windows资源管理器找到虚拟磁盘文件。随后可以看到虚拟磁盘以及其他多个文件，这些文件代表了当前检查点和上一个检查点之间的差异化内容。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/0882c75f56d2e23d17c5d9a13d58b8f2.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">再次打开Hyper-V管理器并删除整个检查点树（右键点击第一个根检查点，选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>删</b><b>除</b><b>检</b><b>查</b><b>点</b><b>子</b><b>树</b></span>”菜
单项），我们会发现整个合并过程只需要几秒钟。这是因为Hyper-V使用了ReFS对块克隆的支持，通过控制代码
FSCTL_DUPLICATE_EXTENTS_TO_FILEI/O将检查点内容正确合并到了基础虚拟硬盘文件中。如上文所述，块克隆实际上并不移动
数据。如果使用格式化为exFAT或NTFS文件系统的卷重复上述实验，将会发现检查点合并的耗时延长了很多。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_325" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>7</b><b>.</b><b>2</b><b> </b><b>R</b><b>e</b><b>F</b><b>S</b><b>直</b><b>写</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">ReFS的设计目标之一是将因为文件系统损坏导致的不可用性降到接近于零的水平。下一节我们将介绍ReFS从磁盘故障中恢复所采用的各种联机修复方法。但在介绍这些方法前，首先有必要了解在将事务写入底层介质时，ReFS是如何实现直写的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">直写是指系统能够合理地保证操作结果在崩溃恢复之后依然可见之前，任何基元修改操作（如创建文件、扩展文件、写入块）都不能被视为完成。直写的性能对各种I/O场景都非常重要，这些场景可以分为两类文件系统操作：数据操作和元数据操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当ReFS对一个文件进行
原地更新而不需要变更任何元数据（例如系统修改一个已分配文件的内容，但并未扩展文件的长度）时，直写性能的开销最小。由于ReFS对元数据使用了“写入
时分配”的策略，因此，在元数据产生变化后，为其他场景进行直写的开销是非常大的。例如文件被重命名，意味着从文件系统的根一直到描述该文件名称的块，所
有元数据块都必须写入一个新位置。ReFS写入时分配的本质还有一个特性：并不会原地修改数据。这意味着，与NTFS相比，系统的恢复不应撤销任何操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了实现直写，
Minstore使用了提前写入日志（Write-Ahead-Logging，WAL）。这种方法如图11-89所示，系统会将记录附加到一个在逻辑上
无限长的日志中。当恢复时，将读取并重新应用该日志。Minstore对除分配器表之外的其他所有表维护了一个逻辑重做事务记录日志。每个日志记录都描述
了一个完整的事务，这样即可在恢复时重新应用。每个事务记录包含一个或多个操作重做记录，其中描述了实际要执行的高层操作（如在表X中插入[键K/值V]
对）。事务记录可实现对特定事务的恢复，这是一种原子性的单位（任何事务都不能部分重做）。从逻辑上来看，日志被每个ReFS事务所拥有，日志记录会被记
录到一个小型日志缓冲区中。如果事务已提交，则日志缓冲区会被附加到内存中的卷日志中，并在稍后写入磁盘；但如果事务被中止，那么内部日志缓冲区也将被丢
弃。直写事务会等待来自日志引擎的确认，由此得知截至通知那一刻的日志均已提交，而非直写事务可以无须确认，随时继续。</span></p><div style="display: block;text-align:center;">
	<img width="626" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/87d6d423353afc925d06a4bed3b35bee.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-89 Minstore的提前写入日志方案</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，ReFS还会利用检查点将系统的某些视图提交至底层磁盘，这会导致一些之前写入的日志记录变得不再有必要。一旦检查点将受影响的树的视图提交至磁盘，就不再需要事务的重做日志记录了。这意味着检查点将负责确定可以被日志引擎丢弃的日志记录范围。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_326" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>7</b><b>.</b><b>3</b><b> </b><b>R</b><b>e</b><b>F</b><b>S</b><b>恢</b><b>复</b><b>支</b><b>持</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">为确保文件系统卷在任何时
候都处于可用状态，ReFS使用了不同的恢复策略。虽然NTFS也支持类似的恢复机制，但ReFS的目标是淘汰所有的脱机检查工具（如NTFS所用的
Chkdsk工具），因为针对大容量磁盘运行这类工具可能需要花费数小时，甚至需要重启动操作系统。ReFS主要使用下列四种恢复策略。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·通过校验值和纠错码检测损坏的元数据。完整性流可使用文件实际内容的校验值（该校验值存储在文件B+树表的一个行中）来验证并维持文件数据的完整性，借此维持文件本身（而不仅仅是文件系统元数据）的完整性。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·只要有另一个可用的有效副本，ReFS即可智能修复出错的任何数据。其他副本可能由ReFS本身提供（例如ReFS会为对象表这样的关键结构创建元数据副本），或可借助存储空间（详见下文“存储空间”一节）提供卷冗余功能。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·ReFS实现的抢救操作可将损坏的数据从联机的文件系统命名空间中移除。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·ReFS会尽可能地通过效果最好的技术来重建丢失的元数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上述的第一个和第二个策略
源自ReFS所依赖的Minstore库（下文将详细介绍完整性流）。对于每个指向不同磁盘块中的子节点（或引导者节点）的链接，对象表和所有全局
Minstore 
B+树表都会维持一个校验值。当Minstore检测到某个块和自己的预期不相符时，就会自动尝试从自己复制的某个副本（如果存在）中进行修复。如果副本
不可用，Minstore则会向ReFS上层返回一个错误信息。ReFS会发起联机抢救操作来响应这种错误信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">抢救（salvage）是
指：当ReFS在目录B+树中检测到损坏的元数据时，为了尽可能多地还原数据所采取的任何必要修复措施。这种抢救操作是Zap技术演变的产物，而Zap技
术的目标是让卷重新恢复联机状态，哪怕这可能导致损坏的数据最终丢失。该技术可以从文件命名空间中移除所有受损的元数据，这些元数据可用于稍后的修复过
程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">假设一个目录B+树的引导者节点损坏。这种情况下，Zap操作可以修复父节点，重写到子节点的所有链接并重新让树实现平衡，但损坏的节点最初指向的数据将彻底丢失。Minstore不知道该如何修复损坏的主节点所指向的项。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了解决这个问题，并在抢
救过程中正确恢复目录树，ReFS需要知道子目录的标识，即便目录表本身已经无法访问（例如可能因为引导者节点损坏）。这种将已丢失目录树的部分内容恢复
出来的能力是通过引入卷全局表实现的，这个表名为父子表（parent-child table），可以针对目录提供冗余信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">父子表中的键代表父表的
ID，数据中则包含一个子表ID的列表。抢救操作会扫描该表，读取子表的列表，重建一个新的未损坏B+树，并在其中包含损坏节点的所有子目录。除了需要子
表ID，为了完全还原损坏的父目录，ReFS还需要知道子表的名称，这些子表最初存储在父B+树的键中。子表通过一种自我记录的项包含了这些信息（主要是
目录链接信息，详见上一节）。抢救过程会打开恢复出的子表，读取自我记录，并将目录链接重新插入父表。该策略使得ReFS能够恢复损坏的引导者和或根节点
的所有子目录（但依然无法恢复文件）。图11-90展示了一个针对损坏的根节点（代表“Bar”目录）执行Zap操作和抢救操作的范例。通过这种抢救操
作，ReFS可以快速让文件系统恢复联机，并且只丢失了目录中的两个文件。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/c2356d8d37e7bac30a8ec872b32ef1af.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-90 Zap操作和抢救操作对比</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">抢救完成后，ReFS会尽
可能地使用效果最好的技术重建缺失的信息。例如，可以通过从其他桶中读取的信息恢复丢失的文件ID（这要感谢可区分文件ID和表的核对规则）。此外，
ReFS还会利用少量额外信息增强Minstore对象表的功能，借此加快修复速度。虽然ReFS会使用这些启发式方法实现尽可能好的效果，但我们依然需
要明白，ReFS主要依靠元数据和存储堆栈提供的冗余能力在不丢失数据的情况下修复损坏的内容。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在非常罕见的情况下，关键
的元数据也可能损坏，ReFS可以将卷挂载为只读模式，但这并不能用于处理表的损坏。举例来说，如果容器表和容器表的所有副本均已损坏，那么卷将无法以只
读模式挂载。但只要跳过这些表，文件系统依然可以直接忽略这些全局表（例如就像分配器那样），这样用户依然可能有机会恢复自己的数据。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ReFS还支持文件的完整
性流，借此可通过校验值保证文件数据（而不仅仅是文件系统的元数据）的完整性。ReFS会在完整性流中存储构成文件范围表的每个“运行”的校验值（该校验
值会存储在范围表行中的数据节内）。该校验值使得ReFS可以在访问数据前验证数据的完整性。在返回任何启用了完整性流的数据前，ReFS首先会计算其校
验值，并将计算得到的值与文件元数据中存储的值进行比较。如果校验值不符，则意味着数据已损坏。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ReFS公开了可被清理器
（scrubber，也叫数据完整性扫描器）使用的FSCTL_SCRUB_DATA控制代码。清理器实现在Discan.dll库中，作为任务计划程序
任务公开，可在系统启动时执行或每周执行一次。当清理器向ReFS驱动程序发送FSCTL时，ReFS驱动程序会对整个卷进行完整性检查：ReFS驱动程
序将检查引导节、每个全局B+树，以及文件系统的元数据。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
本节介绍的联机抢救操作与执行脱机抢救的操作有所差异。Windows中包含的refsutil.exe工具可执行这样的脱机抢救操作，当卷损坏到甚至无
法以只读模式挂载（很罕见的情况）时即可使用该工具。脱机抢救操作会浏览卷上的所有簇，查找似乎是元数据的页面，并尽最大努力将这些页面重新组合起来。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_327" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>7</b><b>.</b><b>4</b><b> </b><b>泄</b><b>漏</b><b>检</b><b>测</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">簇泄漏（leak）是指这
样的情况：某个簇被标记为已分配，但没有对该簇的任何引用。ReFS中可能因为不同的原因发生这样的簇泄漏。当检测到某个目录损坏时，联机抢救可以隔离损
坏并重建树，最终只会丢失一些位于根目录下的文件。如果在树更新算法将Minstore事务写入磁盘之前系统崩溃，这可能导致文件名丢失。这种情况下，文
件的数据已被正确写入磁盘，但ReFS没有指向该数据的元数据。代表该文件本身的B+树表可能依然存在于磁盘上的某个位置，但其嵌入表已不再链接到任何目
录B+树。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows自带的
refsutil.exe工具支持泄漏检测操作，可扫描整个卷，并使用Minstore浏览卷的整个命名空间。随后它可以用自己在命名空间中找到的每个
B+树构建一个列表（每个树可以用一种包含标识符头的已知数据结构来识别），并查询Minstore分配器，将识别出来的每个树的列表与分配器标记为有效
的树列表进行比较。如果发现存在差异，泄漏检测工具会通知ReFS驱动程序，将所发现的未泄漏的树分配的簇标记为空闲。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">卷发生的另一种泄漏可能会影响到块引用计数器表，例如，当某个簇的范围所处的行，其引用计数器数值高于实际引用该簇的文件的计数器数值时就会发生这种情况。lower-case工具可以计算出正确的引用计数并修复该问题。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了正确识别并修复泄漏，泄漏检测工具必须在脱机卷上执行操作，但通过使用与NTFS联机扫描类似的技术，这类工具也可以针对目标卷的只读快照执行操作，而这种快照是由卷影复制服务提供的。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>使</b><b>用</b><b>R</b><b>e</b><b>f</b><b>s</b><b>u</b><b>t</b><b>i</b><b>l</b><b>查</b><b>找</b><b>并</b><b>修</b><b>复</b><b>R</b><b>e</b><b>F</b><b>S</b><b>卷</b><b>上</b><b>的</b><b>泄</b><b>漏</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
这个实验中，我们将使用系统自带的refsutil.exe工具，查找并修复ReFS卷可能出现的簇泄漏问题。默认情况下，该工具不需要卸载卷，因为它可
以针对卷的只读快照执行操作。要通过该工具修复找到的泄漏，我们可以使用/x命令行参数覆盖默认设置。请以管理员身份打开命令提示符窗口并运行下列命令
（在本例中，1TB的ReFS卷被挂载为E:盘，/v参数可以启用该工具的详细输出模式）。</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\&gt;refsutil leak /v e: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Creating volume snapshot on drive \\?\Volume{92aa4440-51de-4566-8c00-bc73e0671b92}...</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Creating the scratch file... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Beginning volume scan... This may take a while... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Begin leak verification pass 1 (Cluster leaks)... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">End leak verification pass 1. Found 0 leaked clusters on the volume. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Begin leak verification pass 2 (Reference count leaks)... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">End leak verification pass 2. Found 0 leaked references on the volume. </span></p>
</div><div class="header0"><h1><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h1></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Begin leak verification pass 3 (Compacted cluster leaks)... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">End leak verification pass 3. </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Begin leak verification pass 4 (Remaining cluster leaks)... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">End leak verification pass 4. Fixed 0 leaks during this pass. </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Finished. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Found leaked clusters: 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Found reference leaks: 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Total cluster fixed : 0 </span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_328" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>7</b><b>.</b><b>5</b><b> </b><b>叠</b><b>瓦</b><b>式</b><b>磁</b><b>记</b><b>录</b><b>卷</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">截至撰写这部分内容，传统机械硬盘所面临的最大问题之一在于记录方式本身所面临的固有物理局限。为了增大磁盘容量，硬盘盘片的密度必须不断增大，然而，为了能读/写越来越小的信息单元，机械硬盘磁头的物理尺寸也必须越来越小。这会造成比特反转（Bit flip）
	<sup><img width="11" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="比特反转是指计算机系统（硬盘、内存、CPU……）中所存储的二进制数据，因为软硬件故障或外部干扰导致其状态在不经意间发生变化的情况，例如，原本的“0”被反转为“1”，原本的“1”被反转为“0”。在某些情况下，这种问题可能导致数据错误、程序崩溃，甚至系统崩溃。——译者注" title="比特反转是指计算机系统（硬盘、内存、CPU……）中所存储的二进制数据，因为软硬件故障或外部干扰导致其状态在不经意间发生变化的情况，例如，原本的“0”被反转为“1”，原本的“1”被反转为“0”。在某些情况下，这种问题可能导致数据错误、程序崩溃，甚至系统崩溃。——译者注" class="epub-footnote"></sup>的
能量壁垒日渐降低，这意味着环境温度所蕴含的能量可能在无意中造成比特反转，进而危及数据完整性。虽然固态硬盘（SSD）在面向消费者的系统中基本已经普
及，但大型存储服务器依然在使用传统的机械硬盘，只有这类硬盘可以用更低的成本来提供更大的容量。为了解决机械硬盘面临的这种问题，业界提出了多种解决方
案，其中最有效的一种方案名为叠瓦式磁记录（Shingled Magnetic 
Recording，SMR），如图11-91所示。传统的PMR（Perpendicular Magnetic 
Recording，垂直磁记录）技术使用了平行轨道的布局，而SMR磁盘用于读取数据的磁头远小于用于写入数据的磁头。更大的写入磁头意味着它可以更有
效地磁化介质（进而写入数据），而不会对可读性或稳定性产生影响。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/17ef116f66a781141cf259532c825de6.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-91 在SMR磁盘中，写入磁道远大于读取磁道</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种新配置造成了一些逻辑上的问题。如果不替换部分连续磁道上的数据，那么几乎不可能向硬盘上的磁道写入数据。为了解决这个问题，SMR磁盘将硬盘分为多个区域（zone），技术上每个区域可称为一个带（band）。区域主要分为两种类型。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·传统（或快速）区域，其工作方式与传统PMR磁盘一样，可进行随机写入。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·写指针区域是有自己的“写指针”并且需要严格进行顺序写入的带（并不一定如此，支持主机感知的SMR磁盘也支持写入首选区域这样的概念，借此依然可支持随机写入。不过ReFS并未使用此类区域）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SMR磁盘中的每个带通常为256MB，可以作为一个基本I/O单位使用。这意味着系统可以在不干扰其他带的情况下向一个带写入。SMR磁盘共分为三种类型。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>驱</b><b>动</b><b>器</b><b>管</b><b>理</b><b>（</b><b>d</b><b>r</b><b>i</b><b>v</b><b>e</b><b>-</b><b>m</b><b>a</b><b>n</b><b>a</b><b>g</b><b>e</b><b>d</b><b>）</b></span>：
在主机看来，这种驱动器与非叠瓦式驱动器没有任何区别。主机无须遵循任何特殊协议，因为所有数据处理工作和磁盘区域的存在以及顺序写入的限制都是由设备固
件负责管理的。此类SMR磁盘兼容性很好，但也存在一些局限，即用于将随机写入转换为顺序写入的磁盘缓存容量是有限的，带的清理是一种复杂操作，并且顺序
写入检测也很重要。这些局限都会对性能产生不利影响。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>主</b><b>机</b><b>管</b><b>理</b><b>（</b><b>h</b><b>o</b><b>s</b><b>t</b><b>-</b><b>m</b><b>a</b><b>n</b><b>a</b><b>g</b><b>e</b><b>d</b><b>）</b></span>：
此类设备要求主机严格遵循特定的I/O规则。主机需要按顺序写入才能不破坏现有数据。如果有命令违反了这一假设，那么硬盘将会拒绝执行这样的命令。主机管
理的硬盘只支持顺序写入区域和传统区域，传统区域可以位于任何介质上，包括非SMR硬盘、驱动器管理的SMR以及闪存。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>主</b><b>机</b><b>感</b><b>知</b><b>（</b><b>h</b><b>o</b><b>s</b><b>t</b><b>-</b><b>a</b><b>w</b><b>a</b><b>r</b><b>e</b><b>）</b></span>：
驱动器管理和主机管理两种技术的结合体，这种硬盘可以管理存储设备“叠瓦式”的本质特征，并能执行主机发出的任何命令，而无论该命令是否连续。然而，主机
可以知道这种硬盘是叠瓦式的，因此可以查询硬盘以获得SMR区域信息。这样，主机就可以围绕叠瓦式的本质特征优化自己的写入操作，同时依然让硬盘具备足够
的灵活性和向后兼容性。主机感知的硬盘支持顺序写入首选区域的概念。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">截至撰写这部分内容，ReFS是唯一能原生支持主机管理SMR磁盘的文件系统。ReFS为支持这类硬盘所使用的策略可实现非常大的容量（20TB甚至更高），并且与分层卷所用的策略类似，通常可通过存储空间创建（有关存储空间的详细信息请参阅最后一节）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_329" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>7</b><b>.</b><b>6</b><b> </b><b>R</b><b>e</b><b>F</b><b>S</b><b>对</b><b>分</b><b>层</b><b>卷</b><b>和</b><b>S</b><b>M</b><b>R</b><b>的</b><b>支</b><b>持</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">分层卷类似于主机感知的
SMR磁盘，其中包含一个快速随机访问区域（通常由SSD提供）和一个速度较慢的顺序写入区域。但这并非必备条件，分层磁盘也可以由不同的随机访问磁盘，
甚至相同速度的磁盘组成。ReFS通过在卷命名空间基础上构建的文件和目录命名空间之间提供一个新的逻辑间接层，即可正确管理分层卷和SMR磁盘。这个新
的间接层将卷划分为多个互不重叠的逻辑容器（因此任何一个簇在任意时间里只能存在于一个容器中）。容器代表了卷中的一个区域，一个卷上的所有容器始终大小
相等，这个大小是根据底层磁盘的类型决定的：标准分层磁盘为64MB，SMR磁盘为256MB。容器也可称为ReFS带，因为如果配合SMR磁盘使用，容
器的大小将会与SMR带的大小完全一致，每个容器可以一对一映射至每个SMR带。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">该间接层如图11-92所
示，是通过全局容器表配置和提供的。该表的行由存储了容器的ID和类型的键组成。对于不同类型的容器（压实或被压缩容器），各自的行数据内容也有所差异。
对于非压缩容器（ReFS压缩的详细介绍请参阅下一节），行数据是一种数据结构，其中包含容器中可寻址簇范围的映射。这样ReFS就获得一种虚拟LCN到
真实LCN命名空间的映射。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/6c6fa6101283ce8106f1d2e52834acfd.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-92 容器表提供了一种从虚拟LCN到真实LCN映射的间接层</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">容器表很重要：ReFS和
Minstore管理的所有数据都需要通过容器表来管理（只有少数例外），因此ReFS会对这个重要的表创建多个副本。为了对一个块执行I/O操作，
ReFS首先必须查找相应范围的容器位置，进而得到数据的实际位置。这是通过范围表实现的，范围表的行数据中包含簇范围的目标虚拟LCN。容器ID可通过
数学关系从LCN中派生而来。这个新增的间接层使得ReFS能够在无须查询或修改文件范围表的前提下移动容器位置。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ReFS可使用由存储空
间、硬件分层卷以及SMR磁盘提供的存储层。ReFS会将小规模的随机I/O重定向到速度更快的存储层，并来用顺序写入方式将这些写入操作移出到速度较慢
的存储层（移出操作发生在容器层面上）。实际上在ReFS中，“快速存储层”（或闪存存储层）这个术语指的是随机访问区域，这种区域可能由SMR磁盘的传
统带提供，也可能完全由SSD或NVMe设备提供；“慢速存储层”（或HDD层）术语指的是顺序写入区域或机械硬盘。ReFS会根据底层存储介质的类型使
用不同的行为。非SMR磁盘没有顺序要求，所以簇可以在卷上任意位置分配；而SMR磁盘如上文所述，需要满足严格的顺序要求，因此ReFS永远不会将随机
数据写入慢速存储层。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">默认情况下，ReFS使用
的所有元数据都需要驻留在快速存储层中；即便在处理一般的写入请求时，ReFS也会尽可能使用快速存储层。在非SMR磁盘的配置中，当闪存容器装满后，
ReFS会将容器从闪存移动至HDD（这意味着在连续写入工作负载中，ReFS会不断地将容器从闪存移动到HDD）。如果需要，ReFS还能执行反向移
动，从HDD中选择容器并将其移动到闪存以供后续执行持续写入。该功能也叫容器旋转（container 
rotation），可分为两个阶段实现。在存储驱动程序复制了实际数据后，ReFS会修改上文提到的容器LCN映射，但无须修改任何文件的范围表。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">容器旋转只在非SMR磁盘
上实现。这一点很重要，因为在SMR磁盘中，ReFS驱动程序永远不会自动在不同的存储层之间移动数据。如果应用程序可感知SMR磁盘并且希望将数据写入
SMR的容量层，此时可使用控制代码FSCTL_SET_REFS_FILE_STRICTLY_SEQUENTIAL。当应用程序向文件句柄中发送该控
制代码时，ReFS驱动程序会将所有新数据写入卷的容量层中。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>观</b><b>察</b><b>S</b><b>M</b><b>R</b><b>磁</b><b>盘</b><b>的</b><b>存</b><b>储</b><b>层</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以使用Windows自带的FsUtil工具查询SMR磁盘的信息，如每个层的大小、可用空间和空闲空间等。为此需要以管理员身份打开命令提示符窗口。可以在搜索框中输入cmd，随后右键点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>命</b><b>令</b><b>提</b><b>示</b><b>符</b></span>”，选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>以</b><b>管</b><b>理</b><b>员</b><b>身</b><b>份</b><b>运</b><b>行</b></span>”。接下来请运行如下命令：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fsutil volume smrInfo &lt;VolumeDrive&gt; </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">请将上述命令中的&lt;VolumeDrive&gt;替换为SMR磁盘的盘符。</span></p><div style="display: block;text-align:center;">
	<img width="848" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/d66fe7cc32095f2fc48e46e2fc5b0ab7.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">此外，我们还可以通过下列命令启动垃圾回收（有关该功能的详情请参阅下一节）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">fsutil volume smrGc &lt;VolumeDrive&gt; Action=startfullspeed </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">甚至可以通过相应的Action参数停止或暂停垃圾回收。也可以指定IoGranularity参数来进行更精确的垃圾回收，该参数指定了垃圾回收I/O的粒度。另外，还可以使用start操作替代startfullspeed操作。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_330" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>7</b><b>.</b><b>7</b><b> </b><b>容</b><b>器</b><b>压</b><b>实</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">容器旋转会造成性能问题，
尤其是在存储小文件，而这些小文件无法装满整个带时。此外，如上文所述，SMR磁盘永远不会进行容器旋转。之前曾经提到，每个SMR带都有相关的写入指针
（由硬件实现），借此可识别顺序写入的位置。如果系统以非顺序方式在写入指针之前或之后写入，就会破坏其他簇中的数据（因此SMR固件必须拒绝此类写
入）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ReFS支持两种类型的容器：基础容器（base container）和压实容器（compacted container）
	<sup><img width="10" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="本节介绍的压实（compacted）容器和下一节将要介绍的压缩（compressed）功能是两个不同的概念。目前网上的一些文档将compacted容器称为“压缩容器”，但为了避免与下一节介绍的compressed功能混淆，这里将其称为“压实容器”。还请读者注意区分。——译者注" title="本节介绍的压实（compacted）容器和下一节将要介绍的压缩（compressed）功能是两个不同的概念。目前网上的一些文档将compacted容器称为“压缩容器”，但为了避免与下一节介绍的compressed功能混淆，这里将其称为“压实容器”。还请读者注意区分。——译者注" class="epub-footnote"></sup>，
基础容器会将虚拟簇的范围直接映射至物理空间，而压实容器会将虚拟容器映射至多个不同的基础容器。为了正确映射压实容器所映射的空间与构成压实容器的基础
容器之间的对应关系，ReFS实现了一种分配位图，该位图存储在全局容器索引表（这是另一种表，其中的每一行描述一个压实容器）的行中。如果相关的簇已经
分配，则该位图中有一位会被设置为1，反之则会设置为0。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图11-93展示了一个基
础容器（C32）范例，该容器将虚拟LCN范围（0x8000至0x8400）映射到真实卷的LCN（0xB800至0xBC00，通过R46区分）。如
上文所述，特定虚拟LCN范围的容器ID是从起始处的虚拟簇编号派生而来的，所有容器实际上是连续的。这样，ReFS就永远不需要针对特定容器范围查找容
器ID。图11-93中的容器C32只有560（0x230）个持续分配的簇（总共有1024个簇）。只有基础容器末端的可用空间能被ReFS使用。或者
对于非SMR磁盘，如果基础容器中间位置的一大块空间被释放，这些空间也可以被重用。即便非SMR磁盘，这方面同样要求空间必须是连续的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果容器变得碎片化（因为一些小的文件范围最终被释放），ReFS可以将基础容器转换为压实容器。该操作使得ReFS能够重用容器的闲置空间，而无须在描述容器本身所用簇的文件范围表中重新分配任何行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ReFS提供了一种对碎片
化容器进行碎片整理的方法。在常规系统I/O活动中，需要更新或创建很多小文件或数据块。因此，位于慢速存储层中的容器可以容纳被释放的小块簇，并很快变
得碎片化。压实容器这项功能可以在慢速存储层中生成一个新的空带，借此即可对容器进行适当的碎片整理。压实容器操作只在分层卷的容量层中进行，其主要设计
目标有以下两个。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>压</b><b>实</b><b>操</b><b>作</b><b>是</b><b>S</b><b>M</b><b>R</b><b>磁</b><b>盘</b><b>的</b><b>垃</b><b>圾</b><b>回</b><b>收</b><b>机</b><b>制</b></span>：
对于SMR磁盘，ReFS只能以顺序的方式将数据写入容量区域。小数据无法在慢速存储层中的容器里单独更新。这些数据并不会驻留在SMR写入指针所指向的
位置，因此，任何此类I/O都可能破坏同一个带中的其他数据。在这种情况下，数据会被复制到一个新带中。非SMR磁盘不存在这种问题，ReFS可以直接更
新驻留在小型层中的数据。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>在</b><b>非</b><b>S</b><b>M</b><b>R</b><b>分</b><b>层</b><b>卷</b><b>中</b><b>，</b><b>压</b><b>实</b><b>操</b><b>作</b><b>催</b><b>生</b><b>了</b><b>容</b><b>器</b><b>旋</b><b>转</b></span>：当数据从快速层移动至慢速层时，所产生的空闲容器可以作为向前旋转的目标。</span></p><div style="display: block;text-align:center;">
	<img width="772" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/63cc7f5acdac367e9aa40cf5ee6aa6ea.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-93 由210MB文件寻址的基础容器范例，容器C32只使用了64MB空间中的35MB</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当格式化卷时，ReFS会
从容量层分配一些专门用于执行压实操作的基础容器，这些容器称为压实保留容器。压实操作首先会在慢速层中搜索碎片化的容器。ReFS会将碎片化容器读入系
统内存并整理碎片。随后，碎片整理后的数据会存储到位于容量层的压实保留容器中。借此，由文件范围表寻址的原始容器就被压实了。描述它的范围变为虚拟范围
（压实操作会增加另一个间接层），并指向由另一个基础容器（保留容器）所描述的虚拟LCN。压实结束后，原始物理容器会被标记为已释放，随后即可用作其他
用途。原始容器还可以充当新的压实保留容器。由于位于慢速层中的容器通常会在相对较短的时间内变得高度碎片化，所以压实操作可以在慢速层中产生大量空带。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由压实容器分配的簇可以存
储在不同的基础容器中。为了正确管理压实容器中这种存储在不同基础容器中的簇，ReFS还额外使用了另一个间接层，该层由全局容器索引表和压实容器的不同
布局共同提供。图11-94展示了与图11-93相同的容器，但这次该容器因为碎片化已进行了压实（总共560个簇释放了272个）。在容器表中，描述压
实容器的行存储了压实容器所描述的簇范围、与基础容器所描述的虚拟簇之间的映射关系。压实容器最多支持4个不同范围（也叫“腿”）。这4条腿创建了第二个
间接层，使得ReFS能够高效地整理容器碎片。压实容器的分配位图也提供了第二个间接层。通过检查所分配的簇（对应于位图中的“1”）位置，ReFS可以
正确映射压实容器中每个碎片化的簇。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在图11-94所示的例子
中，第一个被设置为“1”的位处于位置17处，也就是十六进制的0x11。在本例中，1位对应16个簇，但在实际的实现中，1位只对应1个簇。这意味着在
压实容器C32偏移量0x110处分配的第一个簇，其实存储在基础容器C124的虚拟簇0x1F2E0中。压实容器C32中偏移量0x230处的簇之后的
可用空间会映射至基础容器C56。物理容器R46已被ReFS重新映射，并成为一个空的压实保留容器，被基础容器C180所映射。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/5cb10c5c70e7561ede1ca324c9c422c6.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-94 容器C32已被压实到基础容器C124和C56中</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在SMR磁盘中，启动压实操作的过程也叫垃圾回收。对于SMR磁盘，应用程序可以通过文件系统控制代码FSCTL_SET_REFS_SMR_VOLUME_GC_PARAMETERS决定在什么时候手动启动、停止或暂停垃圾回收过程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">与NTFS相反，对于非
SMR磁盘，ReFS卷分析引擎可以自动启动容器压实过程。ReFS会追踪慢速层和快速层的闲置空间以及慢速层可用的可写入闲置空间。如果闲置空间与可用
空间之间的差异超过阈值，则卷分析引擎会自动发起压实过程。此外，如果底层存储是由存储空间提供的，则会定期由一个专门的线程执行容器压实。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_331" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>7</b><b>.</b><b>8</b><b> </b><b>压</b><b>缩</b><b>和</b><b>幻</b><b>象</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">ReFS不支持原生文件系
统压缩，但在分层卷上，文件系统可以通过容器压缩（compression）在慢速层中节省出更多的可用容器。每当ReFS执行容器压实时，都会将位于碎
片化基础容器中的原始数据读入内存。此时，如果启用了压缩功能，则ReFS会压缩数据并将其写入压缩后的压实容器。ReFS支持四种压缩算法：
LZNT1、LZX、XPRESS以及XPRESS_HUFF。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">很多分层存储管理
（Hierarchical Storage 
Management，HMR）软件解决方案还支持幻象（Ghosted）文件的概念。产生这种状态文件的原因有很多。例如，当HSM将用户文件（或文件
中的某些块）迁移到云服务时，用户随后通过其他设备修改了云中的文件副本，HSM过滤器驱动程序需要跟踪文件的哪些部分发生了变化，并需要为每个修改过的
文件范围设置幻象状态。通常，HMR会通过自己的过滤器驱动程序跟踪幻象状态。在ReFS中则无须这样做，因为ReFS公开了一个新的I/O控制代码
FSCTL_GHOST_FILE_EXTENTS。过滤器驱动程序可以向ReFS驱动程序发送该IOCTL，借此将文件的部分内容设置为幻象状态。此
外，还可以通过I/O控制代码FSCTL_QUERY_GHOSTED_FILE_EXTENTS查询文件处于幻象状态的范围。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ReFS通过将新的状态信
息直接存储在文件范围表中而实现了幻象文件，如上文所述，文件范围表是通过文件记录中嵌入的表实现的。过滤器驱动程序可以为文件的每个范围（必须与簇对
齐）设置幻象状态。当ReFS驱动程序拦截了针对幻象范围的读取请求时，会向调用方返回错误代码STATUS_GHOSTED，随后过滤器驱动程序即可拦
截读取操作，并将其重定向至适当的位置（如在上文的例子中，会被重定向至云服务）。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11_0018.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_332" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>8</b><b> </b><b>存</b><b>储</b><b>空</b><b>间</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">存储空间（storage
 
spaces）技术取代了动态磁盘功能，可以为物理存储硬件提供虚拟化能力。该技术最初是为大型存储服务器设计的，但也包含在客户端版本的Windows
 10中。存储空间允许用户混合使用不同的底层存储介质来创建虚拟磁盘，这些介质在性能方面有着不同的特征。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">截至撰写这部分内容，存储空间可支持这些类型的存储设备：非易失性高速缓存（NVMe）、闪存盘、持久性内存（PM）、SATA和SAS接口的固态硬盘（SSD），以及传统机械硬盘（HDD）。通常NVMe速度最快，HDD速度最慢。存储空间共有如下四个设计目标。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>性</b><b>能</b></span>：存储空间实现了对内置服务器端缓存的支持，可实现存储性能最大化，并支持分层磁盘和RAID 0配置。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>可</b><b>靠</b><b>性</b></span>：除了跨区卷（RAID 0），当数据分布在不同的物理磁盘或同一个集群的不同节点时，存储空间还支持镜像卷（RAID 1和10）以及校验卷（RAID 5、6、50、60）配置。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>灵</b><b>活</b><b>性</b></span>：存储空间可供系统创建能在集群不同节点间自动移动的虚拟磁盘，并能根据空间使用情况自动缩容或扩容。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>可</b><b>用</b><b>性</b></span>：存储空间卷内置容错能力。这意味着如果设备或包含在集群中的一台服务器发生故障，存储空间依然可将I/O流量重定向至其他节点，该过程（在某种程度上）完全无须用户介入。存储空间不会产生单点故障。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">存储空间直通
（storage spaces 
direct）是存储空间技术演变后的产物。存储空间直通是为大型数据中心设计的，其中可能包含大量服务器，分别配备了不同的高速和慢速磁盘，借此创建为
存储池。原本的技术不支持未连接JBOD磁盘阵列的服务器集群，因此新技术的名称中增加了“直通”这个词。所有服务器都通过快速以太网连接（例如
10GbE或40GbE）。而远程磁盘之所以能够对系统呈现为本地磁盘，这是通过两个驱动程序实现的：集群微型端口驱动程序（Clusport.sys）
以及集群块过滤器驱动程序（Clusbflt.sys），这些内容已超出了本书的范围。所有存储物理单元（本地和远程磁盘）均添加到存储池中，存储池作为
管理、汇聚和隔离的主要单位，在它之上可创建虚拟磁盘。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">整个存储集群由存储空间使
用一个名为Blueprint（蓝图）的XML文件在内部进行映射。该文件由存储空间的GUI自动生成，使用不同存储实体组成的树描述了整个集群：机架
（Rack）、底盘（Chassis）、计算机（Machine）、JBOD（Just a Bunch of 
Disks）以及磁盘（Disk）。这些实体构成整个集群的每一层。服务器（计算机）可以连接至不同的JBOD或直接连接各种磁盘。在这种情况下，
JBOD可以用一个实体抽象并代表。通过类似的方式，多台计算机可以位于同一个底盘上，而多个底盘又组成一个服务器机架。最终，集群可能会包含多个服务器
机架。通过用Blueprint来代表，存储空间能够与各种磁盘集群配合使用，并在磁盘、JBOD或计算机故障后，将I/O流量重定向至正确的替代实体。
存储空间直通最多可以承受两个同级别实体的故障。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_333" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>8</b><b>.</b><b>1</b><b> </b><b>存</b><b>储</b><b>空</b><b>间</b><b>的</b><b>内</b><b>部</b><b>架</b><b>构</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">存储空间与动态磁盘之间最
大的一个区别在于，存储空间可创建虚拟磁盘对象，存储空间驱动程序（Spaceport.sys）可将这样的对象以实际磁盘设备对象的形式呈现给系统。而
动态磁盘工作在更高层面上：需要将虚拟卷对象暴露给系统（意味着用户模式的应用程序依然可以访问原始磁盘）。卷管理器负责创建由多个动态卷组成的单一卷。
存储空间驱动程序（一种完整驱动程序，而非微型驱动程序）介于分区管理器（Partmgr.sys）和磁盘类驱动程序之间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">存储空间的架构如图
11-95所示，主要包含两部分：独立于平台的库，以及相关环境部分。其中前者负责实现存储空间核心功能；后者是独立于具体平台的，可将存储空间核心功能
链接至当前环境。环境层向存储空间提供了基本核心功能，根据所运行平台的不同，可通过多种方式实现（因为存储空间可充当可启动的实体，Windows引导
加载器和引导管理器需要知道如何解析存储空间，因而需要同时提供UEFI和Windows的实现）。核心基础功能包括内存管理例程（alloc、
free、lock、unlock等）、设备I/O例程（Control、Pnp、Read和Write）及同步方法。这些函数通常是对特定系统例程包装
的产物。例如在Windows平台上，读取服务就是通过创建一个类型为IRP_MJ_READ的IRP并将其发送给正确的磁盘驱动程序实现的；而在
UEFI环境中，则是使用BLOCK_IO_PROTOCOL实现的。</span></p><div style="display: block;text-align:center;">
	<img width="550" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/8d820078c9dfd732e6059b165fa40e3d.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图11-95 存储空间的架构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了系统引导和
Windows内核中的实现，存储空间在崩溃转储过程中同样必须可用，这是由Spacedump.sys崩溃转储过滤器驱动程序实现的。存储空间甚至可以
作为用户模式库（Backspace.dll）使用，借此即可兼容老版本Windows操作系统，使其能够操作存储空间所创建的虚拟磁盘（尤其是VHD文
件）；甚至如果EFI系统分区本身就包含在存储空间实体中，还可以作为UEFI DXE驱动程序（HyperSpace.efi）被UEFI 
BIOS执行。一些较新的Surface设备出厂时可能配备了大容量固态硬盘，而这些硬盘实际上就是由两块或更多高速NVMe硬盘组成的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">存储空间的核心是作为一种
静态库实现的，不仅独立于特定平台，并且可以被所有不同环境层导入。它由核心（Core）、存储（Store）、元数据（Metadata）及IO四层组
成。核心是最高层，实现了存储空间所提供的全部功能。存储层是负责读取和写入集群数据库（通过Blueprint文件创建）记录的组件。元数据层负责解释
从存储层读取的二进制记录，并通过这些对象公开整个集群的数据库：池（Pool）、驱动器（Drive）、空间（Space）、范围（Extent）、列
（Column）、层（Tier）和元数据（Metadata）。IO组件是最底层，能够以适当的顺序方式向正确的设备发出I/O，当然这还要依赖更高层
所解析的数据。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_334" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>8</b><b>.</b><b>2</b><b> </b><b>存</b><b>储</b><b>空</b><b>间</b><b>提</b><b>供</b><b>的</b><b>服</b><b>务</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">存储空间支持不同类型的磁
盘配置功能。借助该功能，用户可以创建完全由快速磁盘（SSD、NVMe、PM）、慢速磁盘，甚至混合使用所有可支持类型的磁盘（混合配置）创建的虚拟磁
盘。对于混合部署，即使混合使用不同类型的存储设备，存储空间依然可通过下列两个功能创建快速又高效的集群。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>服</b><b>务</b><b>器</b><b>缓</b><b>存</b><b>：</b></span>存
储空间可以从集群中隐藏一个快速驱动器，并将其用作慢速驱动器的缓存。存储空间支持使用PM磁盘作为NVMe或SSD硬盘的缓存，NVMe硬盘可以用作
SSD硬盘的缓存，而SSD硬盘可以用作传统机械硬盘的缓存。与分层磁盘不同，这种缓存对虚拟卷上的文件系统是不可见的。这意味着缓存并不知道某个文件的
访问频率是否高于其他文件。存储空间通过采用日志记录冷热块的方式为虚拟磁盘实现了一种高速缓存。热块代表文件中频繁被系统访问的部分（文件的范围），而
冷块代表文件中很少被访问的部分。该日志将缓存实现为一种队列，热块始终位于队列头部，冷块则位于尾部。这样，如果缓存被装满，冷块就可以从缓存中移除，
并放入慢速存储中保存，而热块通常会在缓存中驻留更长的时间。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>分</b><b>层</b><b>：</b></span>存
储空间可以创建分层磁盘，并由ReFS和NTFS负责管理。ReFS可支持SMR磁盘，但NTFS只支持由存储空间提供的分层磁盘。文件系统会跟踪冷热
块，并根据文件使用情况对带进行旋转（详见上文“ReFS对分层卷和SMR的支持”一节）。存储空间还使得文件系统驱动程序可以支持固定（pin）功能，
该功能可以将文件固定在快速存储层并始终锁定到这里，直到解除锁定。这种情况下将永远不执行带旋转。在执行操作系统升级的过程中，Windows会使用固
定功能将新文件固定到快速存储层中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，存储空间的设
计目标之一在于灵活性。存储空间支持创建可扩展的虚拟磁盘，但在集群的底层设备上只消耗实际分配的空间。此类虚拟磁盘也叫精简预配（thin 
provisioned）磁盘。在固定预配的磁盘中，需要一次性从底层存储集群分配全部空间；而在精简预配磁盘中，只需要分配实际使用的空间，这样就可以
创建出远大于底层存储集群容量的虚拟磁盘。当可用空间减少时，系统管理员可以向集群动态添加磁盘。存储空间会自动将新添加的物理磁盘包含到池中，并将已分
配的块重新分配到新增的磁盘上。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">存储空间可通过碎片
（slab）支持精简预配磁盘。碎片是一种分配单位，类似于ReFS中容器的概念，但会应用于更底层的堆栈：碎片是虚拟磁盘的分配单位，而非文件系统中的
概念。默认情况下，每个碎片大小为256MB，但如果底层存储集群允许（例如集群有大量可用空间），碎片可以更大。存储空间核心会跟踪虚拟磁盘中的每个碎
片，并能使用自己的分配器动态分配或释放碎片。值得注意的是，每个碎片都可以看成一个可靠性点：在镜像和奇偶校验配置中，每个碎片中存储的数据都会自动在
整个集群中进行复制。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当创建精简预配磁盘时，依
然需要指定一个“大小”。文件系统需要知道虚拟磁盘的大小，随后才能正确格式化新卷并创建所需的元数据。卷就绪后，存储空间只有在新数据实际写入磁盘时才
会分配碎片，这种方法也叫“写入时分配”。请注意，预配类型对卷上的文件系统是不可见的，因此文件系统并不知道底层磁盘到底是精简预配还是固定预配。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">存储空间通过镜像和奇偶校
验机制消除了可能的单点故障。在由多个磁盘组成的大型存储集群中，通常使用RAID 6作为主要的奇偶校验解决方案。RAID 
6最多可承受两个底层设备故障，还可无须用户介入无缝重建数据。然而，当集群遇到一个（或两个）故障点后，重建阵列所需的时间（平均修复时间，即
MTTR）很长，往往会导致严重的性能降级。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">存储空间通过使用本地重建
代码（Local Reconstruction 
Code，LRC）算法解决了这个问题，该算法减少了重建大型磁盘阵列所需的读取次数，但代价是增加了一个额外的奇偶校验单元。如图11-96所示，
LRC算法将磁盘阵列拆分成不同的行，并为每一行增加了一个奇偶校验单元。如果一块磁盘出现故障，则只需要读取该行中的其他磁盘，因此故障阵列的重建速度
更快，效率更高。</span></p><div style="display: block;text-align:center;">
	<img width="762" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/20c146eb627df17c63d8f17c56a35d5e.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图11-96 RAID 6奇偶校验和LRC算法</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图11-96展示了在由八
块硬盘组成的集群中，典型的RAID 6奇偶校验实现和LRC算法实现之间的差异。在RAID 
6配置中，如果一块（或两块）磁盘出现故障，为了正确重建丢失的信息，其他六块硬盘都需要读取；但在LRC中，只需要读取与故障磁盘位于同一行中的其他磁
盘。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>创</b><b>建</b><b>分</b><b>层</b><b>卷</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">服
务器和客户端版本的Windows 10均原生支持存储空间。我们可以使用图形用户界面或Windows 
PowerShell创建分层磁盘。在这个实验中，我们将创建虚拟分层磁盘，为此需要准备一台工作站系统，除了Windows引导磁盘外，该系统必须有一
块空的SSD和一块空的机械硬盘（HDD）。为了完成测试，我们可以使用Hyper-V模拟出类似的配置。在这种情况下，需要在SSD上创建一个虚拟磁盘
文件，并在机械硬盘上创建另一个虚拟磁盘文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">首先要以管理员身份打开Windows PowerShell。为此请右键点击开始菜单，选择“Windows PowerShell<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>（</b><b>管</b><b>理</b><b>员</b><b>）</b></span>”。请验证系统已识别出已安装磁盘的类型：</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/8551a82479b8cd3a3c7e502b4af0147e.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在上述范例中，系统已经识别出两块SSD和一块机械硬盘。请确认空磁盘的CanPool值设置为True。如果不为True，则意味着磁盘上包含有效分区，需要将  其删除。如果在虚拟化环境中进行实验，系统可能会无法正确识别底层磁盘的介质类型。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/8d11eb5dc08fb1e0cb9f2e83dc246df2.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
这种情况下，我们可以手动指定磁盘类型，为此请运行Set-PhysicalDisk -UniqueId 
(Get-PhysicalDisk)[&lt;IDX&gt;].UniqueID -MediaType 
&lt;Type&gt;命令，其中IDX是上述输出结果中的行号，MediaType是SSD或HDD（取决于磁盘类型）。例如：</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3e88f0eb4b02775b3fab2a49a6f15025.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后需要创建存储池，其中将包含构成新虚拟磁盘的所有物理磁盘。接着还需要创建存储层。在本例中，我们将存储池的名称设置为DefaultPool：</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/6b0a5287fed3285ff3bf5ede9d5f7458.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">最后，可以创建虚拟分层卷，为此需要分配名称并指定每一层的大小。本例中，我们创建了一个名为TieredVirtualDisk的分层卷，其中包含一个120GB的性能层和一个1000GB的容量层：</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/d780fb4374a9e182bb9d25809c8aaa07.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">创建好虚拟磁盘后还需要创建分区，并通过常规的方式（例如使用磁盘管理控制台或Format工具）格式化新建的卷。卷格式化完毕后，即可使用fsutil.exe工具验证底层卷是否为分层卷：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">PS E:\&gt; fsutil tiering regionList e: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Total Number of Regions for this volume: 2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Total Number of Regions returned by this operation: 2 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Region # 0: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Tier ID: {448ABAB8-F00B-42D6-B345-C8DA68869020} </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Name: TieredVirtualDisk-SSD </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Offset: 0x0000000000000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Length: 0x0000001dff000000 </span></p>
</div><div class="header0"><h1><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h1></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Region # 1: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Tier ID: {16A7BB83-CE3E-4996-8FF3-BEE98B68EBE4} </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Name: TieredVirtualDisk-HDD </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Offset: 0x0000001dff000000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">        Length: 0x000000f9ffe00000 </span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter11_0019.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_335" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>1</b><b>.</b><b>1</b><b>9</b><b> </b><b>总</b><b>结</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows支持各种文
件系统格式，这些文件系统均可被本地系统和远程客户端访问。文件系统过滤器驱动程序架构提供了一种简洁的方式，借此可拓展并增强文件系统的访问。而
NTFS和ReFS都为本地文件系统存储提供了一种可靠、安全、可扩展的文件系统格式。虽然ReFS是一个相对较新的文件系统，并且实现了一些针对大型服
务器环境设计的高级功能，但NTFS通过更新也可支持新的设备类型和功能（如POSIX删除、联机磁盘检查和加密）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存管理器提供了一种高速
智能机制，借此可减少磁盘I/O并提高系统的整体吞吐率。通过在虚拟块的基础上进行缓存，缓存管理器可执行智能预读取，甚至可针对远程的网络文件系统执行
这样的操作。通过借助全局内存管理器的映射文件基元来访问文件数据，缓存管理器提供了一种特殊的快速I/O机制，可降低读/写操作需要的CPU时间，同时
将与物理内存管理有关的所有事务留给Windows内存管理器，借此减少重复代码，提高效率。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">借助对DAX和PM磁盘的支持，以及存储空间和存储空间直通、分层卷、SMR磁盘兼容性等属性，Windows依然矗立在下一代存储架构的前沿，为高可用性、可靠性、性能和云规模的存储提供了必要的设计。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">第12章将介绍Windows的启动和关闭。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter12.xhtml">
</div><div class="header0"><h1><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';display: block;text-align:center;"><b>第</b><b>1</b><b>2</b><b>章</b></span></h1></div>
<div class="part">
</div><div class="header0"><h1><span id="sigil_toc_id_336" style="font-size:22px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';display: block;text-align:center;"><b>启</b><b>动</b><b>和</b><b>关</b><b>机</b></span></h1></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">首先，本章介绍了引导
	<sup><img width="11" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="由于历史原因，“Boot”一词在Windows的不同功能中使用了不同的译法，有的叫“启动”，也有的叫“引导”。为了与Windows中相关功能的称呼保持一致，本章中出现的“Boot”会视具体情况译为“启动”或“引导”，还请读者注意。——译者注" title="由于历史原因，“Boot”一词在Windows的不同功能中使用了不同的译法，有的叫“启动”，也有的叫“引导”。为了与Windows中相关功能的称呼保持一致，本章中出现的“Boot”会视具体情况译为“启动”或“引导”，还请读者注意。——译者注" class="epub-footnote"></sup>Windows
所需的步骤与会影响系统启动的选项，了解引导过程的细节可以帮助我们诊断引导过程中可能遇到的问题；也介绍了新增的UEFI固件的细节，以及这种固件相比
于古老的BIOS所带来的改进；还介绍了Windows启动管理器、Windows加载器、NT内核、测量启动过程和新增的安全运行（Secure 
Launch）过程所涉及的全部组件的作用。安全启动过程可检测到针对启动序列所发起的各种类型的攻击。随后，本章介绍了引导过程中可能出现的各类错误以
及相应的解决方法。最后，本章介绍了系统有序关闭过程中所发生的情况。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter12_0001.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_337" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b> </b><b>引</b><b>导</b><b>过</b><b>程</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">当介绍Windows引导
过程时，首先需要从Windows的安装开始讲，随后介绍引导支持文件的执行过程。设备驱动程序也是引导过程中的一个重要组成部分，因此，我们还会介绍设
备驱动程序在加载和初始化过程中如何控制引导的不同阶段。随后介绍执行体子系统的初始化，以及内核通过启动会话管理器进程（Smss.exe）来启动
Windows中的用户模式，进而启动两个初始会话（会话0和会话1）。我们会重点介绍这一过程中屏幕上显示的各种信息，这些信息可以帮助大家将内部过程
与自己在Windows引导过程中观察到的信息联系起来。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于使用可扩展固件接口
（Extensible Firmware Interface，EFI）和基本输入/输出系统（Basic Input/Output 
System，BIOS）的计算机，其引导过程的早期阶段有很大差异。EFI是一种较新的标准，能消除BIOS所用的大部分遗留的16位代码，并支持加载
预引导程序和驱动程序，进而为操作系统的加载提供支持。EFI 
2.0也被称为统一EFI，即UEFI，该标准已被大量计算机制造商所采用。下文将详细描述UEFI计算机的引导过程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了对不同的固件实现提供支持，Windows提供了一种引导架构，该架构可将用户和开发人员之间的各种差异抽离出来。这样，无论计算机使用了什么类型的固件，都可以向用户和开发者提供一种更一致的环境和体验。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_338" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>1</b><b> </b><b>U</b><b>E</b><b>F</b><b>I</b><b>引</b><b>导</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows的引导过程
并非从用户打开计算机电源或按下重置按钮时开始的，而是始于在计算机上安装Windows的那一刻。在执行Windows安装程序的某一时刻即会对系统的
主硬盘进行一些准备工作，使其能够被Windows启动管理器和UEFI固件所理解。在讨论Windows启动管理器代码的作用前，先简单看看UEFI平
台接口。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">UEFI是一套软件，它为
平台提供了第一个基础编程接口。“平台”这个词在这里代表了主板、芯片组、中央处理器（CPU）以及构成计算机“引擎”的其他组件。如图12-1所示，
UEFI规范提供了四种基础服务，可以在大部分可用的CPU架构（x86、ARM等）中运行。下面以x86-64架构为主进行简要介绍。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>上</b><b>电</b></span>：平台上电后，UEFI Security Phase（安全阶段）开始处理平台重启动事件，验证Pre EFI初始化模块代码，将处理器从16位实模式切换为32位扁平模式（此时依然不支持分页）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>平</b><b>台</b><b>初</b><b>始</b><b>化</b></span>：
PEI（EFI预初始化）阶段会初始化CPU、UEFI内核代码和芯片组，并最终将控制权转交给DXE（Driver Execution 
Environment，驱动程序执行环境）阶段。DXE阶段是首个完全以64位模式运行的代码。实际上，最后一个PEI模块（名为DXE 
IPL）会将执行模式切换为64位长模式。该阶段会在固件卷（存储在系统SPI闪存芯片中）内部搜索并执行每个外设的启动驱动程序（也叫DXE驱动程
序）。下文介绍的重要安全功能“安全启动”就是以UEFI DXE驱动程序的形式实现的。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>操</b><b>作</b><b>系</b><b>统</b><b>引</b><b>导</b></span>：UEFI DXE阶段结束后，执行控制权会交给BDS（Boot Device Selection，启动设备选择）阶段。该阶段负责实现UEFI引导加载器。BDS阶段会寻找并执行安装程序的Windows UEFI引导管理器。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>关</b><b>闭</b></span>：UEFI固件实现了一些运行时服务（甚至可用于操作系统），这些服务负责关闭平台电源。Windows通常不会使用这些功能（而是依赖于ACPI接口）。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/53ff7a4f75618cb1288b4072eb5fb42b.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图12-1 UEFI框架</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">有关完整UEFI框架的介绍已经超出了本书范围。当UEFI BDS阶段结束后，固件依然拥有整个平台，并向操作系统的引导加载器提供下列服务。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>引</b><b>导</b><b>服</b><b>务</b><b>：</b></span>为
引导加载器和其他EFI应用程序提供基本功能，如基本内存管理、同步、文本和图形控制台I/O，以及磁盘和文件I/O。引导服务实现的某些例程可以枚举并
查询已安装的“协议”（EFI接口）。此类服务只在固件拥有整个平台时可用，当引导加载器调用ExitBootService 
EFI运行时API后会被丢弃。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>运</b><b>行</b><b>时</b><b>服</b><b>务</b><b>：</b></span>提供日期和时间服务、胶囊式固件更新（固件升级），以及访问NVRAM数据（如UEFI变量）的方法。操作系统正常运行后，这些服务依然可以访问。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>平</b><b>台</b><b>配</b><b>置</b><b>数</b><b>据</b><b>：</b></span>系统ACPI和SMBIOS表总是可以通过UEFI框架访问。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">UEFI引导管理器可以
读/写计算机硬盘并理解FAT/FAT32以及El Torito这样的基础文件系统（El 
Torito用于从光盘引导）。规范要求引导硬盘使用GPT（GUID分区表）方案创建分区，这种方案可以使用GUID识别不同的分区以及这些分区在系统
中所起的作用。GPT方案克服了老旧的MBR方案所受的一些局限，最多支持128个分区，使用了64位LBA寻址模式（因此可以支持容量更大的分区）。每
个分区可以使用一个唯一的128位GUID值进行识别。此外，还会用另外一个GUID来识别分区的类型。虽然UEFI只定义了三种分区类型，但不同的操作
系统厂商会定义自己的分区GUID类型。UEFI标准要求至少具备一个格式化为FAT32文件系统的EFI系统分区。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows安装程序在初始化磁盘时，通常会创建至少四个分区。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·EFI
系统分区，其中复制了Windows启动管理器（Bootmgrfw.efi）、内存测试应用程序（Memtest.efi）、系统锁定策略
（Winsipolicy.p7b，仅适用于启用Device Guard的系统）以及引导资源文件（Bootres.dll）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个恢复分区，其中存储了当系统启动出现问题时，需要引导至Windows环境所需的文件（boot.sdi和Winre.wim）。该分区会格式化为NTFS。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个Windows保留分区，安装工具会将其作为一种高速、可恢复的临时存储区来保存临时数据。此外，一些系统工具会使用这个保留分区来重映射引导卷中损坏的扇区（保留分区不包含任何文件系统）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·一个引导分区（这是安装Windows的分区，通常与系统分区是不同的），其中包含了引导文件。该分区会格式化为NTFS，安装在内置硬盘上的Windows只支持从NTFS的分区上引导。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在将Windows文件放
置到引导分区后，Windows安装程序会将引导管理器复制到EFI系统分区，并将引导分区的内容对系统的其他部分隐藏起来。UEFI规范定义了一些全局
变量，这些变量驻留在NVRAM（系统的非易失RAM）中，即便在运行阶段，当操作系统完整控制整个平台后，这些变量依然可供访问（UEFI的其他一些变
量甚至可以驻留在系统RAM中）。Windows安装程序通过设置某些UEFI变量（如Boot000X变量，其中“X”是一个由引导加载选项编号决定的
唯一数字，此外还有BootOrder变量）来配置UEFI平台，以便启动Windows启动管理器。当系统在安装结束后重启时，UEFI引导管理器将能
自动执行Windows启动管理器的代码。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">表12-1总结了UEFI引导过程所涉及的组件，图12-2展示了一个采用GPT分区方案的硬盘布局范例（位于Windows引导分区中的文件实则存储在\Windows\System32目录下）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">▼表12-1 UEFI引导过程涉及的组件</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e04369fc361d528ec7a0c96470eaaaaf.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/8c8702232ebc46d18e5821c462107618.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/69929a1a1de7b8f26b3cbd4ad76cacd5.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/d0d72902c6690727d9c1746de7a375c1.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">▲图12-2 UEFI系统的硬盘布局范例</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安装程序的另一个用途是准
备BCD，在UEFI系统中，BCD存储于系统卷根目录下的\EFI\Microsoft\Boot\BCD文件中。该文件包含的选项可启动安装程序所安
装版本的Windows，以及之前已经安装的其他版本的Windows。如果BCD已存在，那么安装程序会直接向其中添加与新安装系统有关的条目。有关
BCD的详细信息请参阅第10章。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">所有UEFI规范，包括PEI和BDS阶段、安全启动等概念的详细信息，可参阅https://uefi.org/specifications。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_339" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>2</b><b> </b><b>B</b><b>I</b><b>O</b><b>S</b><b>引</b><b>导</b><b>过</b><b>程</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">受限于篇幅，本书将不再介绍古老的BIOS引导过程。有关BIOS预引导和引导过程的详细介绍，可参阅本书上一版卷2的相关章节。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_340" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>3</b><b> </b><b>安</b><b>全</b><b>启</b><b>动</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如本书卷1第7章所述，
Windows在设计上即可防范恶意软件。所有老旧的BIOS系统都容易受到高级持续性威胁（Advanced Persistent 
Threat，APT），这类威胁会借助Bootkit隐蔽自身并执行代码。Bootkit是一种特殊类型的恶意软件，可以先于Windows启动管理器
运行，进而在不被反病毒解决方案检测到的情况下运行注入模块。BIOS 
Bootkit的初始部分通常位于系统盘的主引导记录（MBR）或卷引导记录（VBR）扇区中。这样，老旧的BIOS系统在开机后就会直接执行
Bootkit代码，而非操作系统主代码。随后，恶意代码开始运行操作系统加密保存在硬盘其他区域中的原始引导代码。这类Bootkit甚至能在任何版本
Windows的引导阶段直接修改内存中的操作系统代码。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">正如大量安全研究人员所证
明的那样，UEFI规范的第一个版本依然容易受到这个问题的影响，因为固件、引导加载器以及其他组件并不进行验证，因此能够从物理上接触到计算机的攻击者
可篡改这些组件，用恶意引导加载器替换原本的引导加载器。实际上，任何EFI应用程序（符合可移植/可执行格式或简洁可执行文件格式的可执行文件）只要在
相对引导变量中正确注册，都可用于引导系统。此外，即便DXE驱动程序也并未进行正确验证，使得在SPI闪存中注入恶意EFI驱动程序具备了可行性。
Windows无法正确识别被篡改的引导过程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这个问题推动着UEFI联
盟设计开发了安全启动技术。安全启动（Secure 
Boot）是UEFI的一项功能，可以确保引导过程中所加载的每个组件都包含数字签名并通过验证。安全启动使得PC只能使用被PC制造商或用户信任的软件
引导。在安全启动中，固件负责验证所有组件（DXE驱动程序、UEFI引导管理器、加载器等），验证通过才会加载。如果某个组件未能通过验证，则会向用户
显示错误信息，引导过程会被中止。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">验证过程会使用公钥算法（如RSA）进行数字签名，并与UEFI固件中可接受或要拒绝的证书（或哈希）数据库进行对比。这些算法采用了两种类型的密钥。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）公钥，用于解密加密后的摘要信息（是指可执行文件二进制数据的哈希值）。该密钥存储在文件的数字签名中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）私钥，用于加密二进制可执行文件的哈希值，会存储在一个安全保密的位置。可执行文件的数字签名包含三个阶段。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·使用强哈希算法（如SHA256）计算文件内容的摘要。强“哈希”可以产生一个唯一（并且相对较小）的消息摘要，可用于完整代表原始数据（有点像一种复杂的校验值）。哈希算法是一种单向加密，也就是说，无法从摘要逆推出源文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·使用密钥中的私钥加密计算出来的摘要。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·将加密后的摘要、密钥中的公钥以及哈希算法的名称存储在文件的数字签名中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这样，当系统需要验证并确认文件的完整性时，只需要重新计算文件哈希并将其与（从数字签名中解密出的）摘要进行对比即可。除了私钥的拥有者，其他人都无法修改或改变数字签名中存储的加密摘要。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这种简化的模型还可以进一
步扩展，创建一种证书链，其中的每一环都可被固件所信任。实际上，如果某个特定证书中的公钥对固件来说是未知的，但该证书由受信任的实体（中间证书或根证
书）在另一时间签署，那么固件认为这种内部公钥依然是可以被信任的。这种机制名为信任链，如图12-3所示。该机制依赖这样一种事实：用于代码签名的数字
证书可以使用另一个受信任的高级证书（中间证书或根证书）的公钥进行签名。此处对该模型的介绍进行了简化，因为完整详细的介绍已经超出了本书范围。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ba6e7329294f1659a5802579d8057354.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图12-3 简化后的信任链</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">允许/撤销UEFI证书以及哈希值必须通过图12-4所示的实体建立一种信任层级。这些实体存储在UEFI变量中。</span></p><div style="display: block;text-align:center;">
	<img width="545" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ea6c3b206f6a72e672d077022128743c.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图12-4 UEFI安全启动所用的信任链证书</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>平</b><b>台</b><b>密</b><b>钥</b><b>（</b><b>P</b><b>l</b><b>a</b><b>t</b><b>f</b><b>o</b><b>r</b><b>m</b><b> </b><b>K</b><b>e</b><b>y</b><b>，</b><b>P</b><b>K</b><b>）</b><b>：</b></span>平台密钥代表信任的根基，用于保护密钥交换密钥数据库。平台供应商会在生产过程中将PK的公共部分放入UEFI固件，而私密部分依然由供应商保管。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>密</b><b>钥</b><b>交</b><b>换</b><b>密</b><b>钥</b><b>（</b><b>K</b><b>e</b><b>y</b><b> </b><b>E</b><b>x</b><b>c</b><b>h</b><b>a</b><b>n</b><b>g</b><b>e</b><b> </b><b>K</b><b>e</b><b>y</b><b>，</b><b>K</b><b>E</b><b>K</b><b>）</b><b>：</b></span>密钥交换密钥数据库包含的受信任证书可用于修改允许的签名数据库（DB）、不允许的签名数据库（DBX）以及时间戳签名数据库（DBT）。KEK数据库通常包含操作系统供应商证书（OSV），由PK保护其安全性。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">用于验证引导加载器和其他
预引导组件的哈希值和签名保存在三个数据库中。允许的签名数据库（DB）包含特定的二进制文件或证书（或其哈希值）的哈希值，它们可用于生成代码签名证
书，而这种证书可用于对引导加载器和其他预引导组件进行签名（需要遵守信任链模型）。不允许的签名数据库（DBX）包含已被破坏或被撤销的特定二进制文件
或证书（或其哈希值）的哈希值。时间戳签名数据库（DBT）包含在对引导加载器映像进行签名时所需的时间戳证书。所有这些数据库都会被KEK锁定而无法编
辑。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为妥善保护安全启动密钥，
不应允许固件更新密钥，除非试图更新密钥的实体能够（使用带有数字签名的特定载荷，也叫“验证描述符”）证明自己拥有创建变量所用密钥的私密部分。
UEFI通过已验证变量（Authenticated 
Variable）实现了这种机制。截至撰写这部分内容，UEFI规范只允许两类签名密钥：X509和RSA2048。一个认证变量可通过写入一个空的更
新来清除，但其中依然需要包含一个有效的验证描述符。在首次创建已验证变量时，其中同时存储了创建变量的密钥中对应的公共部分，以及时间初始值（或一个单
调计数器），并且随后只接受使用该密钥签名，且具备相同类型的更新。例如，使用某个PK创建的KEK变量，只能使用通过该PK签名的验证描述符更新。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
UEFI固件在安全启动环境中使用已验证变量的方式可能导致一些混乱。实际上，PK、KEK和签名数据库会使用已验证变量来存储。存储启动配置数据的其他
UEFI引导变量依然是常规的运行时变量。这意味着在安全启动环境中，用户依然可以毫无障碍地更新或更改引导配置（甚至更改引导顺序）。不过这并不算是问
题，因为每一种引导应用程序（无论来源或顺序如何）都需要进行安全验证。安全启动在设计上并不是为了禁止修改系统引导配置而产生的。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_341" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>4</b><b> </b><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>启</b><b>动</b><b>管</b><b>理</b><b>器</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，UEFI固件
需要读取并执行Windows启动管理器（Bootmgfw.efi）。EFI固件会将控制权转交给启用了分页并以长模式运行的启动管理器，而UEFI内
存映射所定义的内存空间也会进行一一映射。因此与BIOS系统不同，此时并不需要切换执行上下文。当从彻底关机或休眠（S4电源状态）下启动或恢复
Windows操作系统时，Windows启动管理器实际上是第一个被调用的应用程序。自Windows 
Vista开始，Windows启动管理器就进行了全面的重新设计，其目的在于：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·为使用各类复杂技术的多种操作系统的启动提供支持。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·将操作系统的特定启动代码区分为启动应用程序（Windows加载器）和恢复应用程序（Winresume）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·隔离并向启动应用程序提供通用启动服务，这也是启动库的作用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">尽管Windows启动管理器的最终目标很明显，但它的整个架构依然很复杂。从这里开始，我们将用“启动应用程序”这个词组代表各种操作系统加载器，例如Windows加载器以及其他加载器。启动管理器有很多用途，例如：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·初始化启动记录器和启动应用程序所需的基本系统服务（详见下文）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·初始化安全功能（如安全启动和测量启动），加载它们的系统策略，验证它们的完整性。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·定位、打开并读取引导配置数据存储器。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·创建“引导列表”并展示基本引导菜单（如果引导菜单策略被设置为“Legacy”）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·管理TPM并解锁被BitLocker加密的驱动器（如果获取解密密钥失败，则会显示BitLocker解锁界面并提供恢复方法）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·运行指定的启动应用程序，管理启动失败后的恢复程序（Windows恢复环境）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">首先需要执行的操作之一是
配置启动日志设施并初始化启动库。启动应用程序包含一套标准库，这个库会在启动管理器运行时进行初始化。一旦标准启动库初始化完成，随后它们的核心服务就
可以被所有启动应用程序所使用。这些服务包括一个基础的内存管理器（支持地址转换、分页和堆分配）、固件参数（例如引导设备和BCD中的启动管理器项）、
一个事件通知系统（用于测量启动）、时间、启动记录器、加密模块、受信任平台模块（Trusted Platform 
Module，TPM）、网络、显示驱动程序以及I/O系统（还有一个基础的PE加载器）。我们可以把启动库设想成一种适用于启动管理器和启动应用程序的
特殊基本硬件抽象层（HAL）。在该库初始化的早期阶段，还将初始化“系统完整性”启动库组件。系统完整性服务的目标是为安全相关系统事件（如加载了新代
码、连接了调试器等）的报告和记录提供所需平台。这是利用TPM提供的功能实现的，主要用于测量启动功能中。我们将在下文“测量启动”一节详细介绍该功
能。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了正确执行，启动管理器
初始化函数（BmMain）需要一种名为ApplicationParameters（应用程序参数）的数据结构，顾名思义，该数据结构描述了自己的启动
参数（如引导设备、BCD对象的GUID等）。为了编译这个数据结构，启动管理器会使用EFI固件服务，这样做的目的在于获得其自身可执行文件的完整相对
路径，并获得存储在活跃EFI启动变量（BOOT000X）中的启动加载选项。EFI规范中规定，EFI启动变量必须包含有关启动项的简短描述、启动管理
器的完整设备和文件路径，以及其他一些可选数据。Windows使用这种可选数据来存储和描述自己BCD对象的GUID。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span> 可选数据可以包含任何其他由启动管理器在后续阶段解析的启动选项。这就可以从UEFI变量配置启动管理器，而完全无须使用Windows注册表。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>操</b><b>作</b><b>U</b><b>E</b><b>F</b><b>I</b><b>启</b><b>动</b><b>变</b><b>量</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以使用本书随附资源提供的UefiTool工具转储系统中的所有UEFI启动变量。为此请以管理员身份启动该工具并指定/enum参数（在搜索框中搜索cmd，右键点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>命</b><b>令</b><b>提</b><b>示</b><b>符</b></span>”，选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>以</b><b>管</b><b>理</b><b>员</b><b>身</b><b>份</b><b>运</b><b>行</b></span>”）。常规系统会使用大量UEFI变量。该工具支持按照名称和GUID过滤变量，甚至可使用/out参数将所有变量名和数据导出为文本文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">首先将所有UEFI变量导出为文本文件：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\Tools&gt;UefiTool.exe /enum /out Uefi_Variables.txt </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">UEFI Dump Tool v0.1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright 2018 by Andrea Allievi (AaLl86) </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Firmware type: UEFI </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Bitlocker enabled for System Volume: NO </span></p>
</div><div class="header0"><h1><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h1></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Successfully written “Uefi_Variables.txt” file. </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后可使用下列过滤器得到UEFI启动变量列表：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\Tools&gt;UefiTool.exe /enum Boot </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">UEFI Dump Tool v0.1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright 2018 by Andrea Allievi (AaLl86) </span></p>
</div><div class="header0"><h1><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h1></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Firmware type: UEFI </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Bitlocker enabled for System Volume: NO </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">EFI Variable "BootCurrent" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Guid : {8BE4DF61-93CA-11D2-AA0D-00E098032B8C} </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Attributes: 0x06 ( BS RT ) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Data size : 2 bytes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Data: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   00 00                                           | </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">EFI Variable "Boot0002" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Guid      : {8BE4DF61-93CA-11D2-AA0D-00E098032B8C} </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Attributes: 0x07 ( NV BS RT ) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Data size : 78 bytes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Data: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   01 00 00 00 2C 00 55 00 53 00 42 00 20 00 53 00 |    , U S B S </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   74 00 6F 00 72 00 61 00 67 00 65 00 00 00 04 07 | t o r a g e </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   14 00 67 D5 81 A8 B0 6C EE 4E 84 35 2E 72 D3 3E | g ü¿ l Nä5.r &gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   45 B5 04 06 14 00 71 00 67 50 8F 47 E7 4B AD 13 | E q gPÅG K¡ </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   87 54 F3 79 C6 2F 7F FF 04 00 55 53 42 00       | çT≤y /USB </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">EFI Variable "Boot0000" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Guid      : {8BE4DF61-93CA-11D2-AA0D-00E098032B8C} </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Attributes: 0x07 ( NV BS RT ) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Data size : 300 bytes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Data: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   01 00 00 00 74 00 57 00 69 00 6E 00 64 00 6F 00 |    t W I n d o </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   77 00 73 00 20 00 42 00 6F 00 6F 00 74 00 20 00 | w s B o o t </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   4D 00 61 00 6E 00 61 00 67 00 65 00 72 00 00 00 | M a n a g e r </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   04 01 2A 00 02 00 00 00 00 A0 0F 00 00 00 00 00 | * á </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   00 98 0F 00 00 00 00 00 84 C4 AF 4D 52 3B 80 44 |   ÿ    ä »MR;ÇD </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   98 DF 2C A4 93 AB 30 B0 02 02 04 04 46 00 5C 00 | ÿ ,ñô½0 F \</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   45 00 46 00 49 00 5C 00 4D 00 69 00 63 00 72 00 | E F I \M i c r </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   6F 00 73 00 6F 00 66 00 74 00 5C 00 42 00 6F 00 | o s o f t \B o </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   6F 00 74 00 5C 00 62 00 6F 00 6F 00 74 00 6D 00 | o t \b o o t m </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   67 00 66 00 77 00 2E 00 65 00 66 00 69 00 00 00 | g f w . e f i </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   7F FF 04 00 57 49 4E 44 4F 57 53 00 01 00 00 00 |     WINDOWS </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   88 00 00 00 78 00 00 00 42 00 43 00 44 00 4F 00 | ê x B C D O </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   42 00 4A 00 45 00 43 00 54 00 3D 00 7B 00 39 00 | B J E C T = { 9 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   64 00 65 00 61 00 38 00 36 00 32 00 63 00 2D 00 | d e a 8 6 2 c -</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   35 00 63 00 64 00 64 00 2D 00 34 00 65 00 37 00 | 5 c d d - 4 e 7 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   30 00 2D 00 61 00 63 00 63 00 31 00 2D 00 66 00 | 0 - a c c 1 - f </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   33 00 32 00 62 00 33 00 34 00 34 00 64 00 34 00 | 3 2 b 3 4 4 d 4 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   37 00 39 00 35 00 7D 00 00 00 6F 00 01 00 00 00 | 7 9 5 } o </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   10 00 00 00 04 00 00 00 7F FF 04 00             |  </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">EFI Variable "BootOrder" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Guid      : {8BE4DF61-93CA-11D2-AA0D-00E098032B8C} </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Attributes: 0x07 ( NV BS RT ) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Data size : 8 bytes </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Data: </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   02 00 00 00 01 00 03 00                         | </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">&lt;Full output cut for space reasons&gt; </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">该工具甚至可以解释每个启动变量的内容。你可以使用/enumboot参数来运行：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\Tools&gt;UefiTool.exe /enumboot </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">UEFI Dump Tool v0.1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright 2018 by Andrea Allievi (AaLl86) </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Firmware type: UEFI </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Bitlocker enabled for System Volume: NO </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">System Boot Configuration </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Number of the Boot entries: 4 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Current active entry: 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Order: 2, 0, 1, 3 </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Boot Entry #2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Type: Active </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Description: USB Storage </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Boot Entry #0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Type: Active </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Description: Windows Boot Manager </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Path: Harddisk0\Partition2 [LBA: 0xFA000]\\EFI\Microsoft\Boot\bootmgfw.efi </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   OS Boot Options: BCDOBJECT={9dea862c-5cdd-4e70-acc1-f32b344d4795} </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Boot Entry #1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Type: Active </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Description: Internal Storage </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Boot Entry #3 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Type: Active </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   Description: PXE Network </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">当
该工具可以解析启动路径时，即可输出相对路径行（同样适用于Winload操作系统加载选项）。UEFI规范为启动项的路径字段定义了不同的解释，这主要
取决于硬件接口。如果要更改系统启动顺序，则只需设置BootOrder变量的值，或者使用/setbootorder命令行参数即可做到。不过需要注
意，这可能会让BitLocker卷主密钥失效（详见下文“测量启动”一节）：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">C:\Tools&gt;UefiTool.exe /setvar bootorder {8BE4DF61-93CA-11D2-AA0D-00E098032B8C} </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">0300020000000100 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">UEFI Dump Tool v0.1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Copyright 2018 by Andrea Allievi (AaLl86) </span></p>
</div><div class="header2"><h3><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h3></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Firmware type: UEFI </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">BitLocker enabled for System Volume: YES </span></p>
</div><div class="header1"><h2><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'PingFang SC';"> </span></h2></div>
<div class="part">
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Warning, The "bootorder" firmware variable already exist. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Overwriting it could potentially invalidate the system BitLocker Volume Master Key. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Make sure that you have made a copy of the System volume Recovery Key. </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">Are you really sure that you would like to continue and overwrite its content? [Y/N] y</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">The "bootorder" firmware variable has been successfully written. </span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在构建了
ApplicationParameters数据结构并获得了所有启动路径（\EFI\Microsoft\Boot是主工作目录）后，启动管理器会打开
并解析引导配置数据（Boot Configuration 
Data）文件。从系统内部来看，该文件是一个注册表配置单元，其中包含了所有的启动应用程序描述符，通常会在系统启动完毕后映射至
HKLM\BCD00000000虚拟键。启动管理器使用启动库打开并读取BCD文件。该库可以使用EFI服务读/写硬盘上的物理扇区。截至撰写这部分内
容，该库实现了多种文件系统的轻量级版本，包括NTFS、FAT、ExFAT、UDFS、El Torito，以及为Network Boot 
I/O、VMBus 
I/O（适用于Hyper-V虚拟机）和WIM映像I/O提供支持的虚拟文件系统。引导配置数据配置单元解析完成后，即可通过GUID定位描述启动管理器
的BCD对象，代表启动参数的所有项都会被添加到ApplicationParameters数据结构的Startup节。BCD中的项可以包含启动管理
器、Winload以及启动过程所涉及的其他组件解释的可选参数。表12-2列出了这些选项以及它们对启动管理器的影响，表12-3列出了所有启动应用程
序可用的BCD选项列表，表12-4列出了适用于Windows启动加载器的BCD选项，表12-5列出了控制Windows虚拟机监控程序执行的BCD
选项。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">表12-2 Windows启动管理器（Bootmgr）的BCD选项</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/627391f28774ec5ef8ffd1f1fa2d0e63.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/3ca5a69b0423bd89b18145b1af9dd43d.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">其中，Windows启动管理器的所有BCD元素代码均以BCDE_BOOTMGR_TYPE开头，为了节省版面，已在表12-2中删除。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">表12-3 适用于启动应用程序的BCD库选项（对所有对象类型均有效）</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/0d14aa7960f1a6f6f62d145e72f69a9a.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4de6cae42045159b6faa4bff0b349c70.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/df41f35306cc29ff87361957da0d275a.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/6ff620328d2ee606ac1bd09711067890.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/f997dee1e6fda8b5a986ed9fe2c0a685.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e5c561f2d6ca34b8a2084bb08e0cb89c.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">其中，启动应用程序的所有BCD元素代码均以BCDE_LIBRARY_TYPE开头，为了节省版面，已在表12-3中删除。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">表12-4 Windows操作系统加载器（Winload）的BCD选项</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/4945a0f6452e07ea9f066a29e39c6203.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/8f76f34736fe6edf721af595f1c92781.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/2ec275f81e687b1210af6a1f7cffd7ec.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/68082c000eaa4f8113a3cbdbbe862243.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/edad2e8ed0d7ca30d6814a2acaf92b72.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/877cf86d88ae830ead00ccecb369390a.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/8ad5eb6444d565864fd24586ea86d3ab.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/33a6a88d4ce057445c29fe6ae323e535.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/05358c91d219068aff00d7527e155c29.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ba462b0388fc865bf436768255c2ad6f.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">其中，Windows操作系统加载器的所有BCD元素代码均以BCDE_OSLOADER_TYPE开头，为了节省版面，已在表12-4中删除。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">表12-5 Windows虚拟机监控程序加载器（hvloader）的BCD选项</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ee257b12f33241795d5a8f1723ef7a88.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/bac00fb5284a87945bb2f422859d2920.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/c781811adaa1f255f3917c3d10ce7790.jpg" alt="" title=""></div><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/38c60e07717a078c9b7e7ce4e3c71957.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">其中，Windows虚拟机监控程序加载器的所有BCD元素代码均以BCDE_OSLOADER_TYPE开头，为了节省版面，已在表12-5中删除。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">BCD存储中的每一项都在
启动过程中起着关键作用。在每个启动项（每个启动项都是BCD中的一个对象）中，都会列出所有启动选项，它们以注册表子键的形式存储在配置单元中（见图
12-5）。这些选项被称为BCD元素。Windows启动管理器可以添加或删除任何启动选项，无论它们位于物理配置单元，还是只位于内存中。这一点很重
要，因为下一节“启动菜单”将会提到，并非所有BCD选项都需要存在于物理配置单元中。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/33e07080365a50680f22e9db1e22ed6c.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图12-5 Windows启动管理器的BCD对象及其相关启动选项范例</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果启动配置数据的配置单
元损坏，或解析启动项时遇到错误，启动管理器会通过恢复BCD配置单元重试相关操作。恢复BCD配置单元通常存储在
\EFI\Microsoft\Recovery\BCD中。系统也可配置为跳过常规配置单元，直接使用该存储，为此要使用recoverybcd参数
（存储于UEFI启动变量）或使用Bootstat.log文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统已经准备好加载安全启
动策略，显示启动菜单（如果需要）并运行启动应用程序。固件信任或不信任的启动证书列表均位于db和dbx这两个UEFI已验证变量中。代码完整性启动库
会负责读取并解析UEFI变量，但这些变量只能控制是否可以加载特定的启动管理器模块。一旦Windows启动管理器成功运行，就可使用微软提供的证书列
表进一步自定义或扩展UEFI提供的安全启动配置。安全启动策略文件（位于
\EFI\Microsoft\Boot\SecureBootPolicy.p7b中）、平台清单策略文件（.pm文件）以及补充策略（.pol文件）
都会被解析并与存储在UEFI变量中的策略合并。由于内核代码完整性引擎最终将接管，因此这些附加的策略可以包含与操作系统有关的信息和证书。通过这种方
式，一些Windows的安全版本（例如S版本）就可以在无须消耗宝贵的UEFI资源的前提下验证多个证书。借此也可以创建出信任根，因为指定新的自定义
证书列表的文件已经使用UEFI允许的签名数据库中包含的数字证书签名了。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果未被启动选项（nointegritycheck或testsigning）或安全启动策略禁用，则启动管理器会对自己的完整性进行自我验证：从硬盘上打开自己的文件，并验证其数字签名。如果安全启动已启用，则会根据安全启动签名策略来验证签名链。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">启动管理器会初始化启动调
试器，并检查是否需要展示OEM位图（通过BGRT的系统ACPI表）。如果需要，则会清空屏幕并展示徽标。如果Windows启用了BCD设置来通知启
动管理器恢复休眠（或混合启动），此时的启动过程将大幅简化，将直接运行Windows恢复应用程序（Winresume.efi），并由该应用程序将休
眠文件的内容读入内存，同时将控制权转交给内核中的代码，借此从休眠状态恢复。这些代码负责重新启动系统在上次关闭时处于活跃状态的驱动程序。
Hiberfil.sys文件只在计算机上次关闭到休眠状态或启用混合启动功能的情况下才有效。这是因为，为了避免反复从同一个状态下恢复，休眠文件会在
恢复完成后失效。Windows恢复应用程序BCD对象会通过一个专门的BCD元素（名为resumeobject，详见下文的“休眠和快速启动”一节）
与启动管理器描述符链接。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">启动管理器会通过相关的
BCD元素检测是否注册了自定义的OEM启动操作，如果已注册，则会处理这些操作。截至撰写这部分内容，唯一可支持的自定义操作是运行OEM启动序列。这
样，OEM厂商就可以注册自定义的恢复序列，并当用户在启动过程中按下特定按键后执行自己的恢复序列。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_342" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>5</b><b> </b><b>启</b><b>动</b><b>菜</b><b>单</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows 
8及后续版本引入了一项名为现代启动（modern 
boot）的新技术，使得标准启动配置下的经典（传统）启动菜单永远无法显示。现代启动为Windows提供了丰富的图形化启动体验，同时保持了深入探索
与启动相关设置的功能。在这种配置下，即使在不带键盘和鼠标的计算机上，用户也可以通过触控操作选择自己要运行的操作系统。新的启动菜单是在Win32子
系统的基础上绘制而来的，下文的“Smss、Csrss和Wininit”一节将详细介绍具体架构。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Bootmenupolicy
启动选项控制了启动加载器是使用旧的技术还是新的技术来显示启动菜单。如果计算机中不存在OEM启动序列，则启动管理器会枚举链接到启动管理器
displayorder启动选项的所有系统启动项GUID（如果该值为空，启动管理器将使用默认启动项）。对于找到的每个GUID，启动管理器会打开相
对的BCD对象并查询启动应用程序类型、启动设备以及可读描述。所有这些属性缺一不可，否则启动项会被视为无效并被跳过。如果启动管理器没有找到有效的启
动应用程序，则会向用户展示错误信息，整个启动过程将被终止。启动菜单的显示算法从这里开始生效。此处会使用一个重要函数
BmpProcessBootEntry来确定是否要显示遗留启动菜单。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
如果默认启动应用程序（而非Bootmgr的启动项）的启动菜单策略明确设置为Modern类型，则该算法会立即退出并通过
BmpLaunchBootEntry函数运行默认启动项。值得注意的是，这种情况下将不检查用户是否按下了键盘按键，因此无法强制停止启动过程。如果系
统包含多个启动项，则默认启动应用程序在内存中维持的启动选项列表中会被加入一个特殊的BCD选项
	<sup><img width="10" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="这个多重启动“特殊选项”没有名字。其元素代码为BCDE_LIBRARY_TYPE_MULTI_BOOT_SYSTEM（对应于十六进制的0x16000071）。" title="这个多重启动“特殊选项”没有名字。其元素代码为BCDE_LIBRARY_TYPE_MULTI_BOOT_SYSTEM（对应于十六进制的0x16000071）。" class="epub-footnote"></sup>。这样在系统启动的后续阶段，Winlogon就可以识别该选项并显示现代菜单。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
如果默认启动应用程序的启动策略为传统类型（或完全未设置），并且只存在一个启动项，则BmpProcessBootEntry会检查用户是否按下了F8
键或F10键。这两个键在bootmgr.xsl资源文件中被描述为“高级选项”和“启动选项”键。如果启动管理器检测到启动时按下了其中一个键，则会将
相关BCD元素添加到默认启动应用程序在内存中维持的启动选项列表中（这个BCD元素不会写入硬盘）。随后将由Windows加载器处理这两个启动选项。
最后，BmpProcessBootEntry会检查系统是否被强制在即使只存在一个启动项，依然显示启动菜单（通
过“displaybootmenu”选项进行检查）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果找到多个启动项，则会检查超时值（存储为一个BCD选项），如果超时值设置为0，将会立即运行默认应用程序，否则会使用BmDisplayBootMenu函数来显示传统启动菜单。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在显示传统启动菜单的同时，启动管理器会枚举toolsdisplayorder启动选项列出的已安装的启动工具。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_343" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>6</b><b> </b><b>运</b><b>行</b><b>启</b><b>动</b><b>应</b><b>用</b><b>程</b><b>序</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows启动管理器
的最后一个目标是正确地运行启动应用程序（即使该应用程序位于BitLocker加密的驱动器中），并在出现问题后管理恢复序列。
BmpLaunchBootEntry会收到一个GUID以及需要运行的应用程序所对应的启动选项列表。该函数执行的第一个操作是（通过BCD元素）检查
指定的启动项是否为Windows 
Recovery（WinRE）项。此类启动应用程序主要用于处理恢复序列。如果是WinRE类型的项，则系统需要决定WinRE试图恢复的启动应用程
序。在这种情况下，还需要首先识别并解锁（如果被加密）待恢复启动应用程序所在的启动设备。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">BmTransferExecution
例程会使用启动库提供的服务打开启动应用程序所在的设备，并识别该设备是否被加密。如果已被加密，则会首先解密，随后读取目标操作系统的加载器文件。如果
目标设备被加密，则Windows启动管理器会首先试图从TPM获取主密钥。在这种情况下，TPM只有在满足某些条件（详见下一段）时才会解封主密钥。这
样一来，如果某些启动配置被更改（例如启用了安全启动），则TPM将无法释放密钥。如果从TPM获取密钥的操作失败，Windows启动管理器会显示一个
类似图12-6所示的界面，要求用户输入解锁密钥（即使启动菜单策略被设置为Modern，也会显示该界面，因为这种状态下系统还无法运行现代启动用户界
面）。截至撰写这部分内容，启动管理器支持四种不同的解锁方法：PIN码、密码、外部介质和恢复密钥。如果用户无法提供密钥，则启动过程将被中断，随后将
运行Windows恢复序列。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">固件可用于读取并验证目标
操作系统加载程序。验证过程是通过代码完整性库进行的，该库可以针对文件的数字签名应用安全启动策略（系统策略和所有定制策略）。在将执行实际传递给目标
启动应用程序之前，Windows启动管理器需要通知已注册组件（尤其是ETW和测量启动），告诉它们启动应用程序已在运行。此外，启动管理器还需要确保
TPM无法用于解封其他东西。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">代码的执行会通过BlImgStartBootApplication转交给Windows加载器。该例程只在出现某些错误的情况下返回。与之前一样，启动管理器会在出现错误后运行Windows恢复序列。</span></p><div style="display: block;text-align:center;">
	<img width="844" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/55cb605b5b1875c3d9aa4c1af986a744.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图12-6 因为启动配置中的某些设置被更改而显示的BitLocker恢复过程</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_344" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>7</b><b> </b><b>测</b><b>量</b><b>启</b><b>动</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">2006年年底，
Intel推出了可信执行技术（Trusted Execution 
Technology，TXT），该技术能确保真实的操作系统在可信赖的环境中启动，而不被外部代理（如恶意软件）修改或篡改。TXT使用TPM和加密技
术来测量软件与平台（UEFI）组件。Windows 8.1及后续版本支持一个名为测量启动（measured 
boot）的新功能，该功能可测量从固件到启动系统的驱动器在内的每个组件，将测量结果存储在计算机的TPM中，随后提供一个可以远程测试的日志，以供验
证客户端的启动状态。如果没有TPM，这项技术也将不复存在。“测量”这个词是指计算一个特定实体（如代码、数据结构、配置或其他任何可载入内存的东西）
的加密哈希值的过程。测量结果可用于多种目的。测量启动可以在Windows运行之前为反恶意软件解决方案提供所有启动组件的可信赖（可防欺骗和篡改）日
志。这样，反恶意软件解决方案可以通过这些日志来判断在自己启动之前就已运行的组件到底是可信赖的还是被恶意软件感染的。本地计算机上运行的软件可将日志
发送到远程服务器进行评估。通过与TPM以及非微软软件相配合，测量启动可以让网络上可信赖的服务器验证Windows启动过程的完整性。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">TPM的主要规则如下。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·为需要保护的机密信息提供一种安全的非易失性存储设备。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·为平台配置寄存器（Platform Configuration Register，PCR）提供存储测量结果的位置。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·提供硬件加密引擎和真随机数生成器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">TPM将测量启动的测量结
果存储在PCR中。每个PCR提供一个存储区域，可以在固定容量的空间内存储不限数量的测量结果。该功能是由加密哈希的一个属性提供的。Windows启
动管理器（或后续参与工作的Windows加载器）永远不会直接写入PCR寄存器，而是会“扩展”PCR的内容。这种“扩展”操作会获取PCR的当前值，
将新的测量值附加其中，并对合并后的值计算加密哈希（通常使用SHA-1或SHA-256）。哈希操作的结果就是新的PCR值。这种“扩展”方法保证了测
量结果的顺序依赖性。加密哈希的属性之一就在于，它对顺序有依赖性。这意味着对A和B两个值创建的哈希，将会不同于对B和A两个值创建的哈希。由于PCR
会被扩展（而非写入），因此，即使恶意软件能够扩展PCR，也只能导致PCR中包含了无效的测量结果。这种加密哈希的另一个属性在于，无法根据特定哈希值
逆向创建出能产生该值的数据。因此，除非用严格一致的顺序测量相同的对象，否则无法将PCR扩展为特定结果。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在启动过程的早期阶段，启
动库的系统完整性模块会注册不同的回调函数。每个回调函数都会在后续启动序列的不同节点调用，这样做的目的在于管理已测量的启动事件，例如启用测试签名、
启动调试器、PE映像加载、启动应用程序运行、哈希、运行、退出，以及BitLocker解锁。每个回调将决定要对哪些类型的数据创建哈希，进而将其扩展
至TPM的PCR中。例如，当启动管理器或Windows加载器启动一个外部的可执行映像时，都会生成三个测量启动事件，这些事件对应了映像加载过程的不
同阶段：LoadStarting、ApplicationHashed以及ApplicationLaunched。在这种情况下，发送给TPM 
PCR（11和12）的被测量实体就分别为映像的哈希、映像数字签名的哈希、映像基值以及映像大小。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在系统启动完成后，所有测
量结果还会用于一种名为认证（attestation）的过程中。由于加密后的哈希值具备唯一性，所以可以使用PCR值及其日志来准确了解正在执行的软件
版本以及软件的执行环境。在这个阶段，Windows会使用TPM来提供TPM引述（quote），借此TPM可对PCR值添加签名，以保证这些值在传输
过程中不会被恶意或无意地修改。这样可以保证测量结果的真实性。引述的测量结果会被发送到一个认证机构，这是一个可信任的第三方实体，能够验证PCR值，
并将其与一个已知良好值数据库进行比较，进而解读这些值。这种证明模型所涉及的全部模块的介绍已经超出了本书范围。这种做法的最终目标是：远程服务器可以
确认客户端为可信任的实体，还是已经被某些恶意组件所篡改。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">上文曾经提到，启动管理器
能够自动解锁被BitLocker加密的启动卷。在这个过程中，系统还利用了TPM提供的另一项重要服务：安全的非易失性存储。TPM的非易失性随机访问
内存（NVRAM）在断电后依然可以维持数据，具备比系统内存更多的安全功能。在分配TPM NVRAM时，系统会指定下列内容。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>读</b><b>取</b><b>访</b><b>问</b><b>权</b><b>：</b></span>指定TPM的哪个特权级别（也叫“位置”）可以读取数据。更重要的是，指定能够读取数据的任何PCR是否必须包含特定的值。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>写</b><b>入</b><b>访</b><b>问</b><b>权</b><b>：</b></span>与上述情况类似，不过适用于写入访问。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>特</b><b>性</b><b>/</b><b>权</b><b>限</b><b>：</b></span>为读取或写入提供可选的授权值（例如密码）以及临时性或永久性的锁（即内存可以被锁定以进行写入访问）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">用户首次加密启动卷时，
BitLocker会用另一个随机对称密钥加密其卷主密钥（Volume Master Key，VMK），随后以扩展的TPM PCR值（尤其是PCR
 
7和11，它们用于测量BIOS和Windows启动序列）为条件“密封”该密钥。密封是指让TPM对一个数据块进行加密，这样，只有在指定的PCR具备
正确值的情况下，才能让由进行加密操作的同一个TPM来解密。在后续启动过程中，如果被篡改的启动序列或不同的BIOS配置请求“解封”，那么TPM将拒
绝该请求，因而不进行解封，也不会提供VMK加密密钥。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>使</b><b>T</b><b>P</b><b>M</b><b>测</b><b>量</b><b>结</b><b>果</b><b>失</b><b>效</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
这个实验中，我们将通过一种快速的方法让BIOS配置失效，进而导致TPM的测量结果失效。在测量启动序列、驱动程序和数据之前，测量启动功能会首先对
BIOS配置（存储在PCR1中）进行静态测量。测量得到的BIOS配置数据严格取决于硬件制造商，有时甚至包含UEFI启动顺序列表。在开始实验前，请
确认自己的系统包含有效的TPM。为此可在“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>开</b><b>始</b></span>”菜单的搜索框中输入tpm.msc并运行，随后可以打开受信任平台模块（TPM）管理控制台。请检查状态栏是否显示“TPM已就绪可供使用”的字样，以验证TPM是否存在并已启用。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e224a37e8828f4f7902260a9adcfa605.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随
后需要对系统卷进行BitLocker加密。如果系统卷已加密，则可跳过这一步，但请务必确保自己已经保存了恢复密钥（要查看恢复密钥，可在控制面板的
BitLocker驱动器加密工具中选择“备份恢复密钥”）。点击任务栏图标打开文件资源管理器，随后打开“此电脑”，右键点击系统卷（其中包含所有的
Windows文件，通常为C:盘）并选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>启</b><b>用</b><b>B</b><b>i</b><b>t</b><b>L</b><b>o</b><b>c</b><b>k</b><b>e</b><b>r</b></span>”。初始验证完成后，在看到“选择启动时解锁你的驱动器的方式”页面后，选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>让</b><b>B</b><b>i</b><b>t</b><b>L</b><b>o</b><b>c</b><b>k</b><b>e</b><b>r</b><b>自</b><b>动</b><b>解</b><b>锁</b><b>我</b><b>的</b><b>驱</b><b>动</b><b>器</b></span>”。这样，TPM就会使用启动测量值作为“解封”密钥将VMK封存。别忘了保存或打印恢复密钥，后续操作会用到它。如果缺少该密钥，则将无法访问自己的文件。其他所有选项请都使用默认值。</span></p><div style="display: block;text-align:center;">
	<img width="713" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/074814ac584faef81ac12da366a52c1c.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">加
密完成后，关闭计算机并重新开机，但这次请进入UEFI 
BIOS配置界面（不同厂商生产的计算机进入该界面的方法略有差异，详见硬件用户手册）。在BIOS配置页面中，只需更改启动顺序并重启计算机即可（此
外，也可以使用本书随附资源中提供的UefiTool工具更改启动顺序）。如果所用硬件的制造商在TPM测量结果中包含启动顺序信息，那么在
Windows启动之前，你应该看到BitLocker恢复信息。如果这种方式不可用，为了让TPM测量结果失效，那么可以在开机前插入Windows安
装光盘或U盘。如果启动顺序已正确配置，则Windows安装引导代码将自动运行，并按任意键显示CD 
或DVD的启动信息。如果不按下任意按键，则系统将继续处理下一个启动项。此时启动序列已更改，导致TPM测量结果存在差异，因此TPM将无法解封
VMK。</span></p><div style="display: block;text-align:center;">
	<img width="730" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/88001f9eae4f44101bacaefc361326bf.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如果在启用了安全启动功能的情况下禁用该功能，也会让TPM测量结果无效（获得与上述操作相同的结果）。这个实验验证了测量启动功能与BIOS配置是相关联的。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_345" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>8</b><b> </b><b>可</b><b>信</b><b>执</b><b>行</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">尽管测量启动为远程实体提
供了一种确认启动过程完整性的方法，但有一个重要问题依然未能解决：启动管理器依然信任计算机的固件代码，并使用固件服务与TPM进行有效通信进而启动整
个平台。截至撰写这部分内容，已经多次出现针对UEFI核心固件进行的攻击操作。TXT通过改进可支持另一项重要功能，即安全运行
	<sup><img width="11" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="在计算机领域，Boot和Launch通常都可理解为“启动”。但因上文介绍的Secure Boot功能诞生较早，且已被微软正式称为“安全启动”，因此为了避免混淆，对于随后诞生且截至翻译本书时未有官方中文译名的Secure Launch功能，在本书中将其称为“安全运行”。还请读者注意区分。——译者注" title="在计算机领域，Boot和Launch通常都可理解为“启动”。但因上文介绍的Secure Boot功能诞生较早，且已被微软正式称为“安全启动”，因此为了避免混淆，对于随后诞生且截至翻译本书时未有官方中文译名的Secure Launch功能，在本书中将其称为“安全运行”。还请读者注意区分。——译者注" class="epub-footnote"></sup>（Secure
 Launch）。安全运行（在Intel的术语中也叫Trusted Boot，可信启动）提供了安全认证的代码模块（Authenticated 
Code 
Module，ACM），这些模块由CPU制造商进行签名，并由芯片组（而非固件）负责执行。安全运行提供了无须重置平台，即可对可重置PCR进行动态测
量的能力。在这种情况下，操作系统需要提供一种特殊的可信启动（TBOOT）模块，借此初始化平台的安全模式运作并初始化安全运行过程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ACM是由芯片组制造商提
供的一段代码。ACM由制造商签名，其代码在处理器内部的特殊安全内存中以一种最高特权等级运行。ACM可使用一种特殊的GETSEC指令来调用。ACM
有两种类型：BIOS和SINIT。其中BIOS ACM可测量BIOS并执行BIOS的某些安全功能，而SINIT 
ACM可执行操作系统TCB（TBOOT）模块的测量和运行工作。BIOS ACM和SINIT 
ACM通常都包含在系统BIOS映像中（这并非严格要求），但如果需要，它们也可以被操作系统更新和替换（详见下文“安全运行”一节）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">ACM是可信测量的核心
根，因此需要在最高安全级别上运行，并且需要保护它免受各种类型的攻击。处理器的微码可将ACM模块复制到安全内存中，并在执行各种检查后允许其执行。处
理器会验证ACM在设计上是否适用于目标芯片组。此外，还会验证ACM的完整性、版本以及数字签名是否与硬编码到芯片组保险丝（Fuse）中的公钥相匹
配。如果上述任何一项检查失败，则GETSEC指令将拒绝执行ACM。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全运行的另一项关键功能
是对TPM的动态信任根测量（Dynamic Root of Trust 
Measurement，DRTM）提供了支持。如上文“测量启动”一节所述，16个不同的TPM 
PCR寄存器（0到15）提供了启动测量所需的存储。启动管理器可以扩展这些PCR，但除非重置平台（或上电），否则无法清除其内容。这也解释了为何此类
测量称为静态测量。动态测量是对无须重置平台即可重置的PCR进行的测量。安全运行和受信任的操作系统使用了六个动态PCR（动态PCR共有八个，但另外
两个是预留的，操作系统暂未使用）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在典型的TXT启动序列
中，启动处理器会在验证了ACM的完整性后执行ACM启动代码，然后测量关键的BIOS组件，随后退出ACM安全模式并跳转至UEFI 
BIOS启动代码。接下来，BIOS会测量其余的所有代码，配置平台，验证测量结果，执行GETSEC指令。这条TXT指令可以加载BIOS 
ACM模块，由该模块执行安全检查并锁定BIOS配置。在这个阶段，UEFI 
BIOS可以测量每个选项ROM代码（对于每个设备）以及初始程序加载（Initial Program 
Load，IPL）。至此，平台就已经处于可以引导操作系统（具体来说，将使用IPL引导）的状态。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">TXT启动序列是静态信任
根测量（Static Root of Trust 
Measurement，SRTM）的一部分，因为受信任的BIOS代码（以及启动管理器）已经通过验证并处于良好的已知状态，在下次平台重置前将不再发
生变化。通常来说，对于启用TXT的操作系统，会用一个特殊的TCB（TBOOT）模块来作为要加载的第一个内核模块。这个TBOOT模块的作用是初始化
平台，使其为安全模式的运行做好准备，并初始化安全运行功能。Windows的TBOOT模块名叫TcbLaunch.exe。在启动安全运行功能前，这
个TBOOT模块必须被SINIT 
ACM模块进行认证。因此需要有一些组件来执行GETSEC指令并启动DRTM。在Windows的安全运行模型中，这个组件就是启动库。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统在进入安全模式（secure mode）
	<sup><img width="11" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="此处的安全模式和为了对无法正常启动的系统进行排错而进入的安全模式（safe mode）是不同的概念。——译者注" title="此处的安全模式和为了对无法正常启动的系统进行排错而进入的安全模式（safe mode）是不同的概念。——译者注" class="epub-footnote"></sup>前，必须先将平台置于已知状态（在这种状态下，除自举处理器外，所有其他处理器都处于一种特殊的空闲状态，因此其他代码都无法执行）。启动库将执行GETSEC指令，指定SENTER操作。这会导致处理器执行下列工作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）验证SINIT ACM模块并将其载入处理器的安全内存中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）清除所有相关动态的PCR并测量SINIT ACM，以启动DRTM。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）执行SINIT ACM代码，借此测量受信任的操作系统代码并执行启动控制策略（launch control policy）。该策略决定了当前测量结果（位于某些动态PCR寄存器中）是否允许操作系统被视为“受信任”的。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果上述任何一个检查失
败，将会认定计算机被攻击，ACM将发出TXT重置命令，这会导致任何类型的软件都无法执行，直到平台被强制重置。如果检查均通过，ACM会退出ACM模
式并跳转至受信任的操作系统入口点（在Windows中，这个入口点是TcbLaunch.exe模块的TcbMain函数），借此启用安全运行。随后，
受信任的操作系统会得到控制权，这样就可以针对自己需要的每个测量结果扩展并重置动态PCR（或使用另一套机制保证信任链）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">整个安全运行功能架构的介绍已经超出了本书范围。TXT规范详情请参考Intel的手册。有关Windows可信执行实现方式的详细介绍，请参阅下文“安全运行”一节。图12-7展示了Intel TXT涉及的全部组件。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/1246e4731d9085ce5cbe793a257626a5.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图12-7 Intel TXT组件</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_346" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>9</b><b> </b><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>操</b><b>作</b><b>系</b><b>统</b><b>加</b><b>载</b><b>器</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows操作系统加载器（Winload）是启动管理器所运行的启动应用程序，其用途是加载并正确执行Windows内核。该过程包含很多重要任务。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·为内核创建执行环境。这包括初始化并使用内核的页表，以及创建内存映射。EFI操作系统加载器还会设置并初始化内核的栈、共享用户页、GDT、IDT、TSS以及段选择器。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·在磁盘栈初始化之前，将需要执行或访问的所有模块载入内存。其中也包括内核和HAL，因为操作系统加载器一旦交出控制权，就需要由内核与HAL来处理基础服务的早期初始化工作。启动过程中不可缺少的驱动程序和注册表系统配置单元需要载入内存。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·确定是否需要执行Hyper-V和安全内核（VSM），如果需要，则会正确加载并启动它们。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·使用新增的高分辨率启动图形库（BGFX，取代了古老的Bootvid.dll驱动程序）绘制第一个背景动画。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
对于支持Intel TXT的系统，协调安全运行功能的启动序列（有关测量启动、安全运行以及Intel 
TXT功能的详细介绍请参阅上文）。最初这项任务是在虚拟机监控程序加载器中实现的，但从Windows 
10的10月更新（RS5）开始，已被转交给了Winload执行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows加载器在每个Windows版本中经历了多次改进和完善。OslMain是主要的加载器函数（被启动管理器调用），它可以（重新）初始化启动库并调用内部的OslpMain。截至撰写这部分内容，启动库支持以下两种执行上下文。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·固件上下文，意味着分页被禁用。实际上分页并未被禁用，而是由执行物理地址一对一映射的固件提供，并且仅固件服务会被用于内存管理。Windows会在启动管理器中使用这种执行上下文。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·应用程序上下文，意味着分页已启用，且由操作系统提供。Windows加载器使用了这个上下文。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在由操作系统加载器接管执
行过程前，启动管理器会创建并初始化供Windows内核使用的四级x64页表结构，并且只创建自映射和标识映射项。OslMain会在启动前切换至应用
程序上下文。OslPrepareTarget例程会从系统根目录的bootstat.dat文件中读取最后一次启动时的启动/关机状态。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果最后一次启动失败了两
次以上，则会返回到启动管理器并启动恢复环境，否则会直接读取SYSTEM注册表配置单元的
\Windows\System32\Config\System，借此判断为了完成启动需要加载哪些设备驱动程序（配置单元是一种包含注册表子树的文
件，有关注册表的详细介绍请参阅第10章）。随后会初始化BGFX显示库（绘制第一个背景图像）并在需要时显示高级选项菜单（详见上文“启动菜单”一
节）。NT内核启动过程中所需的重要的数据结构之一Loader 
Block，会在此时进行分配并填充基本信息，例如，系统配置单元的基址和大小、一个随机熵值（如果可能，则将从TPM查询而来）等。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">OslInitializeLoaderBlock
包含的代码可以查询系统的ACPI 
BIOS以检索基本设备和配置信息（包括系统CMOS中存储的事件时间和日期信息）。这些信息会被收集到内部数据结构中，并在启动完成后存储在
HKLM\HARDWARE\DESCRIPTION注册表键中。这是一个遗留的注册表键，它的存在只是为了保证兼容性。如今，有关硬件的这些信息会存储
在即插即用管理器的数据库中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后，Winload开始从启动卷加载进行内核初始化所必需的文件。启动卷是被启动的系统的系统目录（通常是\Windows）所在的卷。Winload将执行下列步骤。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）判断是否需要加载虚拟
机监控程序或安全内核（通过BCD的hypervisorlaunchtype选项和VSM策略决定）。如果需要，则会启动虚拟机监控程序设置过程的阶段
0。阶段0会将HV加载器模块（Hvloader.dll）预加载到RAM内存中并执行HvlLoadHypervisor初始化例程。后者将虚拟机监控
程序映像（Hvix64.exe、Hvax64.exe或Hvaa64.exe，取决于架构）及其所有依赖项加载并映射到内存。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）枚举所有可被固件枚举的磁盘，并将列表附加给加载器参数块（Loader Parameter Block）。此外，如果在配置数据中进行了指定，还会加载聚合初始计算机配置的配置单元（Imc.hiv）并将其附加给加载器块。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）初始化内核代码完整性模块（CI.dll）并构建CI加载器块。该模块随后会在NT内核与安全内核间共享。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）处理任何未决的固件更新（Windows 10支持通过Windows Update分发固件更新）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">5）加载相应的内核和
HAL映像（默认为Ntoskrnl.exe和Hal.dll）。如果Winload加载这两个文件失败，则将会显示错误信息。在开始加载这两个模块的依
赖项之前，Winload会通过数字证书验证其内容并载入API Set Schema系统文件。这样即可处理API Set的导入了。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">6）初始化调试器，加载正确的调试器传输。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">7）如果需要，则加载CPU微码更新模块（Mcupdate.dll）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">8）
OslpLoadAllModules最后会加载NT内核和HAL依赖的模块：ELAM驱动程序、核心扩展、TPM驱动程序，以及其他需要在启动时运行的
驱动程序（会按照顺序加载，文件系统驱动程序会优先加载）。启动设备驱动程序是指启动系统所必需的驱动程序。这些驱动程序的配置存储在SYSTEM注册表
配置单元中。每个设备驱动程序都在HKLM\SYSTEM\CurrentControlSet\Services之下有一个注册表子键。例如，
Services有一个名为rdyboost、适用于ReadyBoost驱动程序的子键，如图12-8所示（有关Services注册表项的详细介绍，
请参阅第10章中的“Windows服务”一节）。所有启动驱动程序的启动值均为SERVICE_BOOT_START (0)。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/fc9d446a3a91cb54fa80c0246278bef3.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图12-8 ReadyBoost驱动程序的服务设置</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">9）到这一阶段，为了正确分配物理内存，Winload依然使用EFI固件提供的服务（AllocatePages启动服务例程）。虚拟地址转换工作此时由运行在应用程序执行上下文中的启动库负责管理。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">10）读入用于实现国际化的NLS（国家语言系统）文件。默认情况下，这些文件为l_intl.nls、C_1252.nls和C_437.nls。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">11）如果评估后的策略需要启动VSM，则会执行安全内核设置工作的阶段0，借此解析VSM加载器支持例程（由Hvloader.dll模块导出）的位置，并加载安全内核模块（Securekernel.exe）及其所有依赖项。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">12）对于S版本的Windows，还将判断Windows应用程序的最低用户模式可配置代码完整性签名的级别。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">13）调用
OslArchpKernelSetupPhase0例程，执行内核转换所需的内存步骤，例如分配GDT、IDT和TSS，映射HAL虚拟地址空间，分配
内核栈、共享用户页以及USB传统交接（legacy 
handoff）。Winload会使用UEFI的GetMemoryMap设施来获取完整的系统物理内存映射，并将属于EFI运行时代码/数据的每个物
理页映射至虚拟内存空间。随后完整的物理映射将被传递给操作系统内核。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">14）执行VSM设置过程的阶段1，将所需的全部ACPI表从VTL0复制到VTL1内存（该步骤还会创建VTL1页表）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">15）虚拟内存转换模块已完全正常运行，因此，Winload将调用ExitBootServices这个UEFI函数来摆脱固件启动服务，并使用UEFI的运行时函数SetVirtualAddressMap将剩余的运行时UEFI服务重映射至所创建的虚拟地址空间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">16）如果需要，将启动虚拟机监控程序和安全内核（严格按照该顺序启动）。如果成功，执行控制权将返回给Hyper-V根分区上下文中的Winload（有关Hyper-V的详细信息请参阅第9章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">17）通过OslArchTransferToKernel例程将执行权转交给内核。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_347" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>1</b><b>0</b><b> </b><b>从</b><b>i</b><b>S</b><b>C</b><b>S</b><b>I</b><b>启</b><b>动</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Internet 
SCSI（iSCSI）设备是一种网络附加存储设备，借此可通过iSCSI主机总线适配器（HBA）或以太网连接远程物理磁盘。不过这些设备和传统的网络
附加存储（NAS）有较大不同，因为可以针对磁盘提供块级访问，而传统NAS使用了基于逻辑访问的网络文件系统。因此使用Microsoft 
iSCSI发起程序通过以太网连接提供访问的iSCSI磁盘，能像其他任何类型的磁盘一样出现在启动加载器和操作系统中。使用iSCSI磁盘代替本地存
储，可以帮助企业节约空间、耗电量以及降低冷却压力。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">传统上，虽然
Windows只支持从本地连接的磁盘启动，或通过PXE进行网络启动，但现代版本的Windows也可通过一种名为iSCSI启动的机制原生支持从
iSCSI设备启动。如图12-9所示，启动加载器（Winload.efi）会读取必须存在于物理内存中（通常通过ACPI暴露）的iSCSI启动固件
表（iBFT）来检测系统是否支持iSCSI启动设备。借助iBFT，Winload可以获知远程磁盘的位置、路径和认证信息。如果存在该表，
Winload会打开并加载制造商提供的网络接口驱动程序，这些驱动程序采用CM_SERVICE_NETWORK_BOOT_LOAD 
(0x1)启动标志。</span></p><div style="display: block;text-align:center;">
	<img width="768" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/f00f8ff1ffdc8a16a17e591bbce5aaba.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图12-9 iSCSI启动架构</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">此外，Windows安装程序也可以读取该表来确定可启动的iSCSI设备，进而直接安装到此类设备上，这样就不需要使用安装镜像了。在Microsoft iSCSI发起程序的帮助下，Windows就获得了从iSCSI启动的能力。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_348" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>1</b><b>1</b><b> </b><b>虚</b><b>拟</b><b>机</b><b>监</b><b>控</b><b>程</b><b>序</b><b>加</b><b>载</b><b>器</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">虚拟机监控程序加载器（文
件名为Hvloader.dll）作为一个启动模块，可正确加载并启动Hyper-V虚拟机监控程序和安全内核。有关Hyper-V与安全内核的详细介绍
请参阅第9章。虚拟机监控程序加载器模块已深入集成于Windows加载器，其主要目标有两个。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·检测硬件平台，加载并启动正确版本的Windows虚拟机监控程序（Intel系统为Hvix64.exe，AMD系统为Hvax64.exe，ARM64系统为Hvaa64.exe）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·解析虚拟安全模式（Virtual Secure Mode，VSM）策略，加载并启动安全内核。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在Windows 8中，该模块是一个由Winload按需加载的外部可执行文件。当时，虚拟机监控程序加载器唯一的作用是加载并启动Hyper-V。随着VSM和可信启动功能的引入，该架构已重新设计，使得不同的组件可实现更紧密的集成。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，虚拟机监控程
序的设置分为两个阶段。第一阶段始于Winload中NT加载器块初始化完成之后的那一刻。HvLoader会通过某些CPUID指令检测目标平台，复制
UEFI的物理内存映射，并发现IOAPIC和IOMMU。随后，HvLoader会将正确的虚拟机监控程序映像（以及所有依赖项，如调试器传输）载入内
存，并检查虚拟机监控程序的版本信息与预期是否一致（这解释了HvLoader为何无法启动不同版本的Hyper-V）。在这一阶段，HvLoader会
收集虚拟机监控程序加载器块，这是一种重要的数据结构，可用于在HvLoader和虚拟机监控程序（类似于Windows加载器块）本身之间传递重要的系
统参数。第一阶段最重要的步骤是构建虚拟机监控程序页表层次结构。这种刚生成的页表只包含虚拟机监控程序映像（及其依赖项）与第一个兆字节之下的系统物理
页之间的映射。后者是一种由启动过渡代码（详见下文）使用的标识映射。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当Winload最后的工
作完成时，便会开始第二阶段：UEFI固件的启动服务已被弃用，因此HvLoader代码会将UEFI运行时服务的物理地址范围复制到虚拟机监控程序加载
器块，并捕获处理器状态；随后会禁用中断、调试器和分页；接着将调用
HvlpTransferToHypervisorViaTransitionSpace，将代码的执行转移到1MB之下的物理页。位于这里的代码（过渡
代码）将切换页表，重新启用分页，并转移到虚拟机监控程序代码（实际上会创建两个地址空间）。虚拟机监控程序启动后，将使用保存的处理器上下文，以正确方
式将代码的执行转回给一个名为根分区（详见第9章）的新虚拟机上下文中运行的Winload。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">由于一些操作只能在虚拟机监控程序启动之后进行，因此虚拟安全模式的启动分为三个阶段。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）第一阶段与虚拟机监控程序设置过程的第一阶段非常类似。数据被从Windows加载器块复制到刚分配的VSM加载器块，生成主密钥、IDK密钥和Crashdump密钥，SecureKernel.exe模块会被载入内存。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）第二阶段由
Winload在OslPrepareTarget工作过程的后期发起，此时虚拟机监控程序已初始化完成但尚未运行。与虚拟机监控程序设置过程的第二阶段
类似，UEFI运行时服务的物理地址范围会被复制到VSM加载器块，同时复制的还有ACPI表、代码完整性数据、完整的系统物理内存映射，以及虚拟化调用
的代码页。第二阶段还会使用OslpVsmBuildPageTables函数构建用于受保护VTL1内存空间的受保护页表层次结构及所需GDT。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）第三阶段是最终的“运
行”阶段。虚拟机监控程序已经运行起来，第三阶段将执行最终的检查（例如检查是否存在IOMMU，根分区是否具备VSM特权IOMMU，这对VSM很重
要，详见第9章）。这个阶段还会设置加密的虚拟机监控程序崩溃转储区域，复制VSM加密密钥，并将执行转移给安全内核入口点
（SkiSystemStartup）。安全内核入口点代码运行在VTL 0下。VTL 
1则是随后由安全内核代码通过HvCallEnablePartitionVtl这个虚拟化调用启动的（详见第9章）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_349" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>1</b><b>2</b><b> </b><b>V</b><b>S</b><b>M</b><b>启</b><b>动</b><b>策</b><b>略</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">启动时，Windows加
载器需要判断是否启动虚拟安全模式（Virtual Secure 
Mode，VSM）。为保证所有恶意软件都无法禁用这种新的防护措施，系统会使用一种特殊的策略来密封VSM启动设置。默认配置下，当首次启动时
（Windows安装程序复制完Windows文件后），Windows加载器会使用OslSetVsmPolicy例程读取并密封VSM配置，这些配置
存储在HKLM\SYSTEM\CurrentControlSet\Control\DeviceGuard下的VSM根注册表键中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">VSM可由不同的源启用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>D</b><b>e</b><b>v</b><b>i</b><b>c</b><b>e</b><b> </b><b>G</b><b>u</b><b>a</b><b>r</b><b>d</b><b>场</b><b>景</b></span>。每个场景都以子键形式存储在VSM根键下。名为Enabled的DWORD注册表值控制对应的场景中是否启用。如果有一个或多个场景被激活，那么VSM将被启用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>全</b><b>局</b><b>设</b><b>置</b></span>。存储在注册表值EnableVirtualizationBasedSecurity中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>H</b><b>V</b><b>C</b><b>I</b><b>代</b><b>码</b><b>完</b><b>整</b><b>性</b><b>策</b><b>略</b></span>。存储在代码完整性策略文件（Policy.p7b）中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">另外，默认情况下，启用虚拟机监控程序的同时，也将自动启用VSM（除非存在HyperVVirtualizationBasedSecurityOptOut注册表值）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">每个VSM激活源都可以指
定一个锁定策略。如果锁定模式已启用，则Windows加载器会构建一个名为VbsPolicy的安全启动变量，并在其中存储VSM激活模式和平台配置。
VSM平台的一部分配置会根据检测到的系统硬件动态生成，另外一部分配置则可直接从VSM根键下的
RequirePlatformSecurityFeatures注册表值中读取。随后每次启动时都会读取这个安全启动变量，而该变量中存储的配置将始终
替代Windows注册表中的配置。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这样，即使恶意软件通过修
改Windows注册表禁用了VSM，Windows依然可以忽略这些改动，以保证用户环境的安全。恶意软件无法修改VSM安全启动变量，因为根据安全启
动规范的要求，只有包含可信任数字签名的新变量才可以修改或删除原先的变量。微软提供了一个特殊的签名工具可以禁用VSM保护，该工具是一个特殊的EFI
启动应用程序，可以设置另一个名为VbsPolicyDisabled的带签名的安全启动变量。Windows加载器可以在启动时识别该变量。如果发现该
变量存在，则Winload将删除VbsPolicy安全变量，并修改注册表以禁用VSM（同时修改全局设置和每个激活的场景）。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>理</b><b>解</b><b>V</b><b>S</b><b>M</b><b>策</b><b>略</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在
这个实验中，我们将了解安全内核的启动过程是如何抵抗外部篡改的。首先请在兼容的Windows版本（通常为专业版或商业版）中启用基于虚拟化的安全性
（Virtualization Based 
Security，VBS）。在这些版本的系统中，我们可以通过任务管理器快速了解VBS是否已启用。如果VBS已启用，即可在“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>详</b><b>细</b><b>信</b><b>息</b></span>”选项卡下看到一个名为Secure System的进程。不过即便已经启用，也别忘了检查UEFI锁是否已启用。在开始菜单的搜索框中输入“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>组</b><b>策</b><b>略</b><b>编</b><b>辑</b><b>器</b></span>”（或gpedit.msc）并启动本地组策略编辑器控制台，随后依次进入“计算机配置”→“管理模板”→“系统”→“Device Guard”，双击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>打</b><b>开</b><b>基</b><b>于</b><b>虚</b><b>拟</b><b>化</b><b>的</b><b>安</b><b>全</b></span>”。请确保该策略设置为“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>已</b><b>启</b><b>用</b></span>”，并且相关选项的设置如下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/97a36a750f34b7416300414751c49bfc.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">接
下来需要检查安全启动是否已启用（为此可以使用系统信息工具或系统BIOS配置工具确认安全启动的激活状态），随后重启系统。“使用UEFI锁启用”选项
甚至可以防止管理员权限的用户进行篡改。重启系统后，通过相同的组策略禁用VBS（务必将所有设置都禁用）并删除
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\DeviceGuard下的所有注册表键和
值（也可将其全部设置为“0”）。请使用注册表编辑器正确删除所有值。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/a47fdd7672e6c6ae4b5bd81cec3e4102.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">使
用管理员权限运行的命令提示符窗口运行“bcdedit/set {current} hypervisorlaunchtype 
off”命令禁用虚拟机监控程序，然后再次重启系统。系统重启后，即便VBS和虚拟机监控程序已经按照预期正确关闭，依然可以通过任务管理器看到
Secure 
System和LsaIso进程。这是因为UEFI服务变量VbsPolicy依然包含原策略，因此，恶意程序或用户无法轻易禁用这一层额外的保护。为了
确认这一点，请运行eventvwr打开系统事件查看器并进入“Windows日志”→“系统”。向下拖动事件列表，应该能看到有一条描述VBS激活类型
的事件（事件来源为Kernel-Boot）。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/10f113539ef083e30ff86d6c013776a7.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">VbsPolicy
是一种由启动服务认证的UEFI变量，这意味着当操作系统切换到运行时模式后，该变量将不可见。上一个实验中用到的UefiTool工具无法显示此类变
量。为了查看VbsPolicy变量内容，请再次重启计算机，禁用安全启动，随后使用Efi Shell。Efi 
Shell（包含在本书随附资源中）必须复制到FAT32文件系统U盘的efi\boot路径下，并将其命名为bootx64.efi。随后用这个U盘启
动系统即可运行Efi Shell。接着请运行下列命令：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">dmpstore VbsPolicy -guid 77FA9ABD-0359-4D32-BD60-28F4E78F784B </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">（77FA9ABD-0359-4D32-BD60-28F4E78F784B是安全启动私有命名空间的GUID。）</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b136865230969a0c547d7914780dc8d6.jpg" alt="" title=""></div>
</div><div class="header2"><h3><span id="sigil_toc_id_350" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>1</b><b>3</b><b> </b><b>安</b><b>全</b><b>运</b><b>行</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果可信执行（通过VSM
策略中的一个特定功能值）已启用，并且系统兼容该功能，那么Winload将启用一个与常规启动路径略有差异的全新启动路径。这个新启动路径称为安全运行
（secure 
launch）。安全运行实现了Intel可信启动（TXT）技术（或AMD64的SKINIT技术）。可信启动通过两个组件实现：启动库和
TcbLaunch.exe文件。启动库在初始化的时候会检测到可信启动功能已启用，并注册一个拦截不同事件的启动回调。可拦截事件包括启动应用程序运
行、哈希计算及启动应用程序结束。Windows加载器在这个早期环节并不加载虚拟机监控程序，而会执行安全运行设置过程的三个阶段（从现在开始，我们
将“安全运行的设置过程”称为“TCB设置过程”）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如上文所述，安全运行的最终目标是运行安全的启动序列，其中CPU是唯一可信任的根。为此，系统需要摆脱对所有固件的依赖。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了实现这一点，
Windows会创建一个RAM磁盘并将其格式化为FAT文件系统，其中包含Winload、虚拟机监控程序、VSM模块，以及启动系统所需的全部操作系
统启动组件。Windows加载器（Winload）会使用BlImgLoadBootApplication例程将TcbLaunch.exe从系统启
动磁盘读入内存。后者将触发可由TCB启动回调管理的三个事件。该回调首先会准备运行测量启动环境（Measured Launch 
Environment，MLE）；然后检查ACM模块和ACPI表，并映射所需的TXT区域；最后用一个特殊的TXT 
MLE例程替换启动应用程序的入口点。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在
OslExecuteTransition例程运行的最新阶段，Windows加载器并不会启动虚拟机监控程序的运行序列。相反，它会将执行转交给TCB
运行序列，这个过程相当简单。TCB启动应用程序将通过上文介绍过的BlImgStartBootApplication例程启动。修改后的启动应用程序
入口点将调用TXT MLE运行例程，借此执行GETSEC(SENTER) 
TXT指令。该指令可测量内存中的TcbLaunch.exe可执行文件（TBOOT模块），如果测量成功，则MLE运行例程会将代码执行转交给真正的启
动应用程序入口点（TcbMain）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">安全运行环境中执行的第一
个代码是TcbMain函数。这个实现相当简单：重新初始化启动库，注册事件以接收虚拟化运行/恢复通知，随后调用安全RAM磁盘中
Tcbloader.dll模块内的TcbLoadEntry。Tcbloader.dll模块是受信任Windows加载器的小型版本，其作用是加载、
验证并启动虚拟机监控程序，设置虚拟化调用页面，以及运行安全内核。安全运行过程就此结束，接下来将由虚拟机监控程序和安全内核负责NT内核与其他模块的
验证工作并提供信任链。随后执行将返回Windows加载器，并通过标准的OslArchTransferToKernel例程回到Windows内核。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">图12-10展示了安全运行功能的结构与涉及的所有组件。用户可以使用本地组策略编辑器启用安全运行功能，为此只需要在“计算机配置”→“管理模板”→“系统”→“Device Guard”下调整“打开基于虚拟化的安全”设置即可。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
可信启动的ACM模块由Intel提供，依赖于特定芯片组。大部分TXT接口都是物理内存中的内存映射。这意味着HvLoader甚至可以访问SINIT
区域，验证SINIT 
ACM版本，并在需要时对其更新。Windows使用一个特殊的压缩WIM文件（名为Tcbres.wim）实现了这一点，该文件中包含每个芯片组的所有
已知SINIT 
ACM模块。如果需要，MLE准备阶段还可以打开该压缩文件，从中提取正确的二进制模块，并用它替换TXT区域中原始的SINIT固件内容。当调用安全运
行过程时，CPU会将SINIT ACM载入安全内存，验证其数字签名的完整性，随后将其公钥的哈希值与芯片组中硬编码的哈希值进行对比。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/77b0260369c11372f8ccb575fcdb06db.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图12-10 安全运行功能的结构与涉及的所有组件。请留意来自RAM磁盘的虚拟机监控程序和安全内核</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>A</b><b>M</b><b>D</b><b>平</b><b>台</b><b>上</b><b>的</b><b>安</b><b>全</b><b>运</b><b>行</b></span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">虽然安全运行功能仅适用于支持TXT技术的Intel计算机，但从Windows 10的2020年春季更新开始，Windows提供了对SKINIT的支持，这是AMD开发的一项类似技术，可用于从最初不受信任的操作模式开始，以可验证的方式启动可信任的软件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SKINIT的用途与
Intel的TXT相同，也可用于安全运行功能的启动流程。不过与TXT的不同之处在于，SKINIT基于一种名为安全加载器（Secure 
Loader，SL）的小型软件，在Windows中，SL是通过AMD所提供的Amddrtm.dll库文件的资源节中包含的amdsl.bin二进制
文件实现的。SKINIT指令可以重新初始化处理器，进而建立安全的执行环境，并以一种无法篡改的方式开始执行SL。安全加载器位于安全加载器程序块中，
这个64KB的结构可由SKINIT指令转换到TPM中。TPM可测量SL的完整性并将执行转交给它的入口点。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">SL可以验证系统状态，将
测量结果扩展到PCR中，并将执行转交给AMD 
MLE运行例程，该例程位于TcbLaunch.exe模块中一个单独的二进制文件内。MLE例程可以初始化IDT和GDT并构建将处理器切换至长模式所
需的页表（AMD计算机中的MLE执行于32位受保护模式下，这是为了尽可能地减少TCB中的代码）。与Intel系统一样，最后它会跳回
TcbLaunch，重新初始化启动库，注册事件以接收虚拟化运行/恢复通知，随后调用Tcbloader.dll模块内的TcbLoadEntry。从
这里往后，引导流程就与Intel系统中实现的安全运行功能完全相同了。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_351" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>1</b><b>4</b><b> </b><b>初</b><b>始</b><b>化</b><b>内</b><b>核</b><b>与</b><b>执</b><b>行</b><b>体</b><b>子</b><b>系</b><b>统</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">当Winload调用
Ntoskrnl时，它会传递一种名为加载器参数块的数据结构。加载器参数块包含系统分区和启动分区路径、一个到内存表（由Winload生成，用于描述
系统物理内存）的指针、一个物理硬件树（用于构建易失性的HARDWARE注册表配置单元）、一个SYSTEM注册表配置单元在内存中的副本，以及一个指
向Winload已加载启动驱动程序列表的指针。此外还包含到目前为止执行过的所有与启动工作有关的其他信息。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>加</b><b>载</b><b>器</b><b>参</b><b>数</b><b>块</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">启
动时，内核会在KeLoaderBlockvariable中保留一个指向加载器参数块的指针。内核会在启动过程的第一阶段丢弃该参数块，因此，查看该结
构内容的唯一方法是在启动前连接内核调试器，并在最初的内核调试器断点处断开。如果可以做到这一点，那么可使用dt命令转储这个参数块，如下所示：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">kd&gt; dt poi(nt!KeLoaderBlock) nt!LOADER_PARAMETER_BLOCK </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x000 OsMajorVersion   : 0xa </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x004 OsMinorVersion   : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x008 Size             : 0x160 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x00c OsLoaderSecurityVersion : 1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x010 LoadOrderListHead :_LIST_ENTRY [ 0xfffff800`2278a230 - 0xfffff800`2288c150 ] </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x020 MemoryDescriptorListHead :_LIST_ENTRY [ 0xfffff800`22949000 - 0xfffff800</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                                                                `22949de8 ]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x030 BootDriverListHead :_LIST_ENTRY [ 0xfffff800`22840f50 - 0xfffff800`2283f3e0 ]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x040 EarlyLaunchListHead :_LIST_ENTRY [ 0xfffff800`228427f0 - 0xfffff800`228427f0 ]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x050 CoreDriverListHead :_LIST_ENTRY [ 0xfffff800`228429a0 - 0xfffff800`228405a0 ]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x060 CoreExtensionsDriverListHead :_LIST_ENTRY [ 0xfffff800`2283ff20 - 0xfffff800</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                                                                `22843090 ]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x070 TpmCoreDriverListHead :_LIST_ENTRY [ 0xfffff800`22831ad0 - 0xfffff800`22831ad0 ]</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x080 KernelStack      : 0xfffff800`25f5e000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x088 Prcb             : 0xfffff800`22acf180 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x090 Process          : 0xfffff800`23c819c0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x098 Thread           : 0xfffff800`23c843c0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x0a0 KernelStackSize  : 0x6000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x0a4 RegistryLength   : 0xb80000 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x0a8 RegistryBase     : 0xfffff800`22b49000 Void </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x0b0 ConfigurationRoot : 0xfffff800`22783090_CONFIGURATION_COMPONENT_DATA </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x0b8 ArcBootDeviceName : 0xfffff800`22785290 "multi(0)disk(0)rdisk(0)partition(4)" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x0c0 ArcHalDeviceName : 0xfffff800`22785190 "multi(0)disk(0)rdisk(0)partition(2)"</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x0c8 NtBootPathName   : 0xfffff800`22785250 "\WINDOWS\" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x0d0 NtHalPathName    : 0xfffff800`22782bd0 "\" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x0d8 LoadOptions      : 0xfffff800`22772c80 "KERNEL=NTKRNLMP.EXE NOEXECUTE=OPTIN </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                 HYPERVISORLAUNCHTYPE=AUTO DEBUG ENCRYPTION_KEY=**** </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                 DEBUGPORT=NET </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">                                 HOST_IP=192.168.18.48 HOST_PORT=50000 NOVGA" </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x0e0 NlsData          : 0xfffff800`2277a450_NLS_DATA_BLOCK </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x0e8 ArcDiskInformation : 0xfffff800`22785e30_ARC_DISK_INFORMATION </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x0f0 Extension        : 0xfffff800`2275cf90_LOADER_PARAMETER_EXTENSION </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x0f8 u                : &lt;unnamed-tag&gt; </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x108 FirmwareInformation :_FIRMWARE_INFORMATION_LOADER_BLOCK </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x148 OsBootstatPathName : (null) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x150 ArcOSDataDeviceName : (null) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x158 ArcWindowsSysPartName : (null) </span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">此外，也可以针对MemoryDescriptorListHead字段使用!loadermemorylist命令来转储物理内存范围：</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/5d13dbcf3b8945998c5a76095e31b69d.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">加载器参数扩展可以显示系统硬件、CPU功能以及启动类型等实用信息：</span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">kd&gt; dt poi(nt!KeLoaderBlock) nt!LOADER_PARAMETER_BLOCK Extension </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x0f0 Extension : 0xfffff800`2275cf90_LOADER_PARAMETER_EXTENSION </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">kd&gt; dt 0xfffff800`2275cf90_LOADER_PARAMETER_EXTENSION </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">nt!_LOADER_PARAMETER_EXTENSION </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x000 Size             : 0xc48 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x004 Profile          :_PROFILE_PARAMETER_BLOCK </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x018 EmInfFileImage   : 0xfffff800`25f2d000 Void </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   ... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x068 AcpiTable        : (null) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x070 AcpiTableSize    : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">  +0x074 LastBootSucceeded : 0y1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x074 LastBootShutdown : 0y1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x074 IoPortAccessSupported : 0y1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x074 BootDebuggerActive : 0y0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x074 StrongCodeGuarantees : 0y0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x074 HardStrongCodeGuarantees : 0y0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x074 SidSharingDisabled : 0y0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x074 TpmInitialized   : 0y0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x074 VsmConfigured    : 0y0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x074 IumEnabled       : 0y0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x074 IsSmbboot        : 0y0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x074 BootLogEnabled   : 0y0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x074 FeatureSettings  : 0y0000000 (0) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x074 FeatureSimulations : 0y000000 (0) </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x074 MicrocodeSelfHosting : 0y0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   ... </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x900 Bootflags        : 0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x900 DbgMenuOsSelection : 0y0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x900 DbgHiberBoot     : 0y1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x900 DbgSoftRestart   : 0y0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x908 InternalBootflags : 2 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x908 DbgUtcBootTime   : 0y0 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x908 DbgRtcBootTime   : 0y1 </span></p>
	<p><span style="font-size:14px;color:rgb(0, 0, 0);font-family:'Source Code Pro';">   +0x908 DbgNoLegacyServices : 0y0 </span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Ntoskrnl开始执行阶段0，它的初始化过程分为两个阶段，这是第一个阶段（阶段1是第二个阶段）。大部分执行体子系统都有一个初始化函数，可以通过接收参数来识别当前正在执行的阶段。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">阶段0期间，中断会被禁
用。这个阶段的作用是建立所需的基本结构，以便让阶段1所需要的服务能被调用。Ntoskrnl的启动函数KiSystemStartup会在每个系统处
理器的上下文中被调用（详见下文“内核初始化阶段1”一节）。该函数负责初始化处理器的启动结构并设置全局描述符表（Global Descriptor
 Table，GDT）和中断描述符表（Interrupt Descriptor 
Table，IDT）。如果从启动处理器调用，启动例程还将初始化控制流防护（Control Flow 
Guard，CFG）检查功能，并与内存管理器协调以初始化KASLR。KASLR的初始化应当在系统启动的早期阶段完成，这样内核才能为各种虚拟内存区
域（如PFN数据库和系统PTE区域，有关KASLR的详细信息请参阅卷1第5章）分配随机VA范围。KiSystemStartup将初始化内核调试
器、XSAVE处理器区域，并在需要时初始化KVA影子，随后它会调用KiInitializeKernel。如果KiInitializeKernel
在启动CPU上运行，则会执行系统级的内核初始化任务，例如，初始化内部列表以及被所有CPU共享的其他数据结构。它还会构建并压缩系统服务描述符表
（System Service Descriptor 
Table，SSDT）并为内部的KiWaitAlways和KiWaitNever计算随机值，这些值会被用于内核指针的编码中。另外，
KiInitializeKernel还会检查虚拟化是否已启动，如果启动，则会映射虚拟化调用页面并开始处理器的启发（有关虚拟机监控程序的启发，请参
阅第9章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当使用兼容的处理器执行
时，KiInitializeKernel还起到其他重要作用：初始化并启用控制强制技术（Control Enforcement 
Technology，CET）。这是一种相对较新的硬件功能，简单来说，可实现一种硬件影子栈，借此检测并阻止ROP攻击。该技术可保护用户模式应用程
序及内核模式驱动程序（但前提是VSM可用）。KiInitializeKernel会初始化Idle进程和线程，并调用
ExpInitializeExecutive。KiInitializeKernel和ExpInitializeExecutive通常会在每个系统
处理器上执行。当由启动处理器执行时，ExpInitializeExecutive会依赖负责协调过程阶段0的InitBootProcessor函
数，而后续处理器只需要调用InitOtherProcessors即可。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 ROP（Return-Oriented 
Programming，返回导向的编程）是一种可被攻击利用的技术，攻击者可获得对程序调用栈的控制，进而劫持程序的控制流，并执行精心选择的机器指令
序列（名为“Gadget”，小工具），而这些机器指令已经存在于计算机内存中了。通过将多个这种“小工具”精心连接在一起，攻击者即可在计算机上执行任
意操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">InitBootProcessor
首先会验证启动加载器。如果用于运行Windows的启动加载器版本与正确的Windows内核不匹配，那么该函数会让系统崩溃并显示
LOADER_BLOCK_MISMATCH错误检查代码（0x100）。如果匹配，则该函数会初始化CPU的旁视指针（look-aside 
pointer）池，随后查询并遵守BCD的Burnmemory启动选项，抛弃这个选项值所指定数量的物理内存。该函数会对Winload所加载的
NLS文件（详见上文）执行足够数量的初始化操作，进而让从Unicode到ANSI的转换以及其他OEM转换可以正常工作。接下来，该函数会继续初始化
Windows硬件错误架构（Windows Hardware Error 
Architecture，WHEA）并调用HAL函数HalInitSystem，该函数为HAL提供了一个在Windows进一步执行重要的初始化任
务之前获得系统控制权的机会。HalInitSystem负责初始化并启动HAL的不同组件，如ACPI表、调试器描述符、DMA、固件、I/O 
MMU、系统计时器、CPU拓扑、性能计数器及PCI总线。HalInitSystem的一个重要职责是让每个CPU中断控制器准备好接收中断，以及配置
间隔时钟计时器中断，该中断主要用于CPU时间计量（有关CPU时间计量的详情，请参阅本书卷1第4章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当
HalInitSystem退出后，InitBootProcessor将接手并开始计算时钟计时器的倒数过期时间。在大部分现代处理器中，会使用这种倒
数来优化除法计算，借此还可以更快速地执行乘法运算，并且因为Windows必须对当前的64位时间值进行除法运算才能找出即将过期的计时器，这种静态计
算有助于减少时钟间隔激发时的中断延迟。InitBootProcessor使用了一个辅助例程CmInitSystem0，以从SYSTEM配置单元的
控制向量中获取注册表值。这个数据结构包含超过150种内核调优选项，同时也是
HKLM\SYSTEM\CurrentControlSet\Control注册表键的一部分，其中甚至包含了当前安装系统的许可数据和版本信息等。所
有这些信息都会预加载并存储在全局变量中。随后，InitBootProcessor会继续设置系统根路径，在内核映像中寻找要在蓝屏界面上显示的崩溃信
息字符串，并将其位置缓存起来，以避免在出现崩溃时再进行查找，因为这种方式很危险并且不可靠。随后，InitBootProcessor会初始化计时器
子系统以及共享的用户数据页。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">至此，InitBootProcessor已经准备好为执行体、驱动程序认证器以及内存管理器调用阶段0初始化例程。这些组件将执行下列初始化任务。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）执行体初始化各种内部锁、资源、列表及变量，并验证注册表中的产品套件类型是否有效，这是为了阻止随意修改注册表数据，以便“升级”为并未实际购买的Windows版本。这只是内核中执行的众多此类检查之一。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）如果被启用，驱动程序认证器会初始化各种设置，并根据系统的当前状态（如是否启用了安全模式）和认证选项执行不同的行为。它还会针对随机选择驱动程序的测试挑选要测试的目标驱动程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）内存管理器构建页表、
PFN数据库和内部数据结构，这些都是提供基本内存服务所必需的。首先，它会强制执行物理内存最大支持量的限制，并为系统文件缓存构建预留一块区域。随后
它会为分页和非分页内存池创建内存区域（详见本书卷1第5章）。其他执行体子系统、内核以及设备驱动程序会使用这两个内存池分配自己的数据结构。最后，它
会创建UltraSpace，这是一个16TB的区域，能为不需要TLB刷新、快速且低开销的页面映射提供支持。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">接下来，
InitBootProcessor会启用虚拟机监控程序CPU动态分区（如果已启用且具备适当许可），并调用HalInitializeBios，设置
HAL中与传统BIOS模拟代码有关的部分。这些代码可用于允许访问（或模拟访问）16位实模式中断和内存，它们主要被Bootvid所使用（该驱动程序
已被BGFX取代，但出于兼容性的目的而保留）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">至此，
InitBootProcessor枚举了Winload加载的启动时运行的驱动程序，并会调用DbgLoadImageSymbols以便让内核调试器
（如果已连接）加载这些驱动程序的符号。如果主机调试器已经配置了符号加载时选项上的断点，那么这将是内核调试器能够获得系统控制权的第一个点。
InitBootProcessor随后会调用HvlPhase1Initialize，由它来执行之前阶段尚未完成的剩余的HVL初始化工作。如果计算
机配置为使用紧急管理服务（EMS），当该函数返回时，还会调用HeadlessInit以初始化串口控制台。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">InitBootProcessor
还会构建启动过程稍后将会用到的版本信息，如构建编号、Service 
Pack版本、Beta版本状态等。随后，它会将Winload之前加载的NLS表载入分页池，重新进行初始化，并按照全局标记的指定创建内核栈跟踪数据
库（有关全局标记的详细信息，请参阅本书卷1第6章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后，InitBootProcessor会调用对象管理器、安全引用监视器、进程管理器、用户模式调试框架以及即插即用管理器。这些组件将执行下列初始化工作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）在对象管理器初始化过
程中，将定义构建对象管理器命名空间所必需的对象，这样，其他子系统就可以向其中插入对象。此外还会创建系统进程和全局内核句柄表，这样就可以开始进行资
源跟踪了。此时还会计算加密对象头所用的值，并创建Directory和SymbolicLink类型的对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）安全引用监视器会初始
化与安全性有关的全局变量（如系统SID和特权LUID）和内存数据库，并创建Token类型的对象。随后它将创建并准备第一个Local 
System账户令牌，以便将其分配给初始进程（有关Local System账户的详细介绍请参阅本书卷1第7章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）进程管理器的大部分初
始化工作都在阶段0进行：定义进程、线程、作业以及分区对象类型，设置列表以跟踪活动进程和线程。另外还会初始化系统级的进程缓解选项，并将其与
HKLM\SYSTEM\CurrentControlSet\Control\Session 
Manager\Kernel\MitigationOptions注册表值指定的选项合并。随后，进程管理器会创建执行体系统分区对象（名为
MemoryPartition0）。这个名称有些误导性，因为该对象实际上是一种执行体分区对象，这是一种新的Windows对象类型，其中封装了内存
分区和缓存管理器分区（用于支持新的应用程序容器）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）进程管理器会为初始化
进程创建一个进程对象，并将其命名为Idle。作为最后一步，进程管理器会创建受保护的System进程和系统线程，以此执行
Phase1Initialization例程。该线程并不会立即运行，因为此时中断依然被禁用。System进程是一种受保护进程，可防范用户模式的攻
击，因为它的虚拟地址空间被用于映射系统和代码完整性驱动程序所使用的敏感数据。此外，System进程的句柄表还维护了内核句柄。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">5）用户模式调试框架创建了调试对象类型的定义，这类对象可用于将调试器连接到进程并接收调试器事件。有关用户模式调试的详细介绍请参阅第8章。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">6）将进行即插即用管理器的阶段0初始化，期间将初始化用于同步访问总线资源所需的执行体资源。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当控制返回到
KiInitializeKernel之后，还需要为当前处理器分配DPC栈，将IRQL提升至调度级别，并启用中断。随后控制将进入空闲循环，这会导致
步骤4创建的系统线程开始执行阶段1（从属处理器开始等待自己的初始化，直到下文将要介绍的阶段1的步骤11）。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_352" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>1</b><b>5</b><b> </b><b>内</b><b>核</b><b>初</b><b>始</b><b>化</b><b>阶</b><b>段</b><b>1</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">只要Idle线程得到执行机会，将开始内核初始化的第一阶段。该阶段包含下列步骤。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）顾名思义，Phase1InitializationDiscard将丢弃内核映像中INIT节所包含的代码，借此保留内存。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）初始化线程将自己的优先级设置为31，这是最高优先级，主要是为了防止自己被抢占。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）评估BCD选项，借此指定虚拟处理器（hypervisorrootproc）数量的最大值。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）创建NUMA/组拓扑关系，系统会尝试通过这种关系在逻辑处理器和处理器组之间实现最优化的映射关系，除非被相关BCD设置覆盖，否则还会考虑NUMA的位置和距离。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">5）HalInitSystem执行自己的第一阶段初始化，让系统准备好接收来自外设的中断。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">6）系统时钟中断初始化完成，启用系统时钟的时钟周期（tick）生成工作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">7）初始化传统的启动视频驱动程序（Bootvid），该驱动程序只用于输出调试信息，以及由SMSS启动的原生应用程序（如NT Chkdsk）所生成的信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">8）内核构建各种字符串和版本信息，如果启用了SOS启动选项，这些信息会通过Bootvid显示在屏幕上。其中包括完整的版本信息、支持的处理器数量以及支持的内存数量。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">9）调用电源管理器的初始化过程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">10）通过HalQueryRealTimeClock初始化系统时间，随后将其作为系统的启动时间存储起来。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">11）在多处理器系统中，
其他处理器将由KeStartAllProcessors和HalAllProcessorsStarted初始化。可被初始化并可支持的处理器数量取决
于多种因素的组合，包括实际安装的物理处理器数量、已安装Windows版本的许可信息、启动选项（如numproc和bootproc），以及是否启用
了动态分区（仅限服务器系统）。在所有可用处理器均初始化完毕后，系统处理器的相关性会被更新，以涵盖所有处理器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">12）对象管理器初始化全
局系统Silo、每个处理器的非分页查找列表和描述符，以及基本审计（如果被系统控制向量启用）。它会创建命名空间根目录
（\）、\KernelObjects目录、\ObjectTypes目录以及DOS设备名映射目录（\Global??），并在其中创建Global和
GLOBALROOT链接。对象管理器还会创建Silo设备映射，借此控制DOS设备名映射并将其附加给系统进程。它还将创建传统的
\DosDevices符号链接（为了维持兼容性），该符号链接会指向Windows子系统设备名映射目录。最后，对象管理器会将每个已注册的对象类型插
入\ObjectTypes目录对象中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">13）调用执行体以创建执行体的对象类型，包括信号量、互斥、事件、计时器、键控事件、推锁以及线程池工作器。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">14）调用I/O管理器以创建I/O管理器对象类型，包括设备、驱动程序、控制器、适配器、I/O完成、等待完成以及文件对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">15）内核初始化系统监视器（Watchdog）。监视器主要分两种类型：DPC监视器，负责检查DPC例程的执行时间是否超过指定时间；CPU Keep Alive监视器，负责确认每个CPU是否总能提供响应。如果系统由虚拟机监控程序执行，那么监视器将不被初始化。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">16）内核初始化每个CPU的处理器控制块（KPRCB）数据结构，计算NUMA成本阵列，最后计算系统时钟周期和量程时长。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">17）无论此前调试器是否被触发，此时内核调试器库都会完成调试设置和参数的初始化工作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">18）事务管理器创建自己的对象类型，例如登记（Enlistment）、资源管理器以及事务管理器类型。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">19）为全局系统Silo初始化用户模式调试库（Dbgk）数据结构。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">20）如果已启用驱动程序认证器并取决于验证选项，则启用池认证，并开始跟踪系统进程的对象句柄。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">21）安全引用监视器在对
象管理器命名空间中创建\Security目录，通过安全描述符对该目录提供保护，只允许SYSTEM账户进行完整访问。如果启用了审计，还将初始化审计
数据结构。此外，安全引用监视器会初始化内核模式SDDL库并创建在LSA初始化完成后发送信号的事件
（\Security\LSA_AUTHENTICATION_INITIALIZED）。最后，安全引用监视器会调用内部的CiInitialize例
程以首次进行内核代码完整性组件（Ci.dll）的初始化，期间会初始化所有代码的完整性回调并保存启动驱动程序列表，以供后续审计与认证工作使用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">22）进程管理器为执行体
系统分区创建系统句柄。首先，该句柄永远不会被取消引用，因此系统分区无法被销毁。随后，进程管理器将初始化对内核可选扩展的支持（详见步骤26）。它会
为各种操作系统服务注册主机调用，例如，后台活动审查器（Background Activity 
Moderator，BAM）、桌面活动审查器（Desktop Activity 
Moderator，DAM）、多媒体类计划程序服务（Multimedia Class Scheduler 
Service，MMCSS）、内核硬件跟踪，以及Windows Defender System 
Guard。最后，如果启用VSM，还会创建第一个最小化进程IUM系统进程，并将其命名为Secure System。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">23）创建\SystemRoot符号链接。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">24）调用内存管理器以执
行第一阶段的初始化工作。首先，该阶段将创建Section对象类型，初始化所有相关结构（如控制区），并创建
\Device\PhysicalMemory节对象。随后，它将初始化对内核控制流防护（control flow 
guard）功能的支持，并创建页面文件支撑的节，这些节将用于描述用户模式CFG位图（有关控制流防护的更多信息请参阅本书卷1第7章）。内存管理器将
初始化对内存隔区的支持（仅限兼容SGX的系统），以及对热补丁的支持，还将初始化页面组合数据结构和系统内存事件。最后，它将启动三个内存管理器系统工
作线程（Balance Set Manager、Process Swapper和Zero Page 
Thread详见本书卷1第5章），并创建一个用于将API集Schema内存缓冲区映射至系统空间所使用的节对象（这个系统空间之前已由Windows
加载器分配）。这些新创建的系统线程将有机会在阶段1结束后的后续环节中执行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">25）NLS表被映射至系统空间，这样就可以被用户模式进程轻松映射。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">26）缓存管理器初始化文件系统缓存数据结构并创建自己的工作线程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">27）配置管理器在对象管理器命名空间中创建\Registry键对象，并将内存中的SYSTEM配置单元作为适当的配置单元文件打开。随后它会将Winload传递来的初始硬件树数据复制到易失的HARDWARE配置单元。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">28）系统初始化内核可选
扩展。该功能由Windows 
8.1引入，目的在于在不使用标准PE（可移植可执行）导出的前提下，将私有系统组件和Windows加载器数据（如内存缓存要求、UEFI运行时服务指
针、UEFI内存映射、SMBIOS数据、安全启动策略及代码完整性数据）导出给不同的内核组件（如安全内核）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">29）勘误表管理器（errata manager）初始化并扫描注册表中的勘误信息，以及包含各类驱动程序对应的勘误信息的INF数据库（INF是一种驱动程序安装文件，详见本书卷1第6章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">30）处理与生产有关的设
置。生产模式（manufacturing 
mode）是一种特殊的操作系统模式，可用于处理与生产商有关的各类任务，例如组件和支持测试。该功能仅适用于移动系统，由UEFI子系统提供。如果固件
（通过一个特殊的UEFI协议）告知操作系统这个特殊模式已启用，Windows将从
HKLM\System\CurrentControlSet\Control\ManufacturingMode注册表键读/写所有的必要信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">31）初始化Superfetch及其预取程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">32）初始化内核虚拟存储管理器，该组件是内存压缩功能的一部分。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">33）初始化VM组件，该组件是一种用于与虚拟机监控程序通信的内核可选扩展。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">34）初始化并设置当前时区信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">35）初始化全局文件系统驱动程序数据结构。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">36）初始化NT Rtl压缩引擎。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">37）如果需要，设置对虚拟机监控程序调试器的支持，这样系统的其他部分就不需要使用自己的设备了。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">38）通过在已注册的传输（如Kdcom.dll）中调用KdDebuggerInitialize1例程，执行与调试器传输相关的阶段1工作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">39）高级本地过程调用（ALPC）子系统初始化ALPC端口类型和ALPC可等待端口类型对象，并将旧的LPC对象设置为别名。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">40）如果系统（使用BCD的Bootlog选项）启用了启动日志记录，将初始化启动日志文件。如果系统启动到安全模式，则会判断是否需要运行备用shell（例如启动到带命令提示符的安全模式）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">41）调用执行体以执行它
的第二阶段初始化工作，这期间会在内核中配置有关Windows许可的部分功能，例如，认证包含了许可数据的注册表设置。此外，如果存在来自启动应用程序
的持久数据（如内存诊断结果或从休眠状态恢复的信息），那么相关日志文件和信息还会被写入硬盘或注册表。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">42）上述方式的启动还将创建MiniNT/WinPE注册表键，随后在命名空间中创建NLS对象目录，该目录稍后将用于保存各种内存映射NLS文件的节对象。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">43）初始化Windows内核代码完整性策略（例如受信任签名方列表和证书哈希）和调试选项，所有相关设置会从加载器程序块复制到内核CI模块（Ci.dll）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">44）再次调用电源管理器并进行初始化。这次将设置对电源请求、电源监视器、用于亮度调整通知的ALPC通道，以及配置文件回调的支持。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">45）开始初始化I/O管理器。这是系统启动过程中的一个复杂阶段，大部分启动时间都在处理这一阶段的工作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">I/O管理器首先初始化各
种内部结构并创建驱动程序和设备对象类型及它们的根目录：
\Driver、\FileSystem、\FileSystem\Filters、\UMDFCommunicationPorts（适用于UMDF驱
动程序框架）。然后初始化内核填充码引擎并调用即插即用管理器、电源管理器和HAL，以开始执行动态设备枚举和初始化所涉及的不同阶段（这个复杂而特殊的
过程请参阅本书卷1第6章）。最后处理Windows管理规范（WMI）子系统，进而为设备驱动程序提供WMI支持（详见第10章）。期间还将初始化
Windows事件跟踪（ETW）并将所有存在的启动持久数据写入ETW事件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">I/O管理器启动与平台相
关的错误驱动程序并初始化硬件错误资源的全局表。这二者是Windows硬件错误基础架构的重要组成部分。然后I/O管理器将执行首个安全内核调用，要求
安全内核在VTL 
1下执行自己初始化过程最后阶段的工作。此外，期间还将初始化加密的安全转储驱动程序，并从Windows注册表
（HKLM\System\CurrentControlSet\Control\CrashControl）读取部分配置信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">再根据依赖性和加载顺序枚举并排序启动时运行的所有驱动程序（有关注册表中所包含的驱动程序加载控制信息处理方式的详细介绍请参阅本书卷1第6章）。所有链接的内核模式DLL都将使用内置的RAW文件系统驱动程序进行初始化。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在这一阶段，I/O管理器
还会将Ntdll.dll、Vertdll.dll以及WOW64版本的Ntdll映射至系统地址空间。首先调用所有启动时运行的驱动程序来执行相关的驱
动程序初始化工作，接下来会启动系统运行的设备驱动程序。Windows子系统设备名会以符号链接的形式创建到对象管理器的命名空间中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">46）配置管理器注册并启动自己Windows注册表的ETW跟踪日志记录提供程序，以跟踪整个配置管理器的活动。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">47）事务管理器设置Windows软件跟踪预处理器（WPP）并注册自己的ETW提供程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">48）至此，引导时运行的以及系统启动时运行的驱动程序均已加载，勘误表管理器将加载并解析INF数据库中的驱动程序勘误表，并应用注册表PCI配置中的应变措施。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">49）如果计算机启动到安全模式，那么这一情况也将被记录到注册表中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">50）除非在注册表中明确禁用，否则将启用Ntoskrnl和驱动程序中内核模式代码的分页。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">51）调用电源管理器以完成初始化工作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">52）初始化对内核时钟计时器的支持。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">53）在Ntoskrnl的INIT节被丢弃前，系统的其余许可信息（包括注册表中存储的当前策略设置）将被复制到一个私有系统节中，随后设置系统过期时间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">54）调用进程管理器以设置作业速率限制和系统进程创建时间。它将为受保护进程初始化静态环境，并在先前由I/O管理器映射的用户模式系统库（通常是Ntdll.dll、Ntdll32.dll和Vertdll.dll）中查找各种系统定义的入口点。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">55）调用安全引用监视器来创建与LSASS通信的Command Server线程。这一阶段将创建引用监视器命令端口，LSA会使用该端口向SRM发送命令（有关Windows实施安全性的详情请参阅卷1第7章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">56）如果VSM已启用，那么加密的VSM密钥将被保存到硬盘。系统中用户模式的库会被映射至Secure System进程。这样，安全内核就可以收到有关VTL 0下系统DLL的所有必要信息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">57）会话管理器（SMSS）进程（详见本书卷1第2章）将启动。Smss负责为Windows提供可见接口的用户模式环境，下一节将介绍该组件的初始化过程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">58）启用Bootvid驱动程序，以允许NT磁盘检查工具显示输出的字符串。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">59）查询TPM启动熵
值。这些值在每次启动系统时只能查询一次，通常来说，到这一步，TPM系统驱动程序应该已经查询过了，但如果因为某些原因该驱动程序尚未运行（也许被用户
禁用），那么未查询的值依然是可用的。因此，为了避免出现这种情况，内核也可以手动查询该值。正常情况下，内核自己的查询操作应该会失败。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">60）加载器参数块使用和引用的所有内存（例如位于INIT节中的Ntoskrnl的初始化代码和所有启动时运行的驱动程序）都将被释放。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">作为执行体和内核初始化完
成之前的最后一步，第一阶段的初始化线程会将终止时的关键中断标记设置给新的Smss进程，这样，如果Smss进程退出或因为其他原因被终止，那么内核将
进行拦截并进入附加的调试器（如果有的话），然后让系统崩溃并显示CRITICAL_PROCESS_DIED停止代码。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果5秒的等待时间结束（也就是说，崩溃并等待5秒后），会话管理器会被认定为已成功启动，第一阶段的初始化线程将会退出。因此，启动处理器将开始执行步骤22中创建的某一个内存管理器系统线程，或返回到Idle循环。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_353" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>1</b><b>6</b><b> </b><b>S</b><b>m</b><b>s</b><b>s</b><b>、</b><b>C</b><b>s</b><b>r</b><b>s</b><b>s</b><b>和</b><b>W</b><b>i</b><b>n</b><b>i</b><b>n</b><b>i</b><b>t</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Smss与其他用户模式进
程类似，但有两点不同。首先，Windows认为Smss是操作系统中可信的部分；其次，Smss是一个原生应用程序。由于是受信任的操作系统组件，所以
Smss会以轻量级保护进程（Protected Process 
Light，PPL，详见本书卷1第3章）的方式运行，可以执行其他进程几乎无法执行的工作，如创建安全令牌。由于是原生应用程序，所以Smss并未使用
Windows 
API，它只使用了核心执行体API，这些API被统称为Windows原生API（通常由Ntdll暴露）。Smss并不使用Win32 
API，因为在Smss启动时，Windows子系统尚未开始执行。实际上，Smss首要任务之一就是启动Windows子系统。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Smss的初始化过程详见
本书卷1第2章“会话管理器”一节，这节内容介绍了Smss初始化过程的所有细节。当主Smss进程创建子Smss进程时，会以参数形式传递两个节对象的
句柄。这两个节对象代表了用在多个Smss和Csrss实例之间交换数据所用的共享缓冲区（一个用在父子Smss进程之间通信，一个用在客户端子系统进程
之间通信）。主Smss使用RtlCreateUserProcess例程生成子进程，指定一个标记来指示进程管理器新建会话。这种情况下，
PspAllocateProcess内核函数将调用内存管理器为新会话创建地址空间。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">初始化过程结束时，子
Smss启动的可执行文件的名称存储在共享节中。如第2章所述，对于会话0，要启动的可执行文件通常为Wininit.exe；对于任何其他交互式会话，
要启动的是Winlogon.exe。这里有一个重要概念需要注意：在新会话0的Smss启动Wininit之前，它首先会通过ALPC端口
SmApiPort连接到主Smss并加载和初始化所有子系统。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">会话管理器将获得Load
 
Driver特权，并要求内核将Win32k驱动程序（使用NtSetSystemInformation原生API）加载并映射到新会话的地址空间。随
后它会启动客户端-服务器的子系统进程（Csrss.exe），并在命令行中指定下列信息：根Windows对象的目录名称（\Windows）、共享节
对象的句柄、子系统名称（Windows）以及子系统的DLL。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Basesrv.dll，子系统进程的服务器端。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Sxssrv.dll，并行子系统支持扩展模块。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Winsrv.dll，多用户子系统支持模块。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">客户端-服务器子系统进程
将执行一些初始化工作：启用一些进程缓解选项，从其令牌中移除不需要的特权，启动自己的ETW提供程序，并初始化CSR_PROCESS数据结构的链表以
跟踪系统中将要启动的所有Win32进程。随后它会解析自己的命令行，获取共享节的句柄，并创建两个ALPC端口。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·CSR API<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>命</b><b>令</b><b>端</b><b>口</b></span>（\Sessions\&lt;ID&gt;\Windows\ApiPort）：每个Win32进程都会使用该ALPC端口与Csrss子系统通信（Kernelbase.dll会在自己的初始化例程中连接到该端口）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>子</b><b>系</b><b>统</b><b>会</b><b>话</b><b>管</b><b>理</b><b>器</b><b>A</b><b>P</b><b>I</b><b>端</b><b>口</b></span>（\Sessions\&lt;ID&gt;\Windows\SbApiPort）：会话管理器用它向Csrss发送命令。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Csrss会创建两个线
程，以此调度ALPC端口所收到的命令。最后，它会通过另一个ALPC端口（\SmApiPort）连接到会话管理器，这个端口是之前在Smss初始化过
程中创建的（第2章所描述初始化过程中的步骤6）。在连接过程中，Csrss进程会发送自己刚创建的会话管理器API端口的名称。从此刻开始，新的交互式
会话就可以启动了。因此，主Csrss线程最终退出。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">启动子系统进程后，子
Smss会运行自己的初始进程（Wininit或Winlogon）并退出。只有Smss的主实例会保持活跃状态。Smss的主线程会在Csrss的进程
句柄上永久等待，而其他ALPC线程会等待创建新会话或子系统的消息。如果Wininit或Csrss意外终止，那么内核将会让系统崩溃，因为这些都是关
键进程。如果Winlogon意外终止，那么与其关联的会话会被注销。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>挂</b><b>起</b><b>的</b><b>文</b><b>件</b><b>重</b><b>命</b><b>名</b><b>操</b><b>作</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">可
执行映像和DLL在使用的时候需要映射到内存中，这使得Windows启动完成后将无法更新核心系统文件（除非使用热修补技术，但这种技术仅适用于微软提
供的操作系统补丁）。Windows的MoveFileEx 
API包含一个选项，可以指定将文件的移动操作推迟到系统下次启动时进行。如果Service 
Pack和热修复程序必须更新使用中的内存映射文件，则可将需要替换的文件安装到系统中的一个临时位置内，随后使用MoveFileEx 
API让它们替换使用中的文件。如果使用该选项，则MoveFileEx会将相关命令记录到
HKLM\SYSTEM\CurrentControlSet\Control\Session 
Manager下的PendingFileRenameOperations和PendingFileRenameOperations2注册表值中。这
些注册表值的类型为MULTI_SZ，其中的每个操作都会指定一组文件名：第一个文件名是源位置，第二个文件名是目标位置。删除操作则会使用空字符串作为
目标位置。我们可以使用Windows 
Sysinternals（https://docs.microsoft.com/sysinternals/）提供的Pendmoves工具查看已注
册的延迟更名和删除命令。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Wininit将按照卷1
第2章“Windows初始化过程”一节介绍的过程执行自己的启动步骤，如创建初始窗口站和桌面对象。Wininit还会设置用户环境，启动
Shutdown 
RPC服务器和WSI接口（详见下文“关机”一节），并创建服务控制管理器（SCM）进程（Services.exe），该进程会加载所有被标记为需要自
启动的服务和设备驱动程序。通过共享的Svchost进程运行的本地会话管理器（Lsm.dll）服务也是在这时启动的。然后Wininit会检查系统之
前是否崩溃，如果是，它会处理崩溃转储并启动Windows错误报告进程（werfault.exe）进行后续处理。最后，Wininit会启动本地安全
验证子系统服务（%SystemRoot%\System32\Lsass.exe），如果凭据保护已启用，还会启动Isolated LSA 
Trustlet（Lsaiso.exe）并永久等待系统关闭请求。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">会话1和后续会话则会运行
Winlogon。Wininit创建了非交互式会话0的窗口站，而Winlogon创建了默认的交互式会话窗口站（名为WinSta0）和两个桌面，即
Winlogon安全桌面及默认的用户桌面。然后Winlogon会使用NtQuerySystemInformation 
API查询系统启动信息（只对第一个交互式登录会话执行该操作）。如果启动配置包含易失性操作系统选择菜单标记，则它会启动GDI系统（进而产生一个
UMDF宿主进程fontdrvhost.exe）并运行现代启动菜单应用程序（Bootim.exe）。易失性操作系统选择菜单标记是在启动过程的早期
阶段由Bootmgr设置的（前提是检测到多重启动环境），详见上文“启动菜单”一节。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Bootim是一个负责绘
制现代启动菜单的GUI应用程序。新的现代启动机制使用了Win32子系统（图形驱动程序和GDI+调用），这是为了支持用更高分辨率显示启动选项以及其
他高级选项。这种方式甚至支持触控屏，因此，用户可以通过触控来选择要启动哪个操作系统。Winlogon会运行新增的Bootim进程并等待它终止。在
用户做出选择后，Bootim将会退出。Winlogon可以检查退出代码，因此能够检测到用户是选择了一个操作系统，还是选择了某个启动工具，或是直接
请求系统关闭。如果用户选择了不同于当前操作系统的其他操作系统，Bootim将会在主系统引导存储（有关BCD存储的详细信息请参阅上
文“Windows启动管理器”一节）中添加bootsequence这个一次性BCD选项。当Winlogon使用NtShutdownSystem 
API重启计算机后，Windows启动管理器可识别出新的启动序列（随后删除之前设置的BCD选项）。Winlogon会将前一个启动项标记为“良
好”，随后重启动系统。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>操</b><b>作</b><b>现</b><b>代</b><b>启</b><b>动</b><b>菜</b><b>单</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">在Csrss启动后，由Winlogon生成的现代启动菜单应用程序实际上是一种经典的Win32 GUI应用程序。本实验将证明这一点。用配置为多重启动的系统执行该实验可以获得更好的效果，否则无法在现代启动菜单中看到多个启动项。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">打开一个非特权模式的命令提示符窗口（在开始菜单搜索框中输入cmd），使用cd /d C:\Windows\System32命令（其中C是启动卷的盘符）进入启动卷的\Windows\System32路径。随后输入Bootim.exe并按下<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>回</b><b>车</b><b>键</b></span>。
然后可以看到一个类似现代启动菜单的界面，其中只显示了关闭计算机的选项。这是因为Bootim进程此时是使用非管理员特权的标准令牌（由用户账户控制生
成）启动的。实际上，该进程并不能访问系统启动配置数据。按下Ctrl+Alt+Del组合键启动任务管理器并终止BootIm进程，或者直接选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>关</b><b>闭</b><b>计</b><b>算</b><b>机</b></span>”。实际的关机过程是由调用方进程（在原始启动序列中该进程是Winlogon）而非BootIm启动的。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">随后使用管理员特权打开命令提示符窗口。为此请右击其图标或搜索结果中的“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>命</b><b>令</b><b>提</b><b>示</b><b>符</b></span>”，并选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>以</b><b>管</b><b>理</b><b>员</b><b>身</b><b>份</b><b>运</b><b>行</b></span>”。在新的命令提示符窗口中启动BootIm可执行文件，这一次即可看到真正的现代启动菜单，其中包含了所有启动选项和工具，类似下图所示。</span></p><div style="display: block;text-align:center;">
	<img width="816" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/06c3213f6ef61dc21c53e355a92a601d.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">其他情况下，
Winlogon都会等待LSASS进程和LSM服务的初始化。随后会产生一个新的DWM进程实例（桌面窗口管理器，用于绘制现代图形界面的组件），并将
系统中已注册凭据提供程序（默认情况下，微软凭据提供程序支持基于密码、PIN码以及生物特征的登录）加载到一个名为LogonUI
（%SystemRoot%\System32\Logonui.exe）的子进程中，该进程负责显示登录界面（有关Wininit、Winlogon和
LSASS的启动序列的详细信息，请参阅卷1第7章）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">启动LogonUI进程
后，Winlogon会启动其内部的有限状态机。借此可以管理不同登录类型所产生的所有可能的状态，例如标准交互式登录、终端服务器、快速用户切换、
Hiberboot。在标准的交互式登录类型中，Winlogon会显示一个欢迎界面并等待来自凭据提供程序的交互式登录通知（如果需要，还会配置SAS
序列）。在用户提供了自己的凭据（密码、PIN码或生物特征验证信息）后，Winlogon会创建登录会话LUID，并使用在LSASS（有关该进程的详
细信息可参阅卷1第7章）中注册的身份验证程序包验证该登录操作。即便身份验证失败，此时的Winlogon也会将当前的启动过程标记为“良好”。如果身
份验证成功，对于客户端版本的Windows，Winlogon将验证“连续登录”场景，这种情况下每次只能产生一个会话；如果还存在其他的活跃会话，则
会询问用户希望如何处理。随后它会从正在登录的用户配置文件中加载注册表配置单元并将其映射至HKCU，此外还会将所需的ACL添加到新会话的窗口站和桌
面，并创建用户的环境变量，随后将这些变量存储到HKCU\Environment中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后Winlogon会等
待Sihost进程，并运行HKLM\SOFTWARE\Microsoft\Windows 
NT\CurrentVersion\WinLogon\Userinit（可通过逗号分隔多个可执行文件）指定的一个或多个可执行文件来启动外壳。上述
值默认会指向\Windows\System32\Userinit.exe。新建的Userinit进程运行在Winsta0\Default桌面上。
Userinit.exe将执行下列操作。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">1）创建仅在每个会话内有效的Explorer Session键HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\SessionInfo\。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">2）处理
HKCU\Software\Policies\Microsoft\Windows\System\Scripts中指定的用户脚本以及
HKLM\SOFTWARE\Policies\Microsoft\Windows\System\Scripts中指定的计算机登录脚本（计算机脚本
是在用户脚本之后运行的，因此可以覆盖用户脚本中的设置）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">3）运行
HKCU\Software\Microsoft\Windows 
NT\CurrentVersion\Winlogon\Shell中指定的以逗号分隔的一个或多个外壳。如果该值不存在，则Userinit.exe将
运行HKLM\SOFTWARE\Microsoft\Windows 
NT\CurrentVersion\Winlogon\Shell指定的一个或多个外壳，默认为Explorer.exe。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">4）如果组策略指定了用户配置文件配额，将启动%SystemRoot%\System32\Proquota.exe为当前用户应用配额。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">最后Winlogon会通
知已注册的网络提供程序，告知用户已登录，并启动mpnotify.exe进程。微软的网络提供程序——多提供程序路由器（Multiple 
Provider Router，%SystemRoot%\System32\Mpr.dll）将还原用户存储在HKCU\Network and 
HKCU\Printers下的持久映射驱动器和映射的打印机。图12-11展示了登录后在Process 
Monitor中看到的进程树（使用其启动功能）。请注意，Smss进程变暗了（意味着已经退出），这代表了初始化每个会话所生成的副本。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/d12509ac43716b302f85aa3918687513.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图12-11 登录过程中涉及的进程</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_354" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>1</b><b>7</b><b> </b><b>R</b><b>e</b><b>a</b><b>d</b><b>y</b><b>B</b><b>o</b><b>o</b><b>t</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果系统可用内存小于
400MB，则Windows会使用标准逻辑的启动时预取器（详见卷1第5章）；但如果系统的可用内存大于400MB，则会使用RAM缓存来优化启动过
程。缓存大小取决于可用RAM的总数，只要足够大，就可以创建大小合理的缓存，同时依然能为系统提供顺利启动所需的内存。ReadyBoot通过两个二进
制文件实现：ReadyBoost驱动程序（Rdyboost.sys）和Sysmain服务（Sysmain.dll，它还实现了
SuperFetch）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">缓存由存储管理器实现，存
储管理器在实现缓存和ReadyBoost缓存时使用了同一个驱动程序（Rdyboost.sys），但缓存的数量是由之前存储在注册表中的启动方案决定
的。尽管启动缓存可以像ReadyBoost缓存那样进行压缩，但ReadyBoost和ReadyBoot缓存管理机制之间的一个差异在于：
ReadyBoot模式下的缓存未被加密。ReadyBoost服务会在服务启动完毕50秒后，或在对内存产生其他需求时删除缓存。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统启动时，在NT内核初
始化阶段1过程中，ReadyBoost驱动程序（属于卷过滤器驱动程序）会拦截启动卷的创建操作，并决定是否启用缓存。只有当目标卷已在
HKLM\System\CurrentControlSet\Services\rdyboost\Parameters\ReadyBootVolumeUniqueId
注册表值中注册过的情况下，才会启用缓存。该值包含了启动卷的ID。如果ReadyBoot被启用，则ReadyBoost驱动程序会开始（通过ETW）
记录所有卷的启动I/O；如果之前的启动方案已经在BootPlan注册表二进制值中注册，则它还会运行一个系统线程，通过异步卷读取填充整个缓存。当新
安装的Windows系统首次启动时，这两个注册表值还不存在，因此，缓存和日志跟踪都不会启用。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在这种情况下，
Sysmain服务（由SCM在启动过程稍后的阶段启动）将决定是否启用缓存，并将检查系统配置以及所运行的Windows 
SKU版本。有些情况下，ReadyBoot会被彻底禁用，例如，启动盘为固态硬盘时。如果检查结果是肯定的，则Sysmain会启用
ReadyBoot，为此需要在相应的注册表值（ReadyBootVolumeUniqueId）中写入启动卷ID，并在
HKLM\SYSTEM\CurrentControlSet\Control\WMI\AutoLogger\Readyboot注册表键中启用WMI
 ReadyBoot 
Autologger。当系统下一次启动时，ReadyBoost驱动程序就会记录所有卷的I/O，但不填充缓存（此时启动方案依然不存在）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在多次启动后，
Sysmain服务会使用闲置的CPU时间为下一次启动计算启动时的缓存方案。它会分析已记录的ETW 
I/O事件来确定访问过哪些文件，以及这些文件在磁盘上的位置，随后会将处理后的跟踪结果以.fx格式的文件存储到%SystemRoot%
\Prefetch\Readyboot中，并根据前五次启动生成的跟踪文件来计算新的启动缓存方案。Sysmain服务会将新生成的方案存储到注册表值
中，如图12-12所示。ReadyBoost启动驱动程序将读取启动方案并填充缓存，以此最大限度地缩短启动过程所需的时间。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b845e66e28394f87391c89c2984866a7.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图12-12 ReadyBoot的配置和统计状态</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_355" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>1</b><b>8</b><b> </b><b>自</b><b>动</b><b>启</b><b>动</b><b>的</b><b>映</b><b>像</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">除了Winlogon键中
的Userinit和Shell注册表值，在启动和登录过程中，默认情况下，系统组件还会检查并自动处理很多其他注册表的位置和目录。Msconfig工
具（%SystemRoot%\System32\Msconfig.exe）可以显示多个位置所配置的映像。Sysinternals网站上提供的
Autoruns工具（见图12-13）可以检查比Msconfig更多的位置，并显示与配置为自动运行的映像有关的详细信息。默认情况下，
Autoruns只显示至少配置了一个自动运行映像的位置，不过只要在Options菜单中选中Include Empty 
Locations选项，就可以显示自己能检查的所有位置。Options菜单还提供了隐藏微软相关项的选项，不过建议始终将该选项与Verify 
Image Signatures选项配合使用，否则可能会忽略通过虚假的公司名称信息伪装成微软映像的恶意程序。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/27ec1eedb2ddd09b566ee1e99f5ed633.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图12-13 Sysinternals提供的Autoruns工具</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_356" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>1</b><b>9</b><b> </b><b>关</b><b>机</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">系统关机过程涉及不同的组件。Wininit在执行完所有初始化任务后，就会永久等待系统关机。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在有人登录的情况下，如果
有进程调用Windows的ExitWindowsEx函数以发起关机过程，则系统会向该会话的Csrss发送一条消息，告知系统即将关机。Csrss反
过来会模拟调用方，向Winlogon发送一条RPC消息，告知对方执行系统关机。Winlogon会检查系统是否处于混合启动（有关混合启动的详细信
息，请参阅下文“休眠和快速启动”一节）的过渡阶段中，随后模拟当前已登录用户（该用户可能具备或不具备与发起系统关机操作的用户相同的安全上下文），要
求LogonUI将屏幕画面变暗（该行为可通过注册表值HKLM\Software\Microsoft\Windows 
NT\CurrentVersion\Winlogon\FadePeriodConfiguration进行配置），并使用特殊的内部标记调用
ExitWindowsEx。同样，这个调用会向该会话中的Csrss进程发送一条要求将系统关闭的消息。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">这一次，Csrss看到的
请求来自Winlogon，随后会按照关机级别逆序循环检查交互式用户（依然不是发出关机请求的用户）登录会话中的所有进程。进程可以调用
SetProcessShutdownParameters来指定自己的关机级别，系统可以借此了解该进程相对于其他进程的退出顺序。有效的关机级别范围
介于0到1023之间，默认值为640。举例来说，Explorer会将自己的关机级别设置为2，任务管理器会设置为1。对于每个拥有顶层窗口的活动进
程，Csrss会向进程中拥有Windows消息循环的每个线程发送WM_QUERYENDSESSION消息。如果线程返回了TRUE，则系统可以继续
关机。随后Csrss会向请求退出的线程发送WM_ENDSESSION这个Windows消息。Csrss会等待该线程退出，等待时间则由
HKCU\Control Panel\Desktop\HungAppTimeout值决定（默认为5000毫秒）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果线程没有在超时前退
出，则Csrss会将屏幕暗淡显示，并展示图12-14所示的应用程序挂起界面（我们可以禁用该界面，为此需要将HKCU\Control 
Panel\Desktop\AutoEndTasks注册表值的数值设置为1）。该界面会告知我们目前哪个程序在运行，并在可能的情况下显示程序状态信
息。Windows会告知哪个程序没有及时关闭，并会让用户选择是要终止该进程，还是要取消关机的过程（该界面永远不会超时，意味着关机请求会在这种状态
下无限期等待）。此外，第三方应用程序还可以在这里显示自己的状态信息，例如虚拟化产品可以显示正在运行的活跃虚拟机的数量（为此需要用到
ShutdownBlockReasonCreate API）。</span></p><div style="display: block;text-align:center;">
	<img width="690" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/bf10145a692193e4a08ea43a95599344.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图12-14 应用程序挂起界面</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>查</b><b>看</b><b>H</b><b>u</b><b>n</b><b>g</b><b>A</b><b>p</b><b>p</b><b>T</b><b>i</b><b>m</b><b>e</b><b>o</b><b>u</b><b>t</b><b>的</b><b>效</b><b>果</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">要
查看HungAppTimeout注册表值的效果，可启动记事本，输入一些文字后注销。在HungAppTimeout注册表值指定的时间到期后，
Csrss.exe会显示一个提示信息，询问我们是否要终止记事本进程，而该进程并未退出，因为它在等待我们决定是否保存输入的文字内容。如果选择取消，
Csrss.exe将终止关机操作。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如果再次尝试关机（记事本的查询对话框依然打开的情况下），则记事本会显示自己的消息对话框，告知我们无法正确关机。不过该对话框只起到向用户告知相关信息的作用，Csrss.exe依然会认为记事本“挂起”，并显示用于终止不响应进程的界面。</span></p><div style="display: block;text-align:center;">
	<img width="516" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/375c635a7c7e88134ed2e9c0c5edf214.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果线程在超时之前退出，Csrss会继续向拥有窗口的进程中的其他线程发送WM_QUERYENDSESSION/WM_ENDSESSION消息对。一旦进程中拥有窗口的所有线程均已退出，Csrss就终止该进程，并继续处理交互式会话中的下一个进程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果Csrss发现控制台
应用程序，则会发送CTRL_LOGOFF_EVENT事件以调用控制台控制处理程序（只有服务进程会在关机时收到
CTRL_SHUTDOWN_EVENT事件）。如果处理程序返回了FALSE，则Csrss会终止进程。如果处理程序返回了TRUE，或在
HKCU\Control 
Panel\Desktop\WaitToKillTimeout定义的时间（默认为5000毫秒）内未响应，则Csrss会显示如图12-14所示的程
序挂起界面。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后，Winlogon状态机会调用ExitWindowsEx，以便让Csrss终止交互式用户会话中的COM进程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">至此，交互式用户会话中的
所有进程已被终止。Wininit随后会调用ExitWindowsEx，不过这次会在系统进程的上下文中执行。这会导致Wininit向会话0（即运行
该服务的会话）中的Csrss发送一条消息。随后，Csrss会检查隶属于系统上下文的所有进程，执行并发送WM_QUERYENDSESSION/
WM_ENDSESSION消息给GUI线程（与之前的过程一样）。不过此时发送的不是CTRL_LOGOFF_EVENT，而是向已经注册了控制处理应
用程序的控制台程序发送CTRL_SHUTDOWN_EVENT。请注意，SCM也是一种注册了控制处理程序的控制台程序。当它收到关机请求后，会向所有
注册了关机通知的服务发送服务关闭的控制消息。有关服务关闭的详细信息（例如Csrss为SCM使用的关闭超时），请参阅第10章的“Windows服
务”一节。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">尽管Csrss执行了与终
止用户进程时相同的超时操作，但这一过程中并不显示任何对话框，也不会终止任何进程（系统进程超时对应的注册表值取自默认用户配置文件）。这些超时只是为
了让系统进程在系统关机前有机会清理并退出。因此，当系统关闭时，很多系统进程（如Smss、Wininit、Services和LSASS）实际上依然
还在运行。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">一旦Csrss完成了向系
统进程通知系统即将关闭的工作，Wininit就会被唤醒，等待60秒让所有会话销毁，随后如果需要，还会调用系统的还原功能（此时系统中没有活动的用户
进程，因此系统的还原功能可以还原之前正被使用的所有文件）。为了完成关闭过程，Wininit会关闭LogonUi并调用执行体子系统函数
NtShutdownSystem。该函数可调用PoSetSystemPowerState函数以协调驱动程序以及执行体子系统剩余组件（即插即用管理
器、电源管理器、执行体、I/O管理器、配置管理器以及内存管理器）的关闭过程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">例如，
PoSetSystemPowerState会调用I/O管理器，向所有请求了关闭通知的设备驱动程序发送关闭I/O的数据包。该操作使得设备驱动程序有
机会在Windows退出前执行设备可能需要进行的特殊处理任务。随后会换入工作线程的栈，配置管理器会将对注册表数据进行的改动刷新到磁盘，内存管理器
则会将包含文件数据的所有已修改页面写入对应的文件中。如果启用了在系统关闭时清空页面文件的选项，内存管理器还将在此时清空页面文件。I/O管理器会被
再次调用，以通知文件系统驱动程序系统正在关闭。系统关闭过程止于电源管理器。电源管理器所要执行的操作取决于用户到底是选择了关机、重启动，还是计算机
遭遇了断电。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">现代应用都依赖
Windows关机接口（Windows Shutdown Interface，WSI）来正确地关闭系统。WSI 
API依然使用RPC实现进程之间的通信，并且支持宽限期。借助宽限期这种机制，在关机过程实际开始之前，用户将能收到系统即将关闭的通知，甚至系统需要
安装更新时也会用到这种机制。Advapi32可以使用WSI与Wininit通信。Wininit会排队等待一个计时器，该计时器会在宽限期结束时触
发，并调用Winlogon来初始化关机请求。Winlogon将调用ExitWindowsEx，后续过程与上文介绍的过程完全相同。所有UWP应用程
序（甚至全新的开始菜单）都会使用ShutdownUX模块来关闭系统。ShutdownUX负责管理UWP应用程序的电源状态转换，并链接到
Advapi32.dll。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_357" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>2</b><b>0</b><b> </b><b>休</b><b>眠</b><b>和</b><b>快</b><b>速</b><b>启</b><b>动</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">为了加快系统启动速度，
Windows 8引入了一项名为快速启动（fast 
startup）的新功能（也叫混合启动）。在之前版本的Windows中，如果支持S4系统电源状态（有关电源管理器的详细信息请参阅卷1第6章），
Windows允许用户将系统置于休眠（hibernation）模式。为了正确理解快速启动功能，首先需要明确休眠的全过程。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当用户或应用程序调用
SetSuspendState 
API时，电源管理器会收到一个工作项。该工作项包含内核初始化电源状态转换所需的全部信息。电源管理器会将未完成的休眠请求通知预取器
（prefetcher），并等待其所有未决I/O全部完成。随后它会调用NtSetSystemPowerState这个内核API。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">NtSetSystemPowerState
是对整个休眠过程进行协调的关键函数。该例程可以检查调用方的令牌中是否包含关机特权，与即插即用管理器、注册表以及电源管理器进行同步（这样即可避免同
时执行的其他事务可能造成的干扰），并循环处理所有已加载的驱动程序，向它们发出IRP_MN_QUERY_POWER这个IRP。通过这种方式，电源管
理器即可告知每个驱动程序电源操作已启动，因此，启动程序对应的设备不能再启动任何I/O操作，也不能执行可能会阻止休眠的其他任何操作。如果上述任何一
个请求失败（也许驱动程序正在执行重要的I/O），那么休眠过程都将被中止。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">电源管理器使用内部例程修改系统启动配置数据（BCD），借此启用“Windows恢复”这个启动应用程序。顾名思义，该应用程序负责恢复休眠的系统（更多细节可参阅上文“Windows启动管理器”一节）。电源管理器将会：</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·打开用于启动系统的BCD对象，读取相关的Windows恢复应用程序GUID（存储在一个特殊的未命名的BCD元素中，其值为0x23000003）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·
搜索BCD中存储的恢复对象，打开对象并检查其描述符。随后写入BCD的设备和路径元素，将其链接至启动盘上的
\Windows\System32\winresume.efi文件，并通过主系统BCD对象填充启动设置（如启动调试器选项）。最后将休眠文件的路径
和设备描述符添加到BCD的filepath和filedevice元素中。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·更新根启动管理器BCD对象：将所发现的Windows恢复启动应用程序的GUID写入BCD的resumeobject元素，将resume元素设置为1。如果休眠功能用于快速启动功能，还会将hiberboot元素设置为1。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">随后，电源管理器会将
BCD数据刷新到磁盘，计算所有需要写入休眠文件的物理内存范围（该过程极为复杂，本书无法详细介绍），并向每个驱动程序发送一个新的IRP
（IRP_MN_SET_POWER函数）。这一次，驱动程序必须将自己的设备置于睡眠状态，已经没有机会让请求失败并停止休眠过程了。系统现在已经准备
好可以休眠了，电源管理器将启动一个“睡眠者”线程，其唯一的作用是让计算机断电。随后它将等待另一个事件，只有当恢复操作成功完成（并且系统被用户重新
启动）后该事件才会发出信号。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">睡眠者线程通过DPC例程
让所有CPU停止，但运行睡眠者线程的CPU除外，该CPU将负责捕获系统时间，禁用中断，并保存CPU状态。最后睡眠者线程会调用电源状态句柄例程（在
HAL中实现），该例程将执行让整个系统处于睡眠状态所需的ACPI机器代码，并调用例程将所有物理内存页写入硬盘。睡眠者线程会使用崩溃转储存储驱动程
序发出所需的底层磁盘I/O，借此将数据写入休眠文件。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows启动管理器
在自己启动过程的早期阶段，可识别恢复BCD元素（存储在启动管理器BCD描述符中），打开Windows恢复启动应用程序BCD对象，读取保存的休眠数
据。最后，它会将执行转交给Windows恢复启动应用程序（Winresume.efi）。Winresume的入口例程HbMain将重新初始化启动
库，并对休眠文件执行不同的检查。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·验证该文件是否是被相同架构的处理器写入的。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·检查是否存在有效且大小正确的页面文件。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·检查固件是否上报了某些硬件配置变化（通过FADT和FACS这两个ACPI表）。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·检查休眠文件的完整性。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">如果上述任何一项检查失
败，那么Winresume将终止执行并将控制权转交给启动管理器，后者将丢弃休眠文件并重新进行标准冷启动。相反，如果上述检查都成功通过，那么
Winresume将使用UEFI启动库读取休眠文件并还原所有保存的物理页内容。随后它将构建所需的页表和内存数据结构，将必要信息复制到操作系统的上
下文，最终将执行权转交给Windows内核，再还原最初的CPU上下文。Windows内核代码将从最初让系统休眠的电源管理器睡眠者线程重新启动。电
源管理器会重新启用中断，并解冻其他所有系统CPU。随后它会更新系统时间（从CMOS读取），重新设置（Rebase）所有系统计时器和监视器
（Watchdog），并向每个系统驱动程序发送另一个IRP，即IRP_MN_SET_POWER，要求驱动程序重启自己的设备。最后还将重启预取器，
并将启动加载器日志发送给预取器以便进一步处理。系统现已正常运行，系统电源状态变为S0（完全开启）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">快速启动功能也是通过休眠
实现的。当应用程序将EWX_HYBRID_SHUTDOWN标记传递给ExitWindowsEx 
API，或当用户点击开始菜单中的关机按钮时，如果系统支持S4（休眠）电源状态并启用了休眠文件，那么将开始进行混合关机。当Csrss关闭了所有交互
式会话进程、会话0服务以及COM服务器时（真正的关机过程详见“关机”一节），Winlogon会检测到关机请求带有Hybrid标记，此时不会唤醒
Winint的关机代码，而是会执行另一项操作。新增的Winlogon状态可使用NtPowerInformation这个系统API关闭显示器，然后
告诉LogonUI存在未完成的混合关机操作，并最终调用NtInitializePowerAction 
API让系统开始休眠。随后的过程与上述休眠过程完全相同。</span></p>
	<p><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>实</b><b>验</b><b>：</b><b>理</b><b>解</b><b>混</b><b>合</b><b>关</b><b>机</b></span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">我们可以在系统关机后通过外部操作系统手动挂载BCD存储，借此观察混合关机的效果。首先请确保系统启用了快速启动功能。为此请通过开始菜单打开“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>控</b><b>制</b><b>面</b><b>板</b></span>”，选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>系</b><b>统</b><b>和</b><b>安</b><b>全</b><b>性</b></span>”，再打开“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>电</b><b>源</b></span>”选项。点击“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>电</b><b>源</b></span>”选项窗口左上角的“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>选</b><b>择</b><b>电</b><b>源</b><b>按</b><b>钮</b><b>的</b><b>功</b><b>能</b></span>”链接，应该可以看到类似下图所示的界面。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/ef78e4b6ac925a76d23f2148a69631e7.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">如上图所示，请选中“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>启</b><b>用</b><b>快</b><b>速</b><b>启</b><b>动</b></span>”选
项。否则系统将执行标准关机。然后即可使用开始菜单中的关机按钮以关闭计算机。在计算机关闭前，请插入包含外部操作系统（例如无须安装即可运行
的“Live”Linux）的光盘或U盘。这个实验不能使用Windows安装程序（或其他任何基于WinRE的环境），因为安装过程会在挂载系统卷之前
清除休眠数据。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">关
闭计算机后，通过外部光盘或U盘启动计算机。不同厂商的计算机的具体操作步骤可能不同，并且通常需要访问BIOS界面。如需了解如何访问BIOS并通过外
部驱动器引导，请查阅计算机用户手册（例如在Surface Pro和Surface 
Book笔记本上通常按下音量增大键不松手，随后按下并松开电源键即可进入BIOS配置界面）。当新操作系统启动时，使用分区工具（具体工具取决于操作系
统类型）挂载主UEFI系统分区。具体方法不再详述。系统分区成功挂载后，可将位于\EFI\Microsoft\Boot\BCD的系统启动配置数据文
件复制到外部驱动器（或用于启动计算机的U盘）中，随后即可重启计算机并等待Windows从睡眠状态恢复了。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">计算机启动后运行注册表编辑器并进入根注册表键HKEY_LOCAL_MACHINE。随后从“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>文</b><b>件</b></span>”菜单中选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>加</b><b>载</b><b>配</b><b>置</b><b>单</b><b>元</b></span>”。找到之前保存的BCD文件，选择“<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>打</b><b>开</b></span>”，
为新加载的配置单元分配一个BCD键名称。然后即可查找主启动管理器BCD对象。在所有的Windows系统中，这个根BCD对象的GUID都是
{9DEA862C-5CDD- 
4E70-ACC1-F32B344D4795}。打开相应的键及其Elements子键。如果系统之前曾正确地使用混合关机的方式关闭，此时将能看到
BCD的resume和hiberboot元素（对应的键名称分别为26000005和26000025，详见表12-2），它们的Element注册值
则会设置为1。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">为
了正确找到与当前Windows安装所对应的BCD元素，可使用displayorder元素（键名称为24000001），它会列出所有已安装操作系统
的启动项。Element注册表值中有一个GUID列表，其中列出了描述所有已安装操作系统加载器的BCD对象。请检查描述Windows恢复应用程序的
BCD对象，读取BCD的resumeobject元素对应的GUID值（对应于23000006键）。该具备GUID的BCD对象在filepath元
素中列出了休眠文件的路径，该元素对应于名为22000002的键。</span></p><div style="display: block;text-align:center;">
	<img width="900" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/6588927739645761021e75b33aeb5ea2.jpg" alt="" title=""></div>
</div><div class="header2"><h3><span id="sigil_toc_id_358" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>2</b><b>1</b><b> </b><b>W</b><b>i</b><b>n</b><b>d</b><b>o</b><b>w</b><b>s</b><b>恢</b><b>复</b><b>环</b><b>境</b><b>（</b><b>W</b><b>i</b><b>n</b><b>R</b><b>E</b><b>）</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows恢复环境提供了可修复大部分常见启动问题的工具和自动修复技术。其中主要包含以下六个工具。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>系</b><b>统</b><b>还</b><b>原</b><b>：</b></span>如果Windows无法启动，可借此将系统还原为之前的状态，支持在安全模式下使用。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>系</b><b>统</b><b>镜</b><b>像</b><b>恢</b><b>复</b><b>器</b><b>：</b></span>在之前版本的Windows中也叫“Complete PC还原”或自动系统恢复（Automated System Recovery，ASR），可利用完整备份还原Windows，该功能不使用系统还原点，因为其中可能不包含所有损坏的文件或丢失的数据。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>启</b><b>动</b><b>修</b><b>复</b><b>：</b></span>这个自动化工具可以检测常见的Windows启动问题并自动尝试修复。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>计</b><b>算</b><b>机</b><b>重</b><b>置</b><b>：</b></span>这个工具可以删除不属于标准Windows安装的所有应用程序和驱动程序，将所有设置还原为默认值，将Windows恢复为刚安装完成时的状态。用户可以选择保留所有的个人数据文件或将其全部清除，后一种情况中的Windows将自动进行全新重装。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>命</b><b>令</b><b>提</b><b>示</b><b>符</b><b>：</b></span>如
果需要在手动介入的情况下进行排错或修复问题（例如从其他驱动器复制文件或修改BCD），则可以使用命令提示符来访问完整的Windows外壳，并可以启
动几乎任何Windows程序（只要程序的依赖性能被满足）。而早期版本Windows中的恢复控制台只支持一组有限的专用命令。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·Windows<span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>内</b><b>存</b><b>诊</b><b>断</b><b>工</b><b>具</b><b>：</b></span>可通过内存诊断测试检查出错的RAM。出错的RAM可能是造成内核与应用程序随机崩溃以及系统不稳定问题的主要原因。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">使用Windows安装光盘或启动盘启动系统时，Windows安装程序可用于安装Windows或修复现有的安装。如果选择修复现有的安装，则系统会显示一个类似于现代启动菜单（见图12-15）的界面，其中提供了多种选项。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">用户可以选择从另一个驱动器启动，使用不同的操作系统（前提是已在系统的BCD存储中正确注册），或选择使用某种恢复工具。上述所有恢复工具（内存诊断工具除外）均位于“故障排查”选项下。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">对于全新系统的安装过程，
Windows安装程序还会在恢复分区上安装WinRE。在使用开始菜单中的相关按钮重启计算机时，按下Shift键的同时点击“重启动”按钮即可访问
WinRE。如果系统使用了传统启动菜单，则可在启动管理器执行过程中按下F8键以访问高级启动选项。如果看到“修复计算机”选项，这意味着在计算机本地
硬盘中存在WinRE的副本。此外，如果系统因为文件损坏或因Winload无法理解的其他原因而无法启动，则会指示启动管理器在下一次重启的过程中自动
启动WinRE。此时将不再显示如图12-15所示的对话框，恢复环境会自动启动如图12-16所示的启动修复工具。</span></p><div style="display: block;text-align:center;">
	<img width="864" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/87860ba739a7c79833911388dfb280a6.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图12-15 Windows恢复环境启动界面</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在扫描和修复流程结束后，工具可以自动尝试修复发现的所有问题，包括从安装介质替换系统文件。如果启动修复工具无法自动修复错误，即用户可以尝试其他方法，此时将再次显示系统恢复选项对话框。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows内存诊断工具可以从运行中的系统启动，也可以在WinRE中通过命令提示符运行mdsched.exe来启动。该工具会询问用户是否要重启计算机以便运行测试。如果系统使用传统启动菜单，则可以使用Tab键在工具菜单中导航并执行内存诊断工具。</span></p><div style="display: block;text-align:center;">
	<img width="490" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/e270d99685adaa907dafaa1081eef78e.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';display: block;text-align:center;">图12-16 启动恢复工具</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_359" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>2</b><b>2</b><b> </b><b>安</b><b>全</b><b>模</b><b>式</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows系统无法启
动最常见的原因也许是设备驱动程序导致计算机在启动过程中崩溃。由于软件或硬件配置会随着时间的推移而改变，驱动程序中随时可能出现潜藏的错误。
Windows为管理员提供了一种解决此类问题的方法：启动至安全模式。安全模式是一种启动配置，其中只包含少量的设备驱动程序和服务。通过只运行系统启
动所必需的驱动程序和服务，Windows可以避免加载导致崩溃的第三方驱动程序和非必要的驱动程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">我们可以通过不同的方式进入安全模式。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·将系统启动到WinRE，在高级选项中选择“启动设置”（见图12-17）。</span></p><div style="display: block;text-align:center;">
	<img width="803" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/927e608536728699f1b6617ae705c155.jpg" alt="" title=""></div>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">图12-17 启动设置界面，用户可以在这里选择不同类型的安全模式</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·多重启动环境中，在现代启动菜单选择“更改默认值或选择其他选项”，随后进入“故障排查”选项并选择“启动设置”。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·如果系统使用传统启动菜单，可按下F8键进入“高级启动选项”菜单。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">我们通常可以从安全模式的
三种变体中选择其中一种使用：标准安全模式、带网络的安全模式，以及带命令提示符的安全模式。标准安全模式包含成功启动系统所必需的最少数量的设备驱动程
序和服务。带网络的安全模式在标准安全模式的基础上额外运行了网络驱动程序和服务。带命令提示符的安全模式和标准安全模式相同，但在启用了GUI模式的情
况下，此时Windows会运行命令提示符应用程序（Cmd.exe）而非Windows Explorer这个外壳。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows还包含第四
种安全模式：目录服务还原模式，该模式与标准安全模式和带网络的安全模式有所差异。我们可以使用目录服务还原模式来启动系统，使域控制器的活动目录服务处
于离线且未打开的状态。随后即可针对数据库执行修复操作，或从备份介质还原。目录服务还原模式下会加载除活动目录服务外的其他所有驱动程序和服务。如果因
为活动目录数据库损坏而无法登录系统，则可通过该模式进行修复。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_360" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>2</b><b>3</b><b> </b><b>安</b><b>全</b><b>模</b><b>式</b><b>下</b><b>加</b><b>载</b><b>的</b><b>驱</b><b>动</b><b>程</b><b>序</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows如何知道在
标准安全模式和带网络的安全模式下需要加载哪些设备驱动程序和服务呢？答案位于
HKLM\SYSTEM\CurrentControlSet\Control\SafeBoot注册表键中。该键包含Minimal和Network子
键，每个子键下还包含多个子键，其中指定了设备驱动程序、服务或驱动程序组的名称。例如，BasicDisplay.sys子键指定了启动配置中需要包含
的基础显示设备驱动程序。该驱动程序为任何兼容PC的显示适配器提供了最基础的图形化服务。系统会使用该驱动程序作为安全模式下的显示驱动程序，以替代虽
然可以驱动适配器的高级硬件功能，但可能存在问题而导致系统无法启动的“高级”驱动程序。SafeBoot键下的每个子键都用一个默认值描述了子键对应的
内容，例如，BasicDisplay.sys子键的默认值就是Driver（驱动程序）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Boot文件系统子键的默
认值为Driver 
Group（驱动程序组）。当开发者设计设备驱动程序的安装脚本（.inf文件）时，可以指定设备驱动程序属于某个驱动程序组。系统定义的驱动程序组包含
在HKLM\SYSTEM\CurrentControlSet\Control\ServiceGroupOrder键下的List值中。开发者通过指
定某个驱动程序作为一个驱动程序组的成员，即可向Windows表明该驱动程序需要在系统启动过程的哪个阶段启动。ServiceGroupOrder键
的主要用途是定义驱动程序组的加载顺序，某些类型的驱动程序必须先于或后于其他类型的驱动程序加载。驱动程序配置注册表键下的Group值可将该驱动程序
关联给某个组。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">驱动程序和服务的配置键位
于HKLM\SYSTEM\CurrentControlSet\Services之下。查看该键会发现BasicDisplay 
键是基础显示设备驱动程序所对应的键，从注册表中可以看到，该驱动程序是Video组的成员。Windows访问系统驱动器所需的任何文件系统驱动程序，
只要被放置在Boot文件系统组，就会被自动加载。其他文件系统驱动程序则属于File 
System组，标准安全模式和带网络的安全模式也会加载这个组的驱动程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">在启动到安全模式后，启动
加载器（Winload）会将一个相关开关作为命令行参数传递给内核（Ntoskrnl.exe），此外，还会传递我们在BCD中为要启动的系统指定的其
他任何开关。当启动到任何一种安全模式时，Winload会将BCD的safeboot选项设置为描述所选择安全模式类型的值。对于标准安全模式，
Winload会将其设置为minimal，带网络的安全模式则会设置为network，带命令提示符的安全模式会设置为minimal并设置
alternateshell，目录服务还原模式则会设置为dsrepair。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><span style="font-size:16px;font-weight: bold;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';"><b>注</b><b>意</b></span>
 
关于安全模式在启动过程中排除的驱动程序，存在一个例外。Winload（而非内核）会在启动时加载注册表键中Start值为0的任何驱动程序。
Winload并不检查注册表中的SafeBoot键，因为它会假设Start值为0的任何驱动程序都是系统成功启动所必需的。由于Winload不通过
检查SafeBoot注册表键来确定要加载的驱动程序，所以Winload会加载所有启动时运行的驱动程序（随后将由Ntoskrnl启动它们）。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows内核会在启
动过程的阶段1（Phase1InitializationDiscard，详见上文“内核初始化阶段1”一节）结束时扫描启动参数，以寻找安全模式开
关，并根据结果为内部变量InitSafeBootMode设置对应的值。在InitSafeBoot函数中，内核会将InitSafeBootMode
值写入注册表HKLM\SYSTEM\CurrentControlSet\Control\SafeBoot\Option\OptionValue
中，这样用户模式组件（如SCM）就可以确定系统所处的启动模式。此外，如果系统以带命令提示符的安全模式启动，内核会将
HKLM\SYSTEM\CurrentControlSet\Control\SafeBoot\Option\UseAlternateShell值
设置为1。内核会将Winload传递给自己的参数并记录到
HKLM\SYSTEM\CurrentControlSet\Control\SystemStartOptions值中。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当I/O管理器内核子系统
加载HKLM\SYSTEM\CurrentControlSet\Services指定的设备驱动程序时，I/O管理器会执行
IopLoadDriver函数。当即插即用管理器检测到新设备并要动态加载该设备的驱动程序时，即插即用管理器会执行
PipCallDriverAddDevice函数。这些函数都会先调用IopSafebootDriverLoad函数，随后才加载目标驱动程序。
IopSafebootDriverLoad可以检查InitSafeBootMode的值，并决定是否应该加载该驱动程序。举例来说，如果系统以标准安
全模式启动，IopSafebootDriverLoad会查看该驱动程序是否属于Minimal子键下指定的某个组。如果
IopSafebootDriverLoad发现这里列出了该驱动程序的组，就会告知调用方该驱动程序可以加载。否则，
IopSafebootDriverLoad会在Minimal子键下查找该驱动程序的名称。如果名称被列为子键，那么该驱动程序就可以加载。如果
IopSafebootDriverLoad找不到驱动程序组或驱动程序名称子键，则该驱动程序将不被加载。如果系统以带网络的安全模式启动，那么
IopSafebootDriverLoad还会针对Network子键执行这样的查找。如果系统未以安全模式启动，则
IopSafebootDriverLoad会让所有的驱动程序正常加载。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_361" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>2</b><b>4</b><b> </b><b>可</b><b>感</b><b>知</b><b>安</b><b>全</b><b>模</b><b>式</b><b>的</b><b>用</b><b>户</b><b>程</b><b>序</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">当SCM用户模式组件（由
Services.exe实现）在启动过程中初始化时，SCM会检查
HKLM\SYSTEM\CurrentControlSet\Control\SafeBoot\Option\OptionValue的值以确定系统
是否正在以安全模式启动。如果是，则SCM会体现出与IopSafebootDriverLoad相同的操作。虽然SCM可以处理
HKLM\SYSTEM\CurrentControlSet\Services下列出的服务，但它只加载由安全模式子键按照名称指定的服务。有关SCM
初始化过程的详细介绍，请参阅第10章“Windows服务”一节。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">当用户登录时，
Userinit（%SystemRoot%\System32\Userinit.exe）组件将负责初始化用户环境，这个用户模式组件也需要知道系统
是否以安全模式启动。它会检查
HKLM\SYSTEM\CurrentControlSet\Control\SafeBoot\Option\UseAlternateShell
值。如果该值已设置，则Userinit将运行
HKLM\SYSTEM\CurrentControlSet\Control\SafeBoot\AlternateShell下指定的程序作为用户的
外壳，而不会直接运行Explorer.exe。Windows会在安装过程中将程序名称Cmd.exe写入AlternateShell值，这样
Windows命令提示符就可以成为带命令提示符的安全模式下的默认外壳。虽然命令提示符已经成为外壳，但我们依然可以运行Explorer.exe来启
动Windows资源管理器，甚至可以直接通过命令提示符运行任何其他GUI程序。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">应用程序如何确定系统是否
以安全模式启动？调用Windows的GetSystemMetrics 
(SM_CLEANBOOT)函数即可。如果批处理脚本需要在系统以安全模式启动之后执行某些操作，则可以直接查找SAFEBOOT_OPTION环境变
量，因为系统只有以安全模式启动后才会定义这个环境变量。</span></p>
</div><div class="header2"><h3><span id="sigil_toc_id_362" style="font-size:17px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>1</b><b>.</b><b>2</b><b>5</b><b> </b><b>启</b><b>动</b><b>状</b><b>态</b><b>文</b><b>件</b></span></h3></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">Windows使用启动状
态文件（%SystemRoot%\Bootstat.dat）记录自己在系统生命周期各个阶段（包括启动和关机）的进展。这样，启动管理器、
Windows以及启动修复工具就可以检测到异常关机或未能正常关机的情况，进而为用户提供启动恢复和诊断选项，例如Windows恢复环境。这个二进制
文件包含大量信息，系统可通过这些信息了解生命周期内下列阶段的成功情况。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·启动。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·关机和混合关机。</span></p>
	<p><span style="font-size:16px;color:rgb(0, 0, 0);font-family:'FZFangSong-Z02';">·从睡眠或挂起状态恢复。</span></p>
	<p><span style="font-size:16px;font-family:'PingFang SC';">启动状态文件还可以指出用
户上次尝试启动操作系统时是否检测到问题，以及当时所显示的恢复选项，这意味着用户已经意识到问题并采取了一些措施。Ntdll.dll中的运行时库
API（Rtl）包含了Windows用于从该文件中读取和写入的私有接口。与BCD一样，该文件也不允许用户编辑。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="Chapter12_0002.xhtml">
</div><div class="header1"><h2><span id="sigil_toc_id_363" style="font-size:19px;font-weight: bold;color:rgb(0, 0, 0);font-family:'PingFang SC';"><b>1</b><b>2</b><b>.</b><b>2</b><b> </b><b>总</b><b>结</b></span></h2></div>
<div class="part">
	<p><span style="font-size:16px;font-family:'PingFang SC';">本章首先介绍了
Windows正常/异常启动和关闭过程中涉及的详细步骤。为了让系统在启动过程的早期阶段也获得安全保护，免受来自外部的各种攻击，系统中设计并实现了
大量全新安全技术。其次介绍了确保系统以足够快速的方式正常启动、顺利运行，并最终成功关机所涉及的各类Windows与核心系统机制的整体结构。</span></p></div>
	<p style="page-break-after: always;">
</p><div id="daima.xhtml">
	<p><span style="font-size:16px;font-family:'PingFang SC';">*文中代码字体版权说明
	<sup><img width="11" src="126572_%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC7%E7%89%88%20%E5%8D%B72%EF%BC%89_%E3%80%90%E7%BE%8E%E3%80%91%E5%AE%89%E5%BE%B7%E9%87%8C%E4%BA%9A%C2%B7%E9%98%BF%E5%88%97%E7%BB%B4%EF%BC%9B%E4%BA%9A%E5%8E%86%E5%85%8B%E6%96%AF%C2%B7%E4%BC%8A%E5%A5%A5%E5%B0%BC%E6%96%AF%E5%BA%93%EF%BC%9B%E9%A9%AC%E5%85%8B%C2%B7E.%20%E9%B2%81%E8%BE%9B%E8%AF%BA%E7%BB%B4%E5%A5%87%EF%BC%9B%E5%A4%A7%E5%8D%AB%C2%B7A.%20%E6%89%80%E7%BD%97%E9%97%A8_files/b02289cc1cabf10965804333386671de.png" alt="Copyright Copyright 2010, 2012 Adobe Systems Incorporated (http://www.adobe.com/), with Reserved Font Name ‘Source’. License This Font Software is licensed under the SIL Open Font License, Version 1.1. This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007 PREAMBLE  The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others. The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives. DEFINITIONS  " font="" software"="" refers="" to="" the="" set="" of="" files="" released="" by="" copyright="" holder(s)="" under="" this="" license="" and="" clearly="" marked="" as="" such.="" may="" include="" source="" files,="" build="" scripts="" documentation.="" "reserved="" name"="" any="" names="" specified="" such="" after="" statement(s).="" "original="" version"="" collection="" software="" components="" distributed="" holder(s).="" "modified="" derivative="" made="" adding="" to,="" deleting,="" or="" substituting="" â€”="" in="" part="" whole="" original="" version,="" changing="" formats="" porting="" a="" new="" environment.="" "author"="" designer,="" engineer,="" programmer,="" technical="" writer="" other="" person="" who="" contributed="" software.="" permission="" &="" conditions="" is="" hereby="" granted,="" free="" charge,="" obtaining="" copy="" software,="" use,="" study,="" copy,="" merge,="" embed,="" modify,="" redistribute,="" sell="" modified="" unmodified="" copies="" subject="" following="" conditions:="" 1)="" neither="" nor="" its="" individual="" components,="" versions,="" be="" sold="" itself.="" 2)="" versions="" bundled,="" redistributed="" with="" provided="" that="" each="" contains="" above="" notice="" license.="" these="" can="" included="" either="" stand-alone="" text="" human-readable="" headers="" appropriate="" machine-readable="" metadata="" fields="" within="" binary="" long="" those="" easily="" viewed="" user.="" 3)="" no="" version="" use="" reserved="" name(s)="" unless="" explicit="" written="" granted="" corresponding="" holder.="" restriction="" only="" applies="" primary="" name="" presented="" users.="" 4)="" author(s)="" shall="" not="" used="" promote,="" endorse="" advertise="" except="" acknowledge="" contribution(s)="" their="" permission.="" 5)="" unmodified,="" whole,="" must="" entirely="" license,="" requirement="" for="" fonts="" remain="" does="" apply="" document="" created="" using="" termination="" becomes="" null="" void="" if="" are="" met.="" disclaimer="" "as="" is",="" without="" warranty="" kind,="" express="" implied,="" including="" but="" limited="" warranties="" merchantability,="" fitness="" particular="" purpose="" noninfringement="" copyright,="" patent,="" trademark,="" right.="" event="" holder="" liable="" claim,="" damages="" liability,="" general,="" special,="" indirect,="" incidental,="" consequential="" damages,="" whether="" an="" action="" contract,="" tort="" otherwise,="" arising="" from,="" out="" inability="" from="" dealings="" software."="" title="Copyright Copyright 2010, 2012 Adobe Systems Incorporated (http://www.adobe.com/), with Reserved Font Name ‘Source’. License This Font Software is licensed under the SIL Open Font License, Version 1.1. This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007 PREAMBLE  The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others. The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives. DEFINITIONS  " class="epub-footnote"></sup></span></p></div>

</body></html>